<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java 结构化并发 | 守株阁</title><meta name="author" content="magicliang"><meta name="copyright" content="magicliang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="结构化并发（Structured Concurrency） 结构化并发是 Java 并发编程的重要演进方向，与虚拟线程紧密配合，旨在解决传统并发编程中的线程泄漏、错误处理困难等问题。 1. 历史背景 1.1 结构化并发的起源与核心类比 术语起源 “结构化并发”（Structured Concurrency）这个术语由 Martin Sústrik（ZeroMQ 作者）在 2016 年首次提出。随后">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 结构化并发">
<meta property="og:url" content="https://magicliang.github.io/2026/02/07/Java-%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91/index.html">
<meta property="og:site_name" content="守株阁">
<meta property="og:description" content="结构化并发（Structured Concurrency） 结构化并发是 Java 并发编程的重要演进方向，与虚拟线程紧密配合，旨在解决传统并发编程中的线程泄漏、错误处理困难等问题。 1. 历史背景 1.1 结构化并发的起源与核心类比 术语起源 “结构化并发”（Structured Concurrency）这个术语由 Martin Sústrik（ZeroMQ 作者）在 2016 年首次提出。随后">
<meta property="og:locale">
<meta property="og:image" content="https://magicliang.github.io/img/wall-paper-25.jpg">
<meta property="article:published_time" content="2026-02-07T03:49:00.000Z">
<meta property="article:modified_time" content="2026-02-07T04:42:14.158Z">
<meta property="article:author" content="magicliang">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="多线程">
<meta property="article:tag" content="并发">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://magicliang.github.io/img/wall-paper-25.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Java 结构化并发",
  "url": "https://magicliang.github.io/2026/02/07/Java-%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91/",
  "image": "https://magicliang.github.io/img/wall-paper-25.jpg",
  "datePublished": "2026-02-07T03:49:00.000Z",
  "dateModified": "2026-02-07T04:42:14.158Z",
  "author": [
    {
      "@type": "Person",
      "name": "magicliang",
      "url": "https://magicliang.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://magicliang.github.io/2026/02/07/Java-%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: magicliang","link":"Link: ","source":"Source: 守株阁","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java 结构化并发',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"><link rel="alternate" href="/atom.xml" title="守株阁" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      if ($loadingBox.classList.contains('loaded')) return
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()

  if (document.readyState === 'complete') {
    preloader.endLoading()
  } else {
    window.addEventListener('load', preloader.endLoading)
    document.addEventListener('DOMContentLoaded', preloader.endLoading)
    // Add timeout protection: force end after 7 seconds
    setTimeout(preloader.endLoading, 7000)
  }

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/wall-paper-25.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">守株阁</span></a><a class="nav-page-title" href="/"><span class="site-name">Java 结构化并发</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">Java 结构化并发</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2026-02-07T03:49:00.000Z" title="Created 2026-02-07 11:49:00">2026-02-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2026-02-07T04:42:14.158Z" title="Updated 2026-02-07 12:42:14">2026-02-07</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">5.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>25mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="结构化并发-structured-concurrency">结构化并发（Structured Concurrency）</h2>
<p>结构化并发是 Java 并发编程的重要演进方向，与虚拟线程紧密配合，旨在解决传统并发编程中的线程泄漏、错误处理困难等问题。</p>
<h3 id="1-历史背景">1. 历史背景</h3>
<h4 id="1-1-结构化并发的起源与核心类比">1.1 结构化并发的起源与核心类比</h4>
<p><strong>术语起源</strong></p>
<p>“结构化并发”（Structured Concurrency）这个术语由 <strong>Martin Sústrik</strong>（ZeroMQ 作者）在 <strong>2016 年</strong>首次提出。随后，<strong>Nathaniel J. Smith</strong> 在 2018 年发表了著名的文章《Notes on structured concurrency, or: Go statement considered harmful》，系统性地阐述了结构化并发的理论基础。</p>
<pre><code class="hljs mermaid">timeline
    title 结构化并发发展历程
    2016 : Martin Sústrik 首创术语
         : 在 250bpm.com 发表系列文章
    2018 : Nathaniel J. Smith 发表核心论文
         : &quot;Go statement considered harmful&quot;
    2018 : Python Trio 库发布
         : 首个完整实现结构化并发的库
    2019 : Kotlin Coroutines 引入结构化并发
         : CoroutineScope 设计
    2022 : Java JEP 428 (JDK 19)
         : StructuredTaskScope 孵化
    2023 : Java JEP 453 (JDK 21)
         : 结构化并发预览
    2024 : Java JEP 462 (JDK 22)
         : 结构化并发第二次预览</code></pre>
<p><strong>核心类比：<code>go</code> 语句之于并发，如同 <code>goto</code> 之于顺序编程</strong></p>
<p>结构化并发的核心洞察来自一个类比：Nathaniel J. Smith 指出，传统并发编程中的 <code>go</code> 语句（以及 thread spawn、callbacks、futures、promises 等）在并发领域的危害，类似于 <code>goto</code> 语句在顺序编程领域的危害。</p>
<blockquote>
<p>“The popular concurrency primitives – go statements, thread spawning functions, callbacks, futures, promises, … they’re all variants on goto, in theory and in practice. And not even the modern domesticated goto, but the old-testament fire-and-brimstone goto, that could leap across function boundaries.”</p>
<p>— Nathaniel J. Smith, 2018</p>
</blockquote>
<p><strong>需要澄清的是</strong>：结构化并发并非&quot;来自于&quot;或&quot;继承自&quot;结构化编程，而是<strong>借鉴了结构化编程的思想</strong>，通过类比的方式将相似的原则应用于并发控制流。两者的关系是<strong>类比关系</strong>，而非<strong>继承关系</strong>。</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>结构化编程（1968）</th>
<th>结构化并发（2016）</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>问题根源</strong></td>
<td><code>goto</code> 破坏顺序控制流</td>
<td><code>go</code> 破坏并发控制流</td>
</tr>
<tr>
<td><strong>核心原则</strong></td>
<td>代码块有清晰的入口和出口</td>
<td>并发任务有清晰的生命周期边界</td>
</tr>
<tr>
<td><strong>解决方案</strong></td>
<td>用 if/while/函数调用替代 goto</td>
<td>用 Nursery/StructuredTaskScope 替代 go</td>
</tr>
<tr>
<td><strong>关系</strong></td>
<td>—</td>
<td>类比，非继承</td>
</tr>
</tbody>
</table>
<h4 id="1-2-与结构化编程的关系">1.2 与结构化编程的关系</h4>
<p>结构化并发借鉴了结构化编程的思想，将控制流的清晰性扩展到并发领域：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>结构化编程</th>
<th>结构化并发</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>控制流</strong></td>
<td>顺序执行</td>
<td>并发执行</td>
</tr>
<tr>
<td><strong>代码块</strong></td>
<td><code>if</code>, <code>while</code>, 函数调用</td>
<td><code>StructuredTaskScope</code></td>
</tr>
<tr>
<td><strong>出口点</strong></td>
<td>唯一返回点</td>
<td>作用域关闭时</td>
</tr>
<tr>
<td><strong>嵌套</strong></td>
<td>支持嵌套</td>
<td>支持嵌套作用域</td>
</tr>
</tbody>
</table>
<h3 id="2-传统并发编程的问题">2. 传统并发编程的问题</h3>
<h4 id="2-1-三大核心问题">2.1 三大核心问题</h4>
<pre><code class="hljs mermaid">flowchart TB
    subgraph &quot;传统并发编程的问题&quot;
        direction TB
        
        subgraph &quot;问题1：线程泄漏&quot;
            P1_CODE[&quot;executor.submit(task)&quot;]
            P1_PROBLEM[&quot;任务提交后，谁负责等待？&lt;br/&gt;谁负责取消？&lt;br/&gt;如果忘记处理会怎样？&quot;]
            P1_RESULT[&quot;线程可能永远运行&lt;br/&gt;资源无法回收&quot;]
            
            P1_CODE --&gt; P1_PROBLEM --&gt; P1_RESULT
            style P1_RESULT fill:#ffcdd2
        end
        
        subgraph &quot;问题2：错误处理困难&quot;
            P2_CODE[&quot;多个并发任务&quot;]
            P2_PROBLEM[&quot;任务A失败了&lt;br/&gt;任务B还在运行&lt;br/&gt;如何协调？&quot;]
            P2_RESULT[&quot;错误被忽略&lt;br/&gt;或处理不一致&quot;]
            
            P2_CODE --&gt; P2_PROBLEM --&gt; P2_RESULT
            style P2_RESULT fill:#ffcdd2
        end
        
        subgraph &quot;问题3：取消传播困难&quot;
            P3_CODE[&quot;父任务被取消&quot;]
            P3_PROBLEM[&quot;子任务如何感知？&lt;br/&gt;如何优雅终止？&quot;]
            P3_RESULT[&quot;子任务继续运行&lt;br/&gt;浪费资源&quot;]
            
            P3_CODE --&gt; P3_PROBLEM --&gt; P3_RESULT
            style P3_RESULT fill:#ffcdd2
        end
    end</code></pre>
<h4 id="2-2-问题代码示例">2.2 问题代码示例</h4>
<p><strong>示例 1：线程泄漏</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 问题：任务提交后，如果忘记处理，线程可能永远运行</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processUser</span><span class="hljs-params">(<span class="hljs-type">long</span> userId)</span> &#123;<br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();<br>    <br>    executor.submit(() -&gt; &#123;<br>        <span class="hljs-comment">// 长时间运行的任务</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            processSomething();<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125;<br>    &#125;);<br>    <br>    <span class="hljs-comment">// 忘记调用 executor.shutdown()</span><br>    <span class="hljs-comment">// 线程会永远运行，直到程序退出</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：错误处理困难</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 问题：任务A失败后，任务B还在运行</span><br><span class="hljs-keyword">public</span> UserProfile <span class="hljs-title function_">fetchProfile</span><span class="hljs-params">(<span class="hljs-type">long</span> userId)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();<br>    <br>    Future&lt;User&gt; userFuture = executor.submit(() -&gt; fetchUser(userId));<br>    Future&lt;List&lt;Order&gt;&gt; ordersFuture = executor.submit(() -&gt; fetchOrders(userId));<br>    <br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userFuture.get();           <span class="hljs-comment">// 如果这里抛异常...</span><br>        List&lt;Order&gt; orders = ordersFuture.get(); <span class="hljs-comment">// 这个任务还在运行！</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserProfile</span>(user, orders);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        executor.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>示例 3：取消传播困难</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 问题：父任务被取消后，子任务继续运行</span><br><span class="hljs-keyword">public</span> Response <span class="hljs-title function_">handleRequest</span><span class="hljs-params">(String requestId)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();<br>    <br>    Future&lt;Response&gt; responseFuture = executor.submit(() -&gt; &#123;<br>        <span class="hljs-comment">// 子任务继续运行，即使父任务被取消</span><br>        <span class="hljs-keyword">return</span> slowOperation();<br>    &#125;);<br>    <br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> responseFuture.get(<span class="hljs-number">5</span>, TimeUnit.SECONDS);<br>    &#125; <span class="hljs-keyword">catch</span> (TimeoutException e) &#123;<br>        <span class="hljs-comment">// 超时了，但子任务还在运行！</span><br>        responseFuture.cancel(<span class="hljs-literal">true</span>);  <span class="hljs-comment">// 可能无法中断</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BusinessException</span>(<span class="hljs-string">&quot;Timeout&quot;</span>);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        executor.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="3-结构化并发的核心思想">3. 结构化并发的核心思想</h3>
<p>结构化并发的核心原则是：<strong>并发任务的生命周期应该与代码的词法作用域绑定</strong>。</p>
<pre><code class="hljs mermaid">flowchart TB
    subgraph &quot;结构化并发的三大原则&quot;
        direction TB
        
        subgraph &quot;原则1：生命周期绑定&quot;
            L1[&quot;子任务的生命周期&quot;]
            L2[&quot;不能超过&quot;]
            L3[&quot;父作用域的生命周期&quot;]
            
            L1 --&gt; L2 --&gt; L3
            style L3 fill:#c8e6c9
        end
        
        subgraph &quot;原则2：错误传播&quot;
            E1[&quot;子任务失败&quot;]
            E2[&quot;自动传播到&quot;]
            E3[&quot;父作用域&quot;]
            
            E1 --&gt; E2 --&gt; E3
            style E3 fill:#c8e6c9
        end
        
        subgraph &quot;原则3：取消传播&quot;
            C1[&quot;父作用域取消&quot;]
            C2[&quot;自动传播到&quot;]
            C3[&quot;所有子任务&quot;]
            
            C1 --&gt; C2 --&gt; C3
            style C3 fill:#c8e6c9
        end
    end</code></pre>
<p><strong>核心特性</strong>：</p>
<ol>
<li><strong>作用域绑定</strong>：并发任务在作用域内启动，作用域关闭时所有任务保证终止</li>
<li><strong>自动取消传播</strong>：父作用域取消时，所有子任务自动取消</li>
<li><strong>错误自动聚合</strong>：子任务的异常自动传播到父作用域</li>
<li><strong>清晰的代码结构</strong>：并发代码的执行流清晰可见</li>
</ol>
<p><strong>与其他语言的对比</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>Java StructuredTaskScope</th>
<th>Go goroutine</th>
<th>Kotlin Coroutines</th>
<th>Python Trio</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>生命周期绑定</strong></td>
<td>强制（try-with-resources）</td>
<td>无</td>
<td>强制（CoroutineScope）</td>
<td>强制（Nursery）</td>
</tr>
<tr>
<td><strong>错误传播</strong></td>
<td>自动（ShutdownOnFailure）</td>
<td>手动（errgroup）</td>
<td>自动（supervisorScope）</td>
<td>自动</td>
</tr>
<tr>
<td><strong>取消传播</strong></td>
<td>自动</td>
<td>手动（context）</td>
<td>自动</td>
<td>自动</td>
</tr>
<tr>
<td><strong>语法集成</strong></td>
<td>API 级别</td>
<td>语言级别（go）</td>
<td>语言级别（suspend）</td>
<td>API 级别</td>
</tr>
</tbody>
</table>
<h3 id="4-java-中的结构化并发演进">4. Java 中的结构化并发演进</h3>
<h4 id="4-1-jep-演进概览">4.1 JEP 演进概览</h4>
<table>
<thead>
<tr>
<th>JEP</th>
<th>JDK 版本</th>
<th>状态</th>
<th>主要变化</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>JEP 428</strong></td>
<td>JDK 19</td>
<td>Incubator</td>
<td>首次引入 <code>StructuredTaskScope</code></td>
</tr>
<tr>
<td><strong>JEP 437</strong></td>
<td>JDK 20</td>
<td>Second Incubator</td>
<td>API 改进，<code>fork()</code> 返回 <code>Future</code></td>
</tr>
<tr>
<td><strong>JEP 453</strong></td>
<td>JDK 21</td>
<td>Preview</td>
<td>重大变化，<code>fork()</code> 返回 <code>Subtask</code></td>
</tr>
<tr>
<td><strong>JEP 462</strong></td>
<td>JDK 22</td>
<td>Second Preview</td>
<td>API 细化，增强可观测性</td>
</tr>
<tr>
<td><strong>JEP 480</strong></td>
<td>JDK 23</td>
<td>Third Preview</td>
<td>进一步完善</td>
</tr>
</tbody>
</table>
<h4 id="4-2-jdk-19-jep-428-首次孵化">4.2 JDK 19 (JEP 428) - 首次孵化</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// JDK 19 Incubator API</span><br><span class="hljs-keyword">import</span> jdk.incubator.concurrent.StructuredTaskScope;<br><br><span class="hljs-keyword">public</span> Response <span class="hljs-title function_">handle</span><span class="hljs-params">(String id)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StructuredTaskScope</span>&lt;Object&gt;()) &#123;<br>        Future&lt;String&gt; userFuture = scope.fork(() -&gt; fetchUser(id));<br>        Future&lt;Integer&gt; orderFuture = scope.fork(() -&gt; fetchOrder(id));<br>        <br>        scope.join();<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>(userFuture.get(), orderFuture.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>特点</strong>：</p>
<ul>
<li><code>fork()</code> 返回 <code>Future</code></li>
<li>需要手动检查异常</li>
<li>基本的生命周期管理</li>
</ul>
<h4 id="4-3-jdk-20-jep-437-第二次孵化">4.3 JDK 20 (JEP 437) - 第二次孵化</h4>
<p>API 改进，增强错误处理能力：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// JDK 20 引入 ShutdownOnFailure</span><br><span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StructuredTaskScope</span>.ShutdownOnFailure()) &#123;<br>    Future&lt;String&gt; userFuture = scope.fork(() -&gt; fetchUser(id));<br>    Future&lt;Integer&gt; orderFuture = scope.fork(() -&gt; fetchOrder(id));<br>    <br>    scope.join()<br>          .throwIfFailed();  <span class="hljs-comment">// 自动抛出异常</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>(userFuture.get(), orderFuture.get());<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="4-4-jdk-21-jep-453-第一次预览">4.4 JDK 21 (JEP 453) - 第一次预览</h4>
<p><strong>重大变化</strong>：<code>fork()</code> 返回 <code>Subtask</code> 而非 <code>Future</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// JDK 21 Preview API (需要 --enable-preview)</span><br><span class="hljs-keyword">import</span> java.util.concurrent.StructuredTaskScope;<br><br><span class="hljs-keyword">public</span> Response <span class="hljs-title function_">handle</span><span class="hljs-params">(String id)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StructuredTaskScope</span>.ShutdownOnFailure()) &#123;<br>        Subtask&lt;String&gt; userTask = scope.fork(() -&gt; fetchUser(id));<br>        Subtask&lt;Integer&gt; orderTask = scope.fork(() -&gt; fetchOrder(id));<br>        <br>        scope.join()<br>              .throwIfFailed();<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>(userTask.get(), orderTask.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Subtask vs Future</strong>：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>Future</th>
<th>Subtask</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>状态查询</strong></td>
<td><code>isDone()</code></td>
<td><code>state()</code> (UNAVAILABLE/SUCCESS/FAILED)</td>
</tr>
<tr>
<td><strong>异常处理</strong></td>
<td><code>get()</code> 抛出 <code>ExecutionException</code></td>
<td><code>exception()</code> 直接获取</td>
</tr>
<tr>
<td><strong>可观测性</strong></td>
<td>有限</td>
<td>丰富（线程 dump 支持）</td>
</tr>
</tbody>
</table>
<h4 id="4-5-jdk-22-jep-462-第二次预览">4.5 JDK 22 (JEP 462) - 第二次预览</h4>
<p>API 细化，增强可观测性和灵活性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// JDK 22 增强功能</span><br><span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StructuredTaskScope</span>.ShutdownOnFailure()) &#123;<br>    <span class="hljs-type">var</span> <span class="hljs-variable">task1</span> <span class="hljs-operator">=</span> scope.fork(() -&gt; fetchUser(id));<br>    <span class="hljs-type">var</span> <span class="hljs-variable">task2</span> <span class="hljs-operator">=</span> scope.fork(() -&gt; fetchOrder(id));<br>    <br>    <span class="hljs-comment">// 支持超时</span><br>    scope.joinUntil(Instant.now().plusSeconds(<span class="hljs-number">5</span>))<br>          .throwIfFailed();<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>(task1.get(), task2.get());<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="5-structuredtaskscope-核心-api">5. StructuredTaskScope 核心 API</h3>
<h4 id="5-1-类层次结构">5.1 类层次结构</h4>
<pre><code class="hljs mermaid">classDiagram
    class StructuredTaskScope~T~ &#123;
        +fork(Callable~T~ task) Subtask~T~
        +join() StructuredTaskScope
        +joinUntil(Instant deadline) StructuredTaskScope
        +shutdown() void
        +close() void
        #handleComplete(Subtask~? extends T~ subtask)* void
    &#125;
    
    class ShutdownOnFailure &#123;
        +throwIfFailed() ShutdownOnFailure
        +throwIfFailed(Function~Throwable, X~ exceptionMapper)* X
        +exception() Throwable
    &#125;
    
    class ShutdownOnSuccess~T~ &#123;
        +result() T
        +resultOrElse(Supplier~? extends T~ supplier) T
    &#125;
    
    class Subtask~T~ &#123;
        +get() T
        +state() State
        +exception() Throwable
        +toString() String
    &#125;
    
    class State &#123;
        &lt;&lt;enumeration&gt;&gt;
        UNAVAILABLE
        SUCCESS
        FAILED
    &#125;
    
    StructuredTaskScope &lt;|-- ShutdownOnFailure
    StructuredTaskScope &lt;|-- ShutdownOnSuccess
    StructuredTaskScope --&gt; Subtask
    Subtask --&gt; State</code></pre>
<h4 id="5-2-基础-api">5.2 基础 API</h4>
<p><strong>StructuredTaskScope 核心方法</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StructuredTaskScope</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AutoCloseable</span> &#123;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 启动子任务，返回 Subtask</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Subtask&lt;T&gt; <span class="hljs-title function_">fork</span><span class="hljs-params">(Callable&lt;? extends T&gt; task)</span> &#123;<br>        <span class="hljs-comment">// 在虚拟线程中执行任务</span><br>        Objects.requireNonNull(task);<br>        <br>        Subtask&lt;T&gt; subtask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Subtask</span>&lt;&gt;(task);<br>        subtask.thread = ThreadFactory.ofVirtual().newThread(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> task.call();<br>                subtask.complete(result);<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>                subtask.completeExceptionally(e);<br>            &#125;<br>        &#125;);<br>        <br>        subtask.thread.start();<br>        <span class="hljs-keyword">return</span> subtask;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 等待所有子任务完成（或作用域被关闭）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> StructuredTaskScope&lt;T&gt; <span class="hljs-title function_">join</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-comment">// 阻塞直到所有子任务完成</span><br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            <span class="hljs-keyword">while</span> (remaining &gt; <span class="hljs-number">0</span> &amp;&amp; !shutdown) &#123;<br>                lock.wait();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 带超时的等待</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> StructuredTaskScope&lt;T&gt; <span class="hljs-title function_">joinUntil</span><span class="hljs-params">(Instant deadline)</span> <br>        <span class="hljs-keyword">throws</span> InterruptedException, TimeoutException &#123;<br>        <br>        <span class="hljs-type">long</span> <span class="hljs-variable">timeout</span> <span class="hljs-operator">=</span> Duration.between(Instant.now(), deadline).toMillis();<br>        <span class="hljs-keyword">if</span> (timeout &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimeoutException</span>();<br>        &#125;<br>        <br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            <span class="hljs-keyword">while</span> (remaining &gt; <span class="hljs-number">0</span> &amp;&amp; !shutdown) &#123;<br>                lock.wait(timeout);<br>                <span class="hljs-keyword">if</span> (Instant.now().isAfter(deadline)) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimeoutException</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 关闭作用域，取消所有未完成的子任务</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            <span class="hljs-keyword">if</span> (shutdown) <span class="hljs-keyword">return</span>;<br>            shutdown = <span class="hljs-literal">true</span>;<br>            <br>            <span class="hljs-comment">// 中断所有未完成的子任务</span><br>            <span class="hljs-keyword">for</span> (Subtask&lt;?&gt; subtask : subtasks) &#123;<br>                <span class="hljs-keyword">if</span> (subtask.state() == Subtask.State.UNAVAILABLE) &#123;<br>                    subtask.thread.interrupt();<br>                &#125;<br>            &#125;<br>            <br>            lock.notifyAll();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 关闭作用域，确保所有子任务已终止</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<br>        shutdown();<br>        <br>        <span class="hljs-comment">// 等待所有子任务终止</span><br>        <span class="hljs-keyword">for</span> (Subtask&lt;?&gt; subtask : subtasks) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                subtask.thread.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                Thread.currentThread().interrupt();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 子任务完成时的回调，可被子类重写</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleComplete</span><span class="hljs-params">(Subtask&lt;? extends T&gt; subtask)</span> &#123;<br>        <span class="hljs-comment">// 默认实现：不做任何特殊处理</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="5-3-shutdownonfailure-策略">5.3 ShutdownOnFailure 策略</h4>
<p><strong>语义</strong>：“所有任务必须成功”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShutdownOnFailure</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">StructuredTaskScope</span>&lt;Object&gt; &#123;<br>    <span class="hljs-keyword">private</span> Throwable firstException;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 当子任务完成时调用</span><br><span class="hljs-comment">     * - 如果任务失败,记录第一个异常并 shutdown</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleComplete</span><span class="hljs-params">(Subtask&lt;?&gt; subtask)</span> &#123;<br>        <span class="hljs-keyword">if</span> (subtask.state() == Subtask.State.FAILED &amp;&amp; firstException == <span class="hljs-literal">null</span>) &#123;<br>            firstException = subtask.exception();<br>            shutdown();  <span class="hljs-comment">// 取消其他任务</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 如果有任务失败,抛出异常</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> ShutdownOnFailure <span class="hljs-title function_">throwIfFailed</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ExecutionException &#123;<br>        <span class="hljs-keyword">if</span> (firstException != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExecutionException</span>(firstException);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 自定义异常转换</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> &lt;X <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Throwable</span>&gt; ShutdownOnFailure <span class="hljs-title function_">throwIfFailed</span><span class="hljs-params">(</span><br><span class="hljs-params">        Function&lt;Throwable, X&gt; exceptionMapper</span><br><span class="hljs-params">    )</span> <span class="hljs-keyword">throws</span> X &#123;<br>        <span class="hljs-keyword">if</span> (firstException != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> exceptionMapper.apply(firstException);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取第一个异常</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Throwable <span class="hljs-title function_">exception</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> firstException;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>使用示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 场景: 聚合多个数据源,全部成功才能继续</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AggregationService</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> UserProfile <span class="hljs-title function_">getUserProfile</span><span class="hljs-params">(String userId)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StructuredTaskScope</span>.ShutdownOnFailure()) &#123;<br>            <span class="hljs-comment">// 并行获取多个数据源</span><br>            <span class="hljs-type">var</span> <span class="hljs-variable">basicInfo</span> <span class="hljs-operator">=</span> scope.fork(() -&gt; fetchBasicInfo(userId));<br>            <span class="hljs-type">var</span> <span class="hljs-variable">preferences</span> <span class="hljs-operator">=</span> scope.fork(() -&gt; fetchPreferences(userId));<br>            <span class="hljs-type">var</span> <span class="hljs-variable">activity</span> <span class="hljs-operator">=</span> scope.fork(() -&gt; fetchActivity(userId));<br>            <span class="hljs-type">var</span> <span class="hljs-variable">social</span> <span class="hljs-operator">=</span> scope.fork(() -&gt; fetchSocialData(userId));<br>            <br>            <span class="hljs-comment">// 等待所有任务完成</span><br>            scope.join()<br>                  .throwIfFailed();<br>            <br>            <span class="hljs-comment">// 所有任务都成功了,聚合结果</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserProfile</span>(<br>                basicInfo.get(),<br>                preferences.get(),<br>                activity.get(),<br>                social.get()<br>            );<br>        &#125;<br>        <span class="hljs-comment">// 作用域关闭,所有子任务都已终止</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> BasicInfo <span class="hljs-title function_">fetchBasicInfo</span><span class="hljs-params">(String userId)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 可能失败</span><br>        <span class="hljs-keyword">return</span> httpClient.get(<span class="hljs-string">&quot;/users/&quot;</span> + userId);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="5-4-shutdownonsuccess-策略">5.4 ShutdownOnSuccess 策略</h4>
<p><strong>语义</strong>: “只需要一个任务成功”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShutdownOnSuccess</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">StructuredTaskScope</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> T firstResult;<br>    <span class="hljs-keyword">private</span> Subtask&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">T</span>&gt; firstSuccess;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 当子任务成功完成时,记录结果并 shutdown</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleComplete</span><span class="hljs-params">(Subtask&lt;? extends T&gt; subtask)</span> &#123;<br>        <span class="hljs-keyword">if</span> (subtask.state() == Subtask.State.SUCCESS &amp;&amp; firstResult == <span class="hljs-literal">null</span>) &#123;<br>            firstSuccess = subtask;<br>            firstResult = subtask.get();<br>            shutdown();  <span class="hljs-comment">// 取消其他任务</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取第一个成功的结果</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">result</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ExecutionException &#123;<br>        <span class="hljs-keyword">if</span> (firstResult != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> firstResult;<br>        &#125;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExecutionException</span>(<span class="hljs-string">&quot;No subtask completed successfully&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 如果没有成功结果,返回默认值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">resultOrElse</span><span class="hljs-params">(Supplier&lt;? extends T&gt; supplier)</span> &#123;<br>        <span class="hljs-keyword">return</span> firstResult != <span class="hljs-literal">null</span> ? firstResult : supplier.get();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>使用示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 场景: 从多个备份源获取数据,只要一个成功即可</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedundancyService</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> Data <span class="hljs-title function_">fetchWithRedundancy</span><span class="hljs-params">(String key)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StructuredTaskScope</span>.ShutdownOnSuccess&lt;Data&gt;()) &#123;<br>            <span class="hljs-comment">// 尝试多个数据源</span><br>            scope.fork(() -&gt; fetchFromPrimary(key));<br>            scope.fork(() -&gt; fetchFromSecondary(key));<br>            scope.fork(() -&gt; fetchFromCache(key));<br>            scope.fork(() -&gt; fetchFromCDN(key));<br>            <br>            <span class="hljs-comment">// 等待第一个成功</span><br>            scope.join();<br>            <span class="hljs-keyword">return</span> scope.result();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> Data <span class="hljs-title function_">fetchFromPrimary</span><span class="hljs-params">(String key)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 主数据库</span><br>        <span class="hljs-keyword">return</span> db.query(key);<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> Data <span class="hljs-title function_">fetchFromSecondary</span><span class="hljs-params">(String key)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 备份数据库</span><br>        <span class="hljs-keyword">return</span> backupDb.query(key);<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> Data <span class="hljs-title function_">fetchFromCache</span><span class="hljs-params">(String key)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// Redis 缓存</span><br>        <span class="hljs-keyword">return</span> redis.get(key);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="6-与虚拟线程的协同">6. 与虚拟线程的协同</h3>
<p>结构化并发与虚拟线程是天然的搭档：</p>
<pre><code class="hljs mermaid">flowchart TB
    subgraph &quot;结构化并发 + 虚拟线程&quot;
        STS[&quot;StructuredTaskScope&quot;]
        VT1[&quot;虚拟线程 1&quot;]
        VT2[&quot;虚拟线程 2&quot;]
        VT3[&quot;虚拟线程 3&quot;]
        CT[&quot;载体线程池&quot;]
        
        STS --&gt;|&quot;fork()&quot;| VT1
        STS --&gt;|&quot;fork()&quot;| VT2
        STS --&gt;|&quot;fork()&quot;| VT3
        
        VT1 -.-&gt;|&quot;调度&quot;| CT
        VT2 -.-&gt;|&quot;调度&quot;| CT
        VT3 -.-&gt;|&quot;调度&quot;| CT
        
        style STS fill:#c8e6c9
        style VT1 fill:#e1f5ff
        style VT2 fill:#e1f5ff
        style VT3 fill:#e1f5ff
    end</code></pre>
<p><strong>虚拟线程是结构化并发的基础设施</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VirtualThreadIntegration</span> &#123;<br>    <br>    <span class="hljs-comment">// 1. 默认使用虚拟线程</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">defaultVirtualThread</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StructuredTaskScope</span>.ShutdownOnFailure()) &#123;<br>            <span class="hljs-comment">// fork 默认使用虚拟线程</span><br>            <span class="hljs-type">var</span> <span class="hljs-variable">task1</span> <span class="hljs-operator">=</span> scope.fork(() -&gt; blockingIO1());<br>            <span class="hljs-type">var</span> <span class="hljs-variable">task2</span> <span class="hljs-operator">=</span> scope.fork(() -&gt; blockingIO2());<br>            <br>            scope.join().throwIfFailed();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 2. 自定义线程工厂</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">customThreadFactory</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 使用平台线程</span><br>        <span class="hljs-type">ThreadFactory</span> <span class="hljs-variable">platformFactory</span> <span class="hljs-operator">=</span> Thread.ofPlatform().factory();<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StructuredTaskScope</span>&lt;Object&gt;(<span class="hljs-literal">null</span>, platformFactory)) &#123;<br>            <span class="hljs-type">var</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> scope.fork(() -&gt; cpuIntensiveTask());<br>            scope.join();<br>        &#125;<br>        <br>        <span class="hljs-comment">// 使用自定义虚拟线程名称</span><br>        <span class="hljs-type">ThreadFactory</span> <span class="hljs-variable">namedVirtualFactory</span> <span class="hljs-operator">=</span> Thread.ofVirtual()<br>            .name(<span class="hljs-string">&quot;worker-&quot;</span>, <span class="hljs-number">0</span>)<br>            .factory();<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StructuredTaskScope</span>&lt;Object&gt;(<span class="hljs-literal">null</span>, namedVirtualFactory)) &#123;<br>            <span class="hljs-type">var</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> scope.fork(() -&gt; ioTask());<br>            scope.join();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 3. 嵌套作用域</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">nestedScopes</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">outerScope</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StructuredTaskScope</span>.ShutdownOnFailure()) &#123;<br>            <span class="hljs-type">var</span> <span class="hljs-variable">task1</span> <span class="hljs-operator">=</span> outerScope.fork(() -&gt; &#123;<br>                <span class="hljs-comment">// 在子任务中创建嵌套作用域</span><br>                <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">innerScope</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StructuredTaskScope</span>.ShutdownOnFailure()) &#123;<br>                    <span class="hljs-type">var</span> <span class="hljs-variable">subTask1</span> <span class="hljs-operator">=</span> innerScope.fork(() -&gt; subTask1());<br>                    <span class="hljs-type">var</span> <span class="hljs-variable">subTask2</span> <span class="hljs-operator">=</span> innerScope.fork(() -&gt; subTask2());<br>                    <br>                    innerScope.join().throwIfFailed();<br>                    <span class="hljs-keyword">return</span> combineResults(subTask1.get(), subTask2.get());<br>                &#125;<br>            &#125;);<br>            <br>            <span class="hljs-type">var</span> <span class="hljs-variable">task2</span> <span class="hljs-operator">=</span> outerScope.fork(() -&gt; anotherTask());<br>            <br>            outerScope.join().throwIfFailed();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 4. 与 ScopedValue 集成</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ScopedValue&lt;String&gt; CONTEXT = ScopedValue.newInstance();<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">withScopedValue</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;user-123&quot;</span>;<br>        <br>        ScopedValue.where(CONTEXT, context).run(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StructuredTaskScope</span>.ShutdownOnFailure()) &#123;<br>                <span class="hljs-comment">// 所有子任务都能访问到 CONTEXT</span><br>                <span class="hljs-type">var</span> <span class="hljs-variable">task1</span> <span class="hljs-operator">=</span> scope.fork(() -&gt; &#123;<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> CONTEXT.get();  <span class="hljs-comment">// &quot;user-123&quot;</span><br>                    <span class="hljs-keyword">return</span> processWithContext(ctx);<br>                &#125;);<br>                <br>                <span class="hljs-type">var</span> <span class="hljs-variable">task2</span> <span class="hljs-operator">=</span> scope.fork(() -&gt; &#123;<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> CONTEXT.get();  <span class="hljs-comment">// &quot;user-123&quot;</span><br>                    <span class="hljs-keyword">return</span> processWithContext(ctx);<br>                &#125;);<br>                <br>                scope.join().throwIfFailed();<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>虚拟线程的优势</strong>:</p>
<ol>
<li><strong>轻量级</strong>: 可以创建百万级虚拟线程</li>
<li><strong>阻塞友好</strong>: <code>Thread.sleep()</code>, <code>BlockingQueue.take()</code> 等阻塞操作不会消耗平台线程</li>
<li><strong>结构化友好</strong>: 虚拟线程的生命周期管理简单,适合结构化并发</li>
</ol>
<h3 id="7-实际应用场景">7. 实际应用场景</h3>
<h4 id="7-1-典型使用模式">7.1 典型使用模式</h4>
<h5 id="模式-1-fan-out-fan-in">模式 1: Fan-Out / Fan-In</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Fan-Out: 并行执行多个任务</span><br><span class="hljs-comment"> * Fan-In: 聚合所有结果</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FanOutFanInPattern</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> OrderSummary <span class="hljs-title function_">processOrder</span><span class="hljs-params">(String orderId)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StructuredTaskScope</span>.ShutdownOnFailure()) &#123;<br>            <span class="hljs-comment">// Fan-Out: 并行获取订单相关数据</span><br>            <span class="hljs-type">var</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> scope.fork(() -&gt; orderService.getOrder(orderId));<br>            <span class="hljs-type">var</span> <span class="hljs-variable">items</span> <span class="hljs-operator">=</span> scope.fork(() -&gt; itemService.getItems(orderId));<br>            <span class="hljs-type">var</span> <span class="hljs-variable">customer</span> <span class="hljs-operator">=</span> scope.fork(() -&gt; customerService.getCustomer(orderId));<br>            <span class="hljs-type">var</span> <span class="hljs-variable">shipping</span> <span class="hljs-operator">=</span> scope.fork(() -&gt; shippingService.getShipping(orderId));<br>            <span class="hljs-type">var</span> <span class="hljs-variable">payment</span> <span class="hljs-operator">=</span> scope.fork(() -&gt; paymentService.getPayment(orderId));<br>            <br>            <span class="hljs-comment">// Fan-In: 等待所有任务完成并聚合结果</span><br>            scope.join().throwIfFailed();<br>            <br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderSummary</span>(<br>                order.get(),<br>                items.get(),<br>                customer.get(),<br>                shipping.get(),<br>                payment.get()<br>            );<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="模式-2-竞争模式-race">模式 2: 竞争模式 (Race)</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 竞争模式: 多个任务竞争,第一个成功的胜出</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RacePattern</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">fetchWithFallback</span><span class="hljs-params">(String url)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StructuredTaskScope</span>.ShutdownOnSuccess&lt;String&gt;()) &#123;<br>            <span class="hljs-comment">// 主数据源</span><br>            scope.fork(() -&gt; fetchFromPrimary(url));<br>            <br>            <span class="hljs-comment">// 备份数据源 (延迟启动)</span><br>            Thread.sleep(<span class="hljs-number">50</span>);  <span class="hljs-comment">// 给主数据源一点时间</span><br>            scope.fork(() -&gt; fetchFromSecondary(url));<br>            <br>            <span class="hljs-comment">// 缓存</span><br>            scope.fork(() -&gt; fetchFromCache(url));<br>            <br>            scope.join();<br>            <span class="hljs-keyword">return</span> scope.result();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="模式-3-批量处理">模式 3: 批量处理</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 批量处理: 并行处理一批任务,收集所有成功结果</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BatchProcessingPattern</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> List&lt;ProcessedItem&gt; <span class="hljs-title function_">processBatch</span><span class="hljs-params">(List&lt;Item&gt; items)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CollectingScope</span>&lt;ProcessedItem&gt;()) &#123;<br>            <span class="hljs-comment">// 并行处理所有项目</span><br>            <span class="hljs-keyword">for</span> (Item item : items) &#123;<br>                scope.fork(() -&gt; processItem(item));<br>            &#125;<br>            <br>            scope.join();<br>            <br>            <span class="hljs-comment">// 返回所有成功处理的结果</span><br>            <span class="hljs-keyword">return</span> scope.results().toList();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CollectingScope</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">StructuredTaskScope</span>&lt;T&gt; &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Queue&lt;T&gt; results = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentLinkedQueue</span>&lt;&gt;();<br>        <br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleComplete</span><span class="hljs-params">(Subtask&lt;? extends T&gt; subtask)</span> &#123;<br>            <span class="hljs-keyword">if</span> (subtask.state() == Subtask.State.SUCCESS) &#123;<br>                results.add(subtask.get());<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">public</span> Stream&lt;T&gt; <span class="hljs-title function_">results</span><span class="hljs-params">()</span> &#123;<br>            ensureOwnerAndJoined();<br>            <span class="hljs-keyword">return</span> results.stream();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="模式-4-服务器处理">模式 4: 服务器处理</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 服务器模式: 持续接受连接,每个连接在独立作用域中处理</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerPattern</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startServer</span><span class="hljs-params">(ServerSocket serverSocket)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StructuredTaskScope</span>&lt;Void&gt;()) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                    <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> serverSocket.accept();<br>                    <br>                    <span class="hljs-comment">// 每个连接在独立的子任务中处理</span><br>                    scope.fork(() -&gt; handleConnection(socket));<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">// 如果出现异常或被中断,关闭所有连接</span><br>                scope.shutdown();<br>                scope.join();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> Void <span class="hljs-title function_">handleConnection</span><span class="hljs-params">(Socket socket)</span> &#123;<br>        <span class="hljs-keyword">try</span> (socket) &#123;<br>            <span class="hljs-comment">// 处理连接</span><br>            processRequests(socket);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            log.error(<span class="hljs-string">&quot;Connection error&quot;</span>, e);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="7-2-与传统-executorservice-的对比">7.2 与传统 ExecutorService 的对比</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 对比: 传统 ExecutorService vs 结构化并发</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Comparison</span> &#123;<br>    <br>    <span class="hljs-comment">// ========== 传统 ExecutorService ==========</span><br>    <span class="hljs-keyword">public</span> Response <span class="hljs-title function_">handleWithExecutorService</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br>        <br>        <span class="hljs-keyword">try</span> &#123;<br>            Future&lt;String&gt; userFuture = executor.submit(() -&gt; findUser());<br>            Future&lt;Integer&gt; orderFuture = executor.submit(() -&gt; fetchOrder());<br>            <br>            <span class="hljs-comment">// 问题 1: 需要手动等待所有任务</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userFuture.get();<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> orderFuture.get();<br>            <br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>(user, order);<br>            <br>            <span class="hljs-comment">// 问题 2: 如果任务失败,需要手动处理异常</span><br>            <span class="hljs-comment">// 问题 3: 如果方法被中断,任务不会自动取消</span><br>            <span class="hljs-comment">// 问题 4: 需要手动管理线程池生命周期</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            executor.shutdown();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// ========== 结构化并发 ==========</span><br>    <span class="hljs-keyword">public</span> Response <span class="hljs-title function_">handleWithStructuredConcurrency</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StructuredTaskScope</span>.ShutdownOnFailure()) &#123;<br>            <span class="hljs-type">var</span> <span class="hljs-variable">userTask</span> <span class="hljs-operator">=</span> scope.fork(() -&gt; findUser());<br>            <span class="hljs-type">var</span> <span class="hljs-variable">orderTask</span> <span class="hljs-operator">=</span> scope.fork(() -&gt; fetchOrder());<br>            <br>            <span class="hljs-comment">// 自动等待所有任务</span><br>            scope.join()<br>                  .throwIfFailed();  <span class="hljs-comment">// 自动处理异常</span><br>            <br>            <span class="hljs-comment">// 自动取消未完成任务</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>(userTask.get(), orderTask.get());<br>            <br>            <span class="hljs-comment">// 自动清理: try-with-resources 确保关闭</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>详细对比</strong>:</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>ExecutorService</th>
<th>Structured Concurrency</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>任务生命周期</strong></td>
<td>不明确,需要手动管理</td>
<td>明确,绑定到作用域</td>
</tr>
<tr>
<td><strong>错误处理</strong></td>
<td>需要手动检查 Future</td>
<td>自动传播到父任务</td>
</tr>
<tr>
<td><strong>取消传播</strong></td>
<td>需要手动实现</td>
<td>自动传播</td>
</tr>
<tr>
<td><strong>资源清理</strong></td>
<td>需要手动 shutdown</td>
<td>自动清理</td>
</tr>
<tr>
<td><strong>可观测性</strong></td>
<td>需要额外工具</td>
<td>内置线程 dump</td>
</tr>
<tr>
<td><strong>代码可读性</strong></td>
<td>中等</td>
<td>高 (类似同步代码)</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>长期运行的任务池</td>
<td>请求-响应模式</td>
</tr>
</tbody>
</table>
<h3 id="8-最佳实践">8. 最佳实践</h3>
<h4 id="8-1-正确使用-try-with-resources">8.1 正确使用 try-with-resources</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 推荐: 使用 try-with-resources</span><br><span class="hljs-keyword">public</span> Response <span class="hljs-title function_">goodExample</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StructuredTaskScope</span>.ShutdownOnFailure()) &#123;<br>        <span class="hljs-type">var</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> scope.fork(() -&gt; doWork());<br>        scope.join().throwIfFailed();<br>        <span class="hljs-keyword">return</span> task.get();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 错误: 忘记关闭作用域</span><br><span class="hljs-keyword">public</span> Response <span class="hljs-title function_">badExample</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">var</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StructuredTaskScope</span>.ShutdownOnFailure();<br>    <span class="hljs-type">var</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> scope.fork(() -&gt; doWork());<br>    scope.join().throwIfFailed();<br>    <span class="hljs-keyword">return</span> task.get();<br>    <span class="hljs-comment">// 忘记 close(),可能导致资源泄漏</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="8-2-正确处理异常">8.2 正确处理异常</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 推荐: 使用 throwIfFailed</span><br><span class="hljs-keyword">public</span> Response <span class="hljs-title function_">goodExceptionHandling</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StructuredTaskScope</span>.ShutdownOnFailure()) &#123;<br>        <span class="hljs-type">var</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> scope.fork(() -&gt; doWork());<br>        scope.join()<br>              .throwIfFailed(e -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyBusinessException</span>(e));<br>        <span class="hljs-keyword">return</span> task.get();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 错误: 忽略异常</span><br><span class="hljs-keyword">public</span> Response <span class="hljs-title function_">badExceptionHandling</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StructuredTaskScope</span>.ShutdownOnFailure()) &#123;<br>        <span class="hljs-type">var</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> scope.fork(() -&gt; doWork());<br>        scope.join();<br>        <span class="hljs-comment">// 忘记检查异常</span><br>        <span class="hljs-keyword">return</span> task.get();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="8-3-响应中断">8.3 响应中断</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 推荐: 子任务响应中断</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">goodInterruptHandling</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StructuredTaskScope</span>.ShutdownOnFailure()) &#123;<br>        <span class="hljs-type">var</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> scope.fork(() -&gt; &#123;<br>            <span class="hljs-comment">// 使用可中断的方法</span><br>            <span class="hljs-keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> httpClient.get(url);<br>                <span class="hljs-keyword">if</span> (data != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> data;<br>                Thread.sleep(<span class="hljs-number">100</span>);  <span class="hljs-comment">// 可中断</span><br>            &#125;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>(<span class="hljs-string">&quot;Task was cancelled&quot;</span>);<br>        &#125;);<br>        <br>        scope.join().throwIfFailed();<br>        <span class="hljs-keyword">return</span> task.get();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 错误: 子任务不响应中断</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">badInterruptHandling</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StructuredTaskScope</span>.ShutdownOnFailure()) &#123;<br>        <span class="hljs-type">var</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> scope.fork(() -&gt; &#123;<br>            <span class="hljs-comment">// 使用不可中断的方法</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> httpClient.get(url);<br>                <span class="hljs-keyword">if</span> (data != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> data;<br>                Thread.sleep(<span class="hljs-number">100</span>);  <span class="hljs-comment">// 可中断</span><br>                <span class="hljs-comment">// 忽略中断信号</span><br>            &#125;<br>        &#125;);<br>        <br>        scope.join().throwIfFailed();<br>        <span class="hljs-keyword">return</span> task.get();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="8-4-避免过深的嵌套">8.4 避免过深的嵌套</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 避免过深的嵌套</span><br><span class="hljs-keyword">public</span> Response <span class="hljs-title function_">deepNesting</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">scope1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StructuredTaskScope</span>.ShutdownOnFailure()) &#123;<br>        <span class="hljs-type">var</span> <span class="hljs-variable">task1</span> <span class="hljs-operator">=</span> scope1.fork(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">scope2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StructuredTaskScope</span>.ShutdownOnFailure()) &#123;<br>                <span class="hljs-type">var</span> <span class="hljs-variable">task2</span> <span class="hljs-operator">=</span> scope2.fork(() -&gt; &#123;<br>                    <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">scope3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StructuredTaskScope</span>.ShutdownOnFailure()) &#123;<br>                        <span class="hljs-type">var</span> <span class="hljs-variable">task3</span> <span class="hljs-operator">=</span> scope3.fork(() -&gt; doWork());<br>                        scope3.join().throwIfFailed();<br>                        <span class="hljs-keyword">return</span> task3.get();<br>                    &#125;<br>                &#125;);<br>                scope2.join().throwIfFailed();<br>                <span class="hljs-keyword">return</span> task2.get();<br>            &#125;<br>        &#125;);<br>        scope1.join().throwIfFailed();<br>        <span class="hljs-keyword">return</span> task1.get();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 推荐: 提取方法</span><br><span class="hljs-keyword">public</span> Response <span class="hljs-title function_">flatStructure</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StructuredTaskScope</span>.ShutdownOnFailure()) &#123;<br>        <span class="hljs-type">var</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> scope.fork(() -&gt; processNested());<br>        scope.join().throwIfFailed();<br>        <span class="hljs-keyword">return</span> task.get();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> String <span class="hljs-title function_">processNested</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StructuredTaskScope</span>.ShutdownOnFailure()) &#123;<br>        <span class="hljs-type">var</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> scope.fork(() -&gt; doWork());<br>        scope.join().throwIfFailed();<br>        <span class="hljs-keyword">return</span> task.get();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="8-5-合理使用超时">8.5 合理使用超时</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 推荐: 使用 joinUntil</span><br><span class="hljs-keyword">public</span> Response <span class="hljs-title function_">withTimeout</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">Instant</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> Instant.now().plusSeconds(<span class="hljs-number">5</span>);<br>    <br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StructuredTaskScope</span>.ShutdownOnFailure()) &#123;<br>        <span class="hljs-type">var</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> scope.fork(() -&gt; doWork());<br>        <br>        <span class="hljs-keyword">try</span> &#123;<br>            scope.joinUntil(deadline).throwIfFailed();<br>        &#125; <span class="hljs-keyword">catch</span> (TimeoutException e) &#123;<br>            <span class="hljs-comment">// 超时后,作用域会自动 shutdown</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BusinessException</span>(<span class="hljs-string">&quot;Operation timed out&quot;</span>, e);<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> task.get();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="9-可观测性">9. 可观测性</h3>
<p>结构化并发提供了强大的可观测性支持:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 生成结构化线程 dump</span><br><span class="hljs-comment">// $ jcmd &lt;pid&gt; Thread.dump_to_file -format=json &lt;file&gt;</span><br><br><span class="hljs-comment">// 输出示例:</span><br>&#123;<br>  <span class="hljs-string">&quot;threadDump&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;threadContainers&quot;</span>: [<br>      &#123;<br>        <span class="hljs-string">&quot;container&quot;</span>: <span class="hljs-string">&quot;&lt;root&gt;&quot;</span>,<br>        <span class="hljs-string">&quot;threads&quot;</span>: [...]<br>      &#125;,<br>      &#123;<br>        <span class="hljs-string">&quot;container&quot;</span>: <span class="hljs-string">&quot;java.util.concurrent.StructuredTaskScope$ShutdownOnFailure@123&quot;</span>,<br>        <span class="hljs-string">&quot;parent&quot;</span>: <span class="hljs-string">&quot;&lt;root&gt;&quot;</span>,<br>        <span class="hljs-string">&quot;owner&quot;</span>: <span class="hljs-string">&quot;1&quot;</span>,<br>        <span class="hljs-string">&quot;threads&quot;</span>: [<br>          &#123;<br>            <span class="hljs-string">&quot;tid&quot;</span>: <span class="hljs-string">&quot;21&quot;</span>,<br>            <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>            <span class="hljs-string">&quot;stack&quot;</span>: [<br>              <span class="hljs-string">&quot;java.base/java.lang.VirtualThread.parkNanos&quot;</span>,<br>              <span class="hljs-string">&quot;java.base/java.lang.Thread.sleep&quot;</span>,<br>              <span class="hljs-string">&quot;com.example.Service.doWork&quot;</span>,<br>              <span class="hljs-string">&quot;...&quot;</span><br>            ]<br>          &#125;<br>        ]<br>      &#125;<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>可观测性优势</strong>:</p>
<ol>
<li><strong>任务树结构</strong>: 清晰显示父子任务关系</li>
<li><strong>作用域信息</strong>: 每个任务属于哪个作用域</li>
<li><strong>栈追踪</strong>: 显示任务在做什么</li>
<li><strong>调试友好</strong>: 类似单线程调试体验</li>
</ol>
<h3 id="10-迁移建议">10. 迁移建议</h3>
<h4 id="10-1-迁移场景">10.1 迁移场景</h4>
<table>
<thead>
<tr>
<th>现有模式</th>
<th>结构化并发替代</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ExecutorService.submit()</code> + <code>Future.get()</code></td>
<td><code>StructuredTaskScope.fork()</code></td>
<td>生命周期自动管理</td>
</tr>
<tr>
<td><code>CompletableFuture.allOf()</code></td>
<td><code>ShutdownOnFailure</code></td>
<td>错误自动传播</td>
</tr>
<tr>
<td><code>CompletableFuture.anyOf()</code></td>
<td><code>ShutdownOnSuccess</code></td>
<td>自动取消其他任务</td>
</tr>
<tr>
<td>手动线程管理</td>
<td>结构化并发</td>
<td>消除线程泄漏</td>
</tr>
</tbody>
</table>
<h4 id="10-2-适用场景评估">10.2 适用场景评估</h4>
<table>
<thead>
<tr>
<th>场景</th>
<th>是否迁移</th>
<th>建议</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>新的 IO 密集型应用</strong></td>
<td>强烈推荐</td>
<td>直接使用结构化并发</td>
</tr>
<tr>
<td><strong>现有 ExecutorService 代码</strong></td>
<td>评估</td>
<td>逐步迁移,优先迁移新功能</td>
</tr>
<tr>
<td><strong>CPU 密集型任务</strong></td>
<td>不推荐</td>
<td>继续使用 ForkJoinPool</td>
</tr>
<tr>
<td><strong>长期运行的任务池</strong></td>
<td>不推荐</td>
<td>继续使用 ExecutorService</td>
</tr>
<tr>
<td><strong>需要细粒度控制的场景</strong></td>
<td>评估</td>
<td>结构化并发可能过于严格</td>
</tr>
</tbody>
</table>
<h3 id="11-未来展望">11. 未来展望</h3>
<p>结构化并发代表了 Java 并发编程的未来方向:</p>
<ol>
<li><strong>JDK 23/24</strong>: 可能正式定稿</li>
<li><strong>生态系统</strong>: 更多库将支持结构化并发</li>
<li><strong>工具链</strong>: IDE 和监控工具将增强支持</li>
<li><strong>最佳实践</strong>: 社区将积累更多经验</li>
</ol>
<blockquote>
<p><strong>核心洞察</strong>: 结构化并发不是要完全取代 ExecutorService,而是为请求-响应模式的并发编程提供更简单、更安全、更可维护的解决方案。理解其适用场景,才能充分发挥其价值。</p>
</blockquote>
<h3 id="12-参考资料">12. 参考资料</h3>
<ul>
<li><a target="_blank" rel="noopener" href="https://openjdk.org/jeps/453">JEP 453: Structured Concurrency (Preview)</a></li>
<li><a target="_blank" rel="noopener" href="https://openjdk.org/jeps/462">JEP 462: Structured Concurrency (Second Preview)</a></li>
<li><a target="_blank" rel="noopener" href="https://openjdk.org/jeps/446">JEP 446: Scoped Values (Preview)</a></li>
<li><a target="_blank" rel="noopener" href="https://250bpm.com/blog:71/">Martin Sústrik: Structured Concurrency</a></li>
<li><a target="_blank" rel="noopener" href="https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/">Notes on structured concurrency, or: Go statement considered harmful</a></li>
</ul>
<h3 id="相关文章">相关文章</h3>
<ul>
<li><a href="https://magicliang.github.io/2026/01/24/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0">Java 线程池笔记</a></li>
<li><a href="https://magicliang.github.io/2026/01/19/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96">线程安全与锁优化</a></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://magicliang.github.io">magicliang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://magicliang.github.io/2026/02/07/Java-%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91/">https://magicliang.github.io/2026/02/07/Java-%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a><a class="post-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91/">并发</a></div><div class="post-share"><div class="social-share" data-image="/img/wall-paper-25.jpg" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/" title="Java 并发编程笔记"><img class="cover" src="/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/volatile%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E5%BD%B1%E5%93%8D.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-12</div><div class="info-item-2">Java 并发编程笔记</div></div><div class="info-2"><div class="info-item-1"> juc.xmind 写在前面的话 并发编程最早的实践都在操作系统里。高层语言的并发模型都要基于底层系统对硬件抽象和并发的设计来设计和实现，不能超出操作系统允许的范围。所谓的高级抽象总体上是简化对 OS 底层机制的复杂调用。 并发与异步 本文聚焦并发（Concurrency），即多任务在同一时间段内的交替或并行执行，核心问题是资源共享、线程同步与协作。 **异步（Asynchronous）**是另一维度：调用方发起操作后不等结果返回即继续执行，通过回调、Future或事件机制获取结果。异步可通过单线程事件循环实现，也可依托多线程并发实现。 二者关系：并发关注&quot;多任务如何执行与协调&quot;，异步关注&quot;调用是否阻塞等待&quot;。并发编程常涉及异步，但本文不展开异步编程模式（如响应式流、协程），相关内容请参阅《Java 线程池笔记》。 管程 理论和实践之间是有鸿沟的，要弥合这种鸿沟，通常需要我们去学习别人的实践。比如并发的标准设计思想来自于操作系统里的管程（monitor），我们应当学习管程，进而了解标准的并发模型-管理共享变量和线程（并发任务）间通信的基本...</div></div></div></a><a class="pagination-related" href="/2026/02/06/%E8%B7%A8%E8%AF%AD%E8%A8%80%E8%B6%85%E6%97%B6%E6%9C%BA%E5%88%B6%E5%85%A8%E8%A7%A3%E6%9E%90/" title="跨语言超时机制全解析"><img class="cover" src="/2026/02/06/%E8%B7%A8%E8%AF%AD%E8%A8%80%E8%B6%85%E6%97%B6%E6%9C%BA%E5%88%B6%E5%85%A8%E8%A7%A3%E6%9E%90/go-channel%E8%B6%85%E6%97%B6.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-02-06</div><div class="info-item-2">跨语言超时机制全解析</div></div><div class="info-2"><div class="info-item-1">从&quot;等不起&quot;到&quot;不想等&quot;：跨语言超时机制全解析  “A distributed system is one in which the failure of a computer you didn’t even know existed can render your own computer unusable.” —— Leslie Lamport 在分布式系统中，超时是应用与混沌之间最后一道防线。没有超时的 RPC 调用，如同没有刹车的汽车——迟早会撞上墙。  许多 Java 开发者对超时的认知停留在 Future.get(timeout, unit) 这一层，其底层依赖 LockSupport.parkNanos 和自旋等待。然而，翻阅 HSF/Dubbo 的源码会发现，这些 RPC 框架选择的是 HashedWheelTimer（时间轮）。 这就引出了一个值得深究的问题：为什么不直接用 Future.get 的超时版本？时间轮到底解决了什么问题？ 事实上，仅 Java 一门语言就存在三种截然不同的超时实现范式。再放眼 Go、JavaS...</div></div></div></a><a class="pagination-related" href="/2026/01/18/%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/" title="无锁队列"><img class="cover" src="/2026/01/18/%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/%E8%AE%A1%E7%AE%97%E6%9C%BACPU%E4%B8%8E%E7%BC%93%E5%AD%98%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-18</div><div class="info-item-2">无锁队列</div></div><div class="info-2"><div class="info-item-1">Java 一读一写（SPSC）：Memory Barrier + Volatile 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * Single-Producer Single-Consumer (SPSC) 无锁环形队列。 * * &lt;p&gt;原理说明： * - 仅允许一个线程调用 &#123;@code offer()&#125;，一个线程调用 &#123;@code poll()&#125;。 * - 由于没有写竞争，无需 CAS；只需保证写操作对消费者可见。 * - 使用两个 volatile 索引（head/tail）建立 happens-before 关系： *   生产者写入元素 → volatile 写 tail → 消费者 volatile 读 tail → 读取元素。 * - 这本质上利用了 Java 内存模型中的“volatile 写-读”内存屏障（StoreLoad）， *   ...</div></div></div></a><a class="pagination-related" href="/2026/01/24/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0/" title="Java 线程池笔记"><img class="cover" src="/2026/01/24/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0/ThreadPoolExecutorUML%E7%B1%BB%E5%9B%BE.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-24</div><div class="info-item-2">Java 线程池笔记</div></div><div class="info-2"><div class="info-item-1">从执行器到线程池（from executor interface to thread pool implementation）  Pooling is the grouping together of resources (assets, equipment, personnel, effort, etc.) for the purposes of maximizing advantage or minimizing risk to the users. The term is used in finance, computing and equipment management.——wikipedia “池化”思想不仅仅能应用在计算机领域，在金融、设备、人员管理、工作管理等领域也有相关的应用。 在计算机领域中的表现为：统一管理IT资源，包括服务器、存储、和网络资源等等。通过共享资源，使用户在低投入中获益。除去线程池，还有其他比较典型的几种使用策略包括： 内存池(Memory Pooling)：预先申请内存，提升申请内存速度，减少内存碎片。 连接池(Connection Pool...</div></div></div></a><a class="pagination-related" href="/2026/01/19/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/" title="线程安全与锁优化"><img class="cover" src="/2026/01/19/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/synchronized%E5%8E%9F%E7%90%86.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-19</div><div class="info-item-2">线程安全与锁优化</div></div><div class="info-2"><div class="info-item-1"> 版本说明：本文主要基于 JDK 6 ~ JDK 14 的 HotSpot 虚拟机实现。需要注意的是，从 JDK 15 开始，偏向锁已被默认关闭并标记为废弃（JEP 374）。如果你使用的是 JDK 15+，文中关于偏向锁的内容仅作为历史参考。  线程安全 什么是线程安全 “当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方法进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象就是线程安全的。” 相对的线程安全，可以分成五个等级。但在深入讨论线程安全的分类之前，我们需要先理解 Java 内存模型——它是理解线程安全问题的理论基础。 Java 内存模型基础 Java 内存模型（Java Memory Model，JMM）是 Java 语言规范的一部分，定义了多线程程序中共享变量的访问规则。理解 JMM 是理解线程安全问题的基础。 为什么需要内存模型？ 现代计算机系统中，CPU 与主内存之间存在巨大的速度差异。为了弥补这一差距，硬件层面引入了多级缓存（L1、L2、L3 Cache）。这带来了一个问...</div></div></div></a><a class="pagination-related" href="/2017/10/23/%E6%98%82%E8%B4%B5%E7%9A%84%E5%BC%82%E5%B8%B8/" title="昂贵的异常"><img class="cover" src="/img/wall-paper-64.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-10-23</div><div class="info-item-2">昂贵的异常</div></div><div class="info-2"><div class="info-item-1">抛出问题 Joshua Bloch 在《Effective Java》的 Item 57 里明确地提到过，不要试图用 Exception 的跳转来代替正常的程序控制流。他列举了很多原因，但特别提到了抛出异常会使得整个程序运行变慢。抛出异常远比普通的 return、break 等操作对控制流、数据流的性能影响要大，它就只适合拿来作异常分支的控制语句，而不能拿来编写正常的逻辑。  Throwing exception is expensive.  这句话在 Java 的程序员世界里面已经成为老生常谈，却很少有人谈及到底抛出异常比正常的程序跳转返回慢在哪里，有多慢。&quot;不要滥用异常&quot;好像一个猴子定律，人们知道不能这么做，却不明白为什么不能这么做。 此前读了一位同事写的好文《Java虚拟机是如何处理异常的》，深入地分析了 JVM 对异常跳转的处理过程：JVM 会通过异常表的机制，优化异常抛出和正常返回之间的性能差异。仅从程序计数器的移动上来讲，抛出一个异常对栈帧的弹栈并不比直接返回更昂贵。写在前头的结论是：&quot;try-catch 语句块几乎不会影响程序运行性能！...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91-structured-concurrency"><span class="toc-number">1.</span> <span class="toc-text">结构化并发（Structured Concurrency）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8E%86%E5%8F%B2%E8%83%8C%E6%99%AF"><span class="toc-number">1.1.</span> <span class="toc-text">1. 历史背景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91%E7%9A%84%E8%B5%B7%E6%BA%90%E4%B8%8E%E6%A0%B8%E5%BF%83%E7%B1%BB%E6%AF%94"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1 结构化并发的起源与核心类比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E4%B8%8E%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2 与结构化编程的关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BC%A0%E7%BB%9F%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.</span> <span class="toc-text">2. 传统并发编程的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1 三大核心问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E9%97%AE%E9%A2%98%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2 问题代码示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="toc-number">1.3.</span> <span class="toc-text">3. 结构化并发的核心思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-java-%E4%B8%AD%E7%9A%84%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91%E6%BC%94%E8%BF%9B"><span class="toc-number">1.4.</span> <span class="toc-text">4. Java 中的结构化并发演进</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-jep-%E6%BC%94%E8%BF%9B%E6%A6%82%E8%A7%88"><span class="toc-number">1.4.1.</span> <span class="toc-text">4.1 JEP 演进概览</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-jdk-19-jep-428-%E9%A6%96%E6%AC%A1%E5%AD%B5%E5%8C%96"><span class="toc-number">1.4.2.</span> <span class="toc-text">4.2 JDK 19 (JEP 428) - 首次孵化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-jdk-20-jep-437-%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AD%B5%E5%8C%96"><span class="toc-number">1.4.3.</span> <span class="toc-text">4.3 JDK 20 (JEP 437) - 第二次孵化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-jdk-21-jep-453-%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%A2%84%E8%A7%88"><span class="toc-number">1.4.4.</span> <span class="toc-text">4.4 JDK 21 (JEP 453) - 第一次预览</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-jdk-22-jep-462-%E7%AC%AC%E4%BA%8C%E6%AC%A1%E9%A2%84%E8%A7%88"><span class="toc-number">1.4.5.</span> <span class="toc-text">4.5 JDK 22 (JEP 462) - 第二次预览</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-structuredtaskscope-%E6%A0%B8%E5%BF%83-api"><span class="toc-number">1.5.</span> <span class="toc-text">5. StructuredTaskScope 核心 API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-%E7%B1%BB%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.1.</span> <span class="toc-text">5.1 类层次结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-%E5%9F%BA%E7%A1%80-api"><span class="toc-number">1.5.2.</span> <span class="toc-text">5.2 基础 API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-shutdownonfailure-%E7%AD%96%E7%95%A5"><span class="toc-number">1.5.3.</span> <span class="toc-text">5.3 ShutdownOnFailure 策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-shutdownonsuccess-%E7%AD%96%E7%95%A5"><span class="toc-number">1.5.4.</span> <span class="toc-text">5.4 ShutdownOnSuccess 策略</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%B8%8E%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8D%8F%E5%90%8C"><span class="toc-number">1.6.</span> <span class="toc-text">6. 与虚拟线程的协同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.7.</span> <span class="toc-text">7. 实际应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-%E5%85%B8%E5%9E%8B%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.7.1.</span> <span class="toc-text">7.1 典型使用模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F-1-fan-out-fan-in"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">模式 1: Fan-Out &#x2F; Fan-In</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F-2-%E7%AB%9E%E4%BA%89%E6%A8%A1%E5%BC%8F-race"><span class="toc-number">1.7.1.2.</span> <span class="toc-text">模式 2: 竞争模式 (Race)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F-3-%E6%89%B9%E9%87%8F%E5%A4%84%E7%90%86"><span class="toc-number">1.7.1.3.</span> <span class="toc-text">模式 3: 批量处理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F-4-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A4%84%E7%90%86"><span class="toc-number">1.7.1.4.</span> <span class="toc-text">模式 4: 服务器处理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-%E4%B8%8E%E4%BC%A0%E7%BB%9F-executorservice-%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">1.7.2.</span> <span class="toc-text">7.2 与传统 ExecutorService 的对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">1.8.</span> <span class="toc-text">8. 最佳实践</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8-try-with-resources"><span class="toc-number">1.8.1.</span> <span class="toc-text">8.1 正确使用 try-with-resources</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-%E6%AD%A3%E7%A1%AE%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8"><span class="toc-number">1.8.2.</span> <span class="toc-text">8.2 正确处理异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-%E5%93%8D%E5%BA%94%E4%B8%AD%E6%96%AD"><span class="toc-number">1.8.3.</span> <span class="toc-text">8.3 响应中断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-%E9%81%BF%E5%85%8D%E8%BF%87%E6%B7%B1%E7%9A%84%E5%B5%8C%E5%A5%97"><span class="toc-number">1.8.4.</span> <span class="toc-text">8.4 避免过深的嵌套</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-%E5%90%88%E7%90%86%E4%BD%BF%E7%94%A8%E8%B6%85%E6%97%B6"><span class="toc-number">1.8.5.</span> <span class="toc-text">8.5 合理使用超时</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7"><span class="toc-number">1.9.</span> <span class="toc-text">9. 可观测性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E8%BF%81%E7%A7%BB%E5%BB%BA%E8%AE%AE"><span class="toc-number">1.10.</span> <span class="toc-text">10. 迁移建议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-%E8%BF%81%E7%A7%BB%E5%9C%BA%E6%99%AF"><span class="toc-number">1.10.1.</span> <span class="toc-text">10.1 迁移场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%E8%AF%84%E4%BC%B0"><span class="toc-number">1.10.2.</span> <span class="toc-text">10.2 适用场景评估</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E6%9C%AA%E6%9D%A5%E5%B1%95%E6%9C%9B"><span class="toc-number">1.11.</span> <span class="toc-text">11. 未来展望</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">1.12.</span> <span class="toc-text">12. 参考资料</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%96%87%E7%AB%A0"><span class="toc-number">1.13.</span> <span class="toc-text">相关文章</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2017 - 2026 By magicliang</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional and Simplified Chinese">簡</button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><script src="/js/tw_cn.js?v=5.5.2"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="/"></script></div></body></html>