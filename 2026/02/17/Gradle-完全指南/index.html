<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Gradle 完全指南 | 守株阁</title><meta name="author" content="magicliang"><meta name="copyright" content="magicliang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Gradle 完全指南 全景导图 mindmap   root((Gradle))     核心概念       Project模型       Task系统       生命周期       插件机制     依赖管理       Configuration       依赖解析       版本冲突       传递依赖     构建脚本       Groovy DSL       Kotl">
<meta property="og:type" content="article">
<meta property="og:title" content="Gradle 完全指南">
<meta property="og:url" content="https://magicliang.github.io/2026/02/17/Gradle-%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/index.html">
<meta property="og:site_name" content="守株阁">
<meta property="og:description" content="Gradle 完全指南 全景导图 mindmap   root((Gradle))     核心概念       Project模型       Task系统       生命周期       插件机制     依赖管理       Configuration       依赖解析       版本冲突       传递依赖     构建脚本       Groovy DSL       Kotl">
<meta property="og:locale">
<meta property="og:image" content="https://magicliang.github.io/2026/02/17/Gradle-%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/Gradle_logo.png">
<meta property="article:published_time" content="2026-02-17T02:00:00.000Z">
<meta property="article:modified_time" content="2026-02-17T15:50:52.033Z">
<meta property="article:author" content="magicliang">
<meta property="article:tag" content="Gradle">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="构建工具">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://magicliang.github.io/2026/02/17/Gradle-%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/Gradle_logo.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Gradle 完全指南",
  "url": "https://magicliang.github.io/2026/02/17/Gradle-%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/",
  "image": "https://magicliang.github.io/2026/02/17/Gradle-%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/Gradle_logo.png",
  "datePublished": "2026-02-17T02:00:00.000Z",
  "dateModified": "2026-02-17T15:50:52.033Z",
  "author": [
    {
      "@type": "Person",
      "name": "magicliang",
      "url": "https://magicliang.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://magicliang.github.io/2026/02/17/Gradle-%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: magicliang","link":"Link: ","source":"Source: 守株阁","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Gradle 完全指南',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"><link rel="alternate" href="/atom.xml" title="守株阁" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      if ($loadingBox.classList.contains('loaded')) return
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()

  if (document.readyState === 'complete') {
    preloader.endLoading()
  } else {
    window.addEventListener('load', preloader.endLoading)
    document.addEventListener('DOMContentLoaded', preloader.endLoading)
    // Add timeout protection: force end after 7 seconds
    setTimeout(preloader.endLoading, 7000)
  }

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/2026/02/17/Gradle-%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/Gradle_logo.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">守株阁</span></a><a class="nav-page-title" href="/"><span class="site-name">Gradle 完全指南</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">Gradle 完全指南</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2026-02-17T02:00:00.000Z" title="Created 2026-02-17 10:00:00">2026-02-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2026-02-17T15:50:52.033Z" title="Updated 2026-02-17 23:50:52">2026-02-17</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">10.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>45mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1>Gradle 完全指南</h1>
<h2 id="全景导图">全景导图</h2>
<pre><code class="hljs mermaid">mindmap
  root((Gradle))
    核心概念
      Project模型
      Task系统
      生命周期
      插件机制
    依赖管理
      Configuration
      依赖解析
      版本冲突
      传递依赖
    构建脚本
      Groovy DSL
      Kotlin DSL
      多项目构建
    插件生态
      Java插件
      Spring Boot插件
      自定义插件
    性能优化
      构建缓存
      并行构建
      增量构建
    测试管理
      单元测试
      集成测试
      覆盖率</code></pre>
<h2 id="什么是-gradle">什么是 Gradle</h2>
<p>Gradle 是新一代的自动化构建工具，基于 Apache Ant 和 Apache Maven 的概念发展而来。与 Maven 使用 XML 配置不同，Gradle 采用基于 Groovy 或 Kotlin 的领域特定语言（DSL）来声明项目配置，大幅简化了构建脚本的复杂度。</p>
<p><strong>核心特点</strong>（参考 <a target="_blank" rel="noopener" href="https://docs.gradle.org/">Gradle 官方文档</a>）：</p>
<ul>
<li><strong>灵活性</strong>：Gradle 的设计理念是&quot;语言优先&quot;而非&quot;框架优先&quot;，提供了高度的可扩展性</li>
<li><strong>性能</strong>：支持增量构建、构建缓存、并行执行等优化手段</li>
<li><strong>生态</strong>：Android 官方构建工具，拥有丰富的插件生态</li>
<li><strong>兼容性</strong>：可以导入 Maven 和 Ivy 仓库，支持迁移现有项目</li>
</ul>
<p><img src="author-gradle-2.png" alt="author-gradle-2"><br>
<img src="gradle-basic-flow.png" alt="gradle-basic-flow"><br>
<a href="gradle.xmind">gradle.xmind</a><br>
<img src="gradle.png" alt="gradle"></p>
<p><img src="gradle%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" alt="gradle流程图"><br>
<img src="android%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B.webp" alt="android打包流程"></p>
<p>这里的 AIDL 是 Android Interface Definition Language 的意思。Dex 是 Dalvik executable format 的意思。</p>
<p><img src="aapt2%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B.webp" alt="aapt2编译流程"></p>
<h2 id="核心概念">核心概念</h2>
<p>Gradle 是一个自动化构建工具（build automation），通过组织一系列 Task 来完成自动化构建。与 Maven 不同，Gradle 不标榜自己是项目管理工具，而是专注于构建自动化。</p>
<h3 id="project-模型">Project 模型</h3>
<p>每个 Gradle 构建由一个或多个 Project 组成。<code>build.gradle</code> 文件本质上是在配置一个 <code>Project</code> 对象（参考 <a target="_blank" rel="noopener" href="https://docs.gradle.org/current/dsl/org.gradle.api.Project.html">Gradle DSL Reference - Project</a>）。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// build.gradle 实际上是在配置 Project 对象</span><br>project.version = <span class="hljs-string">&#x27;1.0.0&#x27;</span><br>project.group = <span class="hljs-string">&#x27;com.example&#x27;</span><br><br><span class="hljs-comment">// 简化写法（省略 project 前缀）</span><br>version = <span class="hljs-string">&#x27;1.0.0&#x27;</span><br>group = <span class="hljs-string">&#x27;com.example&#x27;</span><br></code></pre></td></tr></table></figure>
<p><strong>Project 的核心职责</strong>：</p>
<ol>
<li>管理依赖（dependencies）</li>
<li>定义任务（tasks）</li>
<li>应用插件（plugins）</li>
<li>配置属性（properties）</li>
</ol>
<h3 id="task-系统">Task 系统</h3>
<p>Task 是 Gradle 中最重要的概念。构建过程由一系列 Task 组成，每个 Task 代表一个原子操作（如编译、测试、打包）。以打包生成 APK 为例，整个过程要经过资源处理、javac 编译、dex 打包、apk 打包、签名等步骤，<strong>每个步骤就对应一个 Task</strong>。</p>
<h4 id="task-的创建方式">Task 的创建方式</h4>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// 方式1：使用 task 关键字</span><br>task myTask &#123;<br>    doLast &#123;<br>        println <span class="hljs-string">&#x27;执行任务&#x27;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 方式2：使用 tasks.register（推荐，延迟配置）</span><br>tasks.register(<span class="hljs-string">&#x27;myTask&#x27;</span>) &#123;<br>    doLast &#123;<br>        println <span class="hljs-string">&#x27;执行任务&#x27;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 方式3：指定类型</span><br>tasks.register(<span class="hljs-string">&#x27;myTask&#x27;</span>, Copy) &#123;<br>    from <span class="hljs-string">&#x27;src&#x27;</span><br>    into <span class="hljs-string">&#x27;dest&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="task-的依赖关系">Task 的依赖关系</h4>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs groovy">task taskA &#123;<br>    doLast &#123;<br>        println <span class="hljs-string">&#x27;Task A&#x27;</span><br>    &#125;<br>&#125;<br><br>task taskB &#123;<br>    dependsOn taskA  <span class="hljs-comment">// taskB 依赖 taskA</span><br>    doLast &#123;<br>        println <span class="hljs-string">&#x27;Task B&#x27;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 执行顺序控制</span><br>taskB.mustRunAfter(taskA)  <span class="hljs-comment">// taskB 必须在 taskA 之后执行</span><br>taskB.shouldRunAfter(taskA)  <span class="hljs-comment">// taskB 应该在 taskA 之后执行（软约束）</span><br></code></pre></td></tr></table></figure>
<h4 id="task-的配置">Task 的配置</h4>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs groovy">task myTask &#123;<br>    group = <span class="hljs-string">&#x27;build&#x27;</span>  <span class="hljs-comment">// 任务分组</span><br>    description = <span class="hljs-string">&#x27;这是一个示例任务&#x27;</span>  <span class="hljs-comment">// 任务描述</span><br>    enabled = <span class="hljs-literal">true</span>  <span class="hljs-comment">// 是否启用</span><br>    <br>    doFirst &#123;<br>        println <span class="hljs-string">&#x27;任务开始前执行&#x27;</span><br>    &#125;<br>    <br>    doLast &#123;<br>        println <span class="hljs-string">&#x27;任务结束后执行&#x27;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="生命周期">生命周期</h3>
<p>Gradle 构建分为三个阶段（参考 <a target="_blank" rel="noopener" href="https://docs.gradle.org/current/userguide/build_lifecycle.html">Gradle User Guide - Build Lifecycle</a>）：</p>
<pre><code class="hljs mermaid">graph LR
    A[初始化阶段] --&gt; B[配置阶段]
    B --&gt; C[执行阶段]</code></pre>
<p><strong>1. 初始化阶段（Initialization）</strong></p>
<ul>
<li>读取 <code>settings.gradle</code></li>
<li>确定哪些项目参与构建</li>
<li>为每个项目创建 <code>Project</code> 实例</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// settings.gradle</span><br>rootProject.name = <span class="hljs-string">&#x27;my-project&#x27;</span><br>include <span class="hljs-string">&#x27;module-a&#x27;</span>, <span class="hljs-string">&#x27;module-b&#x27;</span><br></code></pre></td></tr></table></figure>
<p><strong>2. 配置阶段（Configuration）</strong></p>
<ul>
<li>执行所有项目的 <code>build.gradle</code> 脚本</li>
<li>构建 Task 依赖图</li>
<li>确定需要执行的 Task</li>
</ul>
<p><strong>3. 执行阶段（Execution）</strong></p>
<ul>
<li>按依赖顺序执行 Task</li>
<li>执行 Task 的 <code>doFirst</code> 和 <code>doLast</code> 动作</li>
</ul>
<h3 id="插件机制">插件机制</h3>
<p>插件是 Gradle 功能的主要扩展方式。每个插件都会引入新的 Task、配置项和约定（参考 <a target="_blank" rel="noopener" href="https://plugins.gradle.org/">Gradle Plugin Portal</a>）。</p>
<h4 id="应用插件">应用插件</h4>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// 方式1：使用 plugins DSL（推荐）</span><br>plugins &#123;<br>    id <span class="hljs-string">&#x27;java&#x27;</span><br>    id <span class="hljs-string">&#x27;org.springframework.boot&#x27;</span> version <span class="hljs-string">&#x27;2.7.0&#x27;</span><br>&#125;<br><br><span class="hljs-comment">// 方式2：使用 apply</span><br>apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;java&#x27;</span><br></code></pre></td></tr></table></figure>
<h4 id="常用插件">常用插件</h4>
<table>
<thead>
<tr>
<th>插件</th>
<th>功能</th>
<th>引入的主要 Task</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>java</code></td>
<td>Java 项目支持</td>
<td><code>compileJava</code>, <code>test</code>, <code>jar</code></td>
</tr>
<tr>
<td><code>application</code></td>
<td>可执行应用</td>
<td><code>run</code>, <code>installDist</code></td>
</tr>
<tr>
<td><code>maven-publish</code></td>
<td>Maven 发布</td>
<td><code>publish</code>, <code>publishToMavenLocal</code></td>
</tr>
<tr>
<td><code>org.springframework.boot</code></td>
<td>Spring Boot</td>
<td><code>bootJar</code>, <code>bootRun</code></td>
</tr>
</tbody>
</table>
<h3 id="dsl-概念">DSL 概念</h3>
<p>Gradle 可以使用 Groovy 或 Kotlin DSL 编写。DSL（Domain Specific Language）是领域特定语言，相对应的是 GPL（General-Purpose Language）如 Java。与 GPL 相比，DSL 使用简单、定义简洁；比起配置文件，DSL 又可以实现语言逻辑。</p>
<p>以 <code>android {}</code> 为例，这本身是一个函数调用，参数是一个闭包，但这种定义方式明显更简洁。</p>
<h3 id="核心类型">核心类型</h3>
<p>Gradle 的核心类型（参考 <a target="_blank" rel="noopener" href="https://docs.gradle.org/current/dsl/">Gradle DSL Reference</a>）：</p>
<ul>
<li><strong>Project</strong>：<code>build.gradle</code> 实际上就是在描述这个类型对象的生成</li>
<li><strong>Task</strong>：构建的基本执行单元</li>
<li><strong>Gradle</strong>：全局 Gradle 实例</li>
<li><strong>Settings</strong>：项目设置</li>
<li><strong>SourceSet</strong>：源码集合</li>
<li><strong>Configuration</strong>：依赖配置</li>
<li><strong>Plugin</strong>：插件接口</li>
<li>ExtraPropertiesExtension</li>
<li>PluginDependenciesSpec</li>
<li>PluginDependencySpec</li>
<li>PluginManagementSpec</li>
<li>ResourceHandler</li>
<li>TextResourceFactory</li>
<li>InputChanges</li>
<li>Distribution</li>
</ul>
<h2 id="project-对象">Project 对象</h2>
<p>我们常见的属性其实是<strong>一个 Project 对象的实例</strong>，使用 groovy 进行配置更像是使用一种 DSL 进行设值。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs groovy">buildscript <span class="hljs-comment">// 配置脚本（build.gradle）的 classpath</span><br><br>allprojects <span class="hljs-comment">// 配置项目及其子项目</span><br>respositories <span class="hljs-comment">// 配置仓库地址，后面的依赖都会去这里配置的地址查找</span><br>dependencies <span class="hljs-comment">// 配置项目的依赖</span><br><br><br><span class="hljs-comment">// 一个Android Project工程的标准配置</span><br><br>buildscript &#123; <span class="hljs-comment">// 配置项目（build.gradle）的 classpath</span><br>    <span class="hljs-comment">// 每个 &#123;&#125; 圈定的闭包都是对一个单独的对象实例进行配置，配置的流程就是一行一行地调用方法</span><br>    <span class="hljs-comment">// 在这个块中定义的依赖项和仓库只对构建脚本本身可用，不会影响项目的依赖。通常用于添加 Gradle 插件依赖。</span><br>    repositories &#123;  <span class="hljs-comment">// 项目的仓库地址，会按顺序依次查找</span><br>        <span class="hljs-comment">// 这是一种调用法，寻找插件就在这里面寻找</span><br>        google()<br>        jcenter()<br>        mavenLocal()<br>    &#125;<br>    dependencies &#123; <span class="hljs-comment">// 项目的依赖</span><br>        <span class="hljs-comment">// 这是使用参数的调用法</span><br>        classpath <span class="hljs-string">&#x27;com.android.tools.build:gradle:4.2.1&#x27;</span><br>        classpath <span class="hljs-string">&#x27;com.xx.plugin:xxplugin:0.0.1&#x27;</span><br>        <span class="hljs-comment">// 把插件引入类路径以后，下方还需要/可以 apply plugin: &#x27;io.ebean&#x27;</span><br>        classpath <span class="hljs-string">&quot;io.ebean:ebean-gradle-plugin:12.2.3&quot;</span><br>    &#125;<br>    <br>&#125;<br><br>allprojects &#123; <span class="hljs-comment">// 子项目的配置</span><br>    repositories &#123;<br>        google()<br>        jcenter()<br>        mavenLocal()<br>        flatDir &#123;       <br>            dirs <span class="hljs-string">&quot;libs&quot;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里面的 buildscript 的 dependencies 是给 build.gradle 这个项目脚本构建中使用的。而我们常见的其他地方的 dependencies 是给项目打包/运行的时候项目自身用的。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">import</span> org.yaml.snakeyaml.Yaml<br><br>buildscript &#123;<br>    repositories &#123; <span class="hljs-comment">// Where to find the plugin or library</span><br>        maven &#123;<br>            url = uri(<span class="hljs-string">&quot;https://plugins.gradle.org/m2/&quot;</span>)<br>        &#125;<br>        mavenCentral()<br>    &#125;<br>    dependencies &#123;<br>        classpath <span class="hljs-string">&#x27;org.yaml:snakeyaml:1.19&#x27;</span> <span class="hljs-comment">// The library&#x27;s classpath dependency</span><br>        classpath <span class="hljs-string">&#x27;com.gradleup.shadow:shadow-gradle-plugin:8.3.4&#x27;</span> <span class="hljs-comment">// Plugin dependency for legacy plugin application</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Applies legacy Shadow plugin</span><br>apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;com.gradleup.shadow&#x27;</span><br><br><span class="hljs-comment">// Uses the library in the build script</span><br><span class="hljs-keyword">def</span> yamlContent = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        name: Project Name</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><span class="hljs-keyword">def</span> yaml = <span class="hljs-keyword">new</span> Yaml()<br><span class="hljs-keyword">def</span> data = yaml.load(yamlContent)<br></code></pre></td></tr></table></figure>
<p>在 idea 里，右侧的栏目列出的只有<strong>任务（插件看不见，被融入任务列表）+依赖</strong>。</p>
<p>gradle 能支持的仓库类型/风格有 remote（maven、ivy，可以用Nexus/Sonatype/JFrog）和 local（flatDir）。</p>
<h2 id="task">Task</h2>
<p>任务可以被分为：Application tasks、Build tasks、Documentation tasks、Other tasks。</p>
<h3 id="任务管理">任务管理</h3>
<p>A task represents some independent unit of work that a build performs, such as compiling classes, creating a JAR, generating Javadoc, or publishing archives to a repository.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./gradlew tasks<br></code></pre></td></tr></table></figure>
<h4 id="基本的任务创建形式">基本的任务创建形式</h4>
<p>最新版的做法：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs groovy">tasks.register(<span class="hljs-string">&quot;task1&quot;</span>) &#123;  <br>    println(<span class="hljs-string">&quot;REGISTER TASK1: This is executed during the configuration phase&quot;</span>)<br>&#125;<br><br>tasks.named(<span class="hljs-string">&quot;task1&quot;</span>) &#123;  <br>    println(<span class="hljs-string">&quot;NAMED TASK1: This is executed during the configuration phase&quot;</span>)<br>    doFirst &#123;<br>        println(<span class="hljs-string">&quot;NAMED TASK1 - doFirst: This is executed during the execution phase&quot;</span>)<br>    &#125;<br>    doLast &#123;<br>        println(<span class="hljs-string">&quot;NAMED TASK1 - doLast: This is executed during the execution phase&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>To create a custom task, you must subclass DefaultTask in Groovy DSL or DefaultTask in Kotlin DSL.要创建一个自定义任务，你必须在 Groovy DSL 中继承 DefaultTask 类，或者在 Kotlin DSL 中继承 DefaultTask 类。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// 以任务名创建：接受一个name参数</span><br><span class="hljs-keyword">def</span> task myTask = task(myTask)<br>myTask.doLast&#123;<br> println <span class="hljs-string">&quot;第一种创建Task方法，原型为Task task(String name) throws InvalidUserDataException&quot;</span><br>&#125;<br><br><span class="hljs-comment">// 以任务名+Map创建：Map参数用于对创建的task进行配置，可用配置（可选参数有）有 type、overwrite、dependsOn、action、description、group</span><br><span class="hljs-keyword">def</span> task myTask = task(myTask, <span class="hljs-attr">group:</span>BasePlugin.BUILD_GROUP)<br>myTask.doLast &#123;<br> println <span class="hljs-string">&quot;第二种创建Task方法，原型为Task task(String name,Map&lt;String,?&gt; args) throws InvalidUserDataException&quot;</span><br>&#125;<br><br><span class="hljs-comment">// 以任务名+闭包创建：常见形式</span><br>task myTask &#123;<br> doLast&#123;<br>   println <span class="hljs-string">&quot;第三种创建Task方法，原型为Task task(String name,Closure configureClosure)，第一个参数是 name，第二个参数是 configureClosure&quot;</span><br> &#125;<br>&#125;<br><br><span class="hljs-comment">// 多任务依赖，这里面 task1 和 task2 之间没有依赖关系</span><br>task task1&lt;&lt;&#123; <span class="hljs-comment">// 每个任务都使用了 &lt;&lt; 操作符，这是一种在旧版本 Gradle 中添加任务动作的方式。 (注意：&lt;&lt; 操作符在新版本的 Gradle 中已被弃用，现在推荐使用 doLast 方法)</span><br> println <span class="hljs-string">&#x27;hello&#x27;</span><br>&#125;<br>task task2&lt;&lt;&#123;<br> println <span class="hljs-string">&#x27;world&#x27;</span><br>&#125;<br><span class="hljs-comment">// 依赖单个任务</span><br>task task3(<span class="hljs-attr">dependsOn:</span>task1) &#123;<br> doLast&#123;<br>   println <span class="hljs-string">&#x27;one&#x27;</span><br> &#125;<br>&#125;<br><span class="hljs-comment">// 依赖多个任务</span><br>task task4 &#123;<br> dependsOn task1,task2<br> doLast&#123;<br>   println <span class="hljs-string">&#x27;two&#x27;</span><br> &#125;<br>&#125;<br><br><span class="hljs-comment">// 强制排序</span><br>taskB.shouldRunAfter(taskA) <span class="hljs-comment">// 表示taskB应该在taskA执行之后执行，有可能不会按预设执行</span><br>taskB.mustRunAfter(taskA) <span class="hljs-comment">// 表示taskB必须在taskA执行之后执行</span><br><br><span class="hljs-comment">// 分组&amp;描述：分组是对任务的分类，便于归类整理；描述是说明任务的作用；建议两个一起配置，便于快速了解任务的分类和用途。和上面的“以任务名+Map创建”本质上相同</span><br><span class="hljs-keyword">def</span> task myTask = task(myTask)<br>myTask .group = BasePlugin.BUILD_GROUP<br>myTask .description = <span class="hljs-string">&#x27;这是一个构建的引导任务&#x27;</span><br><br><span class="hljs-comment">// 启用&amp;禁用：enable属性可以启动和禁用任务，执行被禁用的任务输出提示该任务被跳过</span><br><span class="hljs-keyword">def</span> task myTask = task(myTask)<br>myTask.enable = <span class="hljs-literal">false</span> <span class="hljs-comment">//禁用任务</span><br></code></pre></td></tr></table></figure>
<p>执行分析：<strong>执行 Task 的时候实际上是执行其拥有的 actions List，它是 Task 对象实例的成员变量；在创建任务时Gradle会解析其中被 TaskAction 注解的方法作为其Task执行的 action，并添加到 actions List，其中 doFirst 和 doList 会被添加到 action List 第一位和最后一位</strong>。</p>
<p>每次构建（build）至少由一个 project 构成，一个 project  由一到多个 task 构成。每个 task 代表了构建过程当中的一个原子性操作，比如编译，打包，生成 javadoc，发布等等这些操作。</p>
<blockquote>
<p>project<br>
– task1 （Action1、Action2…）<br>
– task2 （Action1、Action2…）<br>
– …</p>
</blockquote>
<h4 id="通过任务把功能注册成插件">通过任务把功能注册成插件</h4>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// 伪代码</span><br>open <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProjectDependencyGraphGeneratorTask</span> : DefaultTask() &#123;<br>    <span class="hljs-meta">@TaskAction</span><br>    fun run() &#123;<br>        File(outputDirectory, projectGenerator.outputFileNameDot).writeText(graph.toString())<br><br>        val graphviz = Graphviz.fromGraph(graph)<br><br>        projectGenerator.outputFormats.forEach &#123;<br>            graphviz.render(it).toFile(File(outputDirectory, projectGenerator.outputFileName))<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 伪代码</span><br>open <span class="hljs-keyword">class</span> <span class="hljs-title class_">DependencyGraphGeneratorPlugin</span> : Plugin&lt;Project&gt; &#123;<br>  override fun apply(<span class="hljs-attr">project:</span> Project) &#123;<br>     project.tasks.register(projectGenerator.gradleTaskName, <span class="hljs-attr">ProjectDependencyGraphGeneratorTask:</span>:<span class="hljs-keyword">class</span>.java)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTask</span> : DefaultTask &#123;<br>    <span class="hljs-meta">@TaskAction</span><br>    fun doAction()&#123;<br>        println(<span class="hljs-string">&quot;my task run&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FastPlugin</span> : Plugin&lt;Project&gt; &#123;<br>    override fun apply(<span class="hljs-attr">project:</span> Project) &#123;<br>        println(<span class="hljs-string">&quot;apply my plugin&quot;</span>)<br>        project.tasks.register(<span class="hljs-string">&quot;mytask&quot;</span>, <span class="hljs-attr">MyTask:</span>:<span class="hljs-keyword">class</span>.java)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="定义任务的依赖关系">定义任务的依赖关系</h4>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs groovy">task putOnSocks &#123;<br>    doLast &#123;<br>        println <span class="hljs-string">&quot;Putting on Socks.&quot;</span><br>    &#125;<br>&#125;<br><br>task putOnShoes &#123;<br>    dependsOn <span class="hljs-string">&quot;putOnSocks&quot;</span><br>    doLast &#123;<br>        println <span class="hljs-string">&quot;Putting on Shoes.&quot;</span><br>    &#125;<br>&#125;<br><br>task eatBreakfast &#123;<br>    finalizedBy <span class="hljs-string">&quot;brushYourTeeth&quot;</span><br>    doLast&#123;<br>        println <span class="hljs-string">&quot;Om nom nom breakfast!&quot;</span><br>    &#125;<br>&#125;<br><br>task brushYourTeeth &#123;<br>    doLast &#123;<br>        println <span class="hljs-string">&quot;Brushie Brushie Brushie.&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="向任务注入对象">向任务注入对象</h4>
<p>可注入对象：</p>
<ul>
<li>ObjectFactory- 允许创建模型对象。</li>
<li>ProjectLayout- 提供对关键项目位置的访问权限。</li>
<li>BuildLayout- 提供对 Gradle 构建的重要位置的访问。</li>
<li>ProviderFactory- 创建Provider实例。</li>
<li>WorkerExecutor- 允许任务并行运行。</li>
<li>FileSystemOperations- 允许任务在文件系统上运行操作，例如删除文件、复制文件或同步目录。</li>
<li>ArchiveOperations- 允许任务对存档文件（例如 ZIP 或 TAR 文件）运行操作。</li>
<li>ExecOperations- 允许任务运行外部进程，并提供专门的运行外部java程序的支持。</li>
<li>ToolingModelBuilderRegistry- 允许插件注册 Gradle 工具 API 模型。</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs groovy">tasks.register(<span class="hljs-string">&quot;myObjectFactoryTask&quot;</span>) &#123;<br>    doLast &#123;<br>        <span class="hljs-keyword">def</span> objectFactory = project.objects<br>        <span class="hljs-keyword">def</span> myProperty = objectFactory.property(String)<br>        myProperty.set(<span class="hljs-string">&quot;Hello, Gradle!&quot;</span>)<br>        println myProperty.get()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DownloadExtension</span> &#123;<br>    <span class="hljs-comment">// A nested instance</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Resource resource;<br><br>    <span class="hljs-meta">@Inject</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DownloadExtension</span><span class="hljs-params">(ObjectFactory objectFactory)</span> &#123;<br>        <span class="hljs-comment">// Use an injected ObjectFactory to create a Resource object</span><br>        resource = objectFactory.newInstance(Resource.class);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Resource <span class="hljs-title function_">getResource</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> resource;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Resource</span> &#123;<br>    Property&lt;URI&gt; <span class="hljs-title function_">getUri</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="属性管理">属性管理</h2>
<p>Project、Task 和 SourceSet 都允许用户添加额外的自定义属性、并对自定义属性进行读取和设置。</p>
<ul>
<li>方式：通过ext属性，添加多个 ext 代码块</li>
<li>优点：相比局部变量有广泛的作用域，可以跨 Project、跨 Task 访问，只要能访问这些属性所属的对象即可</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// 给Project添加自定义属性</span><br>ext.age = <span class="hljs-number">18</span><br>ext &#123;<br> phone = <span class="hljs-number">13888888888</span><br> address = <span class="hljs-string">&#x27;Beijing&#x27;</span><br>&#125;<br><br><span class="hljs-comment">// 给Task添加自定义属性</span><br>task customProperty &#123; <br> ext.inner = <span class="hljs-string">&#x27;innnnnner&#x27;</span> <br> <br> doLast&#123;<br>   println project.hasProperty(<span class="hljs-string">&#x27;customProperty&#x27;</span>) <span class="hljs-comment">// true</span><br>   println project.hasProperty(<span class="hljs-string">&#x27;age&#x27;</span>) <span class="hljs-comment">// true</span><br>   println project.hasProperty(<span class="hljs-string">&#x27;inner&#x27;</span>)<span class="hljs-comment">// 返回fasle</span><br>   println <span class="hljs-string">&quot;$&#123;age&#125;&quot;</span><br>   println <span class="hljs-string">&quot;$&#123;phone&#125;&quot;</span><br>   println <span class="hljs-string">&quot;$&#123;inner&#125;&quot;</span><br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="惰性加载">惰性加载</h3>
<p><img src="prop-prov-1.png" alt="为什么要使用 property 而不使用原始类型"></p>
<p>Gradle 使用两个接口表示惰性属性：</p>
<ul>
<li>property - 表示可以查询和更改的值。属性可能是可变的，这意味着它同时具有get()方法和set()方法（类似C#）。</li>
<li>provider - 表示只能查询而不能更改的值。也叫Read-only Managed Properties (Providers)。</li>
</ul>
<h2 id="plugin">Plugin</h2>
<p>Plugins are the primary method to organize build logic and reuse build logic within a project.</p>
<p>Plugins are used to extend Gradle’s capability（功能） and optionally contribute tasks to a project.</p>
<p>plugin 里带有很多 tasks。一个 plugin 主要影响 source set 和 configuration，带来了属性（SourceSet就性质而言是一种 property，但文档把它称作 domain objects）、方法和任务。</p>
<ul>
<li>Java 插件
<ul>
<li>插件 ID: java</li>
<li>主要功能：
<ul>
<li>添加 Java 编译能力</li>
<li>提供标准的 Java 项目结构和任务（如 compileJava, test）</li>
<li>添加基本的依赖配置（如 implementation, testImplementation）</li>
</ul>
</li>
<li>适用场景：基本的 Java 项目，<strong>很多插件都扩展本插件，包括但不限于：Application、Java Library</strong></li>
</ul>
</li>
<li>Application 插件
<ul>
<li>插件 ID: application</li>
<li>主要功能：
<ul>
<li>包含 Java 插件的所有功能</li>
<li>添加运行和打包应用程序的能力</li>
<li>提供 run 任务来执行应用程序</li>
<li>可以创建可分发的 ZIP 和 TAR 包</li>
</ul>
</li>
<li>适用场景：需要作为独立应用程序运行的 Java 项目</li>
</ul>
</li>
<li>Java Library 插件
<ul>
<li>插件 ID: java-library</li>
<li>主要功能：
<ul>
<li>扩展了 Java 插件</li>
<li>引入 api 和 implementation 依赖配置的区别</li>
<li>更好地控制库的 API 暴露</li>
</ul>
</li>
<li>适用场景：开发供其他项目使用的 Java 库</li>
</ul>
</li>
<li>Spring Boot 插件
<ul>
<li>插件 ID: org.springframework.boot</li>
<li>主要功能：
<ul>
<li>提供 Spring Boot 特定的任务（如 bootRun）</li>
<li>能够创建可执行的 JAR 或 WAR 文件</li>
<li>管理 Spring Boot 依赖版本</li>
<li>提供 Spring Boot 的自动配置支持</li>
</ul>
</li>
<li>适用场景：Spring Boot 应用程序开发</li>
</ul>
</li>
<li>Spring Dependency Management 插件
<ul>
<li>插件 ID: io.spring.dependency-management</li>
<li>主要功能：
<ul>
<li>提供类似 Maven BOM（Bill of Materials）的依赖管理</li>
<li>允许在不指定版本的情况下导入依赖</li>
<li>可以与 Spring Boot 插件配合使用，也可以单独使用</li>
</ul>
</li>
<li>适用场景：需要统一管理依赖版本的项目，特别是 Spring 项目</li>
</ul>
</li>
<li>主要区别和使用场景：
<ul>
<li>基本 Java 项目：使用 java 插件。</li>
<li>可执行的 Java 应用：使用 application 插件。</li>
<li>Java 库开发：使用 java-library 插件。</li>
<li>Spring Boot 应用开发：使用 org.springframework.boot 插件，通常与 io.spring.dependency-management 插件一起使用。</li>
<li>需要精细控制依赖版本的项目：使用 io.spring.dependency-management 插件。</li>
</ul>
</li>
</ul>
<p>这些插件可以组合使用，例如：</p>
<ul>
<li>一个 Spring Boot 应用通常会同时使用 java、org.springframework.boot 和 io.spring.dependency-management 插件。</li>
<li>一个作为库开发的 Spring 项目可能会使用 java-library 和 io.spring.dependency-management 插件。</li>
</ul>
<p>大部分构建类的插件都是派生自 Base 插件，比如 java 插件，然后 The Java Library Plugin also integrates the above tasks into the standard Base Plugin lifecycle tasks，比如jar is attached to assemble，test is attached to check。</p>
<h3 id="分类">分类</h3>
<ol>
<li>Core plugins - Gradle develops and maintains a set of Core Plugins. Gradle Core plugins are a set of plugins that are included in the Gradle distribution itself. 核心插件不需要指定版本。</li>
<li>Community plugins - Gradle’s community shares plugins via the [Gradle Plugin Portal][1]. Community plugins are plugins developed by the Gradle community, rather than being part of the core Gradle distribution. These plugins provide additional functionality that may be specific to certain use cases or technologies.</li>
<li>Local plugins/Custom plugins - Gradle enables users to create custom plugins using APIs.Custom or local plugins are developed and used within a specific project or organization. These plugins are not shared publicly and are tailored to the specific needs of the project or organization.</li>
</ol>
<p>Convention plugins are plugins used to share build logic between subprojects (modules). Users can wrap common logic in a convention plugin. For example, a code coverage plugin used as a convention plugin can survey code coverage for the entire project and not just a specific subproject.</p>
<blockquote>
<p>Gradle highly recommends the use of Convention plugins.</p>
</blockquote>
<p>所有的插件的定义都有这样一段<code>tasks.register</code>。</p>
<p>区分插件的标准是看是已经被编译成字节码（binary plugin），还是能看到源码（script plugin i）。A plugin often starts as a script plugin (because they are easy to write). Then, as the code becomes more valuable, it’s migrated to a binary plugin that can be easily tested and shared between multiple projects or organizations.二进制插件可以更高效共享和运行。</p>
<p>插件的使用总是分两步：</p>
<ol>
<li>resolve 解析：这是配置 repo 和 class path 的意义</li>
<li>apply：会调用<code>Plugin.apply(T)</code></li>
</ol>
<h3 id="声明">声明</h3>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs groovy">plugins &#123;<br>    id(<span class="hljs-string">&quot;org.barfuin.gradle.taskinfo&quot;</span>) version <span class="hljs-string">&quot;2.1.0&quot;</span><br>&#125;<br>allprojects &#123;<br>    apply(plugin = <span class="hljs-string">&quot;org.barfuin.gradle.taskinfo&quot;</span>)<br>    repositories &#123;<br>        mavenCentral()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果在顶层指定过版本，则在其他 method 里可以不指定版本了。</p>
<p>现代的 gradle有个特殊的目录和文件，对全部项目可以这样声明：</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-keyword">plugins</span> &#123;<br>    <span class="hljs-built_in">id</span> <span class="hljs-symbol">&#x27;java</span><span class="hljs-operator">-</span>gradle<span class="hljs-operator">-</span>plugin&#x27;<br>&#125;<br><br><span class="hljs-keyword">gradlePlugin</span> &#123;<br>    <span class="hljs-keyword">plugins</span> &#123;<br>        <span class="hljs-keyword">myPlugins</span> &#123;<br>            <span class="hljs-built_in">id</span> <span class="hljs-operator">=</span> <span class="hljs-symbol">&#x27;my</span><span class="hljs-operator">-</span>plugin&#x27;<br>            implementationClass <span class="hljs-operator">=</span> <span class="hljs-symbol">&#x27;my</span>.MyPlugin&#x27;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="插件仓库">插件仓库</h3>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs groovy">pluginManagement &#123;  <br>    plugins &#123;<br>    &#125;<br>    resolutionStrategy &#123;<br>    &#125;<br>    repositories &#123;<br>        gradlePluginPortal()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="java">java</h3>
<p><img src="javaPluginTasks.png" alt="javaPluginTasks"></p>
<p>这几幅图说明了 java 插件是如此重要！我们常见的构建任务都是这个插件带来的。</p>
<h4 id="sourceset">SourceSet</h4>
<p>Gradle’s Java support was the first to introduce a new concept for building <strong>source-based projects</strong>: source sets。</p>
<p><strong>源码集的概念是由 java 插件引入的，不是 gradle 自带的。</strong></p>
<p>source code and resources files 应该被 logically grouped together。每个 source set 要关注自己的 dependencies 和 classpath。</p>
<p>这个插件的假定 layout 是这样的：</p>
<ul>
<li>src/main/java
<ul>
<li><strong>Production Java source</strong>.</li>
</ul>
</li>
<li>src/main/resources
<ul>
<li>Production resources, such as XML and properties files.</li>
</ul>
</li>
<li>src/test/java
<ul>
<li>Test Java source.</li>
</ul>
</li>
<li>src/test/resources
<ul>
<li>Test resources.</li>
</ul>
</li>
<li>src/sourceSet/java
<ul>
<li>Java source for the source set named sourceSet.</li>
</ul>
</li>
<li>src/sourceSet/resources
<ul>
<li>Resources for the source set named sourceSet.</li>
</ul>
</li>
</ul>
<p>The Java plugin will compile whatever it finds, and handles anything which is missing.</p>
<p>You configure the project layout by configuring the appropriate source set.</p>
<p>我们常见的 main 和 test 是两个 java plugin 从 apache maven <strong>借来</strong>的 convention source set（所以它 maven-compatible）。按照 gradle 的观点，只要共享一个 complilation 和 runtime classpath，就可以把 test 配在同一个 source set 里。main 是用来存放 production source code，而 test 是用来存放测试 source code（默认是 unit test，不是 integration test、acceptance test）。这些 source 是 set 是用来保管 source code 的集合的，output 是它的附加属性。</p>
<p>比如上面的默认 source set 大致上等价于这样一段配置：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs groovy">sourceSets &#123;<br>    main &#123;<br>        java &#123;<br>            srcDirs = [<span class="hljs-string">&#x27;src/main/java&#x27;</span>]<br>        &#125;<br>        resources &#123;<br>            srcDirs = [<span class="hljs-string">&#x27;src/main/resources&#x27;</span>]<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>source set 要关注这三个问题：</p>
<ol>
<li>源代码和源代码的定位</li>
<li>编译的类路径-依赖来自于何处</li>
<li>classes 文件应该被输出到何处</li>
</ol>
<p><img src="java-sourcesets-compilation.png" alt="java-sourcesets-compilation"></p>
<p>这个图里面，configuration 是 property，白色的是一个编译任务（每个 sourceSet 有一个编译任务，名称叫 compileSourceSetJava），三个绿方块就是 source set 关注的三个问题。sourceSet 可以被替换为 main 和 test。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs groovy">plugins &#123;<br>    <span class="hljs-comment">// 源码集的概念是由插件引入的，不是 gradle 自带的</span><br>    id <span class="hljs-string">&#x27;java&#x27;</span><br>&#125;<br><br>repositories &#123;<br>    mavenCentral()<br>&#125;<br><br>dependencies &#123;<br>    <span class="hljs-comment">// 仅在编译时需要的依赖</span><br>    sourceSets.main.compileOnly <span class="hljs-string">&#x27;org.projectlombok:lombok:1.18.24&#x27;</span><br>    annotationProcessor <span class="hljs-string">&#x27;org.projectlombok:lombok:1.18.24&#x27;</span><br><br>    <span class="hljs-comment">// 编译时和运行时都需要的依赖</span><br>    sourceSets.main.implementation <span class="hljs-string">&#x27;org.springframework.boot:spring-boot-starter:2.7.4&#x27;</span><br>    sourceSets.main.implementation <span class="hljs-string">&#x27;org.springframework.boot:spring-boot-starter-aop:2.7.4&#x27;</span><br>    sourceSets.main.implementation <span class="hljs-string">&#x27;org.springframework.boot:spring-boot-starter-logging:2.7.4&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>Most language plugins, Java included, automatically create a source set called main, which is used for the project’s production code. This source set is special in that its name is not included in the names of the configurations and tasks, hence why you have just a compileJava task and compileOnly and implementation configurations rather than compileMainJava, mainCompileOnly and mainImplementation respectively.</p>
<p><img src="java-sourcesets-process-resources.png" alt="java-sourcesets-process-resources"></p>
<p>每个源码集都有一个专有的 processSourceSetResources (or processResources for the main source set)。</p>
<p>什么时候我们需要使用一个 custom source set？</p>
<p>当我们要形成特定的布局定义的时候：</p>
<ul>
<li>编译需要一个独特的类路径（unique classpath）</li>
<li>生成需要特殊处理的类，不同于 main 和 test</li>
</ul>
<p>如果有个三方的源代码需要加入源码集里，有个例子是：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs groovy">sourceSets &#123;<br>    main &#123;<br>        <span class="hljs-comment">// 等价于 java.srcDirs = [&#x27;src&#x27;]</span><br>        java &#123;<br>            <span class="hljs-comment">// 这里用第三方的源代码代替了原始的 src/main，如果要把新旧源码混合到一起最好使用数组形式 srcDirs</span><br>            srcDir <span class="hljs-string">&#x27;thirdParty/src/main/java&#x27;</span><br>        &#125;<br>        <span class="hljs-comment">//  manifest.srcFile &#x27;AndroidManifest.xml&#x27;</span><br>        <span class="hljs-comment">//  java.srcDirs = [&#x27;src&#x27;]</span><br>        <span class="hljs-comment">//  resources.srcDirs = [&#x27;src&#x27;]</span><br>        <span class="hljs-comment">//  aidl.srcDirs = [&#x27;src&#x27;]</span><br>        <span class="hljs-comment">//  renderscript.srcDirs = [&#x27;src&#x27;]</span><br>        <span class="hljs-comment">//  res.srcDirs = [&#x27;res&#x27;]</span><br>        <span class="hljs-comment">//   assets.srcDirs = [&#x27;assets&#x27;]</span><br>        <span class="hljs-comment">//  jniLibs.srcDirs = [&#x27;libs&#x27;]</span><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>srcDir 是个方法，调用方法的目的是 append，与之对应的 srcDirs 是个属性，<strong>调用属性的目的是 replace</strong>。这是 gradle 的一个设计惯例。<strong>是 method 还是 property 看赋值方式是看通过空格还是=赋值</strong>，也可以通过查看文档来了解。</p>
<h4 id="为集成测试准备的一些配置">为集成测试准备的一些配置</h4>
<p>参考[setting up integration tests][2]</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// Assembling a JAR for a source set</span><br>tasks.register(<span class="hljs-string">&#x27;intTestJar&#x27;</span>, Jar) &#123;<br>    <span class="hljs-comment">// 这种 sourceSet 的 output 在 java 对象实现里是一些 file collection</span><br>    from sourceSets.intTest.output<br>&#125;<br><br><span class="hljs-comment">// Generating the Javadoc for a source set</span><br>tasks.register(<span class="hljs-string">&#x27;intTestJavadoc&#x27;</span>, Javadoc) &#123;<br>    source sourceSets.intTest.allJava<br>    classpath = sourceSets.intTest.compileClasspath<br>&#125;<br><br><span class="hljs-comment">// 这是配置集成测试的方法之一</span><br><span class="hljs-comment">// Running tests in a source set</span><br>tasks.register(<span class="hljs-string">&#x27;intTest&#x27;</span>, Test) &#123;<br>    testClassesDirs = sourceSets.intTest.output.classesDirs<br>    classpath = sourceSets.intTest.runtimeClasspath<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="依赖配置-dependency-configuration-：">依赖配置（dependency configuration）：</h4>
<p><img src="java-main-configurations.png" alt="java-main-configurations"><br>
<img src="java-test-configurations.png" alt="java-test-configurations"></p>
<p>不同的 dependency 会在不同的 source set 的不同的 phase-compile、implementation、runtime 三重 scope 可见（The compile and runtime configurations have been removed with Gradle 7.0. Please refer to the [upgrade guide][3] how to migrate to implementation and api configurations.）。这是一个 visible 问题。</p>
<p>java plugin 还有一个 java extension，这个 java extension 有一个 java block 来配置，如：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy">java &#123;<br>    toolchain &#123;<br>        languageVersion = JavaLanguageVersion.of(<span class="hljs-number">17</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="java-library">java library</h3>
<p>对于 building 一个 java project 而言，最重要的插件是 java library 而不是 java。它会提供如下任务：</p>
<ul>
<li>A compileJava task that compiles all the Java source files under src/main/java</li>
<li>A compileTestJava task for source files under src/test/java</li>
<li>A test task that runs the tests from src/test/java</li>
<li>A jar task that packages the main compiled classes and resources from src/main/resources into a single JAR named <project>-<version>.jar</li>
<li>A javadoc task that generates Javadoc for the main classes</li>
</ul>
<p>管理 api exposed to consumer。</p>
<p>A library is a Java component meant to be consumed by other components. It’s a very common use case in multi-project builds, but also as soon as you have external dependencies.</p>
<p>在使用多模块和外部依赖的时候，管理 library 成了一个常见的用例。</p>
<p>java library 插件会让它的 consumer transitively 看到 api 依赖，但看不到 implementation 依赖。可以说 compile/implementation 是 gradle 自带的 dependency configuration，而 api 是 java library 带来的。</p>
<p>官方有个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// The following types can appear anywhere in the code</span><br><span class="hljs-comment">// but say nothing about API or implementation usage</span><br><span class="hljs-keyword">import</span> org.apache.commons.lang3.exception.ExceptionUtils;<br><span class="hljs-keyword">import</span> org.apache.http.HttpEntity;<br><span class="hljs-keyword">import</span> org.apache.http.HttpResponse;<br><span class="hljs-keyword">import</span> org.apache.http.HttpStatus;<br><span class="hljs-keyword">import</span> org.apache.http.client.HttpClient;<br><span class="hljs-keyword">import</span> org.apache.http.client.methods.HttpGet;<br><br><span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.UnsupportedEncodingException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpClientWrapper</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HttpClient client; <span class="hljs-comment">// private member: implementation details</span><br><br>    <span class="hljs-comment">// HttpClient is used as a parameter of a public method</span><br>    <span class="hljs-comment">// so &quot;leaks&quot; into the public API of this component</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">HttpClientWrapper</span><span class="hljs-params">(HttpClient client)</span> &#123;<br>        <span class="hljs-built_in">this</span>.client = client;<br>    &#125;<br><br>    <span class="hljs-comment">// public methods belongs to your API</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] doRawGet(String url) &#123;<br>        <span class="hljs-type">HttpGet</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpGet</span>(url);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">HttpEntity</span> <span class="hljs-variable">entity</span> <span class="hljs-operator">=</span> doGet(request);<br>            <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">baos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>            entity.writeTo(baos);<br>            <span class="hljs-keyword">return</span> baos.toByteArray();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            ExceptionUtils.rethrow(e); <span class="hljs-comment">// this dependency is internal only</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            request.releaseConnection();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// HttpGet and HttpEntity are used in a private method, so they don&#x27;t belong to the API</span><br>    <span class="hljs-keyword">private</span> HttpEntity <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpGet get)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">HttpResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> client.execute(get);<br>        <span class="hljs-keyword">if</span> (response.getStatusLine().getStatusCode() != HttpStatus.SC_OK) &#123;<br>            System.err.println(<span class="hljs-string">&quot;Method failed: &quot;</span> + response.getStatusLine());<br>        &#125;<br>        <span class="hljs-keyword">return</span> response.getEntity();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个模块要暴露的 api 仍然要暴露签名中的 httpclient 相关的类库给消费者，但不需要暴露内部的 ExceptionUtils 的应用。所以合理的 gradle 配置如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs groovy">dependencies &#123;<br>    api <span class="hljs-string">&#x27;org.apache.httpcomponents:httpclient:4.5.7&#x27;</span><br>    implementation <span class="hljs-string">&#x27;org.apache.commons:commons-lang3:3.5&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>在 Java 9 以后，只要使用一个<code>module-info.java</code>文件，就可以把一个 java 类库变成 java module，如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">src</span><br>└── <span class="hljs-selector-tag">main</span><br>    └── java<br>        └── module-info<span class="hljs-selector-class">.java</span><br></code></pre></td></tr></table></figure>
<p>其内容为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">module</span> org.gradle.sample &#123;<br>    <span class="hljs-keyword">requires</span> com.google.gson;          <span class="hljs-comment">// real module</span><br>    <span class="hljs-keyword">requires</span> org.apache.commons.lang3; <span class="hljs-comment">// automatic module</span><br>    <span class="hljs-comment">// commons-cli-1.4.jar is not a module and cannot be required</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个插件在两类 source set 视角下，进行 configuration set up 的 graph 如下：</p>
<p><img src="java-library-ignore-deprecated-main.png" alt="java-library-ignore-deprecated-main"><br>
<img src="java-library-ignore-deprecated-test.png" alt="java-library-ignore-deprecated-test"></p>
<h3 id="java-platform">java-platform</h3>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs groovy">plugins &#123;<br>    id <span class="hljs-string">&#x27;java-platform&#x27;</span><br>&#125;<br><br>dependencies &#123;<br>    <span class="hljs-comment">// 该dependencies块提供了一个constraints可用于帮助 Gradle 选择依赖项的特定版本的块，这是指定依赖的一种方法</span><br>    constraints &#123;<br>        api <span class="hljs-string">&#x27;org.springframework:spring-core:5.3.10&#x27;</span><br>        api <span class="hljs-string">&#x27;org.springframework:spring-context:5.3.10&#x27;</span><br>        runtime <span class="hljs-string">&#x27;org.slf4j:slf4j-api:1.7.32&#x27;</span><br>    &#125;<br>&#125;<br><br>dependencies &#123;<br>    implementation platform(project(<span class="hljs-string">&#x27;:platform&#x27;</span>))<br>    implementation <span class="hljs-string">&#x27;org.springframework:spring-core&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>maven 的 bom 必须这样在 gradle 里使用。</p>
<p><strong>依赖项约束的功能与依赖项类似，主要区别在于它们本身不会引入依赖项</strong>。相反，约束定义了版本要求，当依赖项通过其他方式引入项目时，这些要求会影响解析过程。</p>
<p>虽然默认情况下约束不是严格版本，但您可以根据需要指定严格版本约束。一旦包含依赖项，约束指定的版本就会参与冲突解决，就像将其声明为直接依赖项一样。</p>
<h2 id="日志">日志</h2>
<h3 id="级别">级别</h3>
<ul>
<li>ERROR (–quiet 或 -q)：仅显示错误信息。这个级别用于最简化的输出，只在构建失败时提供必要的错误信息。</li>
<li>WARNING：显示警告和错误信息。默认情况下，Gradle会在WARNING级别显示输出，提供有关潜在问题的警告信息。</li>
<li>LIFECYCLE：显示构建生命周期的主要事件，例如任务的开始和结束。这是Gradle的默认日志级别，适合大多数用户的日常使用。</li>
<li>INFO (–info)：显示详细的构建信息，包括任务执行的更多细节和配置信息。这个级别适用于需要了解构建过程更多细节的用户。</li>
<li>DEBUG (–debug)：显示非常详细的调试信息，包括内部状态和详细的执行过程。这个级别通常用于调试构建脚本或插件。</li>
<li>TRACE：显示最详细的日志信息，包括所有可能的内部操作和状态变化。这个级别通常用于开发Gradle本身或深入调试复杂问题。</li>
</ul>
<h1>依赖管理</h1>
<p>Dependency management is an automated technique for declaring and resolving <strong>external resources</strong> required by a project.</p>
<p>依赖管理要回答好三个问题：</p>
<ol>
<li>你需要什么依赖，名称和版本</li>
<li>你用来干什么：compilation 还是 running，这一点不易区分开来</li>
<li>在哪里找这个依赖</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs groovy">repositories &#123;<br>    <span class="hljs-comment">// 回答问题 3</span><br>    mavenCentral()<br>&#125;<br><br>dependencies &#123;<br>    <span class="hljs-comment">// 回答问题 1 和 2</span><br>    implementation <span class="hljs-string">&#x27;org.hibernate:hibernate-core:3.6.7.Final&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>Repository</li>
<li>Configuration：<code>implementation</code>是一种 configuration（所以 api 也是一种 configuration），a named collection of dependencies</li>
<li>Module coordinate：group name + artifact name + version</li>
</ul>
<h2 id="libs-versions-toml">libs.versions.toml</h2>
<p>目前这个方案被拿来当作 version catalog 用：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs groovy">[versions]<br>groovy = <span class="hljs-string">&quot;3.0.5&quot;</span><br>checkstyle = <span class="hljs-string">&quot;8.37&quot;</span><br><br>[libraries]<br>groovy-core = &#123; module = <span class="hljs-string">&quot;org.codehaus.groovy:groovy&quot;</span>, version.ref = <span class="hljs-string">&quot;groovy&quot;</span> &#125;<br>groovy-json = &#123; module = <span class="hljs-string">&quot;org.codehaus.groovy:groovy-json&quot;</span>, version.ref = <span class="hljs-string">&quot;groovy&quot;</span> &#125;<br>groovy-nio = &#123; module = <span class="hljs-string">&quot;org.codehaus.groovy:groovy-nio&quot;</span>, version.ref = <span class="hljs-string">&quot;groovy&quot;</span> &#125;<br>commons-lang3 = &#123; group = <span class="hljs-string">&quot;org.apache.commons&quot;</span>, name = <span class="hljs-string">&quot;commons-lang3&quot;</span>, version = &#123; strictly = <span class="hljs-string">&quot;[3.8, 4.0[&quot;</span>, prefer=<span class="hljs-string">&quot;3.9&quot;</span> &#125; &#125;<br><br>[bundles]<br><span class="hljs-comment">// 把上面的 artifact ref 过来，以后可以这样用：implementation bundles.groovy</span><br>groovy = [<span class="hljs-string">&quot;groovy-core&quot;</span>, <span class="hljs-string">&quot;groovy-json&quot;</span>, <span class="hljs-string">&quot;groovy-nio&quot;</span>]<br><br>[plugins]<br>versions = &#123; id = <span class="hljs-string">&quot;com.github.ben-manes.versions&quot;</span>, version = <span class="hljs-string">&quot;0.45.0&quot;</span> &#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy">plugins &#123;<br>    id <span class="hljs-string">&#x27;java-library&#x27;</span><br>    <span class="hljs-comment">// libs 是文件，plugins 是文件里的 plugins 段，versions 就是一个 ref</span><br>    alias(libs.plugins.versions)<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="configuration-分类">configuration 分类</h2>
<table>
<thead>
<tr>
<th>Configuration Name</th>
<th>Description</th>
<th>Used to:</th>
</tr>
</thead>
<tbody>
<tr>
<td>api</td>
<td>用于编译和运行时都需要的依赖，并包含在发布的 API 中。<br>Dependencies required for both compilation and runtime, and included in the published API.</td>
<td>Declare Dependencies</td>
</tr>
<tr>
<td>implementation</td>
<td>用于编译和运行时都需要的依赖。<br>Dependencies required for both compilation and runtime.</td>
<td>Declare Dependencies</td>
</tr>
<tr>
<td>compileOnly</td>
<td>仅在编译时需要的依赖，不包含在运行时或发布中。<br>Dependencies needed only for compilation, not included in runtime or publication.</td>
<td>Declare Dependencies</td>
</tr>
<tr>
<td>compileOnlyApi</td>
<td>仅在编译时需要的依赖，但包含在发布的 API 中。<br>Dependencies needed only for compilation, but included in the published API.</td>
<td>Declare Dependencies</td>
</tr>
<tr>
<td>runtimeOnly</td>
<td>仅在运行时需要的依赖，不包含在编译类路径中。<br>Dependencies needed only at runtime, not included in the compile classpath.</td>
<td>Declare Dependencies</td>
</tr>
<tr>
<td>testImplementation</td>
<td>用于编译和运行测试所需的依赖。<br>Dependencies required for compiling and running tests.</td>
<td>Declare Dependencies</td>
</tr>
<tr>
<td>testCompileOnly</td>
<td>仅用于测试编译的依赖。<br>Dependencies needed only for test compilation.</td>
<td>Declare Dependencies</td>
</tr>
<tr>
<td>testRuntimeOnly</td>
<td>仅用于运行测试的依赖。<br>Dependencies needed only for running tests.</td>
<td>Declare Dependencies</td>
</tr>
</tbody>
</table>
<p>implementation 才是最需要使用的configuration，因为大多数情况下我们除了专门的 sdk module，不需要 publish api。</p>
<p>本质上只有2种类路径 compileClassPath + runtimeClassPath：</p>
<ul>
<li>compileOnly、runtimeOnly、published api 可叠加。</li>
<li>implementation = compileOnly + runtimeOnly</li>
<li>api = implementation + published api</li>
</ul>
<p><img src="java-main-configurations.png" alt="java-main-configurations"></p>
<p>此外还有隐藏用法：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">dependencies</span> &#123;<br>    <span class="hljs-comment">// 添加编译时依赖</span><br>    compileClasspath <span class="hljs-string">&#x27;org.apache.commons:commons-lang3:3.10&#x27;</span><br>    <br>    <span class="hljs-comment">// 添加运行时依赖</span><br>    runtimeClasspath <span class="hljs-string">&#x27;com.google.guava:guava:28.2-jre&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">task</span> printRuntimeClasspath &#123;<br>    <span class="hljs-keyword">doLast</span> &#123;<br>        <span class="hljs-keyword">configurations</span>.runtimeClasspath.<span class="hljs-keyword">each</span> &#123; <span class="hljs-keyword">println</span> it &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="依赖约束和冲突解决-dependency-constraints-and-conflict-resolution">依赖约束和冲突解决 Dependency Constraints and Conflict Resolution</h2>
<ol>
<li>版本冲突：当两个或多个依赖项需要给定的模块但版本不同时。</li>
<li>功能冲突：当依赖图包含提供相同功能的多个工件时。</li>
</ol>
<ul>
<li>gradle 的做法：Gradle 会考虑所有请求的版本，<strong>无论它们出现在依赖关系图中的哪个位置</strong>。默认情况下，<strong>它会从这些版本中选择最高的版本</strong>。</li>
<li>maven 的做法：
<ul>
<li>默认规则：最近优先（Nearest Definition）
<ul>
<li>Maven 会选择依赖树中离项目最近的版本。</li>
<li>如果路径长度相同，则选择首先声明的版本。</li>
</ul>
</li>
<li>可传递性：
<ul>
<li>Maven 默认会传递所有依赖。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>冲突解决有这些方法：Resolution Rules、Dependency Substitution、Dynamic Versions（这是对构建最危险的，对产生 reproducible builds 造成危害）、Dependency Locking（ resolutionStrategy.activateDependencyLocking()）。最常用的是使用 configuration 的版本 force-没有使用 lock file。</p>
<h1>CLI 接口</h1>
<h2 id="常用命令">常用命令</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 修复某些 spring 的构建</span><br>gradle objenesisRepackJar<br>gradle cglibRepackJar<br><br><span class="hljs-comment"># 初始化项目</span><br>gradle init --<span class="hljs-built_in">type</span> java-application  --dsl groovy<br><br><span class="hljs-comment"># 基于 gradlew 构建，去掉 clean 更快</span><br>./gradlew clean build -x <span class="hljs-built_in">test</span> -x javadoc --console=verbose<br><br><span class="hljs-comment"># 只对某个模块进行构建，这样不用 cd 进文件夹里了</span><br>./gradlew :app:clean :app:build<br><br><span class="hljs-comment"># 列出 root project 依赖树，列出各种配置标题。每个标题（如 annotationProcessor, apiElements 等）代表一个 Gradle 配置。配置是依赖的容器，用于不同的目的。</span><br>./gradlew dependencies<br><br>allCodeCoverageReportClassDirectories - Supplies the class directories used to produce all aggregated JaCoCo coverage data reports<br>--- project : (*)<br><br>allCodeCoverageReportSourceDirectories - Supplies the <span class="hljs-built_in">source</span> directories used to produce all aggregated JaCoCo coverage data reports<br>--- project : (*)<br><br>annotationProcessor - Annotation processors and their dependencies <span class="hljs-keyword">for</span> <span class="hljs-built_in">source</span> <span class="hljs-built_in">set</span> <span class="hljs-string">&#x27;main&#x27;</span>.<br>No dependencies<br><br>apiElements - API elements <span class="hljs-keyword">for</span> main. (n)<br>No dependencies<br><br>archives - Configuration <span class="hljs-keyword">for</span> archive artifacts. (n)<br>No dependencies<br><br><span class="hljs-comment"># 列出模块依赖树-真正的依赖树要这样列出来才有意义，最好从头部 entrance sub project/module 进去</span><br>./gradlew :moduleName:dependencies<br><br><span class="hljs-comment"># 深度解析依赖树，后两个参数是必须的</span><br>./gradlew dependencyInsight --dependency opentelemetry-api-metrics<br><br><span class="hljs-comment"># 更重要的方法是使用 idea 的 analyzer</span><br><br><span class="hljs-comment"># 直接执行 task，build 是一个聚合（aggregate）task， 它触发一个依赖链，build -&gt; assemble -&gt; compileJava</span><br><span class="hljs-comment"># Executing Gradle on the command line conforms to the following structure:</span><br>gradle [taskName...] [--option-name...]<br><span class="hljs-comment"># Options are allowed before and after task names.</span><br>gradle [--option-name...] [taskName...]<br><span class="hljs-comment"># If multiple tasks are specified, you should separate them with a space.</span><br>gradle [taskName1 taskName2...] [--option-name...]<br><span class="hljs-comment">#  --dry-run 可以不执行任务，但是显示任务执行的顺序，对性能影响很小</span><br><br><span class="hljs-comment"># 把内置选项和任务选项区分开</span><br>gradle [--built-in-option-name...] -- [taskName...] [--task-option-name...]<br><br><span class="hljs-comment"># 通用输出 SKIPPED、NO-SOURCE</span><br><span class="hljs-comment"># 使用构建缓存，输出会带有 UP-TO-DATE、FROM-CACHE，所以增量编译是模块-任务级的</span><br>gradle [...] --build-cache<br><span class="hljs-comment"># 不使用缓存</span><br>gradle [...] --no-build-cache<br></code></pre></td></tr></table></figure>
<h1>构建管理</h1>
<h2 id="项目结构">项目结构</h2>
<h3 id="maven">Maven</h3>
<p>Maven 的项目结构通常是这样的（这个结构通常是随着 archetype 变化）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java">└───maven-project<br>    ├───pom.xml<br>    ├───README.txt<br>    ├───NOTICE.txt<br>    ├───LICENSE.txt<br>    └───src 一级文件夹除了 src 和 target 只允许一些隐藏的 .git 文件夹存在<br>        ├───main<br>        │   ├───java<br>        │   ├───resources<br>        │   ├───filters  contains files that inject values into configuration properties in the resources folder during the test phase<br>        │   └───webapp<br>        ├───test<br>        │   ├───java<br>        │   ├───resources<br>        │   └───filters<br>        ├───it failsafe 插件专门用 it 文件夹来承载<br>        ├───site<br>        └───assembly<br>    └───target<br>        └───classes com 文件夹和所有的 resources 下的文件<br>        └───dddsample-<span class="hljs-number">2.0</span>-SNAPSHOT.jar<br>        └───dddsample-<span class="hljs-number">2.0</span>-SNAPSHOT.jar.original<br>        └───generated-sources<br>            └───annotations<br>        └───generated-test-sources<br>            └───test-annotations<br>        └───maven-archiver<br>            └───pom.properties<br>        └───maven-status<br>        └───surefire-reports 每一个测试有一个 txt<br>        └───test-classes com 文件夹和所有的 resources 下的文件<br></code></pre></td></tr></table></figure>
<h3 id="spring-boot">Spring Boot</h3>
<p>Spring Boot 的构建 output 通常是这样的：</p>
<ul>
<li>out
<ul>
<li>production
<ul>
<li>classes</li>
<li>resources</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="gradle">Gradle</h3>
<p>gradle 的构建 output 通常是这样的：</p>
<ul>
<li>build
<ul>
<li>classes
<ul>
<li>java
<ul>
<li>main</li>
</ul>
</li>
</ul>
</li>
<li>docs</li>
<li>generated
<ul>
<li>sources
<ul>
<li>annotationProcessor
<ul>
<li>java
<ul>
<li>main</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>libs
<ul>
<li>project1.jar：这是一个完整 fatjar
<ul>
<li>BOOT-INF
<ul>
<li>classes：大致等同于一个解压过的 project1-plain.jar</li>
<li>lib：各种二方、三方的依赖 jar</li>
<li>classpath.idx：索引文件</li>
<li>layers.idx：索引文件</li>
</ul>
</li>
<li>META-INF
<ul>
<li>MANIFEST.MF</li>
</ul>
</li>
<li>org
<ul>
<li>springframework
<ul>
<li>boot
<ul>
<li>loader：launcher 和 archive 相关的功能</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>project1-javadoc.jar：这里只有 MANIFEST.MF，大小只有 B</li>
<li>project1-plain.jar：结构同 project1-sources 一样，只是 java 文件全部变成 class 文件了</li>
<li>project1-sources.jar
<ul>
<li>这个文件的结构是：
<ul>
<li>com java 源代码包</li>
<li>META-INF
<ul>
<li>MANIFEST.MF</li>
</ul>
</li>
<li>全部的 resources 文件：在进入 lib 以后，packaging 消除了 resources 和 java 文件夹的差别</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>resources
<ul>
<li>main：此处也按照 source set 进行分文件夹，也会 include 进测试 classpath  里</li>
</ul>
</li>
<li>tmp：这一层看起来是不同的 task 的中间结果
<ul>
<li>bootJar</li>
<li>compileJava</li>
<li>jar</li>
<li>javadoc</li>
<li>javadocJar</li>
<li>sourcesJar</li>
</ul>
</li>
<li>bootJarMainClassName：这个类型是 Spring Boot 特有的文件</li>
</ul>
</li>
</ul>
<h2 id="依赖解析">依赖解析</h2>
<p><img src="dep-man-basics-1.png" alt="dep-man-basics-1"></p>
<p>module = component = com.fasterxml.jackson.core:jackson-databind</p>
<p>所谓的图就是搞明白 direct dependencies (explicitly declared in the build script) and transitive dependencies (dependencies of the direct dependencies and other transitive dependencies)。</p>
<p>依赖图由以下节点组成：</p>
<ul>
<li>每个节点代表一个变体。</li>
<li>每个依赖项从一个组件中选择一个变体。</li>
</ul>
<p>这些图就是<code>./gradlew app:dependencies</code>的输出。<br>
强力的依赖解析可以使用<code>./gradlew :app:dependencyInsight --configuration runtimeClasspath --dependency com.fasterxml.jackson.core:jackson-databind:2.17.2</code>命令。</p>
<p>任意的 module 的metadata都包含两个variants，如：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">[</span><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;apiElements&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;runtimeElements&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;attributes&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;org.gradle.category&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;library&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;org.gradle.dependency.bundling&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;external&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;org.gradle.libraryelements&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;jar&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;org.gradle.usage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;java-runtime&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;dependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>      <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;group&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;com.fasterxml.jackson.core&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;module&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;jackson-annotations&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;requires&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2.17.2&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;group&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;com.fasterxml.jackson.core&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;module&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;jackson-core&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;requires&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2.17.2&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;group&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;com.fasterxml.jackson&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;module&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;jackson-bom&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;requires&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2.17.2&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;files&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>      <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;jackson-databind-2.17.2.jar&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure>
<p>Gradle 通常在编译时会选择apiElements，而在运行时会选择runtimeElements。因为apiElements 通常更小，只包含公共 API，这样可以加快编译速度。runtimeElements 包含完整实现，确保应用在运行时有所有需要的类和资源。<strong>似乎</strong>选用 api configuration 会把某个本 project 的依赖加入到本项目的 apiElements variants 里。</p>
<p>gradle 的 download step 就是找到这些 files 里的文件。而transform指的是如果文件不是 jar 而是 zip，可以从 zip 转成 jar。</p>
<h2 id="版本和范围">版本和范围</h2>
<ul>
<li>确保关键依赖使用特定版本（strictly）。</li>
<li>确保依赖不低于某个版本（require）。</li>
<li>优先选择某个版本以避免不必要的升级（prefer）。</li>
<li>排除已知有问题的版本（rejects）。</li>
</ul>
<p>默认的版本解析策略是基于最高版本策略（highest version strategy），<strong>即上面的一个都不选</strong>。</p>
<h2 id="性能优化">性能优化</h2>
<ol>
<li>并行构建-<strong>最好修改 properties</strong></li>
<li>启用各式缓存-局部缓存要单独配，局部的增量构建也是-<strong>最好修改 properties</strong></li>
<li>减少解析依赖的时间-优化仓库、使用版本-<strong>选择最好的镜像</strong></li>
<li>使用 scan 看构建图，查看慢速的部分-<strong>使用构建选项</strong></li>
</ol>
<h3 id="缓存的好处">缓存的好处</h3>
<ul>
<li>使用本地缓存加速开发人员构建</li>
<li>在 CI 构建之间共享结果</li>
<li>通过重复使用 CI 结果来加速开发人员的构建</li>
<li>将远程结果与本地缓存相结合</li>
<li>在开发人员之间共享成果</li>
</ul>
<h3 id="可缓存与不可缓存">可缓存与不可缓存</h3>
<p>默认情况下构建缓存是不打开的。–build-cache 和 properties 配置是两种使用构建缓存的方法。针对相同的输入，可能触发构建缓存。</p>
<p>:classes和:assemble是生命周期任务， 和:processResources 是:jar复制类任务，它们不可缓存，因为执行它们通常更快。</p>
<p>可缓存的任务有：</p>
<ul>
<li>Java toolchain: JavaCompile, Javadoc</li>
<li>Groovy toolchain: GroovyCompile, Groovydoc</li>
<li>Scala toolchain: ScalaCompile, org.gradle.language.scala.tasks.PlatformScalaCompile (removed), ScalaDoc</li>
<li>Native toolchain: CppCompile, CCompile, SwiftCompile</li>
<li>Testing: Test</li>
<li>Code quality tasks: Checkstyle, CodeNarc, Pmd</li>
<li>JaCoCo: JacocoReport</li>
<li>Other tasks: AntlrTask, ValidatePlugins, WriteProperties</li>
</ul>
<p>All other built-in tasks are currently not cacheable.</p>
<h3 id="自定义缓存">自定义缓存</h3>
<p>@CacheableTask 注解可以用来缓存那些耗时比较久的任务，比如自定义的 Javascript 任务。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs groovy">buildCache &#123;<br>    local &#123;<br>        directory = <span class="hljs-keyword">new</span> File(rootDir, <span class="hljs-string">&#x27;build-cache&#x27;</span>)<br>    &#125;<br>&#125;<br><br>buildCache &#123;<br>    remote(HttpBuildCache) &#123;<br>        <span class="hljs-comment">// When attempting to load an entry, a GET request is made to https://example.com:8123/cache/«cache-key». The response must have a 2xx status and the cache entry as the body, or a 404 Not Found status if the entry does not exist.</span><br>        url = <span class="hljs-string">&#x27;https://example.com:8123/cache/&#x27;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="配置缓存">配置缓存</h3>
<p>The configuration cache is a feature that significantly improves build performance by caching the result of the configuration phase and reusing this for subsequent builds.</p>
<h1>测试管理</h1>
<p>自带的 test source set 是为了单元测试用的。如果为了审美（aesthetics）和可管理 （manageability），就需要 separate one from another。</p>
<p>集成测试的存在通常意味着独立的 test task。</p>
<h2 id="配置一个集成测试">配置一个集成测试</h2>
<p>假设我们需要使用一个集成测试，需要首先为它准备一个 sourceSet</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs groovy">sourceSets &#123;<br>    <span class="hljs-comment">// 这里其实还需要配 src，这里重点只是这样做，这样做就是让 main 的 production 的 classes 产出全部成为这个 sourceSet 的 dependency</span><br>    intTest &#123;<br>        compileClasspath += sourceSets.main.output<br>        runtimeClasspath += sourceSets.main.output<br>    &#125;<br>&#125;<br><br>configurations &#123;<br>    <span class="hljs-comment">// 这是把 production 的依赖全部给与本源码集-需要理解的是，production code 的 classes 和它们自己的类路径依赖是不一样的</span><br>    intTestImplementation.extendsFrom implementation<br>    intTestRuntimeOnly.extendsFrom runtimeOnly<br>    <br>&#125;<br><br>dependencies &#123;<br>    <span class="hljs-comment">// 这是给本源码集增加测试环境下的特殊依赖</span><br>    intTestImplementation <span class="hljs-string">&#x27;org.junit.jupiter:junit-jupiter:5.7.1&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>有一个更极端的做法是<code>intTestImplementation.extendsFrom testImplementation</code>，这样单元测试的所有测试依赖也会成为集成测试的依赖。</p>
<p>然后再为它注册一个单独的任务</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs groovy">tasks.register(<span class="hljs-string">&#x27;integrationTest&#x27;</span>, Test) &#123;<br>    description = <span class="hljs-string">&#x27;Runs integration tests.&#x27;</span><br>    group = <span class="hljs-string">&#x27;verification&#x27;</span><br><br>    <span class="hljs-comment">// 把输出给单独的任务用</span><br>    testClassesDirs = sourceSets.intTest.output.classesDirs<br>    <span class="hljs-comment">// 把自己的 source code 的 runtime class path 当作任务的 class path</span><br>    classpath = sourceSets.intTest.runtimeClasspath<br>    <span class="hljs-comment">// 定义任务的依赖</span><br>    shouldRunAfter test<br><br>    useJUnitPlatform()<br><br>    testLogging &#123;<br>        events <span class="hljs-string">&quot;passed&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 这里让 check 又依赖于 integrationTest，等于 check -&gt; integrationTest -&gt; test</span><br>check.dependsOn integrationTest<br></code></pre></td></tr></table></figure>
<h1>Groovy 代码片段</h1>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs groovy">task printStringVar &lt;&lt; &#123;<br> <span class="hljs-keyword">def</span> name = <span class="hljs-string">&quot;张三”</span><br><span class="hljs-string"> println &#x27;单引号的变量计算:$&#123;name&#125;&#x27;</span><br><span class="hljs-string"> println &quot;</span>双引号的变量计算:$&#123;name&#125;<span class="hljs-string">&quot;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">// 运行./gradlew printStringVar输出结果：</span><br><span class="hljs-string">// 单引号的变量计算:$&#123;name&#125;</span><br><span class="hljs-string">// 双引号的变量计算:张三</span><br><span class="hljs-string"></span><br><span class="hljs-string">//List</span><br><span class="hljs-string">task printList&lt;&lt;&#123;</span><br><span class="hljs-string"> def numList = [1,2,3,4,5,6];//定义一个List</span><br><span class="hljs-string"> println numList[1]//输出第二个元素</span><br><span class="hljs-string"> println numList[-1]//输出最后一个元素</span><br><span class="hljs-string"> println numList[1..3]//输出第二个到第四个元素</span><br><span class="hljs-string"> numList.each&#123;</span><br><span class="hljs-string">   println it//输出每个元素</span><br><span class="hljs-string"> &#125;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">//Map</span><br><span class="hljs-string">task printlnMap&lt;&lt;&#123;</span><br><span class="hljs-string"> def map1 =[&#x27;width&#x27;:1024,&#x27;height&#x27;:768]//定义一个Map</span><br><span class="hljs-string"> println mapl[&#x27;width&#x27;]//输出width的值</span><br><span class="hljs-string"> println mapl.height//输出height的值</span><br><span class="hljs-string"> map1.each&#123;</span><br><span class="hljs-string">   println &quot;</span><span class="hljs-attr">Key:</span>$&#123;it.key&#125;,<span class="hljs-attr">Value:</span>$&#123;it.value&#125;<span class="hljs-string">&quot;//输出所有键值对</span><br><span class="hljs-string"> &#125;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">//以集合的each方法为例，接受的参数就是一个闭包</span><br><span class="hljs-string">numList.each(&#123;println it&#125;)</span><br><span class="hljs-string">//省略传参的括号，并调整格式，有以下常见形式</span><br><span class="hljs-string">numList.each&#123;</span><br><span class="hljs-string"> println it</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">// 不是一定要定义成员变量才能作为类属性被访问，用get/set方法也能当作类属性</span><br><span class="hljs-string">task helloJavaBean&lt;&lt;&#123;</span><br><span class="hljs-string"> Person p = new Person()</span><br><span class="hljs-string"> p.name = &quot;</span>张三<span class="hljs-string">&quot;</span><br><span class="hljs-string"> println &quot;</span>名字是: $&#123;p.name&#125;<span class="hljs-string">&quot;//输出类属性name，为张三</span><br><span class="hljs-string"> println &quot;</span>年龄是: $&#123;p.age&#125;<span class="hljs-string">&quot;//输出类属性age，为12</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">class Person&#123;</span><br><span class="hljs-string"> private String name</span><br><span class="hljs-string"> public int getAge()&#123;//省略return</span><br><span class="hljs-string">   12</span><br><span class="hljs-string"> &#125;</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure>
<h1>修复找不到 jar 的情况</h1>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 把每一个能够下下来的jar做一个本地安装</span><br> mvn install:install-file -Dfile=/Users/magicliang/.gradle/caches/modules-2/files-2.1/com.tc.rainbow/java-client/1.0.2-RELEASE/fbaa6826bb26cb2b89bc1261f549abb3c903709e/java-client-1.0.2-RELEASE.jar -DgroupId=com.tc.rainbow -DartifactId=java-client -Dversion=1.0.2-RELEASE -Dpackaging=jar<br><br><span class="hljs-comment"># 再做一个本地安装</span><br>./gradlew clean build -x <span class="hljs-built_in">test</span> -x javadoc --refresh-dependencies<br></code></pre></td></tr></table></figure>
<h2 id="gradle-vs-maven">Gradle vs Maven</h2>
<table>
<thead>
<tr>
<th>特性</th>
<th>Gradle</th>
<th>Maven</th>
</tr>
</thead>
<tbody>
<tr>
<td>配置语言</td>
<td>Groovy/Kotlin DSL</td>
<td>XML</td>
</tr>
<tr>
<td>灵活性</td>
<td>高（编程式）</td>
<td>低（声明式）</td>
</tr>
<tr>
<td>性能</td>
<td>更快（增量构建、缓存）</td>
<td>较慢</td>
</tr>
<tr>
<td>学习曲线</td>
<td>陡峭</td>
<td>平缓</td>
</tr>
<tr>
<td>Android 支持</td>
<td>官方支持</td>
<td>不支持</td>
</tr>
<tr>
<td>插件生态</td>
<td>丰富</td>
<td>更丰富</td>
</tr>
<tr>
<td>企业采用</td>
<td>增长中</td>
<td>主流</td>
</tr>
<tr>
<td>构建脚本</td>
<td>简洁（DSL）</td>
<td>冗长（XML）</td>
</tr>
<tr>
<td>依赖解析</td>
<td>最高版本策略</td>
<td>最近优先策略</td>
</tr>
</tbody>
</table>
<h2 id="最佳实践">最佳实践</h2>
<h3 id="1-使用-gradle-wrapper">1. 使用 Gradle Wrapper</h3>
<p>始终提交 <code>gradlew</code> 和 <code>gradle/wrapper/</code> 到版本控制，确保团队使用相同的 Gradle 版本。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 生成 Wrapper</span><br>gradle wrapper --gradle-version 7.6<br><br><span class="hljs-comment"># 使用 Wrapper</span><br>./gradlew build<br></code></pre></td></tr></table></figure>
<h3 id="2-合理使用-configuration">2. 合理使用 Configuration</h3>
<ul>
<li>优先使用 <code>implementation</code> 而非 <code>api</code>，减少编译依赖</li>
<li>使用 <code>compileOnly</code> 处理编译时依赖（如 Lombok）</li>
<li>使用 <code>runtimeOnly</code> 处理运行时依赖（如 JDBC 驱动）</li>
</ul>
<h3 id="3-启用构建缓存">3. 启用构建缓存</h3>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// gradle.properties</span><br>org.gradle.caching=<span class="hljs-literal">true</span><br>org.gradle.parallel=<span class="hljs-literal">true</span><br>org.gradle.daemon=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>
<h3 id="4-版本管理">4. 版本管理</h3>
<p>使用 Version Catalog 或 <code>gradle.properties</code> 统一管理版本：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// gradle.properties</span><br>guavaVersion=<span class="hljs-number">31.0</span>-jre<br><br><span class="hljs-comment">// build.gradle</span><br>dependencies &#123;<br>    implementation <span class="hljs-string">&quot;com.google.guava:guava:$&#123;guavaVersion&#125;&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="5-避免动态版本">5. 避免动态版本</h3>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// 不推荐</span><br>implementation <span class="hljs-string">&#x27;com.google.guava:guava:+&#x27;</span><br>implementation <span class="hljs-string">&#x27;com.google.guava:guava:30.+&#x27;</span><br><br><span class="hljs-comment">// 推荐</span><br>implementation <span class="hljs-string">&#x27;com.google.guava:guava:31.0-jre&#x27;</span><br></code></pre></td></tr></table></figure>
<h3 id="6-合理组织多项目">6. 合理组织多项目</h3>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// settings.gradle</span><br>include <span class="hljs-string">&#x27;core&#x27;</span>, <span class="hljs-string">&#x27;api&#x27;</span>, <span class="hljs-string">&#x27;web&#x27;</span><br><br><span class="hljs-comment">// 根项目 build.gradle</span><br>subprojects &#123;<br>    apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;java&#x27;</span><br>    <br>    repositories &#123;<br>        mavenCentral()<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 特定项目配置</span><br>project(<span class="hljs-string">&#x27;:web&#x27;</span>) &#123;<br>    dependencies &#123;<br>        implementation project(<span class="hljs-string">&#x27;:api&#x27;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="故障排查">故障排查</h2>
<h3 id="依赖冲突">依赖冲突</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看依赖树</span><br>./gradlew dependencies<br><br><span class="hljs-comment"># 查看特定依赖</span><br>./gradlew dependencyInsight --dependency guava<br><br><span class="hljs-comment"># 查看配置</span><br>./gradlew dependencies --configuration runtimeClasspath<br></code></pre></td></tr></table></figure>
<h3 id="构建缓慢">构建缓慢</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 生成性能报告</span><br>./gradlew build --profile<br><br><span class="hljs-comment"># 使用构建扫描</span><br>./gradlew build --scan<br></code></pre></td></tr></table></figure>
<h3 id="清理缓存">清理缓存</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 清理项目缓存</span><br>./gradlew clean<br><br><span class="hljs-comment"># 清理 Gradle 缓存</span><br><span class="hljs-built_in">rm</span> -rf ~/.gradle/caches/<br><br><span class="hljs-comment"># 刷新依赖</span><br>./gradlew build --refresh-dependencies<br></code></pre></td></tr></table></figure>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.gradle.org/">Gradle 官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.gradle.org/current/userguide/userguide.html">Gradle User Guide</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.gradle.org/current/dsl/">Gradle DSL Reference</a></li>
<li><a target="_blank" rel="noopener" href="https://plugins.gradle.org/">Gradle Plugin Portal</a></li>
<li><a target="_blank" rel="noopener" href="https://scans.gradle.com/">Gradle Build Scans</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/gradle-plugin/reference/htmlsingle/">Spring Boot Gradle Plugin</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.gradle.org/current/userguide/performance.html">Gradle Performance Guide</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.gradle.org/current/userguide/build_cache.html">Gradle Build Cache</a></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://magicliang.github.io">magicliang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://magicliang.github.io/2026/02/17/Gradle-%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/">https://magicliang.github.io/2026/02/17/Gradle-%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/Gradle/">Gradle</a><a class="post-meta__tags" href="/tags/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/">构建工具</a></div><div class="post-share"><div class="social-share" data-image="/2026/02/17/Gradle-%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/Gradle_logo.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2017/10/23/%E6%98%82%E8%B4%B5%E7%9A%84%E5%BC%82%E5%B8%B8/" title="昂贵的异常"><img class="cover" src="/img/wall-paper-167.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-10-23</div><div class="info-item-2">昂贵的异常</div></div><div class="info-2"><div class="info-item-1">抛出问题 Joshua Bloch 在《Effective Java》的 Item 57 里明确地提到过，不要试图用 Exception 的跳转来代替正常的程序控制流。他列举了很多原因，但特别提到了抛出异常会使得整个程序运行变慢。抛出异常远比普通的 return、break 等操作对控制流、数据流的性能影响要大，它就只适合拿来作异常分支的控制语句，而不能拿来编写正常的逻辑。  Throwing exception is expensive.  这句话在 Java 的程序员世界里面已经成为老生常谈，却很少有人谈及到底抛出异常比正常的程序跳转返回慢在哪里，有多慢。&quot;不要滥用异常&quot;好像一个猴子定律，人们知道不能这么做，却不明白为什么不能这么做。 此前读了一位同事写的好文《Java虚拟机是如何处理异常的》，深入地分析了 JVM 对异常跳转的处理过程：JVM 会通过异常表的机制，优化异常抛出和正常返回之间的性能差异。仅从程序计数器的移动上来讲，抛出一个异常对栈帧的弹栈并不比直接返回更昂贵。写在前头的结论是：&quot;try-catch 语句块几乎不会影响程序运行性能！...</div></div></div></a><a class="pagination-related" href="/2017/11/30/Java%E4%B8%AD%E7%9A%84%E5%B9%BD%E7%81%B5%E7%B1%BB%E5%9E%8B/" title="Java中的幽灵类型"><img class="cover" src="/img/wall-paper-153.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-11-30</div><div class="info-item-2">Java中的幽灵类型</div></div><div class="info-2"><div class="info-item-1">什么是幽灵类型 先上结论：幽灵类型（Phantom Type）顾名思义，就是幽灵般的类型，这种类型往往在运行时可以消失，因为在运行时没有任何作用，它们最大的特点就是没有任何实例（Java 的 Void 就是一个不可实例化类型的例子，常被用作幽灵类型的类型参数，如 Future&lt;Void&gt;）。幽灵类型是一种可以把有些运行时才能检测到的错误，在编译时检测出来的技巧。按照有些老外的观点，就是&quot;Making Wrong Code Look Wrong&quot;。在面向对象的编程语言之中，幽灵类型的实现，往往与状态模式较为接近，但比状态模式提供了更强的纠错功能。在 Java 5 以后的版本里，程序员可以使用泛型。通过泛型的类型参数，Java 中也拥有了幽灵类型的能力。 上面的阐述是不是很难看懂？直接进入具体的例子。假设有一个飞机控制程序，操作飞机起飞或者落地。这个程序有一个非常强的业务约束，就是必须保证飞机一开始必须出现在地上，只有在地上的飞机可以起飞，只有起飞的飞机可以落地，那么应该怎样设计程序（主要是类型关系），来保证这个约束必然成立呢？ 定义状态接口 先来定义...</div></div></div></a><a class="pagination-related" href="/2018/05/29/JPA-%E7%9A%84-id-%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5/" title="JPA 的 id 生成策略"><img class="cover" src="/img/wall-paper-74.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-05-29</div><div class="info-item-2">JPA 的 id 生成策略</div></div><div class="info-2"><div class="info-item-1">JPA 有一个@GeneratedValue注解，有一个strategy attribute，如 @GeneratedValue(strategy = GenerationType.IDENTITY)。 常见的可选策略主要有IDENTITY和SEQUENCE。 GenerationType.IDENTITY 要求底层有一个 integer 或者 bigint 类型的自增列（ auto-incremented column)。自增列的赋值必须在插入操作之后发生，因为这个原因，Hibernate 无法进行各种优化（特别是 JDBC 的 batch 处理，一次 flush 操作会产生很多条insert 语句，分别执行）。如果事务回滚，自增列的值就会被丢弃。数据库在这个自增操作上有个高度优化的轻量级锁机制，性能非常棒。 MySQL 支持这种 id 生成策略， 使用 MySQL 应该尽量使用这个策略，即使它无法优化。 JPA 用它生成 id，会一条一条地插入新的 entity。 GenerationType.SEQUENCE 数据库有一个所谓的 sequence 对象，可以通过 selec...</div></div></div></a><a class="pagination-related" href="/2018/06/19/%E5%A6%82%E4%BD%95%E5%81%9A%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8B%E7%9A%84%E7%AD%94%E6%A1%88/" title="如何做性能测试的问题下的答案"><img class="cover" src="/img/wall-paper-122.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-06-19</div><div class="info-item-2">如何做性能测试的问题下的答案</div></div><div class="info-2"><div class="info-item-1">试着回答一下这个问题。 首先要划分系统类型：有状态还是无状态，业务系统还是存储系统。根据不同的业务场景，设立性能测试的目标：是要测 QPS，还是 TPS 还是 TPS，还是任何其他【性能】-从广义来讲，一个存储系统到底能够以多高的平均时延来管理大多的存储空间，可能也是性能的一种。 有了性能测试的目标，接下来就是拆解用例。如果把性能测试归为测试的话，测试就需要测试用例，测试用例只是用例的形式化表达。把用户的使用场景勾勒出来，把每一步拆解成的流程图或者时序图–我们已经得到了一个纸上的集成测试计划，只是没有跟性能挂上钩。 接下来就进入真正写测试用例的环节了。 我们的测试报告如果要涵盖足够立体的信息，则既要了解每一个环节/接口/API 的性能指标，又要了解整体的性能指标。 这个时候测试工具的覆盖面就很重要了。如果我们选择偏黑盒的测试工具，apache ab /JMeter，则我们的测试用例就要围绕着对外交互的 API写，也只能测到外围接口的性能。这样的测试用例写起来最简单，无需侵入任何内部代码中。 如果我们使用了 JMH 一类的工具，则可以自由编写对任何方法的测试用例。但需要对系统有非常...</div></div></div></a><a class="pagination-related" href="/2018/09/07/%E6%97%A5%E6%9C%9F%E4%B8%8E%E6%97%B6%E9%97%B4/" title="日期与时间"><img class="cover" src="/img/wall-paper-160.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-09-07</div><div class="info-item-2">日期与时间</div></div><div class="info-2"><div class="info-item-1">JSR 310 Java Date与Time API 新旧 API 的更迭 旧的 Java API 主要包括java.util.Date和java.util.Calendar 两个包的内容。这两个包的时间类型是可变的。如 Date 的实例可以通过 setYear 来产生变化。 JSR 310 中包括的日期类型主要有：  计算机时间：Instant，对应 java.util.Date，它代表了一个确定的时间点，即相对于标准Java纪元（1970年1月1日）的偏移量；但与java.util.Date类不同的是其精确到了纳秒级别。 人类时间：对应于人类自身的观念，比如LocalDate和LocalTime。他们代表了一般的时区概念，要么是日期（不包含时间），要么是时间（不包含日期），类似于java.sql的表示方式。此外，还有一个MonthDay，它可以存储某人的生日（不包含年份）。每个类都在内部存储正确的数据而不是像java.util.Date那样利用午夜12点来区分日期，利用1970-01-01来表示时间。这些类型的实例是 immutable 的，而且只能通过工厂方法创建。  时区...</div></div></div></a><a class="pagination-related" href="/2018/10/13/%E5%8D%A1%E8%A1%A8%E5%92%8C-RSet/" title="卡表和 RSet"><img class="cover" src="/img/wall-paper-61.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-10-13</div><div class="info-item-2">卡表和 RSet</div></div><div class="info-2"><div class="info-item-1">卡表和 RSet 问题定义：为什么需要跨区域引用记录 JVM 垃圾收集器的核心工作之一是确定 live set——哪些对象仍然存活、不可回收。确定 live set 的标准做法是从 GC Roots（栈帧中的局部变量、静态字段等）出发，沿引用链遍历所有可达对象。 问题在于：当堆被划分为多个区域（代、Region）并且只回收其中一部分时，如何高效地找到从&quot;不回收区域&quot;指向&quot;回收区域&quot;的引用？ 以 Young GC 为例：只回收新生代，但老年代中可能持有指向新生代对象的引用。如果不处理这些跨代引用，就会错误地回收仍被老年代引用的新生代对象。最朴素的做法是扫描整个老年代来找出这些引用——但老年代通常远大于新生代，这样做的代价过高，违背了分代收集&quot;只回收一部分堆&quot;的初衷。 卡表（Card Table）和 RSet（Remembered Set）正是为解决这个问题而设计的辅助数据结构。二者的关系并非互相替代，而是层次不同、协作互补：卡表是底层的脏标记机制，RSet 是建立在卡表之上的更高层索引结构。 核心概念速览 在深入细节之前，...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">Gradle 完全指南</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E6%99%AF%E5%AF%BC%E5%9B%BE"><span class="toc-number">1.1.</span> <span class="toc-text">全景导图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-gradle"><span class="toc-number">1.2.</span> <span class="toc-text">什么是 Gradle</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-number">1.3.</span> <span class="toc-text">核心概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#project-%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">Project 模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#task-%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.3.2.</span> <span class="toc-text">Task 系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#task-%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">Task 的创建方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#task-%E7%9A%84%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">Task 的依赖关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#task-%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">Task 的配置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.3.3.</span> <span class="toc-text">生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">1.3.4.</span> <span class="toc-text">插件机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E6%8F%92%E4%BB%B6"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">应用插件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">常用插件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dsl-%E6%A6%82%E5%BF%B5"><span class="toc-number">1.3.5.</span> <span class="toc-text">DSL 概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.6.</span> <span class="toc-text">核心类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#project-%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.4.</span> <span class="toc-text">Project 对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#task"><span class="toc-number">1.5.</span> <span class="toc-text">Task</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86"><span class="toc-number">1.5.1.</span> <span class="toc-text">任务管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%9A%84%E4%BB%BB%E5%8A%A1%E5%88%9B%E5%BB%BA%E5%BD%A2%E5%BC%8F"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">基本的任务创建形式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E4%BB%BB%E5%8A%A1%E6%8A%8A%E5%8A%9F%E8%83%BD%E6%B3%A8%E5%86%8C%E6%88%90%E6%8F%92%E4%BB%B6"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">通过任务把功能注册成插件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%BB%BB%E5%8A%A1%E7%9A%84%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">定义任务的依赖关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%91%E4%BB%BB%E5%8A%A1%E6%B3%A8%E5%85%A5%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.5.1.4.</span> <span class="toc-text">向任务注入对象</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E7%AE%A1%E7%90%86"><span class="toc-number">1.6.</span> <span class="toc-text">属性管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%83%B0%E6%80%A7%E5%8A%A0%E8%BD%BD"><span class="toc-number">1.6.1.</span> <span class="toc-text">惰性加载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#plugin"><span class="toc-number">1.7.</span> <span class="toc-text">Plugin</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-number">1.7.1.</span> <span class="toc-text">分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E"><span class="toc-number">1.7.2.</span> <span class="toc-text">声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E4%BB%B6%E4%BB%93%E5%BA%93"><span class="toc-number">1.7.3.</span> <span class="toc-text">插件仓库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java"><span class="toc-number">1.7.4.</span> <span class="toc-text">java</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sourceset"><span class="toc-number">1.7.4.1.</span> <span class="toc-text">SourceSet</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95%E5%87%86%E5%A4%87%E7%9A%84%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE"><span class="toc-number">1.7.4.2.</span> <span class="toc-text">为集成测试准备的一些配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E9%85%8D%E7%BD%AE-dependency-configuration-%EF%BC%9A"><span class="toc-number">1.7.4.3.</span> <span class="toc-text">依赖配置（dependency configuration）：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java-library"><span class="toc-number">1.7.5.</span> <span class="toc-text">java library</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java-platform"><span class="toc-number">1.7.6.</span> <span class="toc-text">java-platform</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E5%BF%97"><span class="toc-number">1.8.</span> <span class="toc-text">日志</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A7%E5%88%AB"><span class="toc-number">1.8.1.</span> <span class="toc-text">级别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">依赖管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#libs-versions-toml"><span class="toc-number">2.1.</span> <span class="toc-text">libs.versions.toml</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#configuration-%E5%88%86%E7%B1%BB"><span class="toc-number">2.2.</span> <span class="toc-text">configuration 分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E7%BA%A6%E6%9D%9F%E5%92%8C%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3-dependency-constraints-and-conflict-resolution"><span class="toc-number">2.3.</span> <span class="toc-text">依赖约束和冲突解决 Dependency Constraints and Conflict Resolution</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">CLI 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">3.1.</span> <span class="toc-text">常用命令</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">构建管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84"><span class="toc-number">4.1.</span> <span class="toc-text">项目结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#maven"><span class="toc-number">4.1.1.</span> <span class="toc-text">Maven</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spring-boot"><span class="toc-number">4.1.2.</span> <span class="toc-text">Spring Boot</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gradle"><span class="toc-number">4.1.3.</span> <span class="toc-text">Gradle</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E8%A7%A3%E6%9E%90"><span class="toc-number">4.2.</span> <span class="toc-text">依赖解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%88%E6%9C%AC%E5%92%8C%E8%8C%83%E5%9B%B4"><span class="toc-number">4.3.</span> <span class="toc-text">版本和范围</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">4.4.</span> <span class="toc-text">性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">4.4.1.</span> <span class="toc-text">缓存的好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E7%BC%93%E5%AD%98%E4%B8%8E%E4%B8%8D%E5%8F%AF%E7%BC%93%E5%AD%98"><span class="toc-number">4.4.2.</span> <span class="toc-text">可缓存与不可缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BC%93%E5%AD%98"><span class="toc-number">4.4.3.</span> <span class="toc-text">自定义缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E7%BC%93%E5%AD%98"><span class="toc-number">4.4.4.</span> <span class="toc-text">配置缓存</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">测试管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E4%B8%80%E4%B8%AA%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95"><span class="toc-number">5.1.</span> <span class="toc-text">配置一个集成测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">Groovy 代码片段</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">修复找不到 jar 的情况</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#gradle-vs-maven"><span class="toc-number">7.1.</span> <span class="toc-text">Gradle vs Maven</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">7.2.</span> <span class="toc-text">最佳实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8-gradle-wrapper"><span class="toc-number">7.2.1.</span> <span class="toc-text">1. 使用 Gradle Wrapper</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%90%88%E7%90%86%E4%BD%BF%E7%94%A8-configuration"><span class="toc-number">7.2.2.</span> <span class="toc-text">2. 合理使用 Configuration</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%90%AF%E7%94%A8%E6%9E%84%E5%BB%BA%E7%BC%93%E5%AD%98"><span class="toc-number">7.2.3.</span> <span class="toc-text">3. 启用构建缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86"><span class="toc-number">7.2.4.</span> <span class="toc-text">4. 版本管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E9%81%BF%E5%85%8D%E5%8A%A8%E6%80%81%E7%89%88%E6%9C%AC"><span class="toc-number">7.2.5.</span> <span class="toc-text">5. 避免动态版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%90%88%E7%90%86%E7%BB%84%E7%BB%87%E5%A4%9A%E9%A1%B9%E7%9B%AE"><span class="toc-number">7.2.6.</span> <span class="toc-text">6. 合理组织多项目</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5"><span class="toc-number">7.3.</span> <span class="toc-text">故障排查</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%86%B2%E7%AA%81"><span class="toc-number">7.3.1.</span> <span class="toc-text">依赖冲突</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E7%BC%93%E6%85%A2"><span class="toc-number">7.3.2.</span> <span class="toc-text">构建缓慢</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%85%E7%90%86%E7%BC%93%E5%AD%98"><span class="toc-number">7.3.3.</span> <span class="toc-text">清理缓存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">7.4.</span> <span class="toc-text">参考资料</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2017 - 2026 By magicliang</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional and Simplified Chinese">簡</button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><script src="/js/tw_cn.js?v=5.5.2"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="/"></script></div></body></html>