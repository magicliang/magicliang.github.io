<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>当智能体变成一份 Markdown 文档 | 守株阁</title><meta name="author" content="magicliang"><meta name="copyright" content="magicliang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="当智能体变成一份 Markdown 文档 在传统的软件工程中，构建一个&quot;智能体&quot;（Agent）意味着编写大量代码：状态机、决策树、API 集成、错误处理、权限管理。而在 LLM 时代，定义一个功能完备的 AI 智能体，可能只需要一份结构良好的 Markdown 文档。 这不是夸张。以 Claude Code 的配置体系为例，一个 .md 文件可以定义 Agent 的身份、行为约">
<meta property="og:type" content="article">
<meta property="og:title" content="当智能体变成一份 Markdown 文档">
<meta property="og:url" content="https://magicliang.github.io/2026/02/09/%E5%BD%93%E6%99%BA%E8%83%BD%E4%BD%93%E5%8F%98%E6%88%90%E4%B8%80%E4%BB%BD-Markdown-%E6%96%87%E6%A1%A3/index.html">
<meta property="og:site_name" content="守株阁">
<meta property="og:description" content="当智能体变成一份 Markdown 文档 在传统的软件工程中，构建一个&quot;智能体&quot;（Agent）意味着编写大量代码：状态机、决策树、API 集成、错误处理、权限管理。而在 LLM 时代，定义一个功能完备的 AI 智能体，可能只需要一份结构良好的 Markdown 文档。 这不是夸张。以 Claude Code 的配置体系为例，一个 .md 文件可以定义 Agent 的身份、行为约">
<meta property="og:locale">
<meta property="og:image" content="https://magicliang.github.io/img/wall-paper-141.png">
<meta property="article:published_time" content="2026-02-09T08:00:00.000Z">
<meta property="article:modified_time" content="2026-02-09T08:30:18.259Z">
<meta property="article:author" content="magicliang">
<meta property="article:tag" content="AI">
<meta property="article:tag" content="Agent">
<meta property="article:tag" content="Agentic Coding">
<meta property="article:tag" content="Claude Code">
<meta property="article:tag" content="LLM">
<meta property="article:tag" content="Prompt Engineering">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://magicliang.github.io/img/wall-paper-141.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "当智能体变成一份 Markdown 文档",
  "url": "https://magicliang.github.io/2026/02/09/%E5%BD%93%E6%99%BA%E8%83%BD%E4%BD%93%E5%8F%98%E6%88%90%E4%B8%80%E4%BB%BD-Markdown-%E6%96%87%E6%A1%A3/",
  "image": "https://magicliang.github.io/img/wall-paper-141.png",
  "datePublished": "2026-02-09T08:00:00.000Z",
  "dateModified": "2026-02-09T08:30:18.259Z",
  "author": [
    {
      "@type": "Person",
      "name": "magicliang",
      "url": "https://magicliang.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://magicliang.github.io/2026/02/09/%E5%BD%93%E6%99%BA%E8%83%BD%E4%BD%93%E5%8F%98%E6%88%90%E4%B8%80%E4%BB%BD-Markdown-%E6%96%87%E6%A1%A3/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: magicliang","link":"Link: ","source":"Source: 守株阁","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '当智能体变成一份 Markdown 文档',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"><link rel="alternate" href="/atom.xml" title="守株阁" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      if ($loadingBox.classList.contains('loaded')) return
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()

  if (document.readyState === 'complete') {
    preloader.endLoading()
  } else {
    window.addEventListener('load', preloader.endLoading)
    document.addEventListener('DOMContentLoaded', preloader.endLoading)
    // Add timeout protection: force end after 7 seconds
    setTimeout(preloader.endLoading, 7000)
  }

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/wall-paper-141.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">守株阁</span></a><a class="nav-page-title" href="/"><span class="site-name">当智能体变成一份 Markdown 文档</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">当智能体变成一份 Markdown 文档</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2026-02-09T08:00:00.000Z" title="Created 2026-02-09 16:00:00">2026-02-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2026-02-09T08:30:18.259Z" title="Updated 2026-02-09 16:30:18">2026-02-09</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">14.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>53mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1>当智能体变成一份 Markdown 文档</h1>
<p>在传统的软件工程中，构建一个&quot;智能体&quot;（Agent）意味着编写大量代码：状态机、决策树、API 集成、错误处理、权限管理。而在 LLM 时代，定义一个功能完备的 AI 智能体，可能只需要一份结构良好的 Markdown 文档。</p>
<p>这不是夸张。以 Claude Code 的配置体系为例，一个 <code>.md</code> 文件可以定义 Agent 的身份、行为约束、工具权限、专业知识、工作流程，甚至跨会话的持久记忆。但要真正理解&quot;为什么 Markdown 就够了&quot;，以及&quot;如何写出高效的 Agent 定义&quot;，需要先回到第一性原理——理解 LLM 的本质、Agent 的运行机制，以及上下文窗口的物理约束。</p>
<p>本文将从底层原理出发，逐层构建对 Agentic Coding 的完整认知：先理解 LLM 是什么、Agent Loop 如何运转、上下文窗口为何是核心瓶颈；再拆解 Markdown 配置体系的四层架构；最后落地到实操方法论——如何管理对话、沉淀知识、用工程手段约束 Agent、为 AI 设计友好的工作环境。</p>
<h2 id="全景思维导图">全景思维导图</h2>
<pre><code class="hljs mermaid">mindmap
  root((Agentic Coding 全景))
    第一性原理
      LLM 本质
        概率性文本生成器
        非确定性推理引擎
        Token 预测机制
      Agent Loop
        感知-推理-行动循环
        LLM + 工具 + 循环 = Agent
        自主决策与工具调用
      上下文窗口
        工作记忆的物理约束
        注意力退化曲线
        Lost in the Middle 效应
    Markdown 配置体系
      CLAUDE.md
        项目记忆
        行为约束
        分层加载
      Commands
        参数化提示词模板
        斜杠触发
        变量插值
      Skills
        可复用知识包
        领域专业知识
        工作流定义
      Sub Agents
        独立上下文窗口
        工具权限隔离
        持久化记忆
    实操方法论
      对话管理
        短对话优于长对话
        任务分解策略
        上下文隔离
      知识沉淀
        从会话到持久记忆
        Rules 与 Memory
        经验复利效应
      工程约束
        Linter 与 Git Hooks
        拦截偷懒行为
        工程手段优于 Prompt 指令
      AI 友好设计
        信息架构优化
        API 设计平衡
        命名与统计直觉
      刻意练习
        像学乐器一样学 AI
        从失败中提取教训
        建立肌肉记忆</code></pre>
<h2 id="模式总览">模式总览</h2>
<p>本文覆盖的核心可迁移模式：</p>
<table>
<thead>
<tr>
<th>#</th>
<th>模式名称</th>
<th>一句话口诀</th>
<th>覆盖场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>概率性推理</td>
<td>LLM 是统计直觉而非逻辑推理</td>
<td>理解 Agent 行为的不确定性、命名偏好、错误模式</td>
</tr>
<tr>
<td>2</td>
<td>感知-行动循环</td>
<td>LLM + 工具 + 循环 = Agent</td>
<td>Agent Loop 的运行机制、工具调用、自主决策</td>
</tr>
<tr>
<td>3</td>
<td>上下文即工作记忆</td>
<td>有限窗口决定一切策略</td>
<td>对话管理、任务分解、信息密度优化</td>
</tr>
<tr>
<td>4</td>
<td>分层配置</td>
<td>环境-触发-知识-执行四层分离</td>
<td><a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a> / Commands / Skills / Sub Agents</td>
</tr>
<tr>
<td>5</td>
<td>知识外化</td>
<td>把脑中隐性知识变成文档</td>
<td>Rules、Memory、经验复利</td>
</tr>
<tr>
<td>6</td>
<td>双重投资回报</td>
<td>对人好的改进对 AI 同样有效</td>
<td>文档、架构、测试速度的双重价值</td>
</tr>
<tr>
<td>7</td>
<td>工程约束优于提示</td>
<td>用代码而非文字约束 Agent</td>
<td>Git Hooks、Linter、命令拦截</td>
</tr>
<tr>
<td>8</td>
<td>统计直觉对齐</td>
<td>顺应而非对抗 Agent 的命名偏好</td>
<td>AI 友好的命名、API 设计、信息架构</td>
</tr>
</tbody>
</table>
<pre><code class="hljs mermaid">flowchart LR
    subgraph 原理层
        P1[概率性推理]
        P2[感知-行动循环]
        P3[上下文即工作记忆]
    end
    subgraph 配置层
        P4[分层配置]
        P5[知识外化]
    end
    subgraph 实践层
        P6[双重投资回报]
        P7[工程约束优于提示]
        P8[统计直觉对齐]
    end
    P1 --&gt; P2
    P2 --&gt; P3
    P3 --&gt; P4
    P3 --&gt; P5
    P4 --&gt; P6
    P5 --&gt; P6
    P4 --&gt; P7
    P1 --&gt; P8
    P6 --&gt; P7
    P7 --&gt; P8</code></pre>
<hr>
<h2 id="第一性原理：理解-agentic-coding-的底层逻辑">第一性原理：理解 Agentic Coding 的底层逻辑</h2>
<p>在讨论如何用 Markdown 定义 Agent 之前，需要先回答三个基础问题：LLM 到底是什么？Agent 如何运转？上下文窗口意味着什么？这三个问题的答案，决定了所有上层策略的设计逻辑。</p>
<pre><code class="hljs mermaid">flowchart TB
    subgraph 第一性原理
        A[LLM 的本质] --&gt; B[Agent Loop 的运行机制]
        B --&gt; C[上下文窗口的物理约束]
    end
    C --&gt; D[为什么 Markdown 就够了]
    C --&gt; E[为什么需要分层配置]
    C --&gt; F[为什么短对话优于长对话]
    style A fill:#e1f5fe
    style B fill:#e1f5fe
    style C fill:#e1f5fe</code></pre>
<h3 id="llm-的本质：概率性文本生成器">LLM 的本质：概率性文本生成器</h3>
<p>理解 Agentic Coding 的第一步，是准确理解 LLM 的本质。LLM 不是数据库，不是搜索引擎，也不是确定性的推理引擎。它是一个<strong>概率性的文本生成器</strong>——给定一段输入文本（prompt），它预测最可能的下一个 token，然后把这个 token 加入输入，再预测下一个，如此循环。</p>
<pre><code class="hljs mermaid">flowchart LR
    A[&quot;输入: &#x27;The capital of France is&#x27;&quot;] --&gt; B[LLM 计算概率分布]
    B --&gt; C[&quot;P(&#x27;Paris&#x27;)=0.92&quot;]
    B --&gt; D[&quot;P(&#x27;Lyon&#x27;)=0.03&quot;]
    B --&gt; E[&quot;P(&#x27;the&#x27;)=0.02&quot;]
    C --&gt; F[&quot;输出: &#x27;Paris&#x27;&quot;]
    F --&gt; G[&quot;新输入: &#x27;The capital of France is Paris&#x27;&quot;]
    G --&gt; H[继续预测下一个 token...]</code></pre>
<p>这个机制带来几个关键推论：</p>
<p><strong>1. LLM 的&quot;知识&quot;是统计相关性，而非逻辑推理。</strong> 当 LLM 回答&quot;法国的首都是巴黎&quot;时，它并不是在&quot;推理&quot;，而是因为在训练数据中，&quot;法国&quot;和&quot;巴黎&quot;在&quot;首都&quot;这个上下文中高频共现。这意味着 LLM 在训练数据覆盖良好的领域表现出色，但在罕见场景下可能给出&quot;看起来合理但实际错误&quot;的答案。</p>
<p><strong>2. LLM 的输出具有概率性。</strong> 同样的输入可能产生不同的输出（受 temperature 参数控制）。这不是 bug，而是 feature——它使 LLM 能够生成创造性的内容，但也意味着不能期望 LLM 每次都给出完全一致的结果。</p>
<p><strong>3. LLM 没有持久记忆。</strong> 每次对话都是从零开始。LLM 不会&quot;记住&quot;上一次对话的内容，除非这些内容被显式地放入当前的上下文窗口中。这个特性直接决定了为什么需要 <a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a> 这样的外部记忆机制。</p>
<p><strong>4. LLM 的&quot;推理&quot;是涌现行为。</strong> 当模型规模足够大、训练数据足够丰富时，LLM 展现出类似推理的能力。但这种能力的边界是模糊的——它在常见模式上表现优异，在需要真正创新推理的场景下则不可靠。</p>
<h4 id="模式提炼：概率性推理">模式提炼：概率性推理</h4>
<p><strong>模式公式</strong>：<code>P(next_token) = f(所有前文 tokens 的统计相关性)</code></p>
<p><strong>迁移表</strong>：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>输入上下文</th>
<th>统计基础</th>
<th>可靠性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>常见编程模式</td>
<td>标准 API 调用代码</td>
<td>训练数据中大量出现</td>
<td>高</td>
<td>如 Spring Boot REST 端点</td>
</tr>
<tr>
<td>项目特定约定</td>
<td>私有框架代码</td>
<td>训练数据中未出现</td>
<td>低</td>
<td>需要通过 <a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a> 补充上下文</td>
</tr>
<tr>
<td>创新性设计</td>
<td>全新架构方案</td>
<td>训练数据中无直接对应</td>
<td>中</td>
<td>可组合已知模式，但需人工验证</td>
</tr>
<tr>
<td>边界情况处理</td>
<td>罕见错误场景</td>
<td>训练数据中稀少</td>
<td>低</td>
<td>需要显式提供示例和约束</td>
</tr>
</tbody>
</table>
<p><strong>核心洞察</strong>：当听到&quot;AI 给了错误答案&quot;时，首先应该检查的不是模型能力，而是上下文是否充分。LLM 的表现与输入上下文的质量直接相关——垃圾进，垃圾出；精确的上下文进，精确的答案出。这就是为什么 <a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a> 和 Skills 机制如此重要——它们本质上是在为 LLM 提供高质量的上下文。</p>
<h3 id="agent-loop：感知-推理-行动的循环">Agent Loop：感知-推理-行动的循环</h3>
<p>单独的 LLM 只能做文本补全。要让它成为一个能完成实际任务的 Agent，需要三个要素的组合：<strong>LLM（大脑）+ 工具（手脚）+ 循环（自主性）</strong>。</p>
<pre><code class="hljs mermaid">flowchart TB
    A[用户输入任务] --&gt; B&#123;Agent Loop&#125;
    B --&gt; C[LLM 分析当前状态]
    C --&gt; D&#123;需要更多信息?&#125;
    D --&gt;|是| E[调用工具: 读文件/搜索/执行命令]
    E --&gt; F[工具返回结果]
    F --&gt; B
    D --&gt;|否| G&#123;需要修改代码?&#125;
    G --&gt;|是| H[调用工具: 编辑文件]
    H --&gt; I[验证修改结果]
    I --&gt; B
    G --&gt;|否| J&#123;任务完成?&#125;
    J --&gt;|否| B
    J --&gt;|是| K[输出最终结果]
    style B fill:#fff3e0
    style C fill:#e8f5e9
    style E fill:#e3f2fd
    style H fill:#e3f2fd</code></pre>
<p>这个循环的每一轮都遵循相同的模式：</p>
<ol>
<li><strong>感知</strong>：LLM 读取当前上下文（用户消息 + 历史对话 + 工具返回的结果）</li>
<li><strong>推理</strong>：基于上下文，决定下一步应该做什么（调用哪个工具、传什么参数，或者直接回复用户）</li>
<li><strong>行动</strong>：执行决策（调用工具或生成回复）</li>
<li><strong>观察</strong>：将行动的结果加入上下文，开始下一轮循环</li>
</ol>
<pre><code class="hljs mermaid">sequenceDiagram
    participant U as 用户
    participant A as Agent(LLM)
    participant T as 工具集
    
    U-&gt;&gt;A: &quot;修复登录页面的 bug&quot;
    
    Note over A: 第1轮: 感知+推理
    A-&gt;&gt;T: read_file(&quot;src/login.tsx&quot;)
    T--&gt;&gt;A: 文件内容
    
    Note over A: 第2轮: 分析+搜索
    A-&gt;&gt;T: grep(&quot;handleLogin&quot;)
    T--&gt;&gt;A: 搜索结果
    
    Note over A: 第3轮: 定位+修复
    A-&gt;&gt;T: edit_file(&quot;src/login.tsx&quot;, changes)
    T--&gt;&gt;A: 修改成功
    
    Note over A: 第4轮: 验证
    A-&gt;&gt;T: run_tests(&quot;login.test.tsx&quot;)
    T--&gt;&gt;A: 测试通过
    
    A-&gt;&gt;U: &quot;已修复: 问题是...&quot;</code></pre>
<p>理解 Agent Loop 的关键在于：<strong>每一轮循环都会消耗上下文空间</strong>。用户的消息、LLM 的思考过程、工具调用的参数、工具返回的结果——所有这些都会被追加到上下文中。这意味着 Agent Loop 的轮次越多，上下文消耗越大，最终可能触及上下文窗口的物理限制。</p>
<p>Agent Loop 还有一个重要特性：<strong>LLM 在每一轮都会重新阅读完整的上下文</strong>。这既是优势（保证了一致性），也是劣势（随着上下文增长，注意力会被稀释）。</p>
<h4 id="模式提炼：感知-行动循环">模式提炼：感知-行动循环</h4>
<p><strong>模式公式</strong>：<code>Agent = while(!done) { context = perceive(); action = reason(context); result = act(action); context += result; }</code></p>
<p><strong>迁移表</strong>：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>感知</th>
<th>推理</th>
<th>行动</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bug 修复</td>
<td>读取错误日志+代码</td>
<td>定位根因</td>
<td>编辑代码+运行测试</td>
<td>典型的多轮循环</td>
</tr>
<tr>
<td>代码审查</td>
<td>读取 diff+规范</td>
<td>对比规范找问题</td>
<td>输出审查意见</td>
<td>可能只需 1-2 轮</td>
</tr>
<tr>
<td>新功能开发</td>
<td>读取需求+现有架构</td>
<td>设计方案</td>
<td>创建文件+编写代码</td>
<td>轮次最多，上下文消耗最大</td>
</tr>
<tr>
<td>重构</td>
<td>读取现有代码+依赖</td>
<td>规划重构步骤</td>
<td>批量修改文件</td>
<td>需要精确的任务分解</td>
</tr>
</tbody>
</table>
<p><strong>核心洞察</strong>：当听到&quot;Agent 做了很多无用功&quot;时，问题往往不在 Agent 的推理能力，而在于循环的效率——每一轮是否提供了足够精确的上下文？工具返回的信息是否有助于推进任务？这就是为什么 Commands 和 Skills 机制如此重要——它们通过预定义的工作流减少了 Agent 的&quot;摸索&quot;轮次。</p>
<h3 id="上下文窗口：agent-的工作记忆">上下文窗口：Agent 的工作记忆</h3>
<p>上下文窗口是理解所有 Agentic Coding 策略的关键。可以把它类比为人的工作记忆（Working Memory）——它是 Agent 在任何时刻能&quot;看到&quot;和&quot;思考&quot;的全部信息。</p>
<pre><code class="hljs mermaid">flowchart TB
    subgraph 上下文窗口[&quot;上下文窗口 (如 200K tokens)&quot;]
        direction TB
        A[&quot;系统提示词 (CLAUDE.md 内容)&quot;]
        B[&quot;用户消息历史&quot;]
        C[&quot;Agent 的思考过程&quot;]
        D[&quot;工具调用记录&quot;]
        E[&quot;工具返回结果&quot;]
        F[&quot;当前正在生成的回复&quot;]
    end
    
    G[&quot;窗口外: 之前的对话&quot;] -.-&gt;|&quot;不可见&quot;| 上下文窗口
    H[&quot;窗口外: 未读取的文件&quot;] -.-&gt;|&quot;不可见&quot;| 上下文窗口
    I[&quot;窗口外: 其他项目知识&quot;] -.-&gt;|&quot;不可见&quot;| 上下文窗口
    
    style 上下文窗口 fill:#fff8e1
    style G fill:#ffebee
    style H fill:#ffebee
    style I fill:#ffebee</code></pre>
<h4 id="上下文窗口的三个关键特性">上下文窗口的三个关键特性</h4>
<p><strong>1. 有限性</strong></p>
<p>即使是 200K token 的上下文窗口，看起来很大（约 15 万个英文单词），但在实际的 Agent 工作中会被迅速消耗：</p>
<pre><code class="hljs mermaid">pie title &quot;一次典型 Agent 会话的上下文消耗&quot;
    &quot;系统提示词 + Rules&quot; : 10
    &quot;用户消息&quot; : 5
    &quot;Agent 思考过程&quot; : 20
    &quot;工具调用参数&quot; : 10
    &quot;工具返回结果(文件内容等)&quot; : 40
    &quot;Agent 生成的代码&quot; : 15</code></pre>
<p>一个中等复杂度的编程任务，可能在 10-20 轮 Agent Loop 后就消耗掉大部分上下文空间。</p>
<p><strong>2. 注意力退化（Lost in the Middle）</strong></p>
<p>研究表明，LLM 对上下文中不同位置的信息，注意力分布是不均匀的。开头和结尾的信息得到更多关注，而中间部分的信息容易被&quot;遗忘&quot;。</p>
<pre><code class="hljs mermaid">flowchart LR
    subgraph 注意力分布
        direction LR
        A[&quot;开头&lt;br/&gt;注意力: 高&quot;] --- B[&quot;中间&lt;br/&gt;注意力: 低&quot;] --- C[&quot;结尾&lt;br/&gt;注意力: 高&quot;]
    end
    
    D[&quot;实际影响:&lt;br/&gt;早期的工具返回结果&lt;br/&gt;可能被后续信息&#x27;淹没&#x27;&quot;]
    
    注意力分布 --&gt; D</code></pre>
<p>这意味着：随着对话的进行，Agent 可能会&quot;忘记&quot;早期获取的关键信息，导致重复搜索、前后矛盾，甚至引入之前已经修复过的 bug。</p>
<p><strong>3. 上下文污染</strong></p>
<p>上下文中的错误信息不会自动消失。如果 Agent 在第 3 轮生成了一段有 bug 的代码，即使在第 5 轮修复了，第 3 轮的错误代码仍然存在于上下文中，可能在后续轮次中&quot;误导&quot; Agent。</p>
<pre><code class="hljs mermaid">flowchart TB
    A[&quot;第3轮: Agent 生成错误代码&quot;] --&gt; B[&quot;第4轮: 发现错误&quot;]
    B --&gt; C[&quot;第5轮: 修复错误&quot;]
    C --&gt; D[&quot;第8轮: Agent 再次参考上下文&quot;]
    D --&gt; E&#123;&quot;看到了哪个版本?&quot;&#125;
    E --&gt;|&quot;可能看到第3轮的错误版本&quot;| F[&quot;再次引入相同 bug&quot;]
    E --&gt;|&quot;看到第5轮的修复版本&quot;| G[&quot;正确继续&quot;]
    style F fill:#ffcdd2
    style G fill:#c8e6c9</code></pre>
<h4 id="上下文管理的核心策略">上下文管理的核心策略</h4>
<p>理解了上下文窗口的特性后，所有的 Agentic Coding 策略都可以归结为一个核心目标：<strong>在有限的上下文空间内，最大化有效信息密度</strong>。</p>
<pre><code class="hljs mermaid">flowchart TB
    A[上下文管理核心策略] --&gt; B[减少无效信息]
    A --&gt; C[增加有效信息]
    A --&gt; D[隔离信息空间]
    
    B --&gt; B1[短对话优于长对话]
    B --&gt; B2[精确的工具调用]
    B --&gt; B3[避免重复搜索]
    
    C --&gt; C1[CLAUDE.md 预加载关键上下文]
    C --&gt; C2[Skills 注入领域知识]
    C --&gt; C3[结构化的错误信息]
    
    D --&gt; D1[Sub Agent 独立上下文]
    D --&gt; D2[任务分解与隔离]
    D --&gt; D3[新对话 vs 继续对话]</code></pre>
<h4 id="模式提炼：上下文即工作记忆">模式提炼：上下文即工作记忆</h4>
<p><strong>模式公式</strong>：<code>有效性 = 有效信息量 / 总上下文消耗 × 注意力权重(位置)</code></p>
<p><strong>迁移表</strong>：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>上下文压力</th>
<th>推荐策略</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>简单 bug 修复</td>
<td>低</td>
<td>单次对话完成</td>
<td>2-5 轮 Loop 即可</td>
</tr>
<tr>
<td>中等功能开发</td>
<td>中</td>
<td>预加载 Rules + 精确搜索</td>
<td>控制在 10-15 轮</td>
</tr>
<tr>
<td>大型重构</td>
<td>高</td>
<td>任务分解 + Sub Agent</td>
<td>每个子任务独立上下文</td>
</tr>
<tr>
<td>跨模块修改</td>
<td>极高</td>
<td>多次短对话 + 持久记忆</td>
<td>每个模块一次对话</td>
</tr>
</tbody>
</table>
<p><strong>核心洞察</strong>：当听到&quot;Agent 在长对话中表现越来越差&quot;时，根因几乎总是上下文窗口的退化。解决方案不是&quot;换一个更强的模型&quot;，而是&quot;开一个新对话&quot;。这就是为什么 Sub Agent 机制如此重要——它通过创建独立的上下文窗口，从根本上解决了上下文污染问题。</p>
<hr>
<h2 id="markdown-配置体系：用文档定义智能体">Markdown 配置体系：用文档定义智能体</h2>
<p>理解了第一性原理之后，再来看 Claude Code 的 Markdown 配置体系，就能理解每一层设计背后的&quot;为什么&quot;。</p>
<p>这套体系包含四种机制：<strong><a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a></strong>（项目记忆）、<strong>Commands</strong>（参数化触发）、<strong>Skills</strong>（专业知识包）、<strong>Sub Agents</strong>（独立执行体）。它们按照关注点分离的原则，各自承担不同的职责。</p>
<pre><code class="hljs mermaid">flowchart TB
    subgraph 四层配置体系
        direction TB
        L1[&quot;CLAUDE.md&lt;br/&gt;──────────&lt;br/&gt;项目记忆与行为约束&lt;br/&gt;始终在场 | 自动加载&quot;]
        L2[&quot;Commands&lt;br/&gt;──────────&lt;br/&gt;参数化提示词模板&lt;br/&gt;按需加载 | 用户触发&quot;]
        L3[&quot;Skills&lt;br/&gt;──────────&lt;br/&gt;可复用知识包&lt;br/&gt;按需加载 | Agent 自动匹配&quot;]
        L4[&quot;Sub Agents&lt;br/&gt;──────────&lt;br/&gt;独立执行的专业角色&lt;br/&gt;按需加载 | 独立上下文&quot;]
    end
    
    L1 --&gt;|&quot;提供环境上下文&quot;| L2
    L2 --&gt;|&quot;触发具体任务&quot;| L3
    L3 --&gt;|&quot;提供专业知识&quot;| L4
    L4 --&gt;|&quot;隔离执行&quot;| R[任务完成]
    
    style L1 fill:#e8eaf6
    style L2 fill:#e3f2fd
    style L3 fill:#e8f5e9
    style L4 fill:#fff3e0</code></pre>
<h3 id="claude-md：项目记忆与行为约束"><a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a>：项目记忆与行为约束</h3>
<p><a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a> 是整个体系的基础层。它解决的核心问题是：<strong>LLM 没有持久记忆，每次对话都从零开始</strong>。通过在对话开始时自动加载 <a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a> 的内容，Agent 能立即获得项目的关键上下文。</p>
<h4 id="分层加载机制">分层加载机制</h4>
<p><a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a> 支持三级作用域，按从全局到局部的顺序加载：</p>
<pre><code class="hljs mermaid">flowchart TB
    A[&quot;~/.claude/CLAUDE.md&lt;br/&gt;全局级：跨项目通用偏好&quot;] --&gt; D[合并注入上下文]
    B[&quot;项目根目录/CLAUDE.md&lt;br/&gt;项目级：技术栈、规范、架构&quot;] --&gt; D
    C[&quot;当前目录/CLAUDE.md&lt;br/&gt;目录级：模块特定约束&quot;] --&gt; D
    D --&gt; E[&quot;Agent 开始工作&lt;br/&gt;已具备完整的项目认知&quot;]
    
    style A fill:#e8eaf6
    style B fill:#c5cae9
    style C fill:#9fa8da</code></pre>
<p>这种分层设计的精妙之处在于：<strong>它用最小的上下文消耗，提供了最大的信息覆盖</strong>。全局偏好只写一次，项目规范只在项目级定义，模块特定的约束只在需要时加载。</p>
<h4 id="claude-md-的内容结构"><a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a> 的内容结构</h4>
<p>一份高效的 <a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a> 应该包含以下信息（按优先级排序）：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 项目概述</span><br>这是一个基于 Spring Boot 3.2 的电商平台后端服务。<br>Java 21，Maven 构建，MySQL + Redis。<br><br><span class="hljs-section"># 关键命令</span><br><span class="hljs-bullet">-</span> 构建: <span class="hljs-code">`mvn clean package -DskipTests`</span><br><span class="hljs-bullet">-</span> 测试: <span class="hljs-code">`mvn test -pl module-name`</span><br><span class="hljs-bullet">-</span> 本地运行: <span class="hljs-code">`mvn spring-boot:run -pl app`</span><br><br><span class="hljs-section"># 代码规范</span><br><span class="hljs-bullet">-</span> REST API 统一返回 <span class="hljs-code">`Result&lt;T&gt;`</span>，见 <span class="hljs-code">`common/Result.java`</span><br><span class="hljs-bullet">-</span> 使用 MapStruct 做 DTO 转换，禁止手写 getter/setter 转换<br><span class="hljs-bullet">-</span> 异常统一通过 <span class="hljs-code">`@RestControllerAdvice`</span> 处理<br><br><span class="hljs-section"># 架构约束</span><br><span class="hljs-bullet">-</span> 严格分层: Controller → Service → Repository<br><span class="hljs-bullet">-</span> 禁止 Controller 直接访问 Repository<br><span class="hljs-bullet">-</span> 跨模块调用必须通过 API 接口，禁止直接依赖实现类<br><br><span class="hljs-section"># 当前工作重点</span><br><span class="hljs-bullet">-</span> 正在重构订单模块，从单体迁移到 DDD 风格<br><span class="hljs-bullet">-</span> 支付模块不要改动，正在等待第三方 SDK 升级<br></code></pre></td></tr></table></figure>
<p><strong>关键原则</strong>：<a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a> 应该是<strong>声明式</strong>的——告诉 Agent “是什么&quot;和&quot;不要做什么”，而不是&quot;怎么做&quot;。具体的&quot;怎么做&quot;应该交给 Skills 和 Commands。</p>
<h4 id="从第一性原理理解-claude-md-的设计">从第一性原理理解 <a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a> 的设计</h4>
<p>回到上下文窗口的约束：<a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a> 的内容会在每次对话开始时被注入上下文。这意味着：</p>
<ul>
<li><strong>内容必须精炼</strong>：每多一行，就多消耗一点宝贵的上下文空间</li>
<li><strong>信息密度要高</strong>：用最少的 token 传达最关键的信息</li>
<li><strong>避免重复</strong>：不要在 <a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a> 中写已经在代码注释或 README 中存在的信息</li>
</ul>
<pre><code class="hljs mermaid">flowchart LR
    A[&quot;CLAUDE.md 内容&quot;] --&gt;|&quot;每次对话都消耗&quot;| B[&quot;上下文空间&quot;]
    B --&gt;|&quot;剩余空间&quot;| C[&quot;实际工作可用&quot;]
    
    D[&quot;过长的 CLAUDE.md&quot;] --&gt;|&quot;挤占&quot;| C
    E[&quot;过短的 CLAUDE.md&quot;] --&gt;|&quot;Agent 需要额外搜索&lt;br/&gt;反而消耗更多上下文&quot;| C
    
    F[&quot;最优: 精炼但完整&quot;] --&gt;|&quot;平衡&quot;| C
    style F fill:#c8e6c9
    style D fill:#ffcdd2</code></pre>
<h3 id="commands：参数化的提示词模板">Commands：参数化的提示词模板</h3>
<p>Commands 解决的问题是：<strong>重复性任务的标准化触发</strong>。如果发现自己经常对 Agent 说类似的话（“帮我写一个 API 端点，路径是 X，方法是 Y”），就应该把它封装成一个 Command。</p>
<h4 id="command-的定义结构">Command 的定义结构</h4>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>name: create-api<br>description: 创建一个新的 REST API 端点<br>arguments:<br><span class="hljs-bullet">  -</span> name: method<br><span class="hljs-code">    description: HTTP 方法 (GET/POST/PUT/DELETE)</span><br><span class="hljs-code">    required: true</span><br><span class="hljs-code">  - name: path</span><br><span class="hljs-code">    description: API 路径 (如 /api/v1/users)</span><br><span class="hljs-code">    required: true</span><br><span class="hljs-code">  - name: description</span><br><span class="hljs-code">    description: API 功能描述</span><br><span class="hljs-code">    required: false</span><br><span class="hljs-code">---</span><br><span class="hljs-code"></span><br>创建一个新的 REST API 端点。<br><br>HTTP 方法: $ARGUMENTS.method<br>API 路径: $ARGUMENTS.path<br>功能描述: $ARGUMENTS.description<br><br>请按照以下步骤实现:<br><span class="hljs-bullet">1.</span> 在对应的 Controller 中添加端点方法<br><span class="hljs-bullet">2.</span> 在 Service 层添加业务逻辑接口和实现<br><span class="hljs-bullet">3.</span> 如需要，在 Repository 层添加数据访问方法<br><span class="hljs-bullet">4.</span> 编写单元测试<br><span class="hljs-bullet">5.</span> 更新 API 文档<br><br>遵循项目的 REST API 规范（见 CLAUDE.md）。<br></code></pre></td></tr></table></figure>
<p>用户只需输入 <code>/create-api POST /api/v1/orders &quot;创建订单&quot;</code> 即可触发完整的工作流。</p>
<h4 id="command-与上下文的关系">Command 与上下文的关系</h4>
<p>从上下文管理的角度看，Command 的价值在于：<strong>用少量的用户输入 token，展开为大量的精确指令 token</strong>。这比用户每次手动输入完整指令更高效，也更一致。</p>
<pre><code class="hljs mermaid">flowchart LR
    A[&quot;用户输入:&lt;br/&gt;/create-api POST /orders&quot;] --&gt;|&quot;展开&quot;| B[&quot;完整的提示词模板&lt;br/&gt;+ 参数值&lt;br/&gt;+ 工作流步骤&lt;br/&gt;+ 规范引用&quot;]
    
    C[&quot;用户手动输入:&lt;br/&gt;帮我创建一个 POST API...&lt;br/&gt;路径是 /orders...&lt;br/&gt;记得遵循规范...&lt;br/&gt;要写测试...&quot;] --&gt;|&quot;对比&quot;| D[&quot;信息可能遗漏&lt;br/&gt;表述可能不一致&lt;br/&gt;消耗更多 token&quot;]
    
    style A fill:#c8e6c9
    style C fill:#ffcdd2</code></pre>
<h3 id="skills：可复用的知识包">Skills：可复用的知识包</h3>
<p>Skills 是 Commands 的升级版。如果说 Command 是一个&quot;提示词模板&quot;，那么 Skill 就是一个&quot;知识包&quot;——它不仅包含指令，还包含领域知识、参考文档、工作流定义。</p>
<h4 id="skill-的完整结构">Skill 的完整结构</h4>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs nix">.claude<span class="hljs-operator">/</span>skills<span class="hljs-symbol">/</span><br>└── api-design<span class="hljs-symbol">/</span><br>    ├── skill.md              <span class="hljs-comment"># Skill 定义（入口）</span><br>    └── references<span class="hljs-symbol">/</span><br>        ├── rest-conventions.md    <span class="hljs-comment"># REST API 设计规范</span><br>        ├── error-codes.md         <span class="hljs-comment"># 错误码定义</span><br>        └── examples<span class="hljs-symbol">/</span><br>            ├── user-api.md        <span class="hljs-comment"># 用户 API 示例</span><br>            └── order-api.md       <span class="hljs-comment"># 订单 API 示例</span><br></code></pre></td></tr></table></figure>
<p>Skill 定义文件（<code>skill.md</code>）的结构：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>name: api-design<br><span class="hljs-section">description: REST API 设计专家，遵循团队的 API 设计规范</span><br><span class="hljs-section">---</span><br><br>作为 API 设计专家，在设计和实现 REST API 时：<br><br><span class="hljs-bullet">1.</span> 遵循 <span class="hljs-code">`references/rest-conventions.md`</span> 中的命名和路径规范<br><span class="hljs-bullet">2.</span> 错误响应使用 <span class="hljs-code">`references/error-codes.md`</span> 中定义的错误码<br><span class="hljs-bullet">3.</span> 参考 <span class="hljs-code">`references/examples/`</span> 中的示例了解团队风格<br><br>设计原则：<br><span class="hljs-bullet">-</span> URL 使用名词复数形式（/users, /orders）<br><span class="hljs-bullet">-</span> 使用标准 HTTP 状态码<br><span class="hljs-bullet">-</span> 响应体统一使用 Result<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span></span> 包装<br><span class="hljs-bullet">-</span> 分页使用 cursor-based pagination<br></code></pre></td></tr></table></figure>
<h4 id="skill-的加载机制">Skill 的加载机制</h4>
<p>当 Agent 判断当前任务需要某个 Skill 的知识时，会自动加载该 Skill 的全部内容（包括 <code>references/</code> 目录下的文件）到上下文中。这个过程是<strong>按需</strong>的——只有在需要时才加载，避免了不必要的上下文消耗。</p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant U as 用户
    participant A as Agent
    participant S as Skill 工具
    
    U-&gt;&gt;A: &quot;设计一个订单退款 API&quot;
    
    Note over A: 判断需要 API 设计知识
    A-&gt;&gt;S: 搜索匹配的 Skill
    S--&gt;&gt;A: 找到 api-design Skill
    
    Note over A: 加载 Skill 内容到上下文
    A-&gt;&gt;S: 读取 skill.md + references/*
    S--&gt;&gt;A: API 规范 + 错误码 + 示例
    
    Note over A: 基于 Skill 知识执行任务
    A-&gt;&gt;U: 按照团队规范设计的退款 API</code></pre>
<h4 id="skills-与-claude-md-的分工">Skills 与 <a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a> 的分工</h4>
<pre><code class="hljs mermaid">flowchart TB
    subgraph CLAUDE.md
        A1[&quot;项目级通用信息&quot;]
        A2[&quot;技术栈声明&quot;]
        A3[&quot;全局行为约束&quot;]
    end
    
    subgraph Skills
        B1[&quot;领域专业知识&quot;]
        B2[&quot;详细的参考文档&quot;]
        B3[&quot;具体的工作流程&quot;]
    end
    
    C[&quot;上下文空间&quot;] 
    
    CLAUDE.md --&gt;|&quot;始终占用&quot;| C
    Skills --&gt;|&quot;按需占用&quot;| C
    
    D[&quot;设计原则:&lt;br/&gt;CLAUDE.md 放&#x27;必须始终知道的&#x27;&lt;br/&gt;Skills 放&#x27;需要时才加载的&#x27;&quot;]
    
    style D fill:#e8f5e9</code></pre>
<h3 id="sub-agents：独立执行的专业角色">Sub Agents：独立执行的专业角色</h3>
<p>Sub Agents 是四层体系中最强大的机制。它解决的核心问题是：<strong>上下文隔离</strong>。</p>
<p>回到第一性原理：上下文窗口是有限的，长对话会导致注意力退化和上下文污染。Sub Agent 通过创建<strong>独立的上下文窗口</strong>，从根本上解决了这个问题。</p>
<pre><code class="hljs mermaid">flowchart TB
    subgraph 主对话[&quot;主 Agent 上下文窗口&quot;]
        M1[&quot;用户任务&quot;]
        M2[&quot;项目上下文&quot;]
        M3[&quot;任务分解决策&quot;]
    end
    
    subgraph SA1[&quot;Sub Agent A 上下文窗口&quot;]
        A1[&quot;独立的上下文&quot;]
        A2[&quot;专属工具权限&quot;]
        A3[&quot;子任务 A 的全部工作&quot;]
    end
    
    subgraph SA2[&quot;Sub Agent B 上下文窗口&quot;]
        B1[&quot;独立的上下文&quot;]
        B2[&quot;专属工具权限&quot;]
        B3[&quot;子任务 B 的全部工作&quot;]
    end
    
    主对话 --&gt;|&quot;委派子任务 A&quot;| SA1
    主对话 --&gt;|&quot;委派子任务 B&quot;| SA2
    SA1 --&gt;|&quot;只返回摘要结果&quot;| 主对话
    SA2 --&gt;|&quot;只返回摘要结果&quot;| 主对话
    
    style 主对话 fill:#e8eaf6
    style SA1 fill:#e3f2fd
    style SA2 fill:#e8f5e9</code></pre>
<h4 id="sub-agent-的定义">Sub Agent 的定义</h4>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>name: code-reviewer<br>description: 代码审查专家，专注于代码质量和安全性审查<br><span class="hljs-section">tools: Read, Grep, Glob</span><br><span class="hljs-section">---</span><br><br>作为代码审查专家，执行以下审查流程：<br><br><span class="hljs-bullet">1.</span> 读取待审查的代码文件<br><span class="hljs-bullet">2.</span> 检查代码质量：命名规范、函数长度、复杂度<br><span class="hljs-bullet">3.</span> 检查安全性：SQL 注入、XSS、敏感信息泄露<br><span class="hljs-bullet">4.</span> 检查性能：N+1 查询、不必要的循环、内存泄漏风险<br><span class="hljs-bullet">5.</span> 输出结构化的审查报告<br><br>审查标准：<br><span class="hljs-bullet">-</span> 函数不超过 30 行<br><span class="hljs-bullet">-</span> 圈复杂度不超过 10<br><span class="hljs-bullet">-</span> 所有外部输入必须验证<br><span class="hljs-bullet">-</span> 数据库查询必须使用参数化<br></code></pre></td></tr></table></figure>
<p>注意 <code>tools: Read, Grep, Glob</code>——这个 Sub Agent <strong>只有读取权限，没有编辑权限</strong>。工具列表就是权限边界。</p>
<h4 id="sub-agent-的高级特性">Sub Agent 的高级特性</h4>
<p><strong>1. 持久化记忆</strong></p>
<p>Sub Agent 可以拥有跨对话持久化的记忆目录：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>name: code-reviewer<br>description: 代码审查专家<br><span class="hljs-section">memory: project</span><br><span class="hljs-section">---</span><br></code></pre></td></tr></table></figure>
<p><code>memory</code> 字段支持三种作用域：</p>
<table>
<thead>
<tr>
<th>作用域</th>
<th>存储位置</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>user</code></td>
<td><code>~/.claude/agent-memory/&lt;name&gt;/</code></td>
<td>跨项目通用的经验积累</td>
</tr>
<tr>
<td><code>project</code></td>
<td><code>.claude/agent-memory/&lt;name&gt;/</code></td>
<td>项目特定的知识，可提交 Git</td>
</tr>
<tr>
<td><code>local</code></td>
<td><code>.claude/agent-memory-local/&lt;name&gt;/</code></td>
<td>项目特定但不提交 Git</td>
</tr>
</tbody>
</table>
<p>启用记忆后，Sub Agent 的系统提示词中会自动注入记忆目录中 <code>MEMORY.md</code> 的前 200 行内容。这意味着 <strong>Agent 会随着使用越来越&quot;聪明&quot;</strong>——它在审查代码时发现的模式、踩过的坑，都会被记录下来，下次自动参考。</p>
<p><strong>2. Hook 机制——工具调用的拦截与增强</strong></p>
<p>Sub Agent 支持在工具调用前后执行自定义脚本：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>name: db-reader<br>description: 只读数据库查询专家<br>tools: Bash<br>hooks:<br>  PreToolUse:<br><span class="hljs-bullet">    -</span> matcher: &quot;Bash&quot;<br><span class="hljs-code">      hooks:</span><br><span class="hljs-code">        - type: command</span><br><span class="hljs-code">          command: &quot;./scripts/validate-readonly-query.sh&quot;</span><br><span class="hljs-code">---</span><br></code></pre></td></tr></table></figure>
<p>对应的验证脚本会在每次 Bash 调用前拦截并验证命令内容，只允许 SELECT 查询通过。这实现了比简单的工具白名单更细粒度的权限控制。</p>
<p><strong>3. 预加载 Skills</strong></p>
<p>Sub Agent 可以声明需要预加载的 Skills：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>name: api-developer<br>description: API 开发专家<br>skills:<br><span class="hljs-bullet">  -</span> api-conventions<br><span class="hljs-section">  - error-handling-patterns</span><br><span class="hljs-section">---</span><br></code></pre></td></tr></table></figure>
<p><code>skills</code> 字段列出的 Skill 的全部内容会被注入到 Sub Agent 的上下文中，使得 Sub Agent 在启动时就具备了特定领域的专业知识。</p>
<h3 id="四种机制的-mece-对比">四种机制的 MECE 对比</h3>
<pre><code class="hljs mermaid">flowchart TB
    subgraph 何时加载
        direction LR
        A1[&quot;始终在场&quot;] ---|&quot;←→&quot;| A2[&quot;按需加载&quot;]
        A1 --- A1a[&quot;CLAUDE.md&quot;]
        A2 --- A2a[&quot;Commands / Skills / Sub Agents&quot;]
    end
    
    subgraph 在哪执行
        direction LR
        B1[&quot;主对话上下文&quot;] ---|&quot;←→&quot;| B2[&quot;独立上下文&quot;]
        B1 --- B1a[&quot;CLAUDE.md / Commands / Skills&quot;]
        B2 --- B2a[&quot;Sub Agents&quot;]
    end
    
    subgraph 信息密度
        direction LR
        C1[&quot;低密度&lt;br/&gt;CLAUDE.md&quot;] --- C2[&quot;中密度&lt;br/&gt;Commands&quot;] --- C3[&quot;高密度&lt;br/&gt;Skills&quot;] --- C4[&quot;最高密度&lt;br/&gt;Sub Agents&quot;]
    end</code></pre>
<table>
<thead>
<tr>
<th>维度</th>
<th><a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a></th>
<th>Commands</th>
<th>Skills</th>
<th>Sub Agents</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>加载时机</strong></td>
<td>对话开始自动加载</td>
<td>用户 <code>/</code> 触发</td>
<td>Agent 自动匹配</td>
<td>Agent 委派任务</td>
</tr>
<tr>
<td><strong>执行上下文</strong></td>
<td>主对话</td>
<td>主对话</td>
<td>主对话</td>
<td>独立上下文窗口</td>
</tr>
<tr>
<td><strong>工具权限</strong></td>
<td>继承主对话</td>
<td>继承主对话</td>
<td>继承主对话</td>
<td>独立工具白名单</td>
</tr>
<tr>
<td><strong>持久记忆</strong></td>
<td>不支持</td>
<td>不支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td><strong>信息密度</strong></td>
<td>声明式偏好</td>
<td>提示词模板</td>
<td>知识+流程</td>
<td>角色+工具+流程+权限+记忆</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>项目级通用约束</td>
<td>重复性任务标准化</td>
<td>领域专业知识</td>
<td>自包含的独立任务</td>
</tr>
</tbody>
</table>
<p><strong>判断标准</strong>：如果任务需要频繁的用户交互和迭代，用 Skill；如果任务是自包含的、可以独立完成并返回摘要的，用 Sub Agent。</p>
<h3 id="四种机制的协同工作">四种机制的协同工作</h3>
<p>以一个完整的场景说明四种机制如何协同：在电商项目中为订单模块添加退款 API。</p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant U as 用户
    participant M as 主 Agent
    participant C as CLAUDE.md
    participant CMD as Command
    participant SK as Skill
    participant SA1 as Sub Agent: reviewer
    participant SA2 as Sub Agent: developer
    
    Note over M,C: 第一层: CLAUDE.md 自动加载
    C--&gt;&gt;M: 项目技术栈、规范、架构信息
    
    Note over U,CMD: 第二层: 用户触发 Command
    U-&gt;&gt;M: /create-api POST /api/v1/orders/&#123;id&#125;/refund
    CMD--&gt;&gt;M: 展开为完整的任务指令
    
    Note over M,SK: 第三层: Skill 自动匹配
    M-&gt;&gt;SK: 加载 api-design Skill
    SK--&gt;&gt;M: REST 规范 + 错误码 + 示例
    
    Note over M,SA2: 第四层: Sub Agent 并行执行
    M-&gt;&gt;SA1: 审查现有退款相关代码(只读权限)
    M-&gt;&gt;SA2: 实现退款 API(读写权限, 预加载 api-conventions Skill)
    SA1--&gt;&gt;M: 审查报告摘要
    SA2--&gt;&gt;M: 实现完成摘要
    
    M-&gt;&gt;U: 综合报告 + 最终结果</code></pre>
<blockquote>
<p><strong><a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a> 提供&quot;我是谁、我在哪&quot;的环境上下文，Commands 提供&quot;做这件事&quot;的触发入口，Skills 提供&quot;怎么做好这件事&quot;的专业知识，Sub Agents 提供&quot;让专人去做&quot;的执行隔离。</strong></p>
</blockquote>
<h3 id="更广泛的视角：rules-和-specs">更广泛的视角：Rules 和 Specs</h3>
<p>在不同的 AI 编码平台中，还存在 <code>Rules</code> 和 <code>Specs</code> 这样的概念。它们本质上是对上述体系的变体或补充。</p>
<h4 id="rules：claude-md-的跨平台等价物">Rules：<a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a> 的跨平台等价物</h4>
<table>
<thead>
<tr>
<th>平台</th>
<th>配置文件</th>
</tr>
</thead>
<tbody>
<tr>
<td>Claude Code</td>
<td><code>CLAUDE.md</code></td>
</tr>
<tr>
<td>Cursor</td>
<td><code>.cursorrules</code></td>
</tr>
<tr>
<td>Windsurf</td>
<td><code>.windsurfrules</code></td>
</tr>
<tr>
<td>GitHub Copilot</td>
<td><code>.github/copilot-instructions.md</code></td>
</tr>
<tr>
<td>Aone Copilot</td>
<td>Skills (<code>SKILL.md</code>)</td>
</tr>
</tbody>
</table>
<p>不同的名字，相同的本质：告诉 Agent 所处的环境和应该遵循的规范。如果项目需要支持多个 AI 编码工具，可以维护一份核心规范文档，然后通过符号链接或脚本同步到各平台的配置文件中。</p>
<h4 id="specs：面向任务的需求文档">Specs：面向任务的需求文档</h4>
<p>Specs 与上述所有机制都不同。它们不是 Agent 的&quot;行为定义&quot;，而是 Agent 工作时需要参考的&quot;需求文档&quot;——API 设计规格、数据库 schema 说明、产品需求文档等。</p>
<pre><code class="hljs mermaid">flowchart LR
    subgraph Agent行为定义
        A[CLAUDE.md / Rules]
        B[Commands]
        C[Skills]
        D[Sub Agents]
    end
    
    subgraph 任务需求
        E[Specs / 需求文档]
    end
    
    Agent行为定义 --&gt;|&quot;定义 Agent 怎么工作&quot;| F[Agent]
    任务需求 --&gt;|&quot;定义 Agent 要完成什么&quot;| F</code></pre>
<h4 id="模式提炼：分层配置">模式提炼：分层配置</h4>
<p><strong>模式公式</strong>：<code>Agent 配置 = 环境上下文(始终) + 触发入口(按需) + 专业知识(按需) + 执行隔离(按需)</code></p>
<p><strong>迁移表</strong>：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>环境层</th>
<th>触发层</th>
<th>知识层</th>
<th>执行层</th>
</tr>
</thead>
<tbody>
<tr>
<td>个人项目</td>
<td>简单的 <a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a></td>
<td>不需要</td>
<td>不需要</td>
<td>不需要</td>
</tr>
<tr>
<td>团队项目</td>
<td>详细的 <a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a></td>
<td>常用 Commands</td>
<td>领域 Skills</td>
<td>审查 Sub Agent</td>
</tr>
<tr>
<td>大型企业项目</td>
<td>分层 <a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a></td>
<td>标准化 Commands</td>
<td>多领域 Skills</td>
<td>多角色 Sub Agents</td>
</tr>
<tr>
<td>开源项目</td>
<td>贡献者指南</td>
<td>PR 模板 Command</td>
<td>代码风格 Skill</td>
<td>CI 审查 Sub Agent</td>
</tr>
</tbody>
</table>
<p><strong>核心洞察</strong>：当听到&quot;Agent 不遵循项目规范&quot;时，问题往往不在 Agent 的能力，而在于规范没有被正确地放入 Agent 的上下文中。分层配置体系的核心价值是：确保正确的信息在正确的时机出现在 Agent 的上下文中。</p>
<hr>
<h2 id="实操方法论：从原理到实践">实操方法论：从原理到实践</h2>
<p>理解了第一性原理和配置体系之后，接下来是最关键的部分：如何在日常工作中高效地使用 Agentic Coding。</p>
<pre><code class="hljs mermaid">flowchart TB
    subgraph 实操方法论
        A[对话管理] --&gt; B[知识沉淀]
        B --&gt; C[工程约束]
        C --&gt; D[AI 友好设计]
        D --&gt; E[刻意练习]
    end
    
    F[&quot;第一性原理&quot;] --&gt;|&quot;指导&quot;| 实操方法论
    G[&quot;配置体系&quot;] --&gt;|&quot;支撑&quot;| 实操方法论
    
    style A fill:#e3f2fd
    style B fill:#e8f5e9
    style C fill:#fff3e0
    style D fill:#fce4ec
    style E fill:#f3e5f5</code></pre>
<h3 id="对话管理：短对话优于长对话">对话管理：短对话优于长对话</h3>
<p>这是从上下文窗口约束直接推导出的最重要的实操原则。</p>
<h4 id="为什么长对话会失败">为什么长对话会失败</h4>
<pre><code class="hljs mermaid">flowchart TB
    A[&quot;开始: 新对话&lt;br/&gt;上下文清晰&quot;] --&gt; B[&quot;第5轮: 上下文开始积累&lt;br/&gt;仍然高效&quot;]
    B --&gt; C[&quot;第15轮: 上下文大量积累&lt;br/&gt;注意力开始分散&quot;]
    C --&gt; D[&quot;第25轮: Lost in the Middle&lt;br/&gt;Agent 开始遗忘早期信息&quot;]
    D --&gt; E[&quot;第35轮: 上下文污染严重&lt;br/&gt;Agent 可能前后矛盾&quot;]
    E --&gt; F[&quot;第45轮: 接近上下文上限&lt;br/&gt;性能急剧下降&quot;]
    
    style A fill:#c8e6c9
    style B fill:#dcedc8
    style C fill:#fff9c4
    style D fill:#ffe0b2
    style E fill:#ffccbc
    style F fill:#ffcdd2</code></pre>
<p>Agent 的表现与对话长度之间存在一个&quot;中间区域&quot;的性能退化：</p>
<ul>
<li><strong>简单任务</strong>（1-5 轮）：表现优异，上下文清晰</li>
<li><strong>中等任务</strong>（5-15 轮）：表现良好，但需要注意上下文管理</li>
<li><strong>复杂任务</strong>（15+ 轮）：表现开始退化，需要主动干预</li>
<li><strong>超长对话</strong>（30+ 轮）：高风险区域，建议拆分为多次对话</li>
</ul>
<h4 id="任务分解策略">任务分解策略</h4>
<p>面对复杂任务，核心策略是<strong>分解为多个短对话</strong>，每个对话完成一个独立的子任务：</p>
<pre><code class="hljs mermaid">flowchart TB
    A[&quot;复杂任务:&lt;br/&gt;重构订单模块&quot;] --&gt; B[&quot;拆分&quot;]
    
    B --&gt; C[&quot;对话1: 分析现有代码结构&lt;br/&gt;输出: 架构分析文档&quot;]
    B --&gt; D[&quot;对话2: 设计新的领域模型&lt;br/&gt;输入: 架构分析文档&lt;br/&gt;输出: 领域模型定义&quot;]
    B --&gt; E[&quot;对话3: 实现核心实体&lt;br/&gt;输入: 领域模型定义&lt;br/&gt;输出: 实体代码&quot;]
    B --&gt; F[&quot;对话4: 迁移服务层&lt;br/&gt;输入: 实体代码&lt;br/&gt;输出: 服务层代码&quot;]
    B --&gt; G[&quot;对话5: 编写测试&lt;br/&gt;输入: 服务层代码&lt;br/&gt;输出: 测试代码&quot;]
    
    C --&gt; D
    D --&gt; E
    E --&gt; F
    F --&gt; G
    
    style C fill:#e3f2fd
    style D fill:#e3f2fd
    style E fill:#e3f2fd
    style F fill:#e3f2fd
    style G fill:#e3f2fd</code></pre>
<p>每个对话之间的&quot;接力&quot;通过以下方式实现：</p>
<ol>
<li><strong>文件系统</strong>：前一个对话的输出（代码文件）自然成为下一个对话的输入</li>
<li><strong><a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a></strong>：在 <a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a> 中记录当前工作进度和决策</li>
<li><strong>Memory</strong>：利用 Sub Agent 的持久记忆跨对话传递经验</li>
</ol>
<h4 id="何时开始新对话的判断标准">何时开始新对话的判断标准</h4>
<pre><code class="hljs mermaid">flowchart TB
    A&#123;Agent 是否开始&lt;br/&gt;重复之前的搜索?&#125; --&gt;|是| NEW[开始新对话]
    A --&gt;|否| B&#123;Agent 的回复是否&lt;br/&gt;与之前矛盾?&#125;
    B --&gt;|是| NEW
    B --&gt;|否| C&#123;当前任务是否&lt;br/&gt;已经完成一个里程碑?&#125;
    C --&gt;|是| NEW
    C --&gt;|否| D&#123;对话是否已经&lt;br/&gt;超过 15 轮?&#125;
    D --&gt;|是| NEW
    D --&gt;|否| E[继续当前对话]
    
    style NEW fill:#e3f2fd
    style E fill:#c8e6c9</code></pre>
<h3 id="知识沉淀：从会话记忆到持久记忆">知识沉淀：从会话记忆到持久记忆</h3>
<p>Agentic Coding 中最容易被忽视的一个维度是<strong>知识的沉淀与复用</strong>。每次与 Agent 的对话都会产生有价值的知识——项目的隐性约定、踩过的坑、有效的解决方案——但如果这些知识只存在于对话历史中，它们会随着对话的结束而消失。</p>
<h4 id="知识沉淀的三个层次">知识沉淀的三个层次</h4>
<pre><code class="hljs mermaid">flowchart TB
    subgraph 层次1[&quot;第一层: 会话内记忆&quot;]
        A1[&quot;上下文窗口中的信息&quot;]
        A2[&quot;生命周期: 单次对话&quot;]
        A3[&quot;容量: 有限&quot;]
    end
    
    subgraph 层次2[&quot;第二层: 项目级记忆&quot;]
        B1[&quot;CLAUDE.md / Rules&quot;]
        B2[&quot;生命周期: 项目存续期&quot;]
        B3[&quot;容量: 中等(需精炼)&quot;]
    end
    
    subgraph 层次3[&quot;第三层: 持久化记忆&quot;]
        C1[&quot;Sub Agent Memory&quot;]
        C2[&quot;生命周期: 跨项目/跨对话&quot;]
        C3[&quot;容量: 较大(文件系统)&quot;]
    end
    
    层次1 --&gt;|&quot;手动提炼&quot;| 层次2
    层次2 --&gt;|&quot;自动积累&quot;| 层次3
    
    style 层次1 fill:#ffecb3
    style 层次2 fill:#c8e6c9
    style 层次3 fill:#b3e5fc</code></pre>
<h4 id="经验复利效应">经验复利效应</h4>
<p>知识沉淀的真正价值在于<strong>复利效应</strong>。每一次修复、每一次审查、每一次教训都在为未来投资：</p>
<pre><code class="hljs mermaid">flowchart LR
    A[&quot;第1次: 手动告诉 Agent&lt;br/&gt;&#x27;这个项目用 Result 包装返回值&#x27;&quot;] --&gt; B[&quot;沉淀到 CLAUDE.md&quot;]
    B --&gt; C[&quot;第2次: Agent 自动遵循&lt;br/&gt;无需再次提醒&quot;]
    C --&gt; D[&quot;第3次: Agent 在审查中&lt;br/&gt;主动指出不符合规范的代码&quot;]
    D --&gt; E[&quot;第N次: Agent 基于积累的经验&lt;br/&gt;主动提出改进建议&quot;]
    
    style A fill:#ffecb3
    style B fill:#dcedc8
    style C fill:#c8e6c9
    style D fill:#a5d6a7
    style E fill:#81c784</code></pre>
<p>具体的沉淀实践：</p>
<p><strong>1. 及时更新 <a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a></strong></p>
<p>每当发现 Agent 犯了一个&quot;本不该犯&quot;的错误时，问自己：这个信息是否应该写入 <a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a>？</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># CLAUDE.md 中的经验沉淀示例</span><br><br><span class="hljs-section"># 已知陷阱</span><br><span class="hljs-bullet">-</span> 订单状态机不允许从 CANCELLED 回到 PAID，见 OrderStateMachine.java<br><span class="hljs-bullet">-</span> Redis 缓存的 key 前缀必须包含环境标识，如 prod:order:123<br><span class="hljs-bullet">-</span> 不要使用 @Transactional(readOnly=true) 在写操作方法上<br></code></pre></td></tr></table></figure>
<p><strong>2. 利用 Memory 机制</strong></p>
<p>对于 Sub Agent，启用 <code>memory</code> 字段后，Agent 会自动将工作中发现的模式和教训记录到 <code>MEMORY.md</code> 中：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># MEMORY.md (由 code-reviewer Sub Agent 自动维护)</span><br><br><span class="hljs-section">## 发现的模式</span><br><span class="hljs-bullet">-</span> 该项目倾向于使用 Builder 模式构造复杂对象<br><span class="hljs-bullet">-</span> 异常处理统一在 GlobalExceptionHandler 中，不要在 Service 层 catch<br><br><span class="hljs-section">## 踩过的坑</span><br><span class="hljs-bullet">-</span> PR #234: 变量命名不一致导致审查遗漏<br><span class="hljs-bullet">-</span> PR #241: 缺少空指针检查导致生产事故<br></code></pre></td></tr></table></figure>
<p><strong>3. 将经验编码为 Skills</strong></p>
<p>当某类问题反复出现时，将解决方案编码为 Skill：</p>
<pre><code class="hljs mermaid">flowchart TB
    A[&quot;问题反复出现:&lt;br/&gt;&#x27;如何正确处理分布式事务?&#x27;&quot;] --&gt; B[&quot;提炼为 Skill&quot;]
    B --&gt; C[&quot;distributed-transaction Skill&quot;]
    C --&gt; D[&quot;包含:&lt;br/&gt;- 事务模式选择决策树&lt;br/&gt;- Saga 模式实现模板&lt;br/&gt;- 补偿逻辑示例&lt;br/&gt;- 常见陷阱清单&quot;]
    D --&gt; E[&quot;下次遇到类似问题&lt;br/&gt;Agent 自动加载 Skill&quot;]</code></pre>
<h3 id="工程约束：用代码而非文字约束-agent">工程约束：用代码而非文字约束 Agent</h3>
<p>这是一个反直觉但极其重要的原则：<strong>工程约束比 Prompt 指令更可靠</strong>。</p>
<p>Agent 有时会试图走捷径，绕过 Prompt 中设定的规则。与其在 Prompt 中反复强调&quot;不要跳过测试&quot;，不如用工程手段来强制执行。</p>
<h4 id="借助-linters-formatters-和-git-hooks">借助 Linters、Formatters 和 Git Hooks</h4>
<pre><code class="hljs mermaid">flowchart TB
    A[&quot;Agent 尝试提交代码&quot;] --&gt; B[&quot;pre-commit hook 拦截&quot;]
    B --&gt; C&#123;类型检查通过?&#125;
    C --&gt;|否| D[&quot;拒绝提交&lt;br/&gt;Agent 必须修复类型错误&quot;]
    C --&gt;|是| E&#123;Lint 检查通过?&#125;
    E --&gt;|否| F[&quot;拒绝提交&lt;br/&gt;Agent 必须修复 Lint 错误&quot;]
    E --&gt;|是| G&#123;测试通过?&#125;
    G --&gt;|否| H[&quot;拒绝提交&lt;br/&gt;Agent 必须修复测试&quot;]
    G --&gt;|是| I[&quot;允许提交&quot;]
    
    style D fill:#ffcdd2
    style F fill:#ffcdd2
    style H fill:#ffcdd2
    style I fill:#c8e6c9</code></pre>
<p>一个典型的 pre-commit hook：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment"># .git/hooks/pre-commit</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Running type check...&quot;</span><br>npm run typecheck || <span class="hljs-built_in">exit</span> 1<br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Running linter...&quot;</span><br>npm run lint || <span class="hljs-built_in">exit</span> 1<br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Running tests...&quot;</span><br>npm <span class="hljs-built_in">test</span> || <span class="hljs-built_in">exit</span> 1<br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;All checks passed!&quot;</span><br></code></pre></td></tr></table></figure>
<h4 id="拦截-agent-的-偷懒-行为">拦截 Agent 的&quot;偷懒&quot;行为</h4>
<p>Agent 有时会发现测试一直失败后，尝试使用 <code>--no-verify</code> 绕过 pre-commit hook。解决方案是用一个 git 命令 wrapper 脚本拦截这种行为：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">$ git commit --no-verify</span><br><span class="hljs-section">------------------------------------------------------------------</span><br><span class="hljs-section">ERROR: Commit Rejected.</span><br><span class="hljs-section">------------------------------------------------------------------</span><br><br>GUIDANCE FOR THE AI AGENT:<br>You have attempted to bypass the required pre-commit verification.<br>All code must pass quality checks before it can be committed.<br><br><span class="hljs-section">DO NOT BYPASS THE CHECKS. YOU MUST FIX THE UNDERLYING ERRORS.</span><br><span class="hljs-section">------------------------------------------------------------------</span><br></code></pre></td></tr></table></figure>
<p>这个技巧的本质是：<strong>把对 Agent 的指导嵌入到工具的输出中</strong>。Agent 会读取命令执行的结果，所以错误信息本身就是最好的 Prompt 注入点。</p>
<pre><code class="hljs mermaid">flowchart LR
    A[&quot;Prompt 指令:&lt;br/&gt;&#x27;不要跳过测试&#x27;&quot;] --&gt;|&quot;Agent 可能忽略&quot;| B[&quot;效果不稳定&quot;]
    C[&quot;工程约束:&lt;br/&gt;pre-commit hook&quot;] --&gt;|&quot;Agent 无法绕过&quot;| D[&quot;效果稳定&quot;]
    E[&quot;工具输出中的指导:&lt;br/&gt;错误信息包含修复建议&quot;] --&gt;|&quot;Agent 必然读取&quot;| F[&quot;效果最佳&quot;]
    
    style B fill:#ffcdd2
    style D fill:#c8e6c9
    style F fill:#a5d6a7</code></pre>
<h4 id="模式提炼：工程约束优于提示">模式提炼：工程约束优于提示</h4>
<p><strong>模式公式</strong>：<code>可靠性 = 工程强制(hook/lint/CI) &gt; 工具输出引导(错误信息) &gt; Prompt 指令(文字约束)</code></p>
<p><strong>迁移表</strong>：</p>
<table>
<thead>
<tr>
<th>约束需求</th>
<th>Prompt 方式</th>
<th>工程方式</th>
<th>推荐</th>
</tr>
</thead>
<tbody>
<tr>
<td>代码风格</td>
<td>“请遵循 ESLint 规范”</td>
<td><code>.eslintrc</code> + pre-commit hook</td>
<td>工程</td>
</tr>
<tr>
<td>测试覆盖</td>
<td>“请确保测试通过”</td>
<td>CI pipeline + 覆盖率门禁</td>
<td>工程</td>
</tr>
<tr>
<td>提交规范</td>
<td>“请写好 commit message”</td>
<td>commitlint + husky</td>
<td>工程</td>
</tr>
<tr>
<td>安全检查</td>
<td>“请注意 SQL 注入”</td>
<td>SAST 工具 + pre-commit</td>
<td>工程</td>
</tr>
<tr>
<td>架构约束</td>
<td>“请遵循分层架构”</td>
<td>ArchUnit 测试</td>
<td>工程</td>
</tr>
</tbody>
</table>
<p><strong>核心洞察</strong>：当听到&quot;Agent 总是不遵守规范&quot;时，首先应该检查的不是 Prompt 是否写得够清楚，而是是否有工程手段来强制执行。每当 Agent 发明新的&quot;偷懒&quot;方式，就需要堵上这个漏洞——但总体来说，工程约束比 Prompt 指令更可靠。</p>
<h3 id="ai-友好设计：对人难的事-对-ai-也难">AI 友好设计：对人难的事，对 AI 也难</h3>
<p>有一个简单但常被忽视的事实：<strong>如果一个任务对人类开发者来说很难，那么它对当前的 AI 来说大概率也很难。</strong> 这个推论的深远意义在于：所有能提升人类开发者体验的工作，对 AI 同样有价值。</p>
<pre><code class="hljs mermaid">flowchart TB
    A[&quot;对人难的事&lt;br/&gt;对 AI 也难&quot;] --&gt; B[&quot;文档缺失&quot;]
    A --&gt; C[&quot;架构混乱&quot;]
    A --&gt; D[&quot;测试缓慢&quot;]
    A --&gt; E[&quot;错误信息模糊&quot;]
    
    B --&gt; B1[&quot;人: 花大量时间读源码猜意图&lt;br/&gt;AI: 反复搜索, 消耗上下文, 可能理解错误&quot;]
    C --&gt; C1[&quot;人: 不知道该改哪里&lt;br/&gt;AI: 改错文件, 遗漏同步修改&quot;]
    D --&gt; D1[&quot;人: 倾向于跳过测试&lt;br/&gt;AI: 等待超时, 浪费上下文&quot;]
    E --&gt; E1[&quot;人: 需要额外调试&lt;br/&gt;AI: 盲目搜索, 效率低下&quot;]
    
    style A fill:#fff3e0</code></pre>
<h4 id="双重投资回报">双重投资回报</h4>
<p>当投资于更好的文档、更清晰的架构、更快的测试时，获得的回报是双倍的：</p>
<pre><code class="hljs mermaid">flowchart LR
    subgraph 投资
        A[&quot;更好的文档&quot;]
        B[&quot;更清晰的架构&quot;]
        C[&quot;更快的测试&quot;]
        D[&quot;更好的错误信息&quot;]
    end
    
    subgraph 回报
        E[&quot;人类开发者更高效&quot;]
        F[&quot;AI 助手更高效&quot;]
    end
    
    A --&gt; E
    A --&gt; F
    B --&gt; E
    B --&gt; F
    C --&gt; E
    C --&gt; F
    D --&gt; E
    D --&gt; F
    
    style E fill:#c8e6c9
    style F fill:#b3e5fc</code></pre>
<p><strong>更好的文档</strong>：好的文档不仅帮助新人上手，也帮助 AI 快速建立正确的心智模型。架构决策记录（ADR）解释&quot;为什么这样设计&quot;，避免 AI 做出违背设计意图的修改。API 使用示例比纯粹的类型定义更有效。已知陷阱和常见错误直接告诉 AI 什么不该做。</p>
<p><strong>更清晰的代码结构</strong>：清晰的命名（<code>processUserData()</code> 而非 <code>doStuff()</code>）、单一职责（一个做一件事的函数）、显式依赖（依赖注入而非全局变量）——这些对 AI 的帮助和对人类一样大。</p>
<p><strong>更快的反馈循环</strong>：这可能是最容易被低估的一点。Agent Loop 的每一轮都需要等待工具执行完成。秒级的单元测试让 Agent 可以频繁验证、快速迭代；快速的增量构建让改动能立即得到反馈。</p>
<h4 id="专门为-ai-设计的优化">专门为 AI 设计的优化</h4>
<p>反过来的推论并不总是成立：对人来说简单的事，对 AI 未必简单。有时候需要专门为 AI 设计工具和接口。</p>
<p><strong>1. LLM 需要专门的信息架构</strong></p>
<p>LLM 是在现有的 CLI 工具上训练的，但这些工具是为人类设计的。需要为 Agent 增强这些工具，提供对 LLM 更有用的上下文：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在 .zshrc 中添加，帮助 Agent 快速定位</span><br><span class="hljs-function"><span class="hljs-title">command_not_found_handler</span></span>() &#123;<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;zsh: command not found: &#x27;<span class="hljs-variable">$1</span>&#x27;&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;zsh: current directory is <span class="hljs-variable">$PWD</span>&quot;</span><br>    <span class="hljs-built_in">return</span> 127<br>&#125;<br></code></pre></td></tr></table></figure>
<p>很多命令行工具都提供了 <code>--json</code> 或 <code>--porcelain</code> 选项，在给 Agent 使用的工具中优先使用这些格式——人类喜欢格式化的输出，但 AI 更擅长解析结构化数据。</p>
<p><strong>2. API 设计：在信息量和上下文消耗之间取得平衡</strong></p>
<p>为 Agent 设计工具接口时，需要在两个目标之间取得平衡：提供足够的信息（减少工具调用次数）和避免填满上下文（不要返回过多无关信息）。</p>
<p>一个好的实践是：提供便捷函数和底层函数两套 API，并通过工具描述引导 Agent 优先使用便捷函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_global_variable_at</span>(<span class="hljs-params">address: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">dict</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    获取指定地址的全局变量值。自动识别类型并返回最佳字符串表示。</span><br><span class="hljs-string">    这是读取全局变量的首选方法。</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 智能的、高层的实现</span><br>    ...<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">data_read_byte</span>(<span class="hljs-params">address: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    读取指定地址的 1 字节值。</span><br><span class="hljs-string">    仅在 get_global_variable_at 失败时使用此函数。</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 底层的、更通用的实现</span><br>    ...<br></code></pre></td></tr></table></figure>
<p><strong>3. 显式优于隐式</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 有状态的 API: AI 需要跟踪隐含状态变化</span><br>client.connect()<br>client.authenticate(user, password)<br>client.query(<span class="hljs-string">&quot;SELECT * FROM users&quot;</span>)<br><br><span class="hljs-comment"># 无状态的 API: AI 更容易正确使用</span><br>result = db.query(<br>    connection=&#123;<span class="hljs-string">&quot;host&quot;</span>: host, <span class="hljs-string">&quot;port&quot;</span>: port&#125;,<br>    auth=&#123;<span class="hljs-string">&quot;user&quot;</span>: user, <span class="hljs-string">&quot;password&quot;</span>: password&#125;,<br>    sql=<span class="hljs-string">&quot;SELECT * FROM users&quot;</span><br>)<br></code></pre></td></tr></table></figure>
<p><strong>4. 结构化的错误信息</strong></p>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs subunit"># 对人足够，对 AI 可能困惑<br><span class="hljs-keyword">Error: </span>Something went wrong. Please try again later.<br><br># 对 AI 更友好<br><span class="hljs-keyword">Error </span>[AUTH_TOKEN_EXPIRED]: Token expired at 2024<span class="hljs-string">-01</span><span class="hljs-string">-15</span>T10:30:00Z.<br>Call refreshToken() to obtain a new token. See: docs/auth.md#token-refresh<br></code></pre></td></tr></table></figure>
<h4 id="顺应-agent-的统计直觉">顺应 Agent 的统计直觉</h4>
<p>一个更微妙的发现：AI 认为合理的代码结构和命名，可能和人类的直觉不一致。</p>
<p>Agent 的命名&quot;直觉&quot;来自训练数据的统计概率。例如，<code>present()</code> 是 Flutter 等框架中双缓冲交换的常见命名，对于 Agent 来说是&quot;最可能&quot;的名字。当开发者用自己的命名 <code>swapScreens()</code> 覆盖它时，实际上是在对抗 Agent 的统计直觉——Agent 不能再从权重中找到答案，它必须记住人类的特殊习惯。</p>
<pre><code class="hljs mermaid">flowchart TB
    A[&quot;Agent 的统计直觉:&lt;br/&gt;present() 是双缓冲交换的常见命名&quot;] --&gt; B&#123;开发者干预?&#125;
    B --&gt;|&quot;改为 swapScreens()&quot;| C[&quot;Agent 后续反复寻找 present()&lt;br/&gt;找不到后才找到 swapScreens()&lt;br/&gt;浪费 token 和时间&quot;]
    B --&gt;|&quot;保留 present()&quot;| D[&quot;Agent 后续直接找到&lt;br/&gt;高效继续工作&quot;]
    
    style C fill:#ffcdd2
    style D fill:#c8e6c9</code></pre>
<p>实用的权衡策略：</p>
<ol>
<li><strong>不要过度干预</strong>：如果频繁地因为&quot;觉得这个名字更好&quot;而覆盖 Agent 的决策，可能反而在降低效率</li>
<li><strong>注意&quot;找不到&quot;的信号</strong>：如果 Agent 反复在某个地方&quot;找不到&quot;东西，考虑是否是命名和它的预期不一致</li>
<li><strong>拥抱常见模式</strong>：使用广泛使用的设计模式和命名约定，AI 的训练数据中更可能包含这些</li>
<li><strong>模块级的风格隔离</strong>：在 Agent 主导开发的模块中，可以考虑让 Agent 保持它自己的风格</li>
</ol>
<h4 id="模式提炼：统计直觉对齐">模式提炼：统计直觉对齐</h4>
<p><strong>模式公式</strong>：<code>Agent 效率 ∝ 代码库命名与训练数据统计分布的对齐程度</code></p>
<p><strong>迁移表</strong>：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>人类偏好</th>
<th>Agent 统计偏好</th>
<th>推荐策略</th>
</tr>
</thead>
<tbody>
<tr>
<td>函数命名</td>
<td>团队自定义术语</td>
<td>业界通用术语</td>
<td>优先使用通用术语</td>
</tr>
<tr>
<td>设计模式</td>
<td>自创模式</td>
<td>标准 GoF 模式</td>
<td>优先使用标准模式</td>
</tr>
<tr>
<td>文件布局</td>
<td>团队约定</td>
<td>框架默认布局</td>
<td>在 <a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a> 中明确说明</td>
</tr>
<tr>
<td>错误处理</td>
<td>自定义异常体系</td>
<td>标准异常体系</td>
<td>在 Skills 中提供映射</td>
</tr>
</tbody>
</table>
<p><strong>核心洞察</strong>：当听到&quot;Agent 总是用错误的方式做事&quot;时，考虑是否是项目的约定与 Agent 的统计直觉不一致。解决方案不是反复纠正 Agent，而是要么对齐约定，要么在 <a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a> 中显式说明。</p>
<h3 id="刻意练习：像学乐器一样学习-ai">刻意练习：像学乐器一样学习 AI</h3>
<p>为什么有些人说&quot;AI 对我不起作用&quot;，而另一些人却能用 AI 完成大量的工作？</p>
<p>这个问题需要区分来看。如果只在公司的大型私有代码库中使用过 AI，体验可能确实不好——那些代码库可能有古老的架构和专有模式，AI 的训练数据中根本没有这些。但关键问题是：有没有在个人项目中尝试过 AI？有没有进行刻意的、有意识的练习？</p>
<pre><code class="hljs mermaid">flowchart TB
    A[&quot;刻意练习的五个维度&quot;] --&gt; B[&quot;创造干净的实验环境&quot;]
    A --&gt; C[&quot;从失败中提取教训&quot;]
    A --&gt; D[&quot;观察和模仿高手&quot;]
    A --&gt; E[&quot;建立肌肉记忆&quot;]
    A --&gt; F[&quot;持续投入时间&quot;]
    
    B --&gt; B1[&quot;启动个人项目&lt;br/&gt;没有历史包袱&quot;]
    C --&gt; C1[&quot;Prompt 是否清晰?&lt;br/&gt;上下文是否充分?&lt;br/&gt;任务是否过大?&quot;]
    D --&gt; D1[&quot;关注公开分享工作流的开发者&lt;br/&gt;复制他们的技巧&quot;]
    E --&gt; E1[&quot;何时开始新对话?&lt;br/&gt;如何组织复杂 Prompt?&lt;br/&gt;哪种工具组合最有效?&quot;]
    F --&gt; F1[&quot;每天 30 分钟&lt;br/&gt;坚持几个月&lt;br/&gt;远超每周一次几小时&quot;]</code></pre>
<p>AI 工具就像一件乐器。那些从 AI 中获益最多的人，都投入了刻意练习。他们不会因为一次失败就下结论说&quot;它不行&quot;，然后假设这将是常态体验。他们会实验、会失败、会从失败中学习。</p>
<p><strong>从失败中提取教训的检查清单</strong>：</p>
<ul>
<li>Prompt 是否足够清晰？</li>
<li>是否提供了足够的上下文？</li>
<li>是否在一个对话里塞了太多任务？</li>
<li>这个错误是否揭示了 AI 的某个系统性弱点？</li>
<li>是否应该将这个教训沉淀到 <a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a> 或 Skills 中？</li>
</ul>
<p>每次失败都是一次学习机会。把它记录下来，下次避免同样的陷阱。</p>
<hr>
<h2 id="本质洞察：从-编写程序-到-编写职位描述">本质洞察：从&quot;编写程序&quot;到&quot;编写职位描述&quot;</h2>
<p>回到最初的问题：为什么一份 Markdown 就能定义一个智能体？</p>
<p>因为 LLM 改变了&quot;智能&quot;的供给方式。在传统范式下，智能需要被<strong>编程</strong>——用代码一行一行地告诉计算机如何思考。在 LLM 范式下，智能是<strong>预训练好的</strong>——模型已经具备了通用的推理、规划和执行能力，只需要用自然语言告诉它&quot;你是谁、该做什么、不该做什么&quot;。</p>
<pre><code class="hljs mermaid">flowchart LR
    subgraph 传统范式
        A1[&quot;开发者&lt;br/&gt;(编程能力)&quot;] --&gt; A2[&quot;编写代码&lt;br/&gt;(编译部署)&quot;] --&gt; A3[&quot;Agent&lt;br/&gt;(运行)&quot;]
    end
    
    subgraph LLM范式
        B1[&quot;任何人&lt;br/&gt;(表达能力)&quot;] --&gt; B2[&quot;编写文档&lt;br/&gt;(.md 文件)&quot;] --&gt; B3[&quot;Agent&lt;br/&gt;(即时生效)&quot;]
    end
    
    style A1 fill:#e8eaf6
    style B1 fill:#e8f5e9</code></pre>
<table>
<thead>
<tr>
<th>维度</th>
<th>传统范式</th>
<th>LLM 范式</th>
</tr>
</thead>
<tbody>
<tr>
<td>创建者</td>
<td>程序员</td>
<td>任何能清晰表达的人</td>
</tr>
<tr>
<td>载体</td>
<td>代码</td>
<td>文档</td>
</tr>
<tr>
<td>生效方式</td>
<td>编译部署</td>
<td>保存即生效</td>
</tr>
<tr>
<td>迭代速度</td>
<td>天级别</td>
<td>秒级别</td>
</tr>
<tr>
<td>门槛</td>
<td>会编程 + 会部署</td>
<td>会写文档</td>
</tr>
</tbody>
</table>
<p>这就是为什么定义一个 Agent 的过程，从&quot;编写程序&quot;变成了&quot;编写职位描述&quot;。而 Markdown，恰好是编写职位描述的最佳格式。</p>
<p>但这并不意味着&quot;随便写写就行&quot;。正如一份好的职位描述需要精确地定义岗位职责、能力要求、工作流程和权限边界，一份好的 Agent 定义也需要精心设计：</p>
<ul>
<li><strong>关注点分离</strong>：<a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a> 管环境、Commands 管触发、Skills 管知识、Sub Agents 管执行</li>
<li><strong>最小权限原则</strong>：Sub Agent 的 <code>tools</code> 白名单和 Hook 机制确保每个 Agent 只能做它该做的事</li>
<li><strong>上下文隔离</strong>：Sub Agent 的独立上下文窗口防止信息泄漏和上下文污染</li>
<li><strong>渐进式复杂度</strong>：从简单的 <a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a> 到复杂的带 Hook 的 Sub Agent，根据需要选择合适的抽象层级</li>
</ul>
<hr>
<h2 id="模式速查表">模式速查表</h2>
<table>
<thead>
<tr>
<th>听到的需求关键词</th>
<th>对应模式</th>
<th>方案</th>
<th>口诀</th>
</tr>
</thead>
<tbody>
<tr>
<td>“AI 给了错误答案”</td>
<td>概率性推理</td>
<td>检查上下文是否充分，补充 <a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a></td>
<td>垃圾进垃圾出</td>
</tr>
<tr>
<td>“Agent 做了很多无用功”</td>
<td>感知-行动循环</td>
<td>用 Commands/Skills 减少摸索轮次</td>
<td>预定义工作流</td>
</tr>
<tr>
<td>“长对话中 Agent 越来越差”</td>
<td>上下文即工作记忆</td>
<td>拆分为多个短对话，使用 Sub Agent</td>
<td>短对话优于长对话</td>
</tr>
<tr>
<td>“Agent 不遵循项目规范”</td>
<td>分层配置</td>
<td>将规范写入 <a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a> 或 Skills</td>
<td>信息在正确时机出现</td>
</tr>
<tr>
<td>“每次都要重复告诉 Agent”</td>
<td>知识外化</td>
<td>沉淀到 <a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a> / Memory / Skills</td>
<td>写一次用无数次</td>
</tr>
<tr>
<td>“改了文档/架构后 Agent 更好用了”</td>
<td>双重投资回报</td>
<td>持续投资开发者体验</td>
<td>帮人也帮 AI</td>
</tr>
<tr>
<td>“Agent 总是跳过测试”</td>
<td>工程约束优于提示</td>
<td>用 Git Hooks / CI 强制执行</td>
<td>代码约束不可绕过</td>
</tr>
<tr>
<td>“Agent 总是用错误的命名”</td>
<td>统计直觉对齐</td>
<td>使用通用命名，或在 <a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a> 中说明</td>
<td>顺应而非对抗</td>
</tr>
</tbody>
</table>
<pre><code class="hljs mermaid">flowchart TB
    subgraph 模式组合示例
        A[&quot;大型项目重构&quot;] --&gt; B[&quot;分层配置&lt;br/&gt;+ 上下文隔离&lt;br/&gt;+ 知识外化&quot;]
        C[&quot;日常功能开发&quot;] --&gt; D[&quot;感知-行动循环&lt;br/&gt;+ 分层配置&lt;br/&gt;+ 双重投资回报&quot;]
        E[&quot;代码质量治理&quot;] --&gt; F[&quot;工程约束优于提示&lt;br/&gt;+ 统计直觉对齐&lt;br/&gt;+ 知识外化&quot;]
    end</code></pre>
<hr>
<h2 id="总结">总结</h2>
<p>AI 正在以惊人的速度发展。本文讨论的许多&quot;限制&quot;——上下文窗口的约束、会话间的失忆、中间区域的性能退化——很可能在未来几年内被大幅改善。但这并不意味着应该等待那一天的到来。</p>
<p>恰恰相反，正是这个充满限制的阶段，给了工程师极大的探索和成长空间。那些现在就开始深入理解 LLM 工作原理、积极实践最佳方法、在限制中寻找创造性解决方案的人，将在 AI 能力进一步释放时获得最大的杠杆效应。</p>
<p>从第一性原理理解 LLM 的本质，理解它们如何&quot;思考&quot;、如何受到上下文的限制、如何在 Agent Loop 中发挥作用——这些知识不会随着具体工具的迭代而过时。无论使用的是哪个 Coding Agent，无论模型如何更新换代，这些基础原理都将帮助更好地与 AI 协作。</p>
<p>而 Markdown 配置体系的分层设计——<a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a> 管环境、Commands 管触发、Skills 管知识、Sub Agents 管执行——这种关注点分离的思想，同样具有跨平台、跨时代的迁移价值。</p>
<p>这个范式转换带来的深远影响是：<strong>Agent 的创建门槛从&quot;会编程&quot;降低到了&quot;会写文档&quot;。</strong> 任何能清晰描述一个工作流程的人——产品经理、项目经理、领域专家——都有能力定义一个专业的 AI 智能体。而对于程序员来说，理解这套 Markdown 配置体系的分层设计，就像理解 DDD 的战略设计一样重要——它决定了能否有效地组织和管理一个由多个 AI Agent 协作的复杂工作流。</p>
<p>去实验，去失败，去学习。像学习乐器一样学习 AI。这个过程本身，就是价值所在。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://magicliang.github.io">magicliang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://magicliang.github.io/2026/02/09/%E5%BD%93%E6%99%BA%E8%83%BD%E4%BD%93%E5%8F%98%E6%88%90%E4%B8%80%E4%BB%BD-Markdown-%E6%96%87%E6%A1%A3/">https://magicliang.github.io/2026/02/09/%E5%BD%93%E6%99%BA%E8%83%BD%E4%BD%93%E5%8F%98%E6%88%90%E4%B8%80%E4%BB%BD-Markdown-%E6%96%87%E6%A1%A3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/AI/">AI</a><a class="post-meta__tags" href="/tags/Agent/">Agent</a><a class="post-meta__tags" href="/tags/LLM/">LLM</a><a class="post-meta__tags" href="/tags/Agentic-Coding/">Agentic Coding</a><a class="post-meta__tags" href="/tags/Claude-Code/">Claude Code</a><a class="post-meta__tags" href="/tags/Prompt-Engineering/">Prompt Engineering</a></div><div class="post-share"><div class="social-share" data-image="/img/wall-paper-141.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2018/02/20/%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" title="推荐算法笔记"><img class="cover" src="/img/wall-paper-167.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-02-20</div><div class="info-item-2">推荐算法笔记</div></div><div class="info-2"><div class="info-item-1">分类的话： 用户画像算法 用户画像算法、聚类算法 分类算法： gbtd、随机森林 识别完了看哪个变量更重要。要有可解释性。 价格相关数据：体现在什么方面？一定要跟收入密切相关的。要对数据和业务的理解很重要。 分类项目：部分已知，有一部分训练集，用未知的和已知的做一个比较。打标签。寻找标签里最重要的因素。 gbtd（底层是很多决策树）。svm。dnn。可能解释性那么强。 决策树。xgbox。 输出是：分类的概率。 聚类项目：完全未知，从数据本身来发现特征。k-means。层次聚类。 输出是：不同类别的特征。 要理解商业逻辑。 </div></div></div></a><a class="pagination-related" href="/2024/11/01/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%9B%B8%E5%85%B3/" title="大模型相关"><img class="cover" src="/2024/11/01/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%9B%B8%E5%85%B3/%E5%A4%A7%E6%A8%A1%E5%9E%8B.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-01</div><div class="info-item-2">大模型相关</div></div><div class="info-2"><div class="info-item-1">世界线  大模型发展.xmind   RNN的雏形可以追溯到90年代Jeffrey L.Elman的经典文章：Finding Structure in Time（1990） 2013年Google提出的Word2Vec可能是最为人熟知的Embedding技术之一 Encoder-Decoder架构来自论文：Learning Phrase Representations using RNN Encoder-Decoder for Statistical Machine Translation（2014） 注意力机制参考论文：Neural Machine Translation by Jointly Learning to Align and Translate（2014） LLM的技术发展和相互关系：Harnessing the Power of LLMs in Practice: A Survey on ChatGPT and Beyond（2023） Transformer出自一篇经典论文：Attention Is All You Need（2017） 国外模型的对比可以参考大...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">当智能体变成一份 Markdown 文档</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E6%99%AF%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE"><span class="toc-number">1.1.</span> <span class="toc-text">全景思维导图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%80%BB%E8%A7%88"><span class="toc-number">1.2.</span> <span class="toc-text">模式总览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%80%A7%E5%8E%9F%E7%90%86%EF%BC%9A%E7%90%86%E8%A7%A3-agentic-coding-%E7%9A%84%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91"><span class="toc-number">1.3.</span> <span class="toc-text">第一性原理：理解 Agentic Coding 的底层逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#llm-%E7%9A%84%E6%9C%AC%E8%B4%A8%EF%BC%9A%E6%A6%82%E7%8E%87%E6%80%A7%E6%96%87%E6%9C%AC%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-number">1.3.1.</span> <span class="toc-text">LLM 的本质：概率性文本生成器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%8F%90%E7%82%BC%EF%BC%9A%E6%A6%82%E7%8E%87%E6%80%A7%E6%8E%A8%E7%90%86"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">模式提炼：概率性推理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#agent-loop%EF%BC%9A%E6%84%9F%E7%9F%A5-%E6%8E%A8%E7%90%86-%E8%A1%8C%E5%8A%A8%E7%9A%84%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.3.2.</span> <span class="toc-text">Agent Loop：感知-推理-行动的循环</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%8F%90%E7%82%BC%EF%BC%9A%E6%84%9F%E7%9F%A5-%E8%A1%8C%E5%8A%A8%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">模式提炼：感知-行动循环</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AA%97%E5%8F%A3%EF%BC%9Aagent-%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BF%86"><span class="toc-number">1.3.3.</span> <span class="toc-text">上下文窗口：Agent 的工作记忆</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AA%97%E5%8F%A3%E7%9A%84%E4%B8%89%E4%B8%AA%E5%85%B3%E9%94%AE%E7%89%B9%E6%80%A7"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">上下文窗口的三个关键特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E7%9A%84%E6%A0%B8%E5%BF%83%E7%AD%96%E7%95%A5"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">上下文管理的核心策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%8F%90%E7%82%BC%EF%BC%9A%E4%B8%8A%E4%B8%8B%E6%96%87%E5%8D%B3%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BF%86"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">模式提炼：上下文即工作记忆</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#markdown-%E9%85%8D%E7%BD%AE%E4%BD%93%E7%B3%BB%EF%BC%9A%E7%94%A8%E6%96%87%E6%A1%A3%E5%AE%9A%E4%B9%89%E6%99%BA%E8%83%BD%E4%BD%93"><span class="toc-number">1.4.</span> <span class="toc-text">Markdown 配置体系：用文档定义智能体</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#claude-md%EF%BC%9A%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BF%86%E4%B8%8E%E8%A1%8C%E4%B8%BA%E7%BA%A6%E6%9D%9F"><span class="toc-number">1.4.1.</span> <span class="toc-text">CLAUDE.md：项目记忆与行为约束</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B1%82%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">分层加载机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#claude-md-%E7%9A%84%E5%86%85%E5%AE%B9%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">CLAUDE.md 的内容结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E7%AC%AC%E4%B8%80%E6%80%A7%E5%8E%9F%E7%90%86%E7%90%86%E8%A7%A3-claude-md-%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">从第一性原理理解 CLAUDE.md 的设计</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#commands%EF%BC%9A%E5%8F%82%E6%95%B0%E5%8C%96%E7%9A%84%E6%8F%90%E7%A4%BA%E8%AF%8D%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.4.2.</span> <span class="toc-text">Commands：参数化的提示词模板</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#command-%E7%9A%84%E5%AE%9A%E4%B9%89%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">Command 的定义结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#command-%E4%B8%8E%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">Command 与上下文的关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#skills%EF%BC%9A%E5%8F%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E7%9F%A5%E8%AF%86%E5%8C%85"><span class="toc-number">1.4.3.</span> <span class="toc-text">Skills：可复用的知识包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#skill-%E7%9A%84%E5%AE%8C%E6%95%B4%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">Skill 的完整结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#skill-%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">Skill 的加载机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#skills-%E4%B8%8E-claude-md-%E7%9A%84%E5%88%86%E5%B7%A5"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">Skills 与 CLAUDE.md 的分工</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sub-agents%EF%BC%9A%E7%8B%AC%E7%AB%8B%E6%89%A7%E8%A1%8C%E7%9A%84%E4%B8%93%E4%B8%9A%E8%A7%92%E8%89%B2"><span class="toc-number">1.4.4.</span> <span class="toc-text">Sub Agents：独立执行的专业角色</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sub-agent-%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">Sub Agent 的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sub-agent-%E7%9A%84%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">Sub Agent 的高级特性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E7%A7%8D%E6%9C%BA%E5%88%B6%E7%9A%84-mece-%E5%AF%B9%E6%AF%94"><span class="toc-number">1.4.5.</span> <span class="toc-text">四种机制的 MECE 对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E7%A7%8D%E6%9C%BA%E5%88%B6%E7%9A%84%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C"><span class="toc-number">1.4.6.</span> <span class="toc-text">四种机制的协同工作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E5%B9%BF%E6%B3%9B%E7%9A%84%E8%A7%86%E8%A7%92%EF%BC%9Arules-%E5%92%8C-specs"><span class="toc-number">1.4.7.</span> <span class="toc-text">更广泛的视角：Rules 和 Specs</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#rules%EF%BC%9Aclaude-md-%E7%9A%84%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%AD%89%E4%BB%B7%E7%89%A9"><span class="toc-number">1.4.7.1.</span> <span class="toc-text">Rules：CLAUDE.md 的跨平台等价物</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#specs%EF%BC%9A%E9%9D%A2%E5%90%91%E4%BB%BB%E5%8A%A1%E7%9A%84%E9%9C%80%E6%B1%82%E6%96%87%E6%A1%A3"><span class="toc-number">1.4.7.2.</span> <span class="toc-text">Specs：面向任务的需求文档</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%8F%90%E7%82%BC%EF%BC%9A%E5%88%86%E5%B1%82%E9%85%8D%E7%BD%AE"><span class="toc-number">1.4.7.3.</span> <span class="toc-text">模式提炼：分层配置</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E6%93%8D%E6%96%B9%E6%B3%95%E8%AE%BA%EF%BC%9A%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E8%B7%B5"><span class="toc-number">1.5.</span> <span class="toc-text">实操方法论：从原理到实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%AF%9D%E7%AE%A1%E7%90%86%EF%BC%9A%E7%9F%AD%E5%AF%B9%E8%AF%9D%E4%BC%98%E4%BA%8E%E9%95%BF%E5%AF%B9%E8%AF%9D"><span class="toc-number">1.5.1.</span> <span class="toc-text">对话管理：短对话优于长对话</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%95%BF%E5%AF%B9%E8%AF%9D%E4%BC%9A%E5%A4%B1%E8%B4%A5"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">为什么长对话会失败</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E5%88%86%E8%A7%A3%E7%AD%96%E7%95%A5"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">任务分解策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%95%E6%97%B6%E5%BC%80%E5%A7%8B%E6%96%B0%E5%AF%B9%E8%AF%9D%E7%9A%84%E5%88%A4%E6%96%AD%E6%A0%87%E5%87%86"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">何时开始新对话的判断标准</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E6%B2%89%E6%B7%80%EF%BC%9A%E4%BB%8E%E4%BC%9A%E8%AF%9D%E8%AE%B0%E5%BF%86%E5%88%B0%E6%8C%81%E4%B9%85%E8%AE%B0%E5%BF%86"><span class="toc-number">1.5.2.</span> <span class="toc-text">知识沉淀：从会话记忆到持久记忆</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E6%B2%89%E6%B7%80%E7%9A%84%E4%B8%89%E4%B8%AA%E5%B1%82%E6%AC%A1"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">知识沉淀的三个层次</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%8F%E9%AA%8C%E5%A4%8D%E5%88%A9%E6%95%88%E5%BA%94"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">经验复利效应</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E7%A8%8B%E7%BA%A6%E6%9D%9F%EF%BC%9A%E7%94%A8%E4%BB%A3%E7%A0%81%E8%80%8C%E9%9D%9E%E6%96%87%E5%AD%97%E7%BA%A6%E6%9D%9F-agent"><span class="toc-number">1.5.3.</span> <span class="toc-text">工程约束：用代码而非文字约束 Agent</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%80%9F%E5%8A%A9-linters-formatters-%E5%92%8C-git-hooks"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">借助 Linters、Formatters 和 Git Hooks</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%A6%E6%88%AA-agent-%E7%9A%84-%E5%81%B7%E6%87%92-%E8%A1%8C%E4%B8%BA"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">拦截 Agent 的&quot;偷懒&quot;行为</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%8F%90%E7%82%BC%EF%BC%9A%E5%B7%A5%E7%A8%8B%E7%BA%A6%E6%9D%9F%E4%BC%98%E4%BA%8E%E6%8F%90%E7%A4%BA"><span class="toc-number">1.5.3.3.</span> <span class="toc-text">模式提炼：工程约束优于提示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ai-%E5%8F%8B%E5%A5%BD%E8%AE%BE%E8%AE%A1%EF%BC%9A%E5%AF%B9%E4%BA%BA%E9%9A%BE%E7%9A%84%E4%BA%8B-%E5%AF%B9-ai-%E4%B9%9F%E9%9A%BE"><span class="toc-number">1.5.4.</span> <span class="toc-text">AI 友好设计：对人难的事，对 AI 也难</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E9%87%8D%E6%8A%95%E8%B5%84%E5%9B%9E%E6%8A%A5"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">双重投资回报</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%93%E9%97%A8%E4%B8%BA-ai-%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">1.5.4.2.</span> <span class="toc-text">专门为 AI 设计的优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%94-agent-%E7%9A%84%E7%BB%9F%E8%AE%A1%E7%9B%B4%E8%A7%89"><span class="toc-number">1.5.4.3.</span> <span class="toc-text">顺应 Agent 的统计直觉</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%8F%90%E7%82%BC%EF%BC%9A%E7%BB%9F%E8%AE%A1%E7%9B%B4%E8%A7%89%E5%AF%B9%E9%BD%90"><span class="toc-number">1.5.4.4.</span> <span class="toc-text">模式提炼：统计直觉对齐</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%BB%E6%84%8F%E7%BB%83%E4%B9%A0%EF%BC%9A%E5%83%8F%E5%AD%A6%E4%B9%90%E5%99%A8%E4%B8%80%E6%A0%B7%E5%AD%A6%E4%B9%A0-ai"><span class="toc-number">1.5.5.</span> <span class="toc-text">刻意练习：像学乐器一样学习 AI</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E8%B4%A8%E6%B4%9E%E5%AF%9F%EF%BC%9A%E4%BB%8E-%E7%BC%96%E5%86%99%E7%A8%8B%E5%BA%8F-%E5%88%B0-%E7%BC%96%E5%86%99%E8%81%8C%E4%BD%8D%E6%8F%8F%E8%BF%B0"><span class="toc-number">1.6.</span> <span class="toc-text">本质洞察：从&quot;编写程序&quot;到&quot;编写职位描述&quot;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E9%80%9F%E6%9F%A5%E8%A1%A8"><span class="toc-number">1.7.</span> <span class="toc-text">模式速查表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.8.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2017 - 2026 By magicliang</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional and Simplified Chinese">簡</button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><script src="/js/tw_cn.js?v=5.5.2"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="/"></script></div></body></html>