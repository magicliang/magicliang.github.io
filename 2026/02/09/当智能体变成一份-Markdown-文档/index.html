<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>当智能体变成一份 Markdown 文档 | 守株阁</title><meta name="author" content="magicliang"><meta name="copyright" content="magicliang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="当智能体变成一份 Markdown 文档 在传统的软件工程中，构建一个&quot;智能体&quot;（Agent）意味着编写大量代码：状态机、决策树、API 集成、错误处理、权限管理。而在 LLM（Large Language Model，大语言模型）时代，定义一个功能完备的 AI 智能体，可能只需要一份结构良好的 Markdown 文档。 这不是夸张。以 Claude Code 的配置体系为例，">
<meta property="og:type" content="article">
<meta property="og:title" content="当智能体变成一份 Markdown 文档">
<meta property="og:url" content="https://magicliang.github.io/2026/02/09/%E5%BD%93%E6%99%BA%E8%83%BD%E4%BD%93%E5%8F%98%E6%88%90%E4%B8%80%E4%BB%BD-Markdown-%E6%96%87%E6%A1%A3/index.html">
<meta property="og:site_name" content="守株阁">
<meta property="og:description" content="当智能体变成一份 Markdown 文档 在传统的软件工程中，构建一个&quot;智能体&quot;（Agent）意味着编写大量代码：状态机、决策树、API 集成、错误处理、权限管理。而在 LLM（Large Language Model，大语言模型）时代，定义一个功能完备的 AI 智能体，可能只需要一份结构良好的 Markdown 文档。 这不是夸张。以 Claude Code 的配置体系为例，">
<meta property="og:locale">
<meta property="og:image" content="https://magicliang.github.io/img/wall-paper-106.jpg">
<meta property="article:published_time" content="2026-02-09T08:00:00.000Z">
<meta property="article:modified_time" content="2026-02-12T06:22:21.484Z">
<meta property="article:author" content="magicliang">
<meta property="article:tag" content="AI">
<meta property="article:tag" content="Agent">
<meta property="article:tag" content="Agentic Coding">
<meta property="article:tag" content="Claude Code">
<meta property="article:tag" content="LLM">
<meta property="article:tag" content="Prompt Engineering">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://magicliang.github.io/img/wall-paper-106.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "当智能体变成一份 Markdown 文档",
  "url": "https://magicliang.github.io/2026/02/09/%E5%BD%93%E6%99%BA%E8%83%BD%E4%BD%93%E5%8F%98%E6%88%90%E4%B8%80%E4%BB%BD-Markdown-%E6%96%87%E6%A1%A3/",
  "image": "https://magicliang.github.io/img/wall-paper-106.jpg",
  "datePublished": "2026-02-09T08:00:00.000Z",
  "dateModified": "2026-02-12T06:22:21.484Z",
  "author": [
    {
      "@type": "Person",
      "name": "magicliang",
      "url": "https://magicliang.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://magicliang.github.io/2026/02/09/%E5%BD%93%E6%99%BA%E8%83%BD%E4%BD%93%E5%8F%98%E6%88%90%E4%B8%80%E4%BB%BD-Markdown-%E6%96%87%E6%A1%A3/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: magicliang","link":"Link: ","source":"Source: 守株阁","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '当智能体变成一份 Markdown 文档',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"><link rel="alternate" href="/atom.xml" title="守株阁" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      if ($loadingBox.classList.contains('loaded')) return
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()

  if (document.readyState === 'complete') {
    preloader.endLoading()
  } else {
    window.addEventListener('load', preloader.endLoading)
    document.addEventListener('DOMContentLoaded', preloader.endLoading)
    // Add timeout protection: force end after 7 seconds
    setTimeout(preloader.endLoading, 7000)
  }

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/wall-paper-106.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">守株阁</span></a><a class="nav-page-title" href="/"><span class="site-name">当智能体变成一份 Markdown 文档</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">当智能体变成一份 Markdown 文档</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2026-02-09T08:00:00.000Z" title="Created 2026-02-09 16:00:00">2026-02-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2026-02-12T06:22:21.484Z" title="Updated 2026-02-12 14:22:21">2026-02-12</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">28.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>103mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1>当智能体变成一份 Markdown 文档</h1>
<p>在传统的软件工程中，构建一个&quot;智能体&quot;（Agent）意味着编写大量代码：状态机、决策树、API 集成、错误处理、权限管理。而在 LLM（Large Language Model，大语言模型）时代，定义一个功能完备的 AI 智能体，可能只需要一份结构良好的 Markdown 文档。</p>
<p>这不是夸张。以 Claude Code 的配置体系为例，一个 <code>.md</code> 文件可以定义 Agent 的身份、行为约束、工具权限、专业知识、工作流程，甚至跨会话的持久记忆（Persistent Memory）。但要真正理解&quot;为什么 Markdown 就够了&quot;，以及&quot;如何写出高效的 Agent 定义&quot;，需要先回到第一性原理——理解 LLM 的本质、Agent 的运行机制，以及上下文窗口（Context Window）的物理约束。</p>
<p>本文将从底层原理出发，逐层构建对 Agentic Coding 的完整认知：先理解 LLM 是什么、Agent Loop 如何运转、上下文窗口为何是核心瓶颈；再拆解 Markdown 配置体系的四层架构；最后落地到实操方法论——如何管理对话、沉淀知识、用工程手段约束 Agent、为 AI 设计友好的工作环境。</p>
<h2 id="全景思维导图">全景思维导图</h2>
<pre><code class="hljs mermaid">mindmap
  root((Agentic Coding 全景))
    第一性原理
      LLM 本质
        概率性文本生成器（Probabilistic Text Generator）
        非确定性推理引擎（Non-deterministic Reasoning Engine）
        Token 预测机制（Token Prediction Mechanism）
      Agent Loop
        感知-推理-行动循环（Perceive-Reason-Act Loop）
        LLM + 工具 + 循环 = Agent
        ReAct 决策模式（Reasoning + Acting）
        工具选择与规划（Tool Selection &amp; Planning）
        失败模式与应对（Failure Modes &amp; Mitigation）
      上下文窗口
        工作记忆（Working Memory）的物理约束
        注意力退化曲线（Attention Degradation Curve）
        Lost in the Middle 效应
    Markdown 配置体系
      三层提示机制
        L1 System Prompt 行为宪法
        L2 项目配置 CLAUDE.md
        L3 用户输入 任务指令
      CLAUDE.md
        项目记忆
        行为约束
        分层加载
      Commands
        参数化提示词模板
        斜杠触发
        变量插值
      Skills
        可复用知识包
        领域专业知识
        工作流定义
      Sub Agents
        独立上下文窗口
        工具权限隔离
        持久化记忆
      MCP 协议
        标准化工具调用
        运行时能力发现
        传输层解耦
    实操方法论
      对话管理
        短对话优于长对话
        任务分解策略
        上下文隔离
      知识沉淀
        从会话到持久记忆
        Rules 与 Memory
        经验复利效应
      工程约束
        Linter 与 Git Hooks
        拦截偷懒行为
        工程手段优于 Prompt 指令
      AI 友好设计
        信息架构优化
        API 设计平衡
        命名与统计直觉
      刻意练习
        像学乐器一样学 AI
        从失败中提取教训
        建立肌肉记忆</code></pre>
<h2 id="模式总览">模式总览</h2>
<p>本文覆盖的核心可迁移模式：</p>
<table>
<thead>
<tr>
<th>#</th>
<th>模式名称</th>
<th>一句话口诀</th>
<th>覆盖场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>概率性推理</td>
<td>LLM 是统计直觉而非逻辑推理</td>
<td>理解 Agent 行为的不确定性、命名偏好、错误模式</td>
</tr>
<tr>
<td>2</td>
<td>感知-行动循环</td>
<td>LLM + 工具 + 循环 = Agent</td>
<td>Agent Loop 的运行机制、工具调用、自主决策</td>
</tr>
<tr>
<td>2.5</td>
<td>Agent 决策机制</td>
<td>ReAct + 工具匹配 + 完成判断</td>
<td>决策过程、工具选择、规划能力、失败模式</td>
</tr>
<tr>
<td>3</td>
<td>上下文即工作记忆</td>
<td>有限窗口决定一切策略</td>
<td>对话管理、任务分解、信息密度优化</td>
</tr>
<tr>
<td>4</td>
<td>分层配置</td>
<td>环境-触发-知识-执行四层分离</td>
<td><a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a> / Commands / Skills / Sub Agents</td>
</tr>
<tr>
<td>5</td>
<td>知识外化</td>
<td>把脑中隐性知识变成文档</td>
<td>Rules、Memory、经验复利</td>
</tr>
<tr>
<td>6</td>
<td>双重投资回报</td>
<td>对人好的改进对 AI 同样有效</td>
<td>文档、架构、测试速度的双重价值</td>
</tr>
<tr>
<td>7</td>
<td>工程约束优于提示</td>
<td>用代码而非文字约束 Agent</td>
<td>Git Hooks、Linter、命令拦截</td>
</tr>
<tr>
<td>8</td>
<td>统计直觉对齐</td>
<td>顺应而非对抗 Agent 的命名偏好</td>
<td>AI 友好的命名、API 设计、信息架构</td>
</tr>
</tbody>
</table>
<pre><code class="hljs mermaid">flowchart LR
    subgraph 原理层
        P1[概率性推理]
        P2[感知-行动循环]
        P3[上下文即工作记忆]
    end
    subgraph 配置层
        P4[分层配置]
        P5[知识外化]
    end
    subgraph 实践层
        P6[双重投资回报]
        P7[工程约束优于提示]
        P8[统计直觉对齐]
    end
    P1 --&gt; P2
    P2 --&gt; P3
    P3 --&gt; P4
    P3 --&gt; P5
    P4 --&gt; P6
    P5 --&gt; P6
    P4 --&gt; P7
    P1 --&gt; P8
    P6 --&gt; P7
    P7 --&gt; P8</code></pre>
<hr>
<h2 id="第一性原理：理解-agentic-coding-的底层逻辑">第一性原理：理解 Agentic Coding 的底层逻辑</h2>
<p>在讨论如何用 Markdown 定义 Agent 之前，需要先回答三个基础问题：LLM 到底是什么？Agent 如何运转？上下文窗口意味着什么？这三个问题的答案，决定了所有上层策略的设计逻辑。</p>
<pre><code class="hljs mermaid">flowchart TB
    subgraph 第一性原理
        A[LLM 的本质] --&gt; B[Agent Loop 的运行机制]
        B --&gt; C[上下文窗口的物理约束]
    end
    C --&gt; D[为什么 Markdown 就够了]
    C --&gt; E[为什么需要分层配置]
    C --&gt; F[为什么短对话优于长对话]
    style A fill:#e1f5fe
    style B fill:#e1f5fe
    style C fill:#e1f5fe</code></pre>
<h3 id="llm-的本质：概率性文本生成器">LLM 的本质：概率性文本生成器</h3>
<p>理解 Agentic Coding 的第一步，是准确理解 LLM 的本质。LLM 不是数据库，不是搜索引擎，也不是确定性的推理引擎。它是一个<strong>概率性的文本生成器</strong>（Probabilistic Text Generator）——给定一段输入文本（prompt），它预测最可能的下一个 token，然后把这个 token 加入输入，再预测下一个，如此循环。作为一个 Probabilistic Text Generator，LLM 的核心工作原理就是基于训练数据中学到的统计规律，对下一个可能出现的字符或词进行预测。</p>
<blockquote>
<p><strong>什么是概率性文本生成器？</strong></p>
<p>概率性文本生成器是一种基于统计预测机制的文本生成模型。与传统的确定性程序不同，它不会按照预定义的规则逐字输出结果，而是基于训练数据中学到的概率分布，对下一个可能出现的字符或词进行预测。</p>
<p>例如，当输入&quot;法国的首都是&quot;时，模型会计算所有可能的后续词的概率分布：Paris 可能有 92% 的概率，London 5%，Berlin 2%，其他词 1%。模型会从这个分布中采样（通常选择概率最高的），然后继续这个过程。</p>
<p>这种机制意味着：</p>
<ul>
<li><strong>不确定性</strong>：同样的输入在不同次生成中可能产生略有不同的输出</li>
<li><strong>上下文依赖</strong>：预测结果高度依赖于之前的上下文</li>
<li><strong>统计学习</strong>：&quot;知识&quot;来自训练数据中的统计规律，而非显式存储的事实</li>
<li><strong>创造力</strong>：能够生成训练数据中从未出现过的组合</li>
</ul>
</blockquote>
<pre><code class="hljs mermaid">flowchart LR
    A[&quot;输入: &#x27;The capital of France is&#x27;&quot;] --&gt; B[LLM 计算概率分布]
    B --&gt; C[&quot;P(&#x27;Paris&#x27;)=0.92&quot;]
    B --&gt; D[&quot;P(&#x27;Lyon&#x27;)=0.03&quot;]
    B --&gt; E[&quot;P(&#x27;the&#x27;)=0.02&quot;]
    C --&gt; F[&quot;输出: &#x27;Paris&#x27;&quot;]
    F --&gt; G[&quot;新输入: &#x27;The capital of France is Paris&#x27;&quot;]
    G --&gt; H[继续预测下一个 token...]</code></pre>
<p>这个机制带来几个关键推论：</p>
<p><strong>1. LLM 的&quot;知识&quot;是统计相关性，而非逻辑推理。</strong> 当 LLM 回答&quot;法国的首都是巴黎&quot;时，它并不是在&quot;推理&quot;，而是因为在训练数据中，&quot;法国&quot;和&quot;巴黎&quot;在&quot;首都&quot;这个上下文中高频共现。这意味着 LLM 在训练数据覆盖良好的领域表现出色，但在罕见场景下可能给出&quot;看起来合理但实际错误&quot;的答案。</p>
<p><strong>2. LLM 的输出具有概率性。</strong> 同样的输入可能产生不同的输出（受 temperature 参数控制）。这不是 bug，而是 feature——它使 LLM 能够生成创造性的内容，但也意味着不能期望 LLM 每次都给出完全一致的结果。</p>
<p><strong>3. LLM 没有持久记忆。</strong> 每次对话都是从零开始。LLM 不会&quot;记住&quot;上一次对话的内容，除非这些内容被显式地放入当前的上下文窗口中。这个特性直接决定了为什么需要 <a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a> 这样的外部记忆机制。</p>
<p><strong>4. LLM 的&quot;推理&quot;是涌现行为（Emergent Behavior）。</strong> 当模型规模足够大、训练数据足够丰富时，LLM 展现出类似推理的能力。但这种能力的边界是模糊的——它在常见模式上表现优异，在需要真正创新推理的场景下则不可靠。</p>
<h4 id="模式提炼：概率性推理">模式提炼：概率性推理</h4>
<p><strong>模式公式</strong>：<code>P(next_token) = f(所有前文 tokens 的统计相关性)</code></p>
<p><strong>迁移表</strong>：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>输入上下文</th>
<th>统计基础</th>
<th>可靠性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>常见编程模式</td>
<td>标准 API 调用代码</td>
<td>训练数据中大量出现</td>
<td>高</td>
<td>如 Spring Boot REST 端点</td>
</tr>
<tr>
<td>项目特定约定</td>
<td>私有框架代码</td>
<td>训练数据中未出现</td>
<td>低</td>
<td>需要通过 <a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a> 补充上下文</td>
</tr>
<tr>
<td>创新性设计</td>
<td>全新架构方案</td>
<td>训练数据中无直接对应</td>
<td>中</td>
<td>可组合已知模式，但需人工验证</td>
</tr>
<tr>
<td>边界情况处理</td>
<td>罕见错误场景</td>
<td>训练数据中稀少</td>
<td>低</td>
<td>需要显式提供示例和约束</td>
</tr>
</tbody>
</table>
<p><strong>核心洞察</strong>：当听到&quot;AI 给了错误答案&quot;时，首先应该检查的不是模型能力，而是上下文是否充分。LLM 的表现与输入上下文的质量直接相关——垃圾进，垃圾出；精确的上下文进，精确的答案出。这就是为什么 <a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a> 和 Skills 机制如此重要——它们本质上是在为 LLM 提供高质量的上下文。</p>
<h3 id="agent-loop：感知-推理-行动的循环">Agent Loop：感知-推理-行动的循环</h3>
<p>单独的 LLM 只能做文本补全。要让它成为一个能完成实际任务的 Agent，需要三个要素的组合：<strong>LLM（大脑）+ 工具（手脚）+ 循环（自主性）</strong>。</p>
<pre><code class="hljs mermaid">flowchart TB
    A[用户输入任务] --&gt; B&#123;Agent Loop&#125;
    B --&gt; C[LLM 分析当前状态]
    C --&gt; D&#123;需要更多信息?&#125;
    D --&gt;|是| E[调用工具: 读文件/搜索/执行命令]
    E --&gt; F[工具返回结果]
    F --&gt; B
    D --&gt;|否| G&#123;需要修改代码?&#125;
    G --&gt;|是| H[调用工具: 编辑文件]
    H --&gt; I[验证修改结果]
    I --&gt; B
    G --&gt;|否| J&#123;任务完成?&#125;
    J --&gt;|否| B
    J --&gt;|是| K[输出最终结果]
    style B fill:#fff3e0
    style C fill:#e8f5e9
    style E fill:#e3f2fd
    style H fill:#e3f2fd</code></pre>
<p>这个循环的每一轮都遵循相同的模式：</p>
<ol>
<li><strong>感知</strong>：LLM 读取当前上下文（用户消息 + 历史对话 + 工具返回的结果）</li>
<li><strong>推理</strong>：基于上下文，决定下一步应该做什么（调用哪个工具、传什么参数，或者直接回复用户）</li>
<li><strong>行动</strong>：执行决策（调用工具或生成回复）</li>
<li><strong>观察</strong>：将行动的结果加入上下文，开始下一轮循环</li>
</ol>
<pre><code class="hljs mermaid">sequenceDiagram
    participant U as 用户
    participant A as Agent(LLM)
    participant T as 工具集
    
    U-&gt;&gt;A: &quot;修复登录页面的 bug&quot;
    
    Note over A: 第1轮: 感知+推理
    A-&gt;&gt;T: read_file(&quot;src/login.tsx&quot;)
    T--&gt;&gt;A: 文件内容
    
    Note over A: 第2轮: 分析+搜索
    A-&gt;&gt;T: grep(&quot;handleLogin&quot;)
    T--&gt;&gt;A: 搜索结果
    
    Note over A: 第3轮: 定位+修复
    A-&gt;&gt;T: edit_file(&quot;src/login.tsx&quot;, changes)
    T--&gt;&gt;A: 修改成功
    
    Note over A: 第4轮: 验证
    A-&gt;&gt;T: run_tests(&quot;login.test.tsx&quot;)
    T--&gt;&gt;A: 测试通过
    
    A-&gt;&gt;U: &quot;已修复: 问题是...&quot;</code></pre>
<p>理解 Agent Loop 的关键在于：<strong>每一轮循环都会消耗上下文空间</strong>。用户的消息、LLM 的思考过程、工具调用的参数、工具返回的结果——所有这些都会被追加到上下文中。这意味着 Agent Loop 的轮次越多，上下文消耗越大，最终可能触及上下文窗口的物理限制。</p>
<p>Agent Loop 还有一个重要特性：<strong>LLM 在每一轮都会重新阅读完整的上下文</strong>。这既是优势（保证了一致性），也是劣势（随着上下文增长，注意力会被稀释）。</p>
<h4 id="模式提炼：感知-行动循环">模式提炼：感知-行动循环</h4>
<p><strong>模式公式</strong>：<code>Agent = while(!done) { context = perceive(); action = reason(context); result = act(action); context += result; }</code></p>
<p><strong>迁移表</strong>：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>感知</th>
<th>推理</th>
<th>行动</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bug 修复</td>
<td>读取错误日志+代码</td>
<td>定位根因</td>
<td>编辑代码+运行测试</td>
<td>典型的多轮循环</td>
</tr>
<tr>
<td>代码审查</td>
<td>读取 diff+规范</td>
<td>对比规范找问题</td>
<td>输出审查意见</td>
<td>可能只需 1-2 轮</td>
</tr>
<tr>
<td>新功能开发</td>
<td>读取需求+现有架构</td>
<td>设计方案</td>
<td>创建文件+编写代码</td>
<td>轮次最多，上下文消耗最大</td>
</tr>
<tr>
<td>重构</td>
<td>读取现有代码+依赖</td>
<td>规划重构步骤</td>
<td>批量修改文件</td>
<td>需要精确的任务分解</td>
</tr>
</tbody>
</table>
<p><strong>核心洞察</strong>：当听到&quot;Agent 做了很多无用功&quot;时，问题往往不在 Agent 的推理能力，而在于循环的效率——每一轮是否提供了足够精确的上下文？工具返回的信息是否有助于推进任务？这就是为什么 Commands 和 Skills 机制如此重要——它们通过预定义的工作流减少了 Agent 的&quot;摸索&quot;轮次。</p>
<h3 id="深入-agent-loop：决策-推理与失败">深入 Agent Loop：决策、推理与失败</h3>
<p>上一节描述了 Agent Loop 的基本结构——感知、推理、行动的循环。但要真正理解 Agent 的行为，需要深入到循环内部，回答三个关键问题：Agent 如何决定下一步做什么？如何判断任务是否完成？以及，当它犯错时会发生什么？</p>
<h4 id="agent-的决策过程：react-模式">Agent 的决策过程：ReAct 模式</h4>
<p>当前主流 Coding Agent 的决策过程遵循 ReAct（Reasoning + Acting）范式——Yao et al., 2022 提出的将推理与行动交织进行的方法。与纯粹的 Chain of Thought（仅推理不行动）或纯粹的行动（不推理直接调用工具）不同，ReAct 要求 Agent 在每一步都先<strong>显式推理</strong>，再<strong>执行行动</strong>，然后<strong>观察结果</strong>。</p>
<pre><code class="hljs mermaid">flowchart TB
    A[&quot;用户任务: 修复登录页面的 bug&quot;] --&gt; B[&quot;Thought 1:&lt;br/&gt;需要先查看登录页面的代码，&lt;br/&gt;了解当前实现&quot;]
    B --&gt; C[&quot;Action 1:&lt;br/&gt;read_file(&#x27;src/login.tsx&#x27;)&quot;]
    C --&gt; D[&quot;Observation 1:&lt;br/&gt;文件内容显示 handleLogin&lt;br/&gt;函数中缺少 await&quot;]
    D --&gt; E[&quot;Thought 2:&lt;br/&gt;发现 handleLogin 调用了异步 API&lt;br/&gt;但没有 await，这会导致&lt;br/&gt;Promise 未被正确处理&quot;]
    E --&gt; F[&quot;Action 2:&lt;br/&gt;edit_file(&#x27;src/login.tsx&#x27;,&lt;br/&gt;添加 await)&quot;]
    F --&gt; G[&quot;Observation 2:&lt;br/&gt;文件修改成功&quot;]
    G --&gt; H[&quot;Thought 3:&lt;br/&gt;修改完成，需要运行测试&lt;br/&gt;验证修复是否正确&quot;]
    H --&gt; I[&quot;Action 3:&lt;br/&gt;run_tests(&#x27;login.test.tsx&#x27;)&quot;]
    I --&gt; J[&quot;Observation 3:&lt;br/&gt;所有测试通过&quot;]
    J --&gt; K[&quot;Thought 4:&lt;br/&gt;Bug 已修复，测试通过，&lt;br/&gt;任务完成&quot;]
    K --&gt; L[&quot;输出最终结果&quot;]
    
    style B fill:#fff3e0
    style E fill:#fff3e0
    style H fill:#fff3e0
    style K fill:#fff3e0
    style C fill:#e3f2fd
    style F fill:#e3f2fd
    style I fill:#e3f2fd
    style D fill:#e8f5e9
    style G fill:#e8f5e9
    style J fill:#e8f5e9</code></pre>
<p>这个 Thought → Action → Observation 的循环，就是 Agent Loop 内部的微观结构。每一个 Thought 都是 LLM 生成的推理文本（通常在 <code>&lt;thinking&gt;</code> 标签或 extended thinking 中），它决定了 Agent 接下来要做什么。</p>
<p><strong>为什么显式推理如此重要？</strong> 对比两种模式：</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>无推理（直接行动）</th>
<th>ReAct（推理+行动）</th>
</tr>
</thead>
<tbody>
<tr>
<td>决策质量</td>
<td>基于表面模式匹配，容易选错工具</td>
<td>基于显式分析，决策更准确</td>
</tr>
<tr>
<td>可调试性</td>
<td>黑盒——不知道为什么选了这个工具</td>
<td>白盒——推理过程可观测</td>
</tr>
<tr>
<td>错误恢复</td>
<td>发现错误后缺乏纠正依据</td>
<td>可以回溯推理链找到错误环节</td>
</tr>
<tr>
<td>上下文消耗</td>
<td>低（不生成推理文本）</td>
<td>高（推理文本占用上下文空间）</td>
</tr>
</tbody>
</table>
<p>ReAct 的代价是上下文消耗更大——每一轮的 Thought 都会占用上下文空间。这也是为什么上下文管理如此重要：推理能力和上下文空间之间存在直接的权衡关系。</p>
<h4 id="工具选择：agent-如何决定-用哪个工具">工具选择：Agent 如何决定&quot;用哪个工具&quot;</h4>
<p>Agent 的每一次行动都涉及一个关键决策：从可用的工具集中选择最合适的工具。这个选择过程本质上是一个<strong>语义匹配</strong>问题——LLM 将当前任务的语义与每个工具的描述（tool description）进行匹配，选择概率最高的那个。</p>
<pre><code class="hljs mermaid">flowchart LR
    A[&quot;当前任务语义:&lt;br/&gt;&#x27;需要查看文件内容&#x27;&quot;] --&gt; B[&quot;LLM 计算匹配概率&quot;]
    B --&gt; C[&quot;read_file: 0.85&lt;br/&gt;&#x27;读取并显示文件内容&#x27;&quot;]
    B --&gt; D[&quot;file_grep: 0.10&lt;br/&gt;&#x27;搜索文件中的文本&#x27;&quot;]
    B --&gt; E[&quot;codebase_search: 0.05&lt;br/&gt;&#x27;语义搜索代码库&#x27;&quot;]
    C --&gt; F[&quot;选择 read_file&quot;]
    
    style C fill:#c8e6c9
    style F fill:#c8e6c9</code></pre>
<p>这意味着<strong>工具描述的质量直接决定了 Agent 的行为质量</strong>。一个模糊的工具描述会导致 Agent 频繁选错工具；一个精确的工具描述则能引导 Agent 做出正确选择。</p>
<p>工具描述的设计原则：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 差的工具描述: 模糊，Agent 不知道何时该用</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">search</span>(<span class="hljs-params">query: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">list</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;搜索内容&quot;&quot;&quot;</span><br>    ...<br><br><span class="hljs-comment"># 好的工具描述: 明确场景、输入输出、与其他工具的区别</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">codebase_search</span>(<span class="hljs-params">question: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">list</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    对代码库进行语义搜索。适用于查找某个功能的定义、</span><br><span class="hljs-string">    某个概念的实现位置，或探索代码库中是否存在某类代码。</span><br><span class="hljs-string">    </span><br><span class="hljs-string">    与 file_grep 的区别: file_grep 适合精确的文本匹配，</span><br><span class="hljs-string">    本工具适合语义层面的模糊搜索。</span><br><span class="hljs-string">    </span><br><span class="hljs-string">    当明确知道要搜索的精确字符串时，优先使用 file_grep。</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    ...<br></code></pre></td></tr></table></figure>
<p>工具调用失败时，Agent 的处理策略同样值得关注。成熟的 Agent 实现通常遵循<strong>降级策略</strong>：</p>
<ol>
<li><strong>重试</strong>：相同工具、调整参数（如放宽搜索条件）</li>
<li><strong>降级</strong>：切换到更通用的工具（如从语义搜索降级到文本搜索）</li>
<li><strong>求助</strong>：向用户请求更多信息或确认</li>
</ol>
<p>工具输出中的错误信息本身就是最有效的引导手段——Agent 会读取错误信息并据此调整策略。这就是为什么后文&quot;工程约束优于提示&quot;章节会强调：把对 Agent 的指导嵌入到工具的输出中。</p>
<h4 id="任务完成判断：agent-如何知道-做完了">任务完成判断：Agent 如何知道&quot;做完了&quot;</h4>
<p>Agent 判断任务是否完成，依赖的是 LLM 对当前上下文的综合评估。这个判断过程没有硬编码的规则，而是基于以下信号的概率性推理：</p>
<ul>
<li><strong>显式完成信号</strong>：测试通过、编译成功、用户确认</li>
<li><strong>隐式完成信号</strong>：所有已知的子任务都已处理、没有更多的错误信息</li>
<li><strong>任务描述匹配</strong>：当前状态是否满足用户最初的需求描述</li>
</ul>
<pre><code class="hljs mermaid">flowchart TB
    A[&quot;Agent 评估当前状态&quot;] --&gt; B&#123;所有子任务完成?&#125;
    B --&gt;|否| C[&quot;继续执行下一个子任务&quot;]
    B --&gt;|是| D&#123;有未解决的错误?&#125;
    D --&gt;|是| E[&quot;尝试修复错误&quot;]
    D --&gt;|否| F&#123;满足用户需求描述?&#125;
    F --&gt;|不确定| G[&quot;向用户确认&quot;]
    F --&gt;|是| H[&quot;输出结果，结束循环&quot;]
    
    style H fill:#c8e6c9
    style G fill:#fff3e0</code></pre>
<p>这个判断过程的概率性本质，解释了 Agent 的两种常见失败模式：</p>
<p><strong>过早停止</strong>：Agent 认为任务已完成，但实际上遗漏了某些子任务。这通常发生在任务描述模糊、缺少明确的完成标准时。解决方案是在 Prompt 中提供清晰的验收标准（如&quot;确保所有测试通过&quot;、“确保没有 lint 错误”）。</p>
<p><strong>无法停止</strong>：Agent 陷入无限循环，反复尝试修复同一个问题。这通常发生在错误信息不够明确、Agent 无法理解失败原因时。解决方案是设置最大轮次限制，并在错误信息中提供明确的修复指导。</p>
<h4 id="agent-的规划能力：任务分解">Agent 的规划能力：任务分解</h4>
<p>面对复杂任务时，Agent 不会一步到位，而是会将任务分解为多个子任务，然后逐个执行。这种规划能力（Planning Ability）是 LLM 涌现行为的一部分——模型从训练数据中学习到了&quot;分而治之&quot;（Divide and Conquer）的策略。</p>
<pre><code class="hljs mermaid">flowchart TB
    A[&quot;复杂任务:&lt;br/&gt;&#x27;为项目添加用户认证功能&#x27;&quot;] --&gt; B[&quot;Agent 规划&quot;]
    B --&gt; C[&quot;子任务 1: 创建用户模型&quot;]
    B --&gt; D[&quot;子任务 2: 实现注册接口&quot;]
    B --&gt; E[&quot;子任务 3: 实现登录接口&quot;]
    B --&gt; F[&quot;子任务 4: 添加 JWT 中间件&quot;]
    B --&gt; G[&quot;子任务 5: 编写测试&quot;]
    
    C --&gt; D
    D --&gt; E
    E --&gt; F
    F --&gt; G
    
    style A fill:#fff3e0
    style B fill:#e8f5e9</code></pre>
<p>Agent 的规划策略通常是<strong>渐进式</strong>的——先制定一个粗略的计划，然后在执行过程中根据实际情况调整。这与人类开发者的工作方式类似：先有一个大致的方向，然后在编码过程中不断细化。</p>
<p>但 Agent 的规划能力有明显的边界：</p>
<ul>
<li><strong>依赖关系识别不完整</strong>：Agent 可能遗漏子任务之间的隐含依赖</li>
<li><strong>过于乐观的估计</strong>：Agent 倾向于低估任务的复杂度</li>
<li><strong>缺乏全局视角</strong>：随着上下文消耗，Agent 可能&quot;忘记&quot;最初的整体计划</li>
</ul>
<p>这些局限性解释了为什么 Sub Agent 机制如此重要——通过将复杂任务显式分解为独立的子任务，每个子任务在独立的上下文窗口中执行，可以有效规避 Agent 规划能力的不足。</p>
<h4 id="agent-的常见失败模式">Agent 的常见失败模式</h4>
<p>理解 Agent 的失败模式，是有效使用 Agent 的前提。以下是最常见的几种：</p>
<pre><code class="hljs mermaid">flowchart TB
    A[&quot;Agent 失败模式&quot;] --&gt; B[&quot;死循环&lt;br/&gt;反复尝试相同的&lt;br/&gt;失败操作&quot;]
    A --&gt; C[&quot;幻觉修复&lt;br/&gt;声称已修复但&lt;br/&gt;实际未修复&quot;]
    A --&gt; D[&quot;过度修改&lt;br/&gt;修复一个 bug&lt;br/&gt;引入三个新 bug&quot;]
    A --&gt; E[&quot;偷懒行为&lt;br/&gt;跳过测试、&lt;br/&gt;绕过检查&quot;]
    A --&gt; F[&quot;上下文遗忘&lt;br/&gt;忘记早期获取的&lt;br/&gt;关键信息&quot;]
    
    B --&gt; B1[&quot;应对: 最大轮次限制&lt;br/&gt;+ 错误信息中包含修复指导&quot;]
    C --&gt; C1[&quot;应对: 工程验证&lt;br/&gt;(测试、类型检查、lint)&quot;]
    D --&gt; D1[&quot;应对: 任务粒度控制&lt;br/&gt;+ 增量验证&quot;]
    E --&gt; E1[&quot;应对: Git hooks&lt;br/&gt;+ CI 强制执行&quot;]
    F --&gt; F1[&quot;应对: 短对话策略&lt;br/&gt;+ Sub Agent 隔离&quot;]
    
    style B fill:#ffcdd2
    style C fill:#ffcdd2
    style D fill:#ffcdd2
    style E fill:#ffcdd2
    style F fill:#ffcdd2
    style B1 fill:#c8e6c9
    style C1 fill:#c8e6c9
    style D1 fill:#c8e6c9
    style E1 fill:#c8e6c9
    style F1 fill:#c8e6c9</code></pre>
<p><strong>死循环</strong>是最容易识别的失败模式：Agent 反复调用相同的工具、传入相同的参数，期望得到不同的结果。根因通常是错误信息不够明确——Agent 无法从工具输出中提取足够的信息来调整策略。</p>
<p>**幻觉修复（Hallucination Fix）**更加隐蔽：Agent 在推理文本中声称&quot;已修复问题&quot;，但实际的代码修改并未解决根因。这是 LLM 概率性本质的直接体现——模型生成了&quot;看起来合理&quot;的修复方案，但缺乏真正的因果推理。应对策略是依赖工程验证（测试、类型检查）而非 Agent 的自我评估。</p>
<p>**偷懒行为（Shortcut Behavior）**是一个有趣的现象：当 Agent 发现某个约束难以满足时（如测试一直失败），它可能会尝试绕过约束（如使用 <code>--no-verify</code> 跳过 pre-commit hook），而非解决根本问题。这种行为在后文&quot;工程约束优于提示&quot;章节中会详细讨论。</p>
<h4 id="模式提炼：agent-决策机制">模式提炼：Agent 决策机制</h4>
<p><strong>模式公式</strong>：<code>Agent 决策 = ReAct(Thought → Action → Observation) × 工具语义匹配(task, tool_descriptions) × 完成判断(context_signals)</code></p>
<p><strong>迁移表</strong>：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>决策挑战</th>
<th>推荐策略</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>工具选择错误</td>
<td>工具描述模糊</td>
<td>优化工具描述，明确适用场景</td>
<td>好的描述 &gt; 更多工具</td>
</tr>
<tr>
<td>Agent 死循环</td>
<td>错误信息不明确</td>
<td>在错误输出中嵌入修复指导</td>
<td>工具输出即 Prompt</td>
</tr>
<tr>
<td>过早停止</td>
<td>完成标准模糊</td>
<td>在任务描述中明确验收标准</td>
<td>“确保测试通过”</td>
</tr>
<tr>
<td>规划失败</td>
<td>任务过于复杂</td>
<td>拆分为 Sub Agent 独立执行</td>
<td>每个子任务独立上下文</td>
</tr>
<tr>
<td>幻觉修复</td>
<td>缺乏外部验证</td>
<td>依赖工程手段而非自我评估</td>
<td>测试 &gt; Agent 的&quot;我已修复&quot;</td>
</tr>
</tbody>
</table>
<p><strong>核心洞察</strong>：当听到&quot;Agent 总是做错事&quot;时，问题的根源通常不在 Agent 的推理能力，而在于三个外部因素：工具描述是否精确、错误信息是否有指导性、完成标准是否明确。改善这三个因素，比&quot;换一个更强的模型&quot;更有效。</p>
<h3 id="上下文窗口：agent-的工作记忆">上下文窗口：Agent 的工作记忆</h3>
<p>上下文窗口（Context Window）是理解所有 Agentic Coding 策略的关键。可以把它类比为人的工作记忆（Working Memory）——它是 Agent 在任何时刻能&quot;看到&quot;和&quot;思考&quot;的全部信息。</p>
<pre><code class="hljs mermaid">flowchart TB
    subgraph 上下文窗口[&quot;上下文窗口 (如 200K tokens)&quot;]
        direction TB
        A[&quot;系统提示词 (CLAUDE.md 内容)&quot;]
        B[&quot;用户消息历史&quot;]
        C[&quot;Agent 的思考过程&quot;]
        D[&quot;工具调用记录&quot;]
        E[&quot;工具返回结果&quot;]
        F[&quot;当前正在生成的回复&quot;]
    end
    
    G[&quot;窗口外: 之前的对话&quot;] -.-&gt;|&quot;不可见&quot;| 上下文窗口
    H[&quot;窗口外: 未读取的文件&quot;] -.-&gt;|&quot;不可见&quot;| 上下文窗口
    I[&quot;窗口外: 其他项目知识&quot;] -.-&gt;|&quot;不可见&quot;| 上下文窗口
    
    style 上下文窗口 fill:#fff8e1
    style G fill:#ffebee
    style H fill:#ffebee
    style I fill:#ffebee</code></pre>
<h4 id="上下文窗口的三个关键特性">上下文窗口的三个关键特性</h4>
<p><strong>1. 有限性</strong></p>
<p>即使是 200K token 的上下文窗口，看起来很大（约 15 万个英文单词），但在实际的 Agent 工作中会被迅速消耗：</p>
<pre><code class="hljs mermaid">pie title &quot;一次典型 Agent 会话的上下文消耗&quot;
    &quot;系统提示词 + Rules&quot; : 10
    &quot;用户消息&quot; : 5
    &quot;Agent 思考过程&quot; : 20
    &quot;工具调用参数&quot; : 10
    &quot;工具返回结果(文件内容等)&quot; : 40
    &quot;Agent 生成的代码&quot; : 15</code></pre>
<p>一个中等复杂度的编程任务，可能在 10-20 轮 Agent Loop 后就消耗掉大部分上下文空间。</p>
<p><strong>2. 注意力退化（Attention Degradation）/ Lost in the Middle</strong></p>
<p>研究表明，LLM 对上下文中不同位置的信息，注意力分布是不均匀的。开头和结尾的信息得到更多关注，而中间部分的信息容易被&quot;遗忘&quot;。</p>
<pre><code class="hljs mermaid">flowchart LR
    subgraph 注意力分布
        direction LR
        A[&quot;开头&lt;br/&gt;注意力: 高&quot;] --- B[&quot;中间&lt;br/&gt;注意力: 低&quot;] --- C[&quot;结尾&lt;br/&gt;注意力: 高&quot;]
    end
    
    D[&quot;实际影响:&lt;br/&gt;早期的工具返回结果&lt;br/&gt;可能被后续信息&#x27;淹没&#x27;&quot;]
    
    注意力分布 --&gt; D</code></pre>
<p>这意味着：随着对话的进行，Agent 可能会&quot;忘记&quot;早期获取的关键信息，导致重复搜索、前后矛盾，甚至引入之前已经修复过的 bug。</p>
<p><strong>3. 上下文污染（Context Pollution）</strong></p>
<p>上下文中的错误信息不会自动消失。如果 Agent 在第 3 轮生成了一段有 bug 的代码，即使在第 5 轮修复了，第 3 轮的错误代码仍然存在于上下文中，可能在后续轮次中&quot;误导&quot; Agent。</p>
<pre><code class="hljs mermaid">flowchart TB
    A[&quot;第3轮: Agent 生成错误代码&quot;] --&gt; B[&quot;第4轮: 发现错误&quot;]
    B --&gt; C[&quot;第5轮: 修复错误&quot;]
    C --&gt; D[&quot;第8轮: Agent 再次参考上下文&quot;]
    D --&gt; E&#123;&quot;看到了哪个版本?&quot;&#125;
    E --&gt;|&quot;可能看到第3轮的错误版本&quot;| F[&quot;再次引入相同 bug&quot;]
    E --&gt;|&quot;看到第5轮的修复版本&quot;| G[&quot;正确继续&quot;]
    style F fill:#ffcdd2
    style G fill:#c8e6c9</code></pre>
<h4 id="上下文管理的核心策略">上下文管理的核心策略</h4>
<p>理解了上下文窗口的特性后，所有的 Agentic Coding 策略都可以归结为一个核心目标：<strong>在有限的上下文空间内，最大化有效信息密度</strong>。</p>
<pre><code class="hljs mermaid">flowchart TB
    A[上下文管理核心策略] --&gt; B[减少无效信息]
    A --&gt; C[增加有效信息]
    A --&gt; D[隔离信息空间]
    
    B --&gt; B1[短对话优于长对话]
    B --&gt; B2[精确的工具调用]
    B --&gt; B3[避免重复搜索]
    
    C --&gt; C1[CLAUDE.md 预加载关键上下文]
    C --&gt; C2[Skills 注入领域知识]
    C --&gt; C3[结构化的错误信息]
    
    D --&gt; D1[Sub Agent 独立上下文]
    D --&gt; D2[任务分解与隔离]
    D --&gt; D3[新对话 vs 继续对话]</code></pre>
<h4 id="模式提炼：上下文即工作记忆">模式提炼：上下文即工作记忆</h4>
<p><strong>模式公式</strong>：<code>有效性 = 有效信息量 / 总上下文消耗 × 注意力权重(位置)</code></p>
<p><strong>迁移表</strong>：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>上下文压力</th>
<th>推荐策略</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>简单 bug 修复</td>
<td>低</td>
<td>单次对话完成</td>
<td>2-5 轮 Loop 即可</td>
</tr>
<tr>
<td>中等功能开发</td>
<td>中</td>
<td>预加载 Rules + 精确搜索</td>
<td>控制在 10-15 轮</td>
</tr>
<tr>
<td>大型重构</td>
<td>高</td>
<td>任务分解 + Sub Agent</td>
<td>每个子任务独立上下文</td>
</tr>
<tr>
<td>跨模块修改</td>
<td>极高</td>
<td>多次短对话 + 持久记忆</td>
<td>每个模块一次对话</td>
</tr>
</tbody>
</table>
<p><strong>核心洞察</strong>：当听到&quot;Agent 在长对话中表现越来越差&quot;时，根因几乎总是上下文窗口的退化。解决方案不是&quot;换一个更强的模型&quot;，而是&quot;开一个新对话&quot;。这就是为什么 Sub Agent 机制如此重要——它通过创建独立的上下文窗口，从根本上解决了上下文污染问题。</p>
<hr>
<h2 id="markdown-配置体系：用文档定义智能体">Markdown 配置体系：用文档定义智能体</h2>
<p>理解了第一性原理之后，再来看 Claude Code 的 Markdown 配置体系，就能理解每一层设计背后的&quot;为什么&quot;。</p>
<p>这套体系包含四种机制：<strong><a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a></strong>（项目记忆）、<strong>Commands</strong>（参数化触发）、<strong>Skills</strong>（专业知识包）、<strong>Sub Agents</strong>（独立执行体）。它们按照关注点分离（Separation of Concerns）的原则，各自承担不同的职责。#### 核心关系：平行而非层级</p>
<p><strong>关键认知</strong>：Command、Skill、Sub Agent 是<strong>平行存在</strong>的三种机制，而非包含或层级关系。它们的核心区别在于<strong>触发方式</strong>和<strong>执行环境</strong>：</p>
<p><strong>Command 和 Skill 的相互关系</strong>：</p>
<p>Command 和 Skill 之间<strong>可以互相调用/引用</strong>，并非单向关系：</p>
<ul>
<li><strong>Command 可以调用 Skill</strong>：Command 的内容可以指示 Agent 使用某个 Skill 来完成子任务</li>
<li><strong>Skill 可以包含 Slash Command</strong>：Skill 可以通过 <code>user-invocable: true</code> 字段将自己作为 Slash Command 暴露，也可以在 Skill 内容中引用其他 Command</li>
</ul>
<pre><code class="hljs mermaid">flowchart TB
    subgraph Command 与 Skill 的双向关系
        CMD[Command&lt;br/&gt;参数化触发]
        SKL[Skill&lt;br/&gt;专业知识包]
        
        CMD --&gt;|&quot;可以调用&quot;| SKL
        SKL --&gt;|&quot;可以包含 Command&lt;br/&gt;(user-invocable)&quot;| CMD
        
        CMD -.-&gt;|&quot;两者都在&lt;br/&gt;主对话上下文执行&quot;| SKL
    end
    
    style CMD fill:#fff9c4
    style SKL fill:#e8f5e9</code></pre>
<pre><code class="hljs mermaid">flowchart TB
    subgraph 四层配置体系
        direction TB
        L1[&quot;CLAUDE.md&lt;br/&gt;──────────&lt;br/&gt;项目记忆与行为约束&lt;br/&gt;始终在场 | 自动加载&quot;]
        
        subgraph 平行的三种机制
            L2[&quot;Commands&lt;br/&gt;──────────&lt;br/&gt;参数化提示词模板&lt;br/&gt;手动触发 | 主对话上下文&quot;]
            L3[&quot;Skills&lt;br/&gt;──────────&lt;br/&gt;可复用知识包&lt;br/&gt;自动触发 | 主对话上下文&quot;]
            L4[&quot;Sub Agents&lt;br/&gt;──────────&lt;br/&gt;独立执行的专业角色&lt;br/&gt;委派执行 | 独立上下文&quot;]
        end
        
        PLG[&quot;Plugins&lt;br/&gt;──────────&lt;br/&gt;外部工具扩展&lt;br/&gt;MCP Servers | 可执行程序&quot;]
        
        L1 -.-&gt;|&quot;始终可见&quot;| L2
        L1 -.-&gt;|&quot;始终可见&quot;| L3
        L1 -.-&gt;|&quot;始终可见&quot;| L4
        
        L2 --&gt;|&quot;可以调用&quot;| L4
        L3 --&gt;|&quot;可以调用&quot;| L4
        L2 &lt;--&gt;|&quot;可以互相调用/引用&quot;| L3
        
        L4 -.-&gt;|&quot;通过 tools 字段引用&quot;| PLG
    end
    
    style L1 fill:#e3f2fd
    style L2 fill:#fff9c4
    style L3 fill:#e8f5e9
    style L4 fill:#fff3e0
    style PLG fill:#f3e5f5</code></pre>
<p><strong>触发方式对比</strong>：</p>
<table>
<thead>
<tr>
<th>机制</th>
<th>触发方式</th>
<th>控制权</th>
<th>执行环境</th>
<th>比喻</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Command</strong></td>
<td>用户手动输入 <code>/command</code></td>
<td>你决定何时执行</td>
<td>主对话上下文</td>
<td>手动挡变速箱</td>
</tr>
<tr>
<td><strong>Skill</strong></td>
<td>Agent 自动识别场景</td>
<td>系统自动决定</td>
<td>主对话上下文</td>
<td>定速巡航系统</td>
</tr>
<tr>
<td><strong>Sub Agent</strong></td>
<td>Command/Skill/主对话委派</td>
<td>委派者决定</td>
<td>独立上下文窗口</td>
<td>外包给专业团队</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注</strong>：Plugins 是外部工具扩展层（MCP Servers 和可执行程序），通过 Sub Agent 的 <code>tools</code> 字段被引用。它与四层配置体系的关系是：四层配置定义&quot;Agent 是什么、怎么做&quot;，Plugins 提供&quot;Agent 可以使用哪些工具&quot;。</p>
</blockquote>
<h3 id="全景视角：三层提示机制">全景视角：三层提示机制</h3>
<p>在深入四层配置体系之前，有必要先理解一个更宏观的分层结构。Agent 的行为实际上由<strong>三层提示机制</strong>共同决定，它们各自解决不同层次的问题：</p>
<pre><code class="hljs mermaid">flowchart TB
    subgraph L1[&quot;L1: 行为宪法 (System Prompt)&quot;]
        A1[&quot;安全边界: 拒绝危险操作&quot;]
        A2[&quot;工作流规范: 先读文件再修改&quot;]
        A3[&quot;工具调用协议: 何时使用哪个工具&quot;]
    end
    
    subgraph L2[&quot;L2: 项目记忆 (CLAUDE.md / .cursor/rules)&quot;]
        B1[&quot;技术栈: Spring Boot 3.2 + Java 21&quot;]
        B2[&quot;架构约束: 严格分层, 禁止跨层调用&quot;]
        B3[&quot;团队规范: commit 格式, 代码风格&quot;]
    end
    
    subgraph L3[&quot;L3: 任务指令 (用户实时输入)&quot;]
        C1[&quot;具体需求: 实现登录表单&quot;]
        C2[&quot;即时反馈: 修复这个 bug&quot;]
    end
    
    L1 --&gt;|&quot;由平台预置, 变更频率极低&quot;| L2
    L2 --&gt;|&quot;由用户编写, 随项目演进更新&quot;| L3
    L3 --&gt;|&quot;每次对话动态变化&quot;| D[&quot;Agent 执行&quot;]
    
    style L1 fill:#e8eaf6
    style L2 fill:#c5cae9
    style L3 fill:#9fa8da</code></pre>
<table>
<thead>
<tr>
<th>层级</th>
<th>职责</th>
<th>维护者</th>
<th>变更频率</th>
<th>类比</th>
</tr>
</thead>
<tbody>
<tr>
<td>L1: System Prompt</td>
<td>基础行为准则与安全边界</td>
<td>平台厂商（Anthropic、Cursor 等）</td>
<td>极低</td>
<td>操作系统内核</td>
</tr>
<tr>
<td>L2: 项目配置</td>
<td>项目特定知识与约束</td>
<td>开发者/团队</td>
<td>随项目演进</td>
<td>应用配置文件</td>
</tr>
<tr>
<td>L3: 用户输入</td>
<td>具体任务指令</td>
<td>用户</td>
<td>每次对话</td>
<td>用户输入</td>
</tr>
</tbody>
</table>
<h4 id="三层为何不能互相替代">三层为何不能互相替代</h4>
<p><strong>仅靠 L2（项目配置）的局限</strong>：项目配置文件是用户可编辑的文本，无法提供强制性安全防护——Agent 可能被诱导绕过其中的约束。此外，&quot;调用工具前必须确认&quot;这类行为规范属于工具调用的元协议，必须由 System Prompt 提供底层支持。如果每个项目都要重新定义&quot;先规划再执行&quot;等通用准则，将造成大量冗余。</p>
<p><strong>仅靠 L1（System Prompt）的局限</strong>：如果将所有项目知识塞入 System Prompt，会迅速消耗上下文窗口。每个项目需定制独立的 System Prompt，破坏工具的通用性。而且 System Prompt 通常由厂商控制，无法随项目架构的持续变化而动态更新。</p>
<h4 id="三层协同示例">三层协同示例</h4>
<p>以&quot;为 Next.js 项目添加 Dark Mode&quot;为例：</p>
<ul>
<li><strong>L1（System Prompt）</strong> 提供行为框架：必须先理解现有代码再修改；调用执行工具前需用户确认；拒绝执行可能破坏系统的命令</li>
<li><strong>L2（<a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a>）</strong> 提供项目知识：技术栈为 Next.js 14 + TypeScript + Tailwind；主题方案使用 <code>next-themes</code>，配置位于 <code>/lib/theme.ts</code>；所有组件必须基于 <code>shadcn/ui</code></li>
<li><strong>L3（用户输入）</strong> 提供具体任务：“在导航栏右侧添加 Dark Mode 切换按钮”</li>
</ul>
<p>Agent 的执行路径：依据 L1，先读取 <code>/lib/theme.ts</code> 理解现有主题实现；依据 L2，使用 <code>next-themes</code> API 而非自研方案，按钮样式遵循 <code>shadcn/ui</code>；依据 L3，将按钮精准放置在导航栏右侧。三层缺一不可：缺少 L1 会导致盲目生成代码；缺少 L2 会用错技术栈；缺少 L3 则不知具体目标。</p>
<blockquote>
<p>本文后续章节聚焦于 L2 层——即开发者可以直接控制的项目配置体系。理解 L1 的存在，有助于理解为什么 <a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a> 不需要重复定义安全规则和通用行为准则。</p>
</blockquote>
<h3 id="claude-md：项目记忆与行为约束"><a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a>：项目记忆与行为约束</h3>
<p><a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a> 是整个体系的基础层。它解决的核心问题是：<strong>LLM 没有持久记忆，每次对话都从零开始</strong>。通过在对话开始时自动加载 <a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a> 的内容，Agent 能立即获得项目的关键上下文。</p>
<h4 id="分层加载机制">分层加载机制</h4>
<p><a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a> 支持三级作用域，按从全局到局部的顺序加载：</p>
<pre><code class="hljs mermaid">flowchart TB
    A[&quot;~/.claude/CLAUDE.md&lt;br/&gt;全局级：跨项目通用偏好&quot;] --&gt; D[合并注入上下文]
    B[&quot;项目根目录/CLAUDE.md&lt;br/&gt;项目级：技术栈、规范、架构&quot;] --&gt; D
    C[&quot;当前目录/CLAUDE.md&lt;br/&gt;目录级：模块特定约束&quot;] --&gt; D
    D --&gt; E[&quot;Agent 开始工作&lt;br/&gt;已具备完整的项目认知&quot;]
    
    style A fill:#e8eaf6
    style B fill:#c5cae9
    style C fill:#9fa8da</code></pre>
<p>这种分层设计的精妙之处在于：<strong>它用最小的上下文消耗，提供了最大的信息覆盖</strong>。全局偏好只写一次，项目规范只在项目级定义，模块特定的约束只在需要时加载。</p>
<h4 id="claude-md-的内容结构"><a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a> 的内容结构</h4>
<p>一份高效的 <a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a> 应该包含以下信息（按优先级排序）：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 项目概述</span><br>这是一个基于 Spring Boot 3.2 的电商平台后端服务。<br>Java 21，Maven 构建，MySQL + Redis。<br><br><span class="hljs-section"># 关键命令</span><br><span class="hljs-bullet">-</span> 构建: <span class="hljs-code">`mvn clean package -DskipTests`</span><br><span class="hljs-bullet">-</span> 测试: <span class="hljs-code">`mvn test -pl module-name`</span><br><span class="hljs-bullet">-</span> 本地运行: <span class="hljs-code">`mvn spring-boot:run -pl app`</span><br><br><span class="hljs-section"># 代码规范</span><br><span class="hljs-bullet">-</span> REST API 统一返回 <span class="hljs-code">`Result&lt;T&gt;`</span>，见 <span class="hljs-code">`common/Result.java`</span><br><span class="hljs-bullet">-</span> 使用 MapStruct 做 DTO 转换，禁止手写 getter/setter 转换<br><span class="hljs-bullet">-</span> 异常统一通过 <span class="hljs-code">`@RestControllerAdvice`</span> 处理<br><br><span class="hljs-section"># 架构约束</span><br><span class="hljs-bullet">-</span> 严格分层: Controller → Service → Repository<br><span class="hljs-bullet">-</span> 禁止 Controller 直接访问 Repository<br><span class="hljs-bullet">-</span> 跨模块调用必须通过 API 接口，禁止直接依赖实现类<br><br><span class="hljs-section"># 当前工作重点</span><br><span class="hljs-bullet">-</span> 正在重构订单模块，从单体迁移到 DDD 风格<br><span class="hljs-bullet">-</span> 支付模块不要改动，正在等待第三方 SDK 升级<br></code></pre></td></tr></table></figure>
<p><strong>关键原则</strong>：<a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a> 应该是<strong>声明式</strong>的——告诉 Agent “是什么&quot;和&quot;不要做什么”，而不是&quot;怎么做&quot;。具体的&quot;怎么做&quot;应该交给 Skills 和 Commands。</p>
<h4 id="从第一性原理理解-claude-md-的设计">从第一性原理理解 <a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a> 的设计</h4>
<p>回到上下文窗口的约束：<a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a> 的内容会在每次对话开始时被注入上下文。这意味着：</p>
<ul>
<li><strong>内容必须精炼</strong>：每多一行，就多消耗一点宝贵的上下文空间</li>
<li><strong>信息密度要高</strong>：用最少的 token 传达最关键的信息</li>
<li><strong>避免重复</strong>：不要在 <a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a> 中写已经在代码注释或 README 中存在的信息</li>
</ul>
<pre><code class="hljs mermaid">flowchart LR
    A[&quot;CLAUDE.md 内容&quot;] --&gt;|&quot;每次对话都消耗&quot;| B[&quot;上下文空间&quot;]
    B --&gt;|&quot;剩余空间&quot;| C[&quot;实际工作可用&quot;]
    
    D[&quot;过长的 CLAUDE.md&quot;] --&gt;|&quot;挤占&quot;| C
    E[&quot;过短的 CLAUDE.md&quot;] --&gt;|&quot;Agent 需要额外搜索&lt;br/&gt;反而消耗更多上下文&quot;| C
    
    F[&quot;最优: 精炼但完整&quot;] --&gt;|&quot;平衡&quot;| C
    style F fill:#c8e6c9
    style D fill:#ffcdd2</code></pre>
<h3 id="commands：参数化的提示词模板">Commands：参数化的提示词模板</h3>
<blockquote>
<p><strong>术语说明</strong>：本文中 “Commands” 指的是功能概念，即&quot;封装了特定工作流的可调用单元&quot;。当需要强调用户通过 <code>/</code> 前缀触发的方式时，也会使用 “Slash Commands” 这个术语。两者关系是：所有 Slash Commands 都是 Commands，但 Commands 可以被 Agent 自动调用，不一定需要用户手动触发。</p>
</blockquote>
<p>Commands 解决的问题是：<strong>重复性任务的标准化触发</strong>。如果发现自己经常对 Agent 说类似的话（“帮我写一个 API 端点，路径是 X，方法是 Y”），就应该把它封装成一个 Command。</p>
<h4 id="command-的定义结构">Command 的定义结构</h4>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>name: create-api<br>description: 创建一个新的 REST API 端点<br>arguments:<br><span class="hljs-bullet">  -</span> name: method<br><span class="hljs-code">    description: HTTP 方法 (GET/POST/PUT/DELETE)</span><br><span class="hljs-code">    required: true</span><br><span class="hljs-code">  - name: path</span><br><span class="hljs-code">    description: API 路径 (如 /api/v1/users)</span><br><span class="hljs-code">    required: true</span><br><span class="hljs-code">  - name: description</span><br><span class="hljs-code">    description: API 功能描述</span><br><span class="hljs-code">    required: false</span><br><span class="hljs-code">---</span><br><span class="hljs-code"></span><br>创建一个新的 REST API 端点。<br><br>HTTP 方法: $ARGUMENTS.method<br>API 路径: $ARGUMENTS.path<br>功能描述: $ARGUMENTS.description<br><br>请按照以下步骤实现:<br><span class="hljs-bullet">1.</span> 在对应的 Controller 中添加端点方法<br><span class="hljs-bullet">2.</span> 在 Service 层添加业务逻辑接口和实现<br><span class="hljs-bullet">3.</span> 如需要，在 Repository 层添加数据访问方法<br><span class="hljs-bullet">4.</span> 编写单元测试<br><span class="hljs-bullet">5.</span> 更新 API 文档<br><br>遵循项目的 REST API 规范（见 CLAUDE.md）。<br></code></pre></td></tr></table></figure>
<p>用户只需输入 <code>/create-api POST /api/v1/orders &quot;创建订单&quot;</code> 即可触发完整的工作流。</p>
<h4 id="command-与上下文的关系">Command 与上下文的关系</h4>
<p>从上下文管理的角度看，Command 的价值在于：<strong>用少量的用户输入 token，展开为大量的精确指令 token</strong>。这比用户每次手动输入完整指令更高效，也更一致。</p>
<pre><code class="hljs mermaid">flowchart LR
    A[&quot;用户输入:&lt;br/&gt;/create-api POST /orders&quot;] --&gt;|&quot;展开&quot;| B[&quot;完整的提示词模板&lt;br/&gt;+ 参数值&lt;br/&gt;+ 工作流步骤&lt;br/&gt;+ 规范引用&quot;]
    
    C[&quot;用户手动输入:&lt;br/&gt;帮我创建一个 POST API...&lt;br/&gt;路径是 /orders...&lt;br/&gt;记得遵循规范...&lt;br/&gt;要写测试...&quot;] --&gt;|&quot;对比&quot;| D[&quot;信息可能遗漏&lt;br/&gt;表述可能不一致&lt;br/&gt;消耗更多 token&quot;]
    
    style A fill:#c8e6c9
    style C fill:#ffcdd2</code></pre>
<h3 id="skills：可复用的知识包">Skills：可复用的知识包</h3>
<p>Skills 是 Commands 的补充机制。如果说 Command 侧重于&quot;工作流的标准化触发&quot;，那么 Skill 侧重于&quot;领域知识的自动注入&quot;——它不仅包含指令，还包含领域知识、参考文档、工作流定义。</p>
<p><strong>Command 和 Skill 的区别</strong>：</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>Command</th>
<th>Skill</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>核心价值</strong></td>
<td>标准化重复性任务的触发</td>
<td>自动注入领域专业知识</td>
</tr>
<tr>
<td><strong>触发方式</strong></td>
<td>用户手动输入 <code>/command</code></td>
<td>Agent 根据场景自动匹配</td>
</tr>
<tr>
<td><strong>内容结构</strong></td>
<td>提示词模板 + 参数</td>
<td>知识包 + 指令 + 参考文档</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>明确的、重复的工作流程</td>
<td>需要领域知识的复杂任务</td>
</tr>
<tr>
<td><strong>关系</strong></td>
<td>可以调用 Skill</td>
<td>可以调用 Command（双向）</td>
</tr>
</tbody>
</table>
<h4 id="skill-的完整结构">Skill 的完整结构</h4>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs nix">.claude<span class="hljs-operator">/</span>skills<span class="hljs-symbol">/</span><br>└── api-design<span class="hljs-symbol">/</span><br>    ├── skill.md              <span class="hljs-comment"># Skill 定义（入口）</span><br>    └── references<span class="hljs-symbol">/</span><br>        ├── rest-conventions.md    <span class="hljs-comment"># REST API 设计规范</span><br>        ├── error-codes.md         <span class="hljs-comment"># 错误码定义</span><br>        └── examples<span class="hljs-symbol">/</span><br>            ├── user-api.md        <span class="hljs-comment"># 用户 API 示例</span><br>            └── order-api.md       <span class="hljs-comment"># 订单 API 示例</span><br></code></pre></td></tr></table></figure>
<p>Skill 定义文件（<code>skill.md</code>）的结构：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>name: api-design<br><span class="hljs-section">description: REST API 设计专家，遵循团队的 API 设计规范</span><br><span class="hljs-section">---</span><br><br>作为 API 设计专家，在设计和实现 REST API 时：<br><br><span class="hljs-bullet">1.</span> 遵循 <span class="hljs-code">`references/rest-conventions.md`</span> 中的命名和路径规范<br><span class="hljs-bullet">2.</span> 错误响应使用 <span class="hljs-code">`references/error-codes.md`</span> 中定义的错误码<br><span class="hljs-bullet">3.</span> 参考 <span class="hljs-code">`references/examples/`</span> 中的示例了解团队风格<br><br>设计原则：<br><span class="hljs-bullet">-</span> URL 使用名词复数形式（/users, /orders）<br><span class="hljs-bullet">-</span> 使用标准 HTTP 状态码<br><span class="hljs-bullet">-</span> 响应体统一使用 Result<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span></span> 包装<br><span class="hljs-bullet">-</span> 分页使用 cursor-based pagination<br></code></pre></td></tr></table></figure>
<h4 id="skill-的加载机制">Skill 的加载机制</h4>
<p>当 Agent 判断当前任务需要某个 Skill 的知识时，会自动加载该 Skill 的全部内容（包括 <code>references/</code> 目录下的文件）到上下文中。这个过程是<strong>按需</strong>的——只有在需要时才加载，避免了不必要的上下文消耗。</p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant U as 用户
    participant A as Agent
    participant S as Skill 工具
    
    U-&gt;&gt;A: &quot;设计一个订单退款 API&quot;
    
    Note over A: 判断需要 API 设计知识
    A-&gt;&gt;S: 搜索匹配的 Skill
    S--&gt;&gt;A: 找到 api-design Skill
    
    Note over A: 加载 Skill 内容到上下文
    A-&gt;&gt;S: 读取 skill.md + references/*
    S--&gt;&gt;A: API 规范 + 错误码 + 示例
    
    Note over A: 基于 Skill 知识执行任务
    A-&gt;&gt;U: 按照团队规范设计的退款 API</code></pre>
<h4 id="skills-与-claude-md-的分工">Skills 与 <a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a> 的分工</h4>
<pre><code class="hljs mermaid">flowchart TB
    subgraph CLAUDE.md
        A1[&quot;项目级通用信息&quot;]
        A2[&quot;技术栈声明&quot;]
        A3[&quot;全局行为约束&quot;]
    end
    
    subgraph Skills
        B1[&quot;领域专业知识&quot;]
        B2[&quot;详细的参考文档&quot;]
        B3[&quot;具体的工作流程&quot;]
    end
    
    C[&quot;上下文空间&quot;] 
    
    CLAUDE.md --&gt;|&quot;始终占用&quot;| C
    Skills --&gt;|&quot;按需占用&quot;| C
    
    D[&quot;设计原则:&lt;br/&gt;CLAUDE.md 放&#x27;必须始终知道的&#x27;&lt;br/&gt;Skills 放&#x27;需要时才加载的&#x27;&quot;]
    
    style D fill:#e8f5e9</code></pre>
<h3 id="sub-agents：独立执行的专业角色">Sub Agents：独立执行的专业角色</h3>
<p>Sub Agents 是四层体系中最强大的机制。它解决的核心问题是：<strong>上下文隔离（Context Isolation）</strong>。</p>
<p>回到第一性原理：上下文窗口是有限的，长对话会导致注意力退化和上下文污染。Sub Agent 通过创建<strong>独立的上下文窗口</strong>，从根本上解决了这个问题。</p>
<pre><code class="hljs mermaid">flowchart TB
    subgraph 主对话[&quot;主 Agent 上下文窗口&quot;]
        M1[&quot;用户任务&quot;]
        M2[&quot;项目上下文&quot;]
        M3[&quot;任务分解决策&quot;]
    end
    
    subgraph SA1[&quot;Sub Agent A 上下文窗口&quot;]
        A1[&quot;独立的上下文&quot;]
        A2[&quot;专属工具权限&quot;]
        A3[&quot;子任务 A 的全部工作&quot;]
    end
    
    subgraph SA2[&quot;Sub Agent B 上下文窗口&quot;]
        B1[&quot;独立的上下文&quot;]
        B2[&quot;专属工具权限&quot;]
        B3[&quot;子任务 B 的全部工作&quot;]
    end
    
    主对话 --&gt;|&quot;委派子任务 A&quot;| SA1
    主对话 --&gt;|&quot;委派子任务 B&quot;| SA2
    SA1 --&gt;|&quot;只返回摘要结果&quot;| 主对话
    SA2 --&gt;|&quot;只返回摘要结果&quot;| 主对话
    
    style 主对话 fill:#e8eaf6
    style SA1 fill:#e3f2fd
    style SA2 fill:#e8f5e9</code></pre>
<h4 id="sub-agent-的定义">Sub Agent 的定义</h4>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>name: code-reviewer<br>description: 代码审查专家，专注于代码质量和安全性审查<br><span class="hljs-section">tools: Read, Grep, Glob</span><br><span class="hljs-section">---</span><br><br>作为代码审查专家，执行以下审查流程：<br><br><span class="hljs-bullet">1.</span> 读取待审查的代码文件<br><span class="hljs-bullet">2.</span> 检查代码质量：命名规范、函数长度、复杂度<br><span class="hljs-bullet">3.</span> 检查安全性：SQL 注入、XSS、敏感信息泄露<br><span class="hljs-bullet">4.</span> 检查性能：N+1 查询、不必要的循环、内存泄漏风险<br><span class="hljs-bullet">5.</span> 输出结构化的审查报告<br><br>审查标准：<br><span class="hljs-bullet">-</span> 函数不超过 30 行<br><span class="hljs-bullet">-</span> 圈复杂度不超过 10<br><span class="hljs-bullet">-</span> 所有外部输入必须验证<br><span class="hljs-bullet">-</span> 数据库查询必须使用参数化<br></code></pre></td></tr></table></figure>
<p>注意 <code>tools: Read, Grep, Glob</code>——这个 Sub Agent <strong>只有读取权限，没有编辑权限</strong>。工具列表就是权限边界。</p>
<h4 id="内置的默认-sub-agents">内置的默认 Sub Agents</h4>
<p>除了用户自定义的 Sub Agents，Claude Code 还提供了几个<strong>内置的默认 Sub Agents</strong>，它们针对特定的任务类型进行了优化：</p>
<table>
<thead>
<tr>
<th>内置 Agent</th>
<th>用途</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>explore</code></td>
<td>代码探索和理解</td>
<td>只读权限，专注于理解代码结构和关系</td>
</tr>
<tr>
<td><code>analyze</code></td>
<td>深度分析</td>
<td>只读权限，专注于性能、安全性、架构分析</td>
</tr>
<tr>
<td><code>edit</code></td>
<td>代码修改</td>
<td>读写权限，专注于精确的代码修改</td>
</tr>
<tr>
<td><code>test</code></td>
<td>测试生成和执行</td>
<td>读写权限，专注于测试覆盖和验证</td>
</tr>
</tbody>
</table>
<p>这些内置 Agent 的优势在于：</p>
<p><strong>1. 预优化的行为模式</strong></p>
<ul>
<li><code>explore</code> Agent 会优先使用 <code>grep</code>、<code>find</code> 等搜索工具，快速定位代码</li>
<li><code>analyze</code> Agent 会使用静态分析工具，输出结构化的分析报告</li>
<li><code>edit</code> Agent 会采用更保守的修改策略，优先使用 <code>edit_file</code> 而非重写整个文件</li>
</ul>
<p><strong>2. 自动化的上下文管理</strong></p>
<ul>
<li>每个内置 Agent 都有自己优化的上下文加载策略</li>
<li><code>explore</code> 会优先读取目录结构和关键文件</li>
<li><code>analyze</code> 会加载依赖关系和调用链信息</li>
</ul>
<p><strong>3. 与用户自定义 Sub Agent 的协同</strong></p>
<pre><code class="hljs mermaid">flowchart TB
    subgraph 内置Sub Agents
        EXP[&quot;explore&lt;br/&gt;代码探索&quot;]
        ANA[&quot;analyze&lt;br/&gt;深度分析&quot;]
        EDT[&quot;edit&lt;br/&gt;代码修改&quot;]
        TST[&quot;test&lt;br/&gt;测试验证&quot;]
    end
    
    subgraph 用户自定义Sub Agents
        USA1[&quot;code-reviewer&lt;br/&gt;代码审查&quot;]
        USA2[&quot;api-developer&lt;br/&gt;API开发&quot;]
    end
    
    U[用户] --&gt;|&quot;简单任务&quot;| EXP
    U --&gt;|&quot;简单任务&quot;| EDT
    U --&gt;|&quot;复杂任务&quot;| USA1
    U --&gt;|&quot;复杂任务&quot;| USA2
    
    USA1 -.-&gt;|&quot;调用内置&quot;| ANA
    USA2 -.-&gt;|&quot;调用内置&quot;| TST
    
    style EXP fill:#e3f2fd
    style ANA fill:#e3f2fd
    style EDT fill:#e3f2fd
    style TST fill:#e3f2fd
    style USA1 fill:#fff3e0
    style USA2 fill:#fff3e0</code></pre>
<h4 id="sub-agent-的调用能力与限制">Sub Agent 的调用能力与限制</h4>
<p><strong>关键限制</strong>：根据 Claude Code 官方文档的明确说明：</p>
<blockquote>
<p><strong>Subagents cannot spawn other subagents. If your workflow requires nested delegation, use Skills or chain subagents from the main conversation.</strong></p>
<p>—— Claude Code 官方文档 §Sub Agents</p>
</blockquote>
<p>这意味着 Sub Agent 的调用能力有严格的边界：</p>
<pre><code class="hljs mermaid">flowchart TB
    subgraph Sub Agent 可以调用
        A1[&quot;✅ 内置 Agents&lt;br/&gt;(explore, analyze 等)&quot;]
        A2[&quot;✅ Skills&lt;br/&gt;(预加载或动态加载)&quot;]
        A3[&quot;✅ MCP 工具&lt;br/&gt;(通过 tools 白名单)&quot;]
    end
    
    subgraph Sub Agent 不能调用
        B1[&quot;❌ 其他 Sub Agents&lt;br/&gt;(用户自定义的)&quot;]
        B2[&quot;❌ 嵌套创建 Sub Agents&quot;]
    end
    
    style A1 fill:#c8e6c9
    style A2 fill:#c8e6c9
    style A3 fill:#c8e6c9
    style B1 fill:#ffcdd2
    style B2 fill:#ffcdd2</code></pre>
<p><strong>正确的调用示例</strong>：</p>
<p>用户自定义的 Sub Agent 可以<strong>调用内置 Agent</strong>来完成子任务。例如：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>name: code-reviewer<br>description: 代码审查专家<br><span class="hljs-section">tools: Read, Grep, Glob, task</span><br><span class="hljs-section">---</span><br><br>作为代码审查专家，执行以下审查流程：<br><br><span class="hljs-bullet">1.</span> 使用内置的 <span class="hljs-code">`explore`</span> Agent 理解代码结构<br><span class="hljs-bullet">2.</span> 使用内置的 <span class="hljs-code">`analyze`</span> Agent 检测潜在问题<br><span class="hljs-bullet">3.</span> 综合分析结果，输出审查报告<br></code></pre></td></tr></table></figure>
<p>这里的 <code>task</code> 工具允许 Sub Agent 启动内置的 <code>explore</code>、<code>analyze</code> 等 Agent。这是一种<strong>委派模式</strong>——Sub Agent 将子任务委派给更专业的内置 Agent。</p>
<p><strong>为什么有这个限制？</strong></p>
<ol>
<li><strong>防止无限递归</strong>：如果 Sub Agent 可以创建 Sub Agent，可能导致失控的嵌套调用</li>
<li><strong>上下文管理</strong>：每个 Sub Agent 都有独立的上下文窗口，嵌套会导致上下文管理复杂度指数级增长</li>
<li><strong>清晰的职责边界</strong>：强制开发者在主对话层面进行任务编排，而非在 Sub Agent 内部隐式编排</li>
</ol>
<p><strong>4. 何时使用内置 vs 自定义</strong></p>
<table>
<thead>
<tr>
<th>场景</th>
<th>推荐</th>
<th>原因</th>
</tr>
</thead>
<tbody>
<tr>
<td>快速浏览代码</td>
<td><code>explore</code></td>
<td>内置优化，无需额外配置</td>
</tr>
<tr>
<td>查找性能问题</td>
<td><code>analyze</code></td>
<td>内置分析工具，结果更准确</td>
</tr>
<tr>
<td>简单的代码修改</td>
<td><code>edit</code></td>
<td>内置的保守修改策略</td>
</tr>
<tr>
<td>项目特定的审查规则</td>
<td>自定义 Sub Agent</td>
<td>需要注入项目规范</td>
</tr>
<tr>
<td>领域专业知识</td>
<td>自定义 Sub Agent + Skill</td>
<td>需要领域知识</td>
</tr>
</tbody>
</table>
<h4 id="sub-agent-的高级特性">Sub Agent 的高级特性</h4>
<p><strong>1. 持久化记忆（Persistent Memory）</strong></p>
<p>Sub Agent 可以拥有跨对话持久化的记忆目录：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>name: code-reviewer<br>description: 代码审查专家<br><span class="hljs-section">memory: project</span><br><span class="hljs-section">---</span><br></code></pre></td></tr></table></figure>
<p><code>memory</code> 字段支持三种作用域：</p>
<table>
<thead>
<tr>
<th>作用域</th>
<th>存储位置</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>user</code></td>
<td><code>~/.claude/agent-memory/&lt;name&gt;/</code></td>
<td>跨项目通用的经验积累</td>
</tr>
<tr>
<td><code>project</code></td>
<td><code>.claude/agent-memory/&lt;name&gt;/</code></td>
<td>项目特定的知识，可提交 Git</td>
</tr>
<tr>
<td><code>local</code></td>
<td><code>.claude/agent-memory-local/&lt;name&gt;/</code></td>
<td>项目特定但不提交 Git</td>
</tr>
</tbody>
</table>
<p>启用记忆后，Sub Agent 的系统提示词中会自动注入记忆目录中 <code>MEMORY.md</code> 的前 200 行内容。这意味着 <strong>Agent 会随着使用越来越&quot;聪明&quot;</strong>——它在审查代码时发现的模式、踩过的坑，都会被记录下来，下次自动参考。</p>
<p><strong>2. Hook 机制——工具调用的拦截与增强（Tool Call Interception &amp; Enhancement）</strong></p>
<p>Sub Agent 支持在工具调用前后执行自定义脚本：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>name: db-reader<br>description: 只读数据库查询专家<br>tools: Bash<br>hooks:<br>  PreToolUse:<br><span class="hljs-bullet">    -</span> matcher: &quot;Bash&quot;<br><span class="hljs-code">      hooks:</span><br><span class="hljs-code">        - type: command</span><br><span class="hljs-code">          command: &quot;./scripts/validate-readonly-query.sh&quot;</span><br><span class="hljs-code">---</span><br></code></pre></td></tr></table></figure>
<p>对应的验证脚本会在每次 Bash 调用前拦截并验证命令内容，只允许 SELECT 查询通过。这实现了比简单的工具白名单更细粒度的权限控制。</p>
<p><strong>3. 预加载 Skills（Preloaded Skills）</strong></p>
<p>Sub Agent 可以声明需要预加载的 Skills：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>name: api-developer<br>description: API 开发专家<br>skills:<br><span class="hljs-bullet">  -</span> api-conventions<br><span class="hljs-section">  - error-handling-patterns</span><br><span class="hljs-section">---</span><br></code></pre></td></tr></table></figure>
<p><code>skills</code> 字段列出的 Skill 的全部内容会被注入到 Sub Agent 的上下文中，使得 Sub Agent 在启动时就具备了特定领域的专业知识。</p>
<h3 id="四种机制的-mece-对比">四种机制的 MECE 对比</h3>
<h4 id="正确的多-agent-协作模式">正确的多 Agent 协作模式</h4>
<p>由于 Sub Agents 不能互相调用，正确的多 Agent 协作模式是<strong>由主对话协调</strong>：</p>
<pre><code class="hljs mermaid">flowchart TB
    U[用户] --&gt; MC[主对话&lt;br/&gt;协调中心]
    
    MC --&gt;|&quot;1. 委派任务&quot;| SA1[Sub Agent A&lt;br/&gt;代码审查]
    SA1 --&gt;|&quot;2. 返回结果&quot;| MC
    
    MC --&gt;|&quot;3. 基于结果委派&quot;| SA2[Sub Agent B&lt;br/&gt;运行测试]
    SA2 --&gt;|&quot;4. 返回结果&quot;| MC
    
    MC --&gt;|&quot;5. 基于结果委派&quot;| SA3[Sub Agent C&lt;br/&gt;生成报告]
    SA3 --&gt;|&quot;6. 返回结果&quot;| MC
    
    MC --&gt;|&quot;7. 汇总结果&quot;| U
    
    style MC fill:#e3f2fd
    style SA1 fill:#fff3e0
    style SA2 fill:#fff3e0
    style SA3 fill:#fff3e0</code></pre>
<p><strong>错误的做法</strong>（Sub Agent 互相调用）：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section">❌ 这不会被支持</span><br><span class="hljs-section">---</span><br>name: code-reviewer<br><span class="hljs-section">tools: Task</span><br><span class="hljs-section">---</span><br>After reviewing, call the test-runner subagent to run tests.<br></code></pre></td></tr></table></figure>
<p><strong>正确的做法</strong>（主对话协调）：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs markdown">✅ 用户指令<br>&quot;Use the code-reviewer subagent to review my changes, <br>then use the test-runner subagent to run tests.&quot;<br><br>执行流程：<br><span class="hljs-bullet">1.</span> 主对话调用 code-reviewer Sub Agent<br><span class="hljs-bullet">2.</span> code-reviewer 返回审查结果<br><span class="hljs-bullet">3.</span> 主对话调用 test-runner Sub Agent  <br><span class="hljs-bullet">4.</span> test-runner 返回测试结果<br><span class="hljs-bullet">5.</span> 主对话汇总并呈现给用户<br></code></pre></td></tr></table></figure>
<h4 id="四层配置体系的完整对比">四层配置体系的完整对比</h4>
<pre><code class="hljs mermaid">flowchart TB
    subgraph 何时加载
        direction LR
        A1[&quot;始终在场&quot;] ---|&quot;←→&quot;| A2[&quot;按需加载&quot;]
        A1 --- A1a[&quot;CLAUDE.md&quot;]
        A2 --- A2a[&quot;Commands / Skills / Sub Agents&quot;]
    end
    
    subgraph 在哪执行
        direction LR
        B1[&quot;主对话上下文&quot;] ---|&quot;←→&quot;| B2[&quot;独立上下文&quot;]
        B1 --- B1a[&quot;CLAUDE.md / Commands / Skills&quot;]
        B2 --- B2a[&quot;Sub Agents&quot;]
    end
    
    subgraph 调用能力
        direction LR
        C1[&quot;可以调用&lt;br/&gt;Sub Agents&quot;] --- C2[&quot;不能调用&lt;br/&gt;Sub Agents&quot;]
        C1 --- C1a[&quot;Commands / Skills / 主对话&quot;]
        C2 --- C2a[&quot;Sub Agents&quot;]
    end</code></pre>
<table>
<thead>
<tr>
<th>维度</th>
<th><a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a></th>
<th>Commands</th>
<th>Skills</th>
<th>Sub Agents</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>加载时机</strong></td>
<td>对话开始自动加载</td>
<td>用户 <code>/</code> 触发</td>
<td>Agent 自动匹配</td>
<td>Agent 委派任务</td>
</tr>
<tr>
<td><strong>执行上下文</strong></td>
<td>主对话</td>
<td>主对话</td>
<td>主对话</td>
<td>独立上下文窗口</td>
</tr>
<tr>
<td><strong>工具权限</strong></td>
<td>继承主对话</td>
<td>继承主对话</td>
<td>继承主对话</td>
<td>独立工具白名单</td>
</tr>
<tr>
<td><strong>持久记忆</strong></td>
<td>不支持</td>
<td>不支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td><strong>调用 Sub Agents</strong></td>
<td>N/A</td>
<td>✅ 可以</td>
<td>✅ 可以</td>
<td>❌ 不能调用其他 Sub Agents<br/>✅ 可以调用内置 Agents</td>
</tr>
<tr>
<td><strong>信息密度</strong></td>
<td>声明式偏好</td>
<td>提示词模板</td>
<td>知识+流程</td>
<td>角色+工具+流程+权限+记忆</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>项目级通用约束</td>
<td>重复性任务标准化</td>
<td>领域专业知识</td>
<td>自包含的独立任务</td>
</tr>
</tbody>
</table>
<p><strong>判断标准</strong>：如果任务需要频繁的用户交互和迭代，用 Skill；如果任务是自包含的、可以独立完成并返回摘要的，用 Sub Agent。</p>
<h4 id="深度理解：skill-vs-sub-agent-的本质区别">深度理解：Skill vs Sub Agent 的本质区别</h4>
<p>为了更深入地理解 Skill 和 Sub Agent 的机制差异，让我们从第一性原理出发，通过问答形式来澄清关键概念。</p>
<p><strong>Q: Skill 和 Sub Agent 在上下文管理上的本质区别是什么？</strong></p>
<p><strong>A</strong>: 核心区别在于<strong>上下文融合（Context Fusion）vs 上下文隔离（Context Isolation）</strong>。</p>
<ul>
<li><strong>Skill（内联融合）</strong>：Skill 的全部内容会被<strong>直接插入</strong>到当前对话的上下文中，成为上下文的一部分。Agent 在<strong>同一个上下文窗口</strong>中继续工作，Skill 不创建新的上下文窗口，只是向现有上下文&quot;注入&quot;信息。这类似于编程中的&quot;宏&quot;（Macro）展开。</li>
</ul>
<pre><code class="hljs mermaid">flowchart TB
    subgraph 主对话上下文窗口
        A[&quot;用户消息&quot;] 
        B[&quot;Agent 思考&quot;]
        C[&quot;Skill 内容&lt;br/&gt;(直接插入上下文)&quot;]
        D[&quot;Agent 继续推理&quot;]
        E[&quot;工具调用&quot;]
    end
    
    C -.-&gt;|&quot;按需加载&lt;br/&gt;成为上下文的一部分&quot;| D
    
    style C fill:#e8f5e9</code></pre>
<ul>
<li><strong>Sub Agent（独立上下文）</strong>：Sub Agent 拥有<strong>完全独立的上下文窗口</strong>，与主对话隔离。主对话只传递任务摘要，Sub Agent 内部的工作过程对主对话<strong>不可见</strong>（黑箱执行）。Sub Agent 完成后只返回<strong>结果摘要</strong>，不返回完整的上下文。这类似于函数调用或服务调用。</li>
</ul>
<pre><code class="hljs mermaid">flowchart TB
    subgraph 主对话上下文[&quot;主对话上下文&quot;]
        A[&quot;用户任务&quot;]
        B[&quot;任务分解决策&quot;]
        C[&quot;委派请求&quot;]
    end
    
    subgraph SubAgent独立上下文[&quot;Sub Agent 独立上下文窗口&quot;]
        D[&quot;接收任务描述&quot;]
        E[&quot;独立推理&quot;]
        F[&quot;独立工具调用&quot;]
        G[&quot;生成结果&quot;]
    end
    
    C --&gt;|&quot;摘要传递&quot;| D
    G --&gt;|&quot;摘要返回&quot;| H[&quot;主对话继续&quot;]
    
    style 主对话上下文 fill:#e8eaf6
    style SubAgent独立上下文 fill:#fff3e0</code></pre>
<p><strong>Q: Sub Agent 可以使用 Skills 吗？</strong></p>
<p><strong>A</strong>: 是的，而且有两种方式。</p>
<p><strong>方式 1：预加载 Skills（启动时注入）</strong></p>
<p>Sub Agent 可以在定义中声明需要预加载的 Skills：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>name: api-developer<br>description: API 开发专家<br>skills:<br><span class="hljs-bullet">  -</span> api-conventions<br><span class="hljs-section">  - error-handling-patterns</span><br><span class="hljs-section">---</span><br></code></pre></td></tr></table></figure>
<p><strong>机制</strong>：Sub Agent 启动时，<code>skills</code> 字段列出的 Skill 的<strong>全部内容</strong>会被注入到 Sub Agent 的<strong>独立上下文窗口</strong>中。这些 Skill 成为 Sub Agent 上下文的<strong>一部分</strong>，在 Sub Agent 的整个生命周期中可用。这是<strong>Sub Agent 内部</strong>的 Skill，与主对话的上下文无关。</p>
<pre><code class="hljs mermaid">flowchart TB
    subgraph SubAgent独立上下文[&quot;Sub Agent 独立上下文窗口&quot;]
        A[&quot;系统提示词&quot;]
        B[&quot;预加载的 Skill 1&lt;br/&gt;(api-conventions)&quot;]
        C[&quot;预加载的 Skill 2&lt;br/&gt;(error-handling)&quot;]
        D[&quot;任务描述&quot;]
        E[&quot;Agent 推理&quot;]
        F[&quot;工具调用&quot;]
    end
    
    B -.-&gt;|&quot;上下文的一部分&quot;| E
    C -.-&gt;|&quot;上下文的一部分&quot;| E
    
    style B fill:#e8f5e9
    style C fill:#e8f5e9</code></pre>
<p><strong>方式 2：运行时动态加载（通过 <code>task</code> 工具调用内置 Agent）</strong></p>
<p>Sub Agent 可以调用内置 Agent（如 <code>explore</code>、<code>analyze</code>），这些内置 Agent 会<strong>自动匹配并加载相关的 Skills</strong>。这是<strong>Sub Agent 主动触发</strong>的 Skill 加载，发生在 Sub Agent 的独立上下文中。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>name: code-reviewer<br>description: 代码审查专家<br><span class="hljs-section">tools: Read, Grep, Glob, task</span><br><span class="hljs-section">---</span><br><br>作为代码审查专家，执行以下审查流程：<br><br><span class="hljs-bullet">1.</span> 使用内置的 <span class="hljs-code">`explore`</span> Agent 理解代码结构<br><span class="hljs-bullet">2.</span> 使用内置的 <span class="hljs-code">`analyze`</span> Agent 检测潜在问题<br><span class="hljs-bullet">3.</span> 综合分析结果，输出审查报告<br></code></pre></td></tr></table></figure>
<p><strong>Q: 如何在编程类比中理解 Skill 和 Sub Agent？</strong></p>
<p><strong>A</strong>:</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>Skill</th>
<th>Sub Agent</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>编程类比</strong></td>
<td>宏（Macro）</td>
<td>函数/服务调用</td>
</tr>
<tr>
<td><strong>上下文位置</strong></td>
<td>内联到当前对话上下文</td>
<td>独立的上下文窗口</td>
</tr>
<tr>
<td><strong>加载时机</strong></td>
<td>Agent 判断需要时按需加载</td>
<td>Sub Agent 启动时预加载 / 运行时调用</td>
</tr>
<tr>
<td><strong>可见性</strong></td>
<td>对当前对话完全可见</td>
<td>对主对话不可见（黑箱）</td>
</tr>
<tr>
<td><strong>隔离性</strong></td>
<td>无隔离，共享上下文</td>
<td>完全隔离</td>
</tr>
<tr>
<td><strong>返回方式</strong></td>
<td>直接返回结果</td>
<td>只返回摘要</td>
</tr>
<tr>
<td><strong>Sub Agent 能否使用</strong></td>
<td>不适用（Skill 是内容）</td>
<td>✅ 可以预加载或动态调用</td>
</tr>
<tr>
<td><strong>调用其他 Sub Agents</strong></td>
<td>N/A</td>
<td>❌ 不能调用其他 Sub Agents<br/>✅ 可以调用内置 Agents</td>
</tr>
</tbody>
</table>
<p><strong>核心洞察</strong>：</p>
<ul>
<li><strong>Skill</strong> 是<strong>内容注入（Content Injection）</strong>（向上下文添加信息）</li>
<li><strong>Sub Agent</strong> 是<strong>执行隔离（Execution Isolation）</strong>（创建独立的执行环境）</li>
<li>Skill 像&quot;把代码内联展开&quot;，Sub Agent 像&quot;调用一个服务&quot;</li>
<li>Sub Agent 可以使用 Skills，但那些 Skill 是在 Sub Agent 的独立上下文中，与主对话无关</li>
<li><strong>Sub Agents 不能互相调用</strong>，多 Agent 协作必须由主对话协调（官方文档明确限制）</li>
<li><strong>Sub Agents 不能互相调用</strong>，多 Agent 协作必须由主对话协调（官方文档明确限制）</li>
</ul>
<p><strong>Q: 什么时候应该用 Skill，什么时候应该用 Sub Agent？</strong></p>
<p><strong>A</strong>: 回到之前的判断标准，但用机制视角重新理解：</p>
<ul>
<li>
<p><strong>用 Skill 的情况</strong>：</p>
<ul>
<li>任务需要频繁的用户交互和迭代</li>
<li>需要领域专业知识</li>
<li>需要在主对话上下文中与用户持续沟通</li>
<li><strong>关键</strong>：期望 Agent &quot;内联&quot;地使用这些知识，保持上下文的连续性</li>
</ul>
</li>
<li>
<p><strong>用 Sub Agent 的情况</strong>：</p>
<ul>
<li>任务是自包含的</li>
<li>可以独立完成并返回摘要</li>
<li>需要独立的上下文窗口</li>
<li>需要独立的工具权限控制</li>
<li>需要持久化记忆</li>
<li><strong>关键</strong>：期望 Agent &quot;隔离&quot;地执行任务，避免污染主对话的上下文</li>
</ul>
</li>
</ul>
<p>这个判断标准背后的<strong>第一性原理</strong>是：<strong>上下文窗口的有限性和注意力退化（Attention Degradation）</strong>。Skill 通过内联注入增加了上下文空间的有效信息密度（Information Density），而 Sub Agent 通过隔离执行从根本上解决了上下文污染问题。选择 Skill 还是 Sub Agent，本质上是在&quot;增加信息密度&quot;和&quot;隔离信息空间&quot;之间做权衡。</p>
<h4 id="组件包含关系全景图">组件包含关系全景图</h4>
<pre><code class="hljs mermaid">graph TB
    subgraph 配置组件
        MD[&quot;CLAUDE.md&lt;br/&gt;项目记忆&quot;]
        CMD[&quot;Commands&lt;br/&gt;参数化触发&quot;]
        SKL[&quot;Skills&lt;br/&gt;知识包&quot;]
        SA[&quot;Sub Agents&lt;br/&gt;独立执行体&quot;]
        PLG[&quot;Plugins&lt;br/&gt;外部工具&quot;]
    end
    
    subgraph SubAgent可包含
        SA_tools[&quot;tools&lt;br/&gt;工具白名单&quot;]
        SA_memory[&quot;memory&lt;br/&gt;持久记忆&quot;]
        SA_hooks[&quot;hooks&lt;br/&gt;工具拦截&quot;]
        SA_skills[&quot;skills&lt;br/&gt;预加载知识&quot;]
    end
    
    subgraph Skill可包含
        SKL_refs[&quot;references/&lt;br/&gt;参考文档目录&quot;]
        SKL_ref_files[&quot;*.md&lt;br/&gt;规范/示例/文档&quot;]
    end
    
    subgraph 独立组件
        IND1[&quot;Commands&lt;br/&gt;独立配置&quot;]
        IND2[&quot;CLAUDE.md&lt;br/&gt;独立配置&quot;]
        IND3[&quot;Plugins&lt;br/&gt;独立部署&quot;]
    end
    
    subgraph Plugin类型
        PLG_mcp[&quot;MCP Servers&lt;br/&gt;标准协议工具&quot;]
        PLG_exec[&quot;可执行程序&lt;br/&gt;命令行工具&quot;]
    end
    
    SA --&gt;|&quot;可以包含&quot;| SA_tools
    SA --&gt;|&quot;可以包含&quot;| SA_memory
    SA --&gt;|&quot;可以包含&quot;| SA_hooks
    SA --&gt;|&quot;可以包含&quot;| SA_skills
    
    SKL --&gt;|&quot;可以包含&quot;| SKL_refs
    SKL_refs --&gt;|&quot;包含&quot;| SKL_ref_files
    
    PLG --&gt;|&quot;包含类型&quot;| PLG_mcp
    PLG --&gt;|&quot;包含类型&quot;| PLG_exec
    
    CMD -.-&gt;|&quot;不包含其他组件&quot;| IND1
    MD -.-&gt;|&quot;不包含其他组件&quot;| IND2
    PLG -.-&gt;|&quot;独立部署&quot;| IND3
    
    SA_tools -.-&gt;|&quot;可以引用&quot;| PLG_mcp
    SA_tools -.-&gt;|&quot;可以引用&quot;| PLG_exec
    
    style MD fill:#e8eaf6
    style CMD fill:#e3f2fd
    style SKL fill:#e8f5e9
    style SA fill:#fff3e0
    style PLG fill:#f3e5f5
    style SA_tools fill:#ffe0b2
    style SA_memory fill:#ffe0b2
    style SA_hooks fill:#ffe0b2
    style SA_skills fill:#ffe0b2
    style SKL_refs fill:#c8e6c9
    style SKL_ref_files fill:#a5d6a7
    style IND1 fill:#ffcdd2
    style IND2 fill:#ffcdd2
    style IND3 fill:#e1bee7
    style PLG_mcp fill:#ce93d8
    style PLG_exec fill:#ce93d8</code></pre>
<p><strong>关键洞察</strong>：</p>
<ul>
<li><strong>Sub Agent</strong> 是最复杂的组件，可以包含 <code>tools</code>（权限控制，Permission Control）、<code>memory</code>（持久化，Persistence）、<code>hooks</code>（工具拦截，Tool Interception）、<code>skills</code>（预加载知识，Preloaded Knowledge）</li>
<li><strong>Skill</strong> 可以包含 <code>references/</code> 目录下的多个参考文档文件</li>
<li><strong>Plugins</strong> 是独立部署的工具，包括 MCP Servers 和可执行程序，可以被 Sub Agent 的 <code>tools</code> 字段引用</li>
<li><strong>Commands</strong> 和 <strong><a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a></strong> 是独立的配置文件，不包含其他组件</li>
</ul>
<p><strong>Plugins 的特殊地位</strong>：</p>
<ul>
<li>Plugins 是唯一需要<strong>独立部署和运行</strong>的组件（其他都是 Markdown 配置文件）</li>
<li>Plugins 提供了<strong>扩展 Agent 能力</strong>的机制，通过 MCP 协议或标准输入输出（Standard I/O）与 Agent 通信</li>
<li>Sub Agent 可以通过 <code>tools</code> 字段声明可用的 Plugins，实现权限控制（Permission Control）</li>
</ul>
<h3 id="四种机制的协同工作">四种机制的协同工作</h3>
<p>以一个完整的场景说明四种机制如何协同：在电商项目中为订单模块添加退款 API。</p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant U as 用户
    participant M as 主 Agent
    participant C as CLAUDE.md
    participant CMD as Command
    participant SK as Skill
    participant SA1 as Sub Agent: reviewer
    participant SA2 as Sub Agent: developer
    
    Note over M,C: 第一层: CLAUDE.md 自动加载
    C--&gt;&gt;M: 项目技术栈、规范、架构信息
    
    Note over U,CMD: 第二层: 用户触发 Command
    U-&gt;&gt;M: /create-api POST /api/v1/orders/&#123;id&#125;/refund
    CMD--&gt;&gt;M: 展开为完整的任务指令
    
    Note over M,SK: 第三层: Skill 自动匹配
    M-&gt;&gt;SK: 加载 api-design Skill
    SK--&gt;&gt;M: REST 规范 + 错误码 + 示例
    
    Note over M,SA2: 第四层: Sub Agent 并行执行
    M-&gt;&gt;SA1: 审查现有退款相关代码(只读权限)
    M-&gt;&gt;SA2: 实现退款 API(读写权限, 预加载 api-conventions Skill)
    SA1--&gt;&gt;M: 审查报告摘要
    SA2--&gt;&gt;M: 实现完成摘要
    
    M-&gt;&gt;U: 综合报告 + 最终结果</code></pre>
<blockquote>
<p><strong><a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a> 提供&quot;我是谁、我在哪&quot;的环境上下文（Environmental Context），Commands 提供&quot;做这件事&quot;的触发入口（Trigger Entry），Skills 提供&quot;怎么做好这件事&quot;的专业知识（Domain Knowledge），Sub Agents 提供&quot;让专人去做&quot;的执行隔离（Execution Isolation）。</strong></p>
</blockquote>
<h3 id="工具扩展层：mcp-协议">工具扩展层：MCP 协议</h3>
<p>前文提到 Agent 通过 JSON Schema 描述工具接口，LLM 基于 Schema 生成结构化的工具调用参数。但在实际的多工具、多环境生态中，一个关键问题浮现：<strong>如何让 Agent 以标准化的方式发现和调用异构的外部工具？</strong></p>
<p>MCP（Model Context Protocol，模型上下文协议）正是为解决这个问题而设计的标准化工具调用协议。它的核心设计原则是：<strong>强制工具提供者以运行时可发现的方式声明自身能力</strong>，而非依赖静态文档。</p>
<h4 id="三层架构">三层架构</h4>
<p>MCP 集成涉及三个职责分离的组件：</p>
<pre><code class="hljs mermaid">flowchart LR
    subgraph Client[&quot;LLM Client (如 Claude Code)&quot;]
        C1[&quot;接收用户自然语言&quot;]
        C2[&quot;调用 tools/list 获取工具定义&quot;]
        C3[&quot;将 Schema + 用户消息发送给 LLM&quot;]
        C4[&quot;执行 tools/call&quot;]
        C5[&quot;将结果回传 LLM&quot;]
    end
    
    subgraph Server[&quot;MCP Server (适配层)&quot;]
        S1[&quot;声明能力 (JSON Schema)&quot;]
        S2[&quot;接收结构化调用&quot;]
        S3[&quot;调用上游 API&quot;]
    end
    
    subgraph Upstream[&quot;上游 API (如 Sentry REST)&quot;]
        U1[&quot;实际业务逻辑&quot;]
    end
    
    Client --&gt;|&quot;JSON-RPC&quot;| Server
    Server --&gt;|&quot;HTTP/SDK&quot;| Upstream
    
    style Client fill:#e3f2fd
    style Server fill:#fff3e0
    style Upstream fill:#e8f5e9</code></pre>
<p>完整交互流程：</p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant U as 用户
    participant Client as LLM Client
    participant MCP as MCP Server
    participant API as 上游 API
    participant LLM as 云端 LLM
    
    U-&gt;&gt;Client: 自然语言请求
    Client-&gt;&gt;MCP: tools/list (JSON-RPC)
    MCP--&gt;&gt;Client: JSON Schema (工具定义)
    Client-&gt;&gt;LLM: Schema + 用户消息
    LLM--&gt;&gt;Client: tool_use 指令
    Client-&gt;&gt;MCP: tools/call (JSON-RPC)
    MCP-&gt;&gt;API: 调用业务逻辑
    API--&gt;&gt;MCP: 返回结果
    MCP--&gt;&gt;Client: JSON 结果
    Client-&gt;&gt;LLM: 调用结果
    LLM--&gt;&gt;Client: 最终回复
    Client--&gt;&gt;U: 自然语言回复
    
    Note over Client,MCP: JSON-RPC 通信
    Note over MCP,API: HTTP/SDK 调用
    Note over Client,LLM: 结构化工具调用</code></pre>
<p>关键澄清：<strong>MCP Server 完全不需要理解自然语言</strong>。它只处理结构化 JSON-RPC 消息，职责是声明能力（Schema）和执行调用。自然语言理解完全由 LLM 负责。</p>
<h4 id="mcp-的能力发现机制">MCP 的能力发现机制</h4>
<p>MCP 服务器必须实现一套标准的 JSON-RPC 方法，Claude 会在连接后自动调用这些方法进行能力协商：</p>
<table>
<thead>
<tr>
<th>阶段</th>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>1. 握手</td>
<td><code>initialize</code></td>
<td>客户端与服务器交换协议版本、能力声明</td>
</tr>
<tr>
<td>2. 能力发现</td>
<td><code>tools/list</code></td>
<td>服务器返回所有可用工具的完整 JSON Schema（名称、描述、参数类型、required 字段等）</td>
</tr>
<tr>
<td>3. 调用</td>
<td><code>tools/call</code></td>
<td>客户端根据 schema 调用具体工具</td>
</tr>
</tbody>
</table>
<p>这个设计使得 MCP 服务器的能力是<strong>运行时可发现</strong>的——客户端无需预先知道服务器提供哪些工具，通过调用 <code>tools/list</code> 即可动态获取。这与传统的 API 集成形成鲜明对比：后者需要基于预先编写的文档或静态配置来了解可用能力。</p>
<p><code>tools/list</code> 返回的 JSON Schema 是 MCP 协议的核心——它不仅描述工具的参数类型，还包含了人类可读的描述（description）。这些描述直接决定了 LLM 如何选择和使用工具，因此工具描述的质量至关重要（后文&quot;工具选择&quot;章节会详细讨论）。</p>
<h4 id="为什么需要-mcp-而非直接使用-openapi">为什么需要 MCP 而非直接使用 OpenAPI</h4>
<p>表面上看，Client 与 MCP Server 之间只是 JSON 输入输出，似乎直接调用带 OpenAPI 文档的 REST API 即可。但 MCP 提供了几个关键的抽象价值（Abstraction Value）：</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>OpenAPI</th>
<th>MCP</th>
<th>差异</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>抽象层级</strong></td>
<td>资源抽象（<code>GET /issues/{id}</code>）</td>
<td>动作抽象（<code>get_issue_details(id)</code>）</td>
<td>LLM 无需理解路径模板、查询参数等传输层细节</td>
</tr>
<tr>
<td><strong>发现方式</strong></td>
<td>静态文档（设计时阅读）</td>
<td>运行时调用 <code>tools/list</code></td>
<td>可根据权限/环境动态返回不同工具集</td>
</tr>
<tr>
<td><strong>生态标准化</strong></td>
<td>每个 API 各自集成</td>
<td>统一接入层</td>
<td>多个 LLM 客户端可复用同一套工具</td>
</tr>
<tr>
<td><strong>交互原语</strong></td>
<td>无标准机制</td>
<td>流式结果、进度通知、操作取消</td>
<td>原生支持有状态交互</td>
</tr>
</tbody>
</table>
<p>类比：OpenAPI 如同每个电器自带不同规格的电源线（两脚/三脚/欧标），MCP 则是 USB-C 标准——所有设备统一接口，主机无需关心设备细节。</p>
<h4 id="mcp-与-rag-graphql-的关系">MCP 与 RAG、GraphQL 的关系</h4>
<ul>
<li><strong>MCP vs RAG</strong>：RAG（Retrieval-Augmented Generation，检索增强生成）是知识增强（向量检索 → 注入上下文 → 只读），MCP 是能力增强（工具调用 → 执行 → 可写）。MCP 可以封装 RAG 作为工具（如定义 <code>search_knowledge_base</code>），但 RAG 无法替代 MCP 的动作执行能力</li>
<li><strong>MCP vs GraphQL</strong>：GraphQL 是查询语言（幂等、无副作用），面向开发者手写查询；MCP 是动作协议（可能有副作用），面向 LLM 自动生成调用。两者都有 Schema 和自省能力（Introspection Capability），但语义目标不同</li>
</ul>
<blockquote>
<p>MCP 的本质是为 LLM 提供标准化的&quot;手&quot;，使其能安全操作外部世界。当面对单一稳定 API 时，MCP 确实显得冗余；但当需要管理多工具、多环境、多客户端的异构生态时，MCP 通过运行时能力发现、传输层解耦和标准化交互原语，提供了不可替代的互操作性价值。</p>
</blockquote>
<h3 id="配置化-vs-编程化：两种构建-agent-的路径">配置化 vs 编程化：两种构建 Agent 的路径</h3>
<p>至此，Markdown 配置体系的四种机制及其工具扩展层已经完整呈现。一个自然的问题是：这种配置化的方式与传统的编程化方式相比，各有什么优劣？</p>
<p>基于 YAML frontmatter 的 Markdown Sub Agent 和基于 Claude Agent SDK 构建的 Agent，代表了构建 Agent 的两条不同路径：<strong>配置化路径</strong>和<strong>编程化路径</strong>。</p>
<h4 id="配置化路径：markdown-sub-agent">配置化路径：Markdown Sub Agent</h4>
<p>这是本文重点讨论的方式，通过在 Markdown 文件中编写 YAML frontmatter 来定义 Agent。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>name: code-reviewer<br>description: 代码审查专家<br>tools: Read, Grep, Glob<br>memory: project<br>skills:<br><span class="hljs-section">  - api-conventions</span><br><span class="hljs-section">---</span><br><br>作为代码审查专家，执行以下审查流程：<br><span class="hljs-bullet">1.</span> 读取待审查的代码文件<br><span class="hljs-bullet">2.</span> 检查代码质量：命名规范、函数长度、复杂度<br><span class="hljs-bullet">3.</span> 检查安全性：SQL 注入、XSS、敏感信息泄露<br>...<br></code></pre></td></tr></table></figure>
<p><strong>核心特点：</strong></p>
<ul>
<li><strong>声明式配置</strong>：用自然语言 + YAML 描述&quot;是什么&quot;和&quot;怎么做&quot;</li>
<li><strong>无需编程</strong>：不需要写代码，只需要写文档</li>
<li><strong>即时生效</strong>：保存文件即可使用，无需编译部署</li>
<li><strong>平台依赖</strong>：依赖于特定平台（Claude Code、Aone Copilot 等）对这些配置的解析</li>
<li><strong>能力受限</strong>：只能使用平台提供的工具和功能</li>
</ul>
<p><strong>适用场景：</strong></p>
<ul>
<li>在 IDE 内开发，需要 AI 辅助编程</li>
<li>定义一个专业角色供团队共享</li>
<li>封装重复性工作流</li>
<li>快速实验和迭代</li>
<li>个人或团队内部使用</li>
</ul>
<h4 id="编程化路径：基于-sdk-构建的-agent">编程化路径：基于 SDK 构建的 Agent</h4>
<p>这是通过编程语言（Python/TypeScript/Java 等）直接调用 Claude API 来构建 Agent 的方式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> anthropic <span class="hljs-keyword">import</span> Anthropic<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CodeReviewerAgent</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, api_key: <span class="hljs-built_in">str</span></span>):<br>        <span class="hljs-variable language_">self</span>.client = Anthropic(api_key=api_key)<br>        <span class="hljs-variable language_">self</span>.memory = []<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">review_code</span>(<span class="hljs-params">self, code: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>        response = <span class="hljs-variable language_">self</span>.client.messages.create(<br>            model=<span class="hljs-string">&quot;claude-sonnet-4-20250514&quot;</span>,<br>            max_tokens=<span class="hljs-number">4096</span>,<br>            system=<span class="hljs-variable language_">self</span>._build_system_prompt(),<br>            messages=[<br>                &#123;<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: <span class="hljs-string">f&quot;请审查以下代码：\n\n<span class="hljs-subst">&#123;code&#125;</span>&quot;</span>&#125;<br>            ]<br>        )<br>        <span class="hljs-keyword">return</span> response.content[<span class="hljs-number">0</span>].text<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_build_system_prompt</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">str</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;&quot;代码审查专家。执行以下审查流程：</span><br><span class="hljs-string">1. 检查代码质量：命名规范、函数长度、复杂度</span><br><span class="hljs-string">2. 检查安全性：SQL 注入、XSS、敏感信息泄露</span><br><span class="hljs-string">...&quot;&quot;&quot;</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">save_to_memory</span>(<span class="hljs-params">self, review: <span class="hljs-built_in">str</span></span>):<br>        <span class="hljs-string">&quot;&quot;&quot;持久化记忆到数据库&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">pass</span><br><br>agent = CodeReviewerAgent(api_key=<span class="hljs-string">&quot;your-key&quot;</span>)<br>result = agent.review_code(<span class="hljs-string">&quot;def foo(): pass&quot;</span>)<br>agent.save_to_memory(result)<br></code></pre></td></tr></table></figure>
<p><strong>核心特点：</strong></p>
<ul>
<li><strong>编程式构建</strong>：用代码实现 Agent 的每一行逻辑</li>
<li><strong>完全控制</strong>：可以精确控制 Agent 的推理流程、工具调用、错误处理</li>
<li><strong>平台无关</strong>：可以集成到任何系统（Web 应用、CI/CD、微服务）</li>
<li><strong>无限扩展</strong>：可以调用任意 API、数据库、外部服务</li>
<li><strong>可部署</strong>：独立部署为服务，提供 API 对外访问</li>
</ul>
<p><strong>适用场景：</strong></p>
<ul>
<li>构建面向最终用户的 AI 产品（如代码审查 SaaS 平台）</li>
<li>需要将 AI 能力集成到现有业务系统</li>
<li>需要 API 对外提供服务</li>
<li>需要复杂的业务逻辑和持久化</li>
<li>需要独立的部署和运维</li>
</ul>
<h4 id="关键对比表">关键对比表</h4>
<table>
<thead>
<tr>
<th>维度</th>
<th>Markdown Sub Agent</th>
<th>SDK Agent</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>构建方式</strong></td>
<td>写 Markdown 文档</td>
<td>写代码（Python/TS/Java）</td>
</tr>
<tr>
<td><strong>入门门槛</strong></td>
<td>低（会写文档即可）</td>
<td>中（需要编程能力）</td>
</tr>
<tr>
<td><strong>部署方式</strong></td>
<td>保存在特定目录</td>
<td>部署为服务/应用</td>
</tr>
<tr>
<td><strong>执行环境</strong></td>
<td>特定 IDE/平台内</td>
<td>任意环境（浏览器、服务器、容器）</td>
</tr>
<tr>
<td><strong>能力范围</strong></td>
<td>平台提供的工具</td>
<td>无限（API、数据库、网络、第三方服务）</td>
</tr>
<tr>
<td><strong>可集成性</strong></td>
<td>仅限平台生态</td>
<td>可集成到任何系统</td>
</tr>
<tr>
<td><strong>定制灵活性</strong></td>
<td>受限于配置字段</td>
<td>完全自定义逻辑</td>
</tr>
<tr>
<td><strong>迭代速度</strong></td>
<td>快（改文档即生效）</td>
<td>中（需重新编译部署）</td>
</tr>
<tr>
<td><strong>维护复杂度</strong></td>
<td>低</td>
<td>中高（代码维护、依赖管理）</td>
</tr>
<tr>
<td><strong>持久化</strong></td>
<td>平台提供的 memory</td>
<td>完全自定义（数据库、文件等）</td>
</tr>
<tr>
<td><strong>权限控制</strong></td>
<td>平台的 tools 白名单</td>
<td>完全自定义权限体系</td>
</tr>
<tr>
<td><strong>错误处理</strong></td>
<td>平台默认处理</td>
<td>完全自定义错误处理</td>
</tr>
<tr>
<td><strong>监控和日志</strong></td>
<td>平台提供</td>
<td>需要自行实现</td>
</tr>
</tbody>
</table>
<h4 id="深度对比：从第一性原理理解">深度对比：从第一性原理理解</h4>
<p><strong>1. 表达能力的差异</strong></p>
<pre><code class="hljs mermaid">flowchart TB
    subgraph 配置化路径
        A1[&quot;YAML frontmatter&quot;] --&gt; A2[&quot;有限的结构化字段&quot;]
        A2 --&gt; A3[&quot;声明式描述&quot;]
        A3 --&gt; A4[&quot;平台解释执行&quot;]
    end
    
    subgraph 编程化路径
        B1[&quot;编程语言&quot;] --&gt; B2[&quot;完整的图灵完备性&quot;]
        B2 --&gt; B3[&quot;命令式逻辑&quot;]
        B3 --&gt; B4[&quot;自定义执行引擎&quot;]
    end
    
    A4 --&gt;|&quot;适用场景：快速配置、标准化&quot;| C[选择配置化]
    B4 --&gt;|&quot;适用场景：复杂逻辑、深度集成&quot;| D[选择编程化]
    
    style A3 fill:#fff3e0
    style B3 fill:#e8f5e9</code></pre>
<ul>
<li><strong>配置化</strong>：通过预定义的字段（name、description、tools、skills 等）表达意图。这种方式<strong>简洁但受限</strong>，适合表达&quot;是什么&quot;和&quot;怎么做&quot;，但难以表达复杂的分支逻辑、异常处理、状态机等。</li>
<li><strong>编程化</strong>：通过编程语言的完整表达能力（条件判断、循环、异常、类、函数等）实现任意逻辑。这种方式<strong>灵活但复杂</strong>，适合实现复杂的业务流程、多轮对话、状态管理等。</li>
</ul>
<p><strong>2. 集成能力的差异</strong></p>
<pre><code class="hljs mermaid">flowchart LR
    subgraph 配置化集成
        A1[&quot;平台工具集&quot;] --&gt; A2[&quot;文件读写&lt;br/&gt;代码搜索&lt;br/&gt;命令执行&quot;]
        A2 --&gt; A3[&quot;有限集成（Limited Integration）&quot;]
    end
    
    subgraph 编程化集成
        B1[&quot;任意集成&quot;] --&gt; B2[&quot;数据库&lt;br/&gt;外部API&lt;br/&gt;消息队列&lt;br/&gt;文件系统&lt;br/&gt;第三方服务&quot;]
        B2 --&gt; B3[&quot;无限集成（Unlimited Integration）&quot;]
    end
    
    style A3 fill:#ffe0b2
    style B3 fill:#c8e6c9</code></pre>
<ul>
<li><strong>配置化</strong>：只能使用平台提供的工具（Read、Grep、Bash 等）。无法直接连接数据库、调用外部 API、发送消息等。</li>
<li><strong>编程化</strong>：可以调用任何 Python/TypeScript/Java 库，连接任何服务，实现任何集成需求。</li>
</ul>
<p><strong>3. 部署和运维的差异</strong></p>
<pre><code class="hljs mermaid">flowchart TB
    subgraph 配置化部署
        A1[&quot;保存文件&quot;] --&gt; A2[&quot;平台自动加载&quot;] --&gt; A3[&quot;立即可用&quot;]
    end
    
    subgraph 编程化部署
        B1[&quot;编写代码&quot;] --&gt; B2[&quot;编译打包&quot;] --&gt; B3[&quot;部署服务&quot;] --&gt; B4[&quot;配置监控&quot;] --&gt; B5[&quot;运维保障&quot;]
    end
    
    A3 --&gt;|&quot;适合：个人/团队内部&lt;br/&gt;快速迭代&quot;| C[配置化]
    B5 --&gt;|&quot;适合：产品化&lt;br/&gt;生产环境&quot;| D[编程化]
    
    style A2 fill:#e8f5e9
    style B3 fill:#fff3e0</code></pre>
<ul>
<li><strong>配置化</strong>：零运维成本，平台负责加载、执行、监控。适合个人和团队内部使用。</li>
<li><strong>编程化</strong>：需要完整的软件工程实践（版本控制、CI/CD、监控、日志、错误追踪、负载均衡等）。适合产品化和生产环境。</li>
</ul>
<h4 id="如何选择">如何选择</h4>
<p><strong>选择配置化路径（Markdown Sub Agent）的场景：</strong></p>
<ol>
<li><strong>需求是&quot;辅助编程（Coding Assistance）“而非&quot;构建产品（Product Building）”</strong>——在 IDE 中开发，需要 AI 帮助写代码、重构、调试；定义一个专业角色供团队成员共享使用</li>
<li><strong>需要快速迭代和实验</strong>——不断调整 Agent 的行为和工作流，不希望每次修改都重新部署</li>
<li><strong>使用场景是团队内部</strong>——不需要对外提供 API，不需要复杂的权限控制和用户管理</li>
<li><strong>不需要深度集成外部系统</strong>——只需要文件读写、代码搜索、命令执行等基础能力</li>
</ol>
<p><strong>选择编程化路径（SDK Agent）的场景：</strong></p>
<ol>
<li><strong>需求是&quot;构建产品（Product Building）“而非&quot;辅助编程（Coding Assistance）”</strong>——开发一个 AI 应用（如代码审查 SaaS、智能客服平台），需要将 AI 能力集成到现有产品中</li>
<li><strong>需要对外提供服务</strong>——提供 REST API 让第三方调用，需要用户认证、权限控制、计费等</li>
<li><strong>需要深度集成业务系统</strong>——连接公司数据库、调用内部 API，与现有业务流程深度集成</li>
<li><strong>需要复杂的功能</strong>——多轮对话、状态管理、工作流引擎、自定义的监控和错误处理</li>
</ol>
<h4 id="混合使用：两全其美的方案">混合使用：两全其美的方案</h4>
<p>实际上，这两种方式并不是互斥的。成熟的 AI 应用往往会采用混合策略：</p>
<pre><code class="hljs mermaid">flowchart TB
    A[用户需求] --&gt; B&#123;是否需要&lt;br/&gt;对外提供服务?&#125;
    B --&gt;|否| C[使用配置化路径&lt;br/&gt;Markdown Sub Agent]
    B --&gt;|是| D&#123;是否需要&lt;br/&gt;复杂集成?&#125;
    D --&gt;|否| E[使用 SDK Agent&lt;br/&gt;简单封装 API]
    D --&gt;|是| F[混合方案&lt;br/&gt;SDK 调用 + 配置化定义]
    
    F --&gt; G[&quot;底层：SDK 实现 API 和集成&quot;]
    F --&gt; H[&quot;上层：配置化定义业务逻辑&quot;]
    
    style C fill:#e8f5e9
    style E fill:#fff3e0
    style F fill:#e1bee7</code></pre>
<p><strong>混合方案示例：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CodeReviewService</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;SDK 层：提供 API 和集成能力&quot;&quot;&quot;</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, claude_api_key: <span class="hljs-built_in">str</span>, db_connection</span>):<br>        <span class="hljs-variable language_">self</span>.client = Anthropic(api_key=claude_api_key)<br>        <span class="hljs-variable language_">self</span>.db = db_connection<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">load_sub_agent_config</span>(<span class="hljs-params">self, agent_name: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">dict</span>:<br>        <span class="hljs-string">&quot;&quot;&quot;从数据库加载 Sub Agent 配置&quot;&quot;&quot;</span><br>        config = <span class="hljs-variable language_">self</span>.db.query(<br>            <span class="hljs-string">&quot;SELECT * FROM agents WHERE name = ?&quot;</span>,<br>            (agent_name,)<br>        )<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-string">&quot;name&quot;</span>: config.name,<br>            <span class="hljs-string">&quot;description&quot;</span>: config.description,<br>            <span class="hljs-string">&quot;system_prompt&quot;</span>: config.system_prompt,<br>            <span class="hljs-string">&quot;tools&quot;</span>: json.loads(config.tools)<br>        &#125;<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">execute_agent</span>(<span class="hljs-params">self, agent_name: <span class="hljs-built_in">str</span>, input_data: <span class="hljs-built_in">str</span></span>):<br>        <span class="hljs-string">&quot;&quot;&quot;执行 Sub Agent&quot;&quot;&quot;</span><br>        config = <span class="hljs-variable language_">self</span>.load_sub_agent_config(agent_name)<br>        response = <span class="hljs-variable language_">self</span>.client.messages.create(<br>            model=<span class="hljs-string">&quot;claude-sonnet-4-20250514&quot;</span>,<br>            system=config[<span class="hljs-string">&quot;system_prompt&quot;</span>],<br>            messages=[&#123;<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: input_data&#125;]<br>        )<br>        <span class="hljs-keyword">return</span> response.content[<span class="hljs-number">0</span>].text<br></code></pre></td></tr></table></figure>
<p>这种混合方案结合了两者的优势：</p>
<ul>
<li><strong>SDK 层</strong>：提供稳定的 API、数据库集成、认证授权、监控日志</li>
<li><strong>配置化层</strong>：让非程序员也能通过 UI 或 API 动态定义和修改 Agent，无需重新部署</li>
</ul>
<h4 id="模式提炼：配置化-vs-编程化">模式提炼：配置化 vs 编程化</h4>
<p><strong>模式公式</strong>：<code>选择 = f(是否产品化 × 集成复杂度 × 迭代速度需求)</code></p>
<p><strong>迁移表</strong>：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>推荐路径</th>
<th>理由</th>
</tr>
</thead>
<tbody>
<tr>
<td>个人开发辅助</td>
<td>配置化</td>
<td>快速迭代，无需部署</td>
</tr>
<tr>
<td>团队共享 Agent</td>
<td>配置化</td>
<td>简单易用，通过 Git 协作</td>
</tr>
<tr>
<td>AI 辅助插件</td>
<td>编程化</td>
<td>需要深度集成 IDE</td>
</tr>
<tr>
<td>代码审查 SaaS</td>
<td>编程化</td>
<td>需要用户体系、计费、监控</td>
</tr>
<tr>
<td>内部 AI 平台</td>
<td>混合</td>
<td>SDK 提供平台能力，配置化让用户自定义</td>
</tr>
<tr>
<td>CI/CD 集成</td>
<td>混合</td>
<td>SDK 接入 CI 系统，配置化定义审查规则</td>
</tr>
</tbody>
</table>
<p><strong>核心洞察</strong>：配置化和编程化不是对立的，而是互补的。配置化路径适合&quot;快速定义和使用&quot;，编程化路径适合&quot;深度集成和产品化&quot;。理解两者的区别，才能在合适的场景选择合适的工具。</p>
<hr>
<h3 id="更广泛的视角-rules-和-specs">更广泛的视角:Rules 和 Specs</h3>
<p>在不同的 AI 编码平台中，还存在 <code>Rules</code> 和 <code>Specs</code> 这样的概念。它们本质上是对上述体系的变体或补充。</p>
<h4 id="rules：claude-md-的跨平台等价物">Rules：<a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a> 的跨平台等价物</h4>
<table>
<thead>
<tr>
<th>平台</th>
<th>配置文件</th>
</tr>
</thead>
<tbody>
<tr>
<td>Claude Code</td>
<td><code>CLAUDE.md</code></td>
</tr>
<tr>
<td>Cursor</td>
<td><code>.cursorrules</code></td>
</tr>
<tr>
<td>Windsurf</td>
<td><code>.windsurfrules</code></td>
</tr>
<tr>
<td>GitHub Copilot</td>
<td><code>.github/copilot-instructions.md</code></td>
</tr>
<tr>
<td>Aone Copilot</td>
<td>Skills (<code>SKILL.md</code>)</td>
</tr>
</tbody>
</table>
<p>不同的名字，相同的本质：告诉 Agent 所处的环境和应该遵循的规范。如果项目需要支持多个 AI 编码工具，可以维护一份核心规范文档，然后通过符号链接或脚本同步到各平台的配置文件中。</p>
<h4 id="specs：面向任务的需求文档">Specs：面向任务的需求文档</h4>
<p>Specs 与上述所有机制都不同。它们不是 Agent 的&quot;行为定义&quot;，而是 Agent 工作时需要参考的&quot;需求文档&quot;——API 设计规格、数据库 schema 说明、产品需求文档等。</p>
<pre><code class="hljs mermaid">flowchart LR
    subgraph Agent行为定义
        A[CLAUDE.md / Rules]
        B[Commands]
        C[Skills]
        D[Sub Agents]
    end
    
    subgraph 任务需求
        E[Specs / 需求文档]
    end
    
    Agent行为定义 --&gt;|&quot;定义 Agent 怎么工作&quot;| F[Agent]
    任务需求 --&gt;|&quot;定义 Agent 要完成什么&quot;| F</code></pre>
<h4 id="模式提炼：分层配置">模式提炼：分层配置</h4>
<p><strong>模式公式</strong>：<code>Agent 配置 = 环境上下文(始终) + 触发入口(按需) + 专业知识(按需) + 执行隔离(按需)</code></p>
<p><strong>迁移表</strong>：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>环境层</th>
<th>触发层</th>
<th>知识层</th>
<th>执行层</th>
</tr>
</thead>
<tbody>
<tr>
<td>个人项目</td>
<td>简单的 <a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a></td>
<td>不需要</td>
<td>不需要</td>
<td>不需要</td>
</tr>
<tr>
<td>团队项目</td>
<td>详细的 <a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a></td>
<td>常用 Commands</td>
<td>领域 Skills</td>
<td>审查 Sub Agent</td>
</tr>
<tr>
<td>大型企业项目</td>
<td>分层 <a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a></td>
<td>标准化 Commands</td>
<td>多领域 Skills</td>
<td>多角色 Sub Agents</td>
</tr>
<tr>
<td>开源项目</td>
<td>贡献者指南</td>
<td>PR 模板 Command</td>
<td>代码风格 Skill</td>
<td>CI 审查 Sub Agent</td>
</tr>
</tbody>
</table>
<p><strong>核心洞察</strong>：当听到&quot;Agent 不遵循项目规范&quot;时，问题往往不在 Agent 的能力，而在于规范没有被正确地放入 Agent 的上下文中。分层配置体系的核心价值是：确保正确的信息在正确的时机出现在 Agent 的上下文中。</p>
<hr>
<h2 id="实操方法论：从原理到实践">实操方法论：从原理到实践</h2>
<p>理解了第一性原理和配置体系之后，接下来是最关键的部分：如何在日常工作中高效地使用 Agentic Coding。</p>
<pre><code class="hljs mermaid">flowchart TB
    subgraph 实操方法论
        A[对话管理] --&gt; B[知识沉淀]
        B --&gt; C[工程约束]
        C --&gt; D[AI 友好设计]
        D --&gt; E[刻意练习]
    end
    
    F[&quot;第一性原理&quot;] --&gt;|&quot;指导&quot;| 实操方法论
    G[&quot;配置体系&quot;] --&gt;|&quot;支撑&quot;| 实操方法论
    
    style A fill:#e3f2fd
    style B fill:#e8f5e9
    style C fill:#fff3e0
    style D fill:#fce4ec
    style E fill:#f3e5f5</code></pre>
<h3 id="对话管理：短对话优于长对话">对话管理：短对话优于长对话</h3>
<p>这是从上下文窗口约束直接推导出的最重要的实操原则。</p>
<h4 id="为什么长对话会失败">为什么长对话会失败</h4>
<pre><code class="hljs mermaid">flowchart TB
    A[&quot;开始: 新对话&lt;br/&gt;上下文清晰&quot;] --&gt; B[&quot;第5轮: 上下文开始积累&lt;br/&gt;仍然高效&quot;]
    B --&gt; C[&quot;第15轮: 上下文大量积累&lt;br/&gt;注意力开始分散&quot;]
    C --&gt; D[&quot;第25轮: Lost in the Middle&lt;br/&gt;Agent 开始遗忘早期信息&quot;]
    D --&gt; E[&quot;第35轮: 上下文污染严重&lt;br/&gt;Agent 可能前后矛盾&quot;]
    E --&gt; F[&quot;第45轮: 接近上下文上限&lt;br/&gt;性能急剧下降&quot;]
    
    style A fill:#c8e6c9
    style B fill:#dcedc8
    style C fill:#fff9c4
    style D fill:#ffe0b2
    style E fill:#ffccbc
    style F fill:#ffcdd2</code></pre>
<p>Agent 的表现与对话长度之间存在一个&quot;中间区域&quot;的性能退化：</p>
<ul>
<li><strong>简单任务</strong>（1-5 轮）：表现优异，上下文清晰</li>
<li><strong>中等任务</strong>（5-15 轮）：表现良好，但需要注意上下文管理</li>
<li><strong>复杂任务</strong>（15+ 轮）：表现开始退化，需要主动干预</li>
<li><strong>超长对话</strong>（30+ 轮）：高风险区域，建议拆分为多次对话</li>
</ul>
<h4 id="任务分解策略">任务分解策略</h4>
<p>面对复杂任务，核心策略是<strong>分解为多个短对话</strong>，每个对话完成一个独立的子任务：</p>
<pre><code class="hljs mermaid">flowchart TB
    A[&quot;复杂任务:&lt;br/&gt;重构订单模块&quot;] --&gt; B[&quot;拆分&quot;]
    
    B --&gt; C[&quot;对话1: 分析现有代码结构&lt;br/&gt;输出: 架构分析文档&quot;]
    B --&gt; D[&quot;对话2: 设计新的领域模型&lt;br/&gt;输入: 架构分析文档&lt;br/&gt;输出: 领域模型定义&quot;]
    B --&gt; E[&quot;对话3: 实现核心实体&lt;br/&gt;输入: 领域模型定义&lt;br/&gt;输出: 实体代码&quot;]
    B --&gt; F[&quot;对话4: 迁移服务层&lt;br/&gt;输入: 实体代码&lt;br/&gt;输出: 服务层代码&quot;]
    B --&gt; G[&quot;对话5: 编写测试&lt;br/&gt;输入: 服务层代码&lt;br/&gt;输出: 测试代码&quot;]
    
    C --&gt; D
    D --&gt; E
    E --&gt; F
    F --&gt; G
    
    style C fill:#e3f2fd
    style D fill:#e3f2fd
    style E fill:#e3f2fd
    style F fill:#e3f2fd
    style G fill:#e3f2fd</code></pre>
<p>每个对话之间的&quot;接力&quot;通过以下方式实现：</p>
<ol>
<li><strong>文件系统</strong>：前一个对话的输出（代码文件）自然成为下一个对话的输入</li>
<li><strong><a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a></strong>：在 <a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a> 中记录当前工作进度和决策</li>
<li><strong>Memory</strong>：利用 Sub Agent 的持久记忆跨对话传递经验</li>
</ol>
<h4 id="何时开始新对话的判断标准">何时开始新对话的判断标准</h4>
<pre><code class="hljs mermaid">flowchart TB
    A&#123;Agent 是否开始&lt;br/&gt;重复之前的搜索?&#125; --&gt;|是| NEW[开始新对话]
    A --&gt;|否| B&#123;Agent 的回复是否&lt;br/&gt;与之前矛盾?&#125;
    B --&gt;|是| NEW
    B --&gt;|否| C&#123;当前任务是否&lt;br/&gt;已经完成一个里程碑?&#125;
    C --&gt;|是| NEW
    C --&gt;|否| D&#123;对话是否已经&lt;br/&gt;超过 15 轮?&#125;
    D --&gt;|是| NEW
    D --&gt;|否| E[继续当前对话]
    
    style NEW fill:#e3f2fd
    style E fill:#c8e6c9</code></pre>
<h3 id="知识沉淀：从会话记忆到持久记忆">知识沉淀：从会话记忆到持久记忆</h3>
<p>Agentic Coding 中最容易被忽视的一个维度是<strong>知识的沉淀与复用</strong>。每次与 Agent 的对话都会产生有价值的知识——项目的隐性约定、踩过的坑、有效的解决方案——但如果这些知识只存在于对话历史中，它们会随着对话的结束而消失。</p>
<h4 id="知识沉淀的三个层次">知识沉淀的三个层次</h4>
<pre><code class="hljs mermaid">flowchart TB
    subgraph 层次1[&quot;第一层: 会话内记忆&quot;]
        A1[&quot;上下文窗口中的信息&quot;]
        A2[&quot;生命周期: 单次对话&quot;]
        A3[&quot;容量: 有限&quot;]
    end
    
    subgraph 层次2[&quot;第二层: 项目级记忆&quot;]
        B1[&quot;CLAUDE.md / Rules&quot;]
        B2[&quot;生命周期: 项目存续期&quot;]
        B3[&quot;容量: 中等(需精炼)&quot;]
    end
    
    subgraph 层次3[&quot;第三层: 持久化记忆&quot;]
        C1[&quot;Sub Agent Memory&quot;]
        C2[&quot;生命周期: 跨项目/跨对话&quot;]
        C3[&quot;容量: 较大(文件系统)&quot;]
    end
    
    层次1 --&gt;|&quot;手动提炼&quot;| 层次2
    层次2 --&gt;|&quot;自动积累&quot;| 层次3
    
    style 层次1 fill:#ffecb3
    style 层次2 fill:#c8e6c9
    style 层次3 fill:#b3e5fc</code></pre>
<h4 id="经验复利效应">经验复利效应</h4>
<p>知识沉淀的真正价值在于<strong>复利效应</strong>。每一次修复、每一次审查、每一次教训都在为未来投资：</p>
<pre><code class="hljs mermaid">flowchart LR
    A[&quot;第1次: 手动告诉 Agent&lt;br/&gt;&#x27;这个项目用 Result 包装返回值&#x27;&quot;] --&gt; B[&quot;沉淀到 CLAUDE.md&quot;]
    B --&gt; C[&quot;第2次: Agent 自动遵循&lt;br/&gt;无需再次提醒&quot;]
    C --&gt; D[&quot;第3次: Agent 在审查中&lt;br/&gt;主动指出不符合规范的代码&quot;]
    D --&gt; E[&quot;第N次: Agent 基于积累的经验&lt;br/&gt;主动提出改进建议&quot;]
    
    style A fill:#ffecb3
    style B fill:#dcedc8
    style C fill:#c8e6c9
    style D fill:#a5d6a7
    style E fill:#81c784</code></pre>
<p>具体的沉淀实践：</p>
<p><strong>1. 及时更新 <a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a></strong></p>
<p>每当发现 Agent 犯了一个&quot;本不该犯&quot;的错误时，问自己：这个信息是否应该写入 <a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a>？</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># CLAUDE.md 中的经验沉淀示例</span><br><br><span class="hljs-section"># 已知陷阱</span><br><span class="hljs-bullet">-</span> 订单状态机不允许从 CANCELLED 回到 PAID，见 OrderStateMachine.java<br><span class="hljs-bullet">-</span> Redis 缓存的 key 前缀必须包含环境标识，如 prod:order:123<br><span class="hljs-bullet">-</span> 不要使用 @Transactional(readOnly=true) 在写操作方法上<br></code></pre></td></tr></table></figure>
<p><strong>2. 利用 Memory 机制</strong></p>
<p>对于 Sub Agent，启用 <code>memory</code> 字段后，Agent 会自动将工作中发现的模式和教训记录到 <code>MEMORY.md</code> 中：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># MEMORY.md (由 code-reviewer Sub Agent 自动维护)</span><br><br><span class="hljs-section">## 发现的模式</span><br><span class="hljs-bullet">-</span> 该项目倾向于使用 Builder 模式构造复杂对象<br><span class="hljs-bullet">-</span> 异常处理统一在 GlobalExceptionHandler 中，不要在 Service 层 catch<br><br><span class="hljs-section">## 踩过的坑</span><br><span class="hljs-bullet">-</span> PR #234: 变量命名不一致导致审查遗漏<br><span class="hljs-bullet">-</span> PR #241: 缺少空指针检查导致生产事故<br></code></pre></td></tr></table></figure>
<p><strong>3. 将经验编码为 Skills</strong></p>
<p>当某类问题反复出现时，将解决方案编码为 Skill：</p>
<pre><code class="hljs mermaid">flowchart TB
    A[&quot;问题反复出现:&lt;br/&gt;&#x27;如何正确处理分布式事务?&#x27;&quot;] --&gt; B[&quot;提炼为 Skill&quot;]
    B --&gt; C[&quot;distributed-transaction Skill&quot;]
    C --&gt; D[&quot;包含:&lt;br/&gt;- 事务模式选择决策树&lt;br/&gt;- Saga 模式实现模板&lt;br/&gt;- 补偿逻辑示例&lt;br/&gt;- 常见陷阱清单&quot;]
    D --&gt; E[&quot;下次遇到类似问题&lt;br/&gt;Agent 自动加载 Skill&quot;]</code></pre>
<h3 id="工程约束：用代码而非文字约束-agent">工程约束：用代码而非文字约束 Agent</h3>
<p>这是一个反直觉但极其重要的原则：<strong>工程约束比 Prompt 指令更可靠</strong>。</p>
<p>Agent 有时会试图走捷径，绕过 Prompt 中设定的规则。与其在 Prompt 中反复强调&quot;不要跳过测试&quot;，不如用工程手段来强制执行。</p>
<h4 id="借助-linters-formatters-和-git-hooks">借助 Linters、Formatters 和 Git Hooks</h4>
<pre><code class="hljs mermaid">flowchart TB
    A[&quot;Agent 尝试提交代码&quot;] --&gt; B[&quot;pre-commit hook 拦截&quot;]
    B --&gt; C&#123;类型检查通过?&#125;
    C --&gt;|否| D[&quot;拒绝提交&lt;br/&gt;Agent 必须修复类型错误&quot;]
    C --&gt;|是| E&#123;Lint 检查通过?&#125;
    E --&gt;|否| F[&quot;拒绝提交&lt;br/&gt;Agent 必须修复 Lint 错误&quot;]
    E --&gt;|是| G&#123;测试通过?&#125;
    G --&gt;|否| H[&quot;拒绝提交&lt;br/&gt;Agent 必须修复测试&quot;]
    G --&gt;|是| I[&quot;允许提交&quot;]
    
    style D fill:#ffcdd2
    style F fill:#ffcdd2
    style H fill:#ffcdd2
    style I fill:#c8e6c9</code></pre>
<p>一个典型的 pre-commit hook：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment"># .git/hooks/pre-commit</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Running type check...&quot;</span><br>npm run typecheck || <span class="hljs-built_in">exit</span> 1<br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Running linter...&quot;</span><br>npm run lint || <span class="hljs-built_in">exit</span> 1<br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Running tests...&quot;</span><br>npm <span class="hljs-built_in">test</span> || <span class="hljs-built_in">exit</span> 1<br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;All checks passed!&quot;</span><br></code></pre></td></tr></table></figure>
<h4 id="拦截-agent-的-偷懒-行为">拦截 Agent 的&quot;偷懒&quot;行为</h4>
<p>Agent 有时会发现测试一直失败后，尝试使用 <code>--no-verify</code> 绕过 pre-commit hook。解决方案是用一个 git 命令 wrapper 脚本拦截这种行为：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">$ git commit --no-verify</span><br><span class="hljs-section">------------------------------------------------------------------</span><br><span class="hljs-section">ERROR: Commit Rejected.</span><br><span class="hljs-section">------------------------------------------------------------------</span><br><br>GUIDANCE FOR THE AI AGENT:<br>You have attempted to bypass the required pre-commit verification.<br>All code must pass quality checks before it can be committed.<br><br><span class="hljs-section">DO NOT BYPASS THE CHECKS. YOU MUST FIX THE UNDERLYING ERRORS.</span><br><span class="hljs-section">------------------------------------------------------------------</span><br></code></pre></td></tr></table></figure>
<p>这个技巧的本质是：<strong>把对 Agent 的指导嵌入到工具的输出中</strong>。Agent 会读取命令执行的结果，所以错误信息本身就是最好的 Prompt 注入点。</p>
<pre><code class="hljs mermaid">flowchart LR
    A[&quot;Prompt 指令:&lt;br/&gt;&#x27;不要跳过测试&#x27;&quot;] --&gt;|&quot;Agent 可能忽略&quot;| B[&quot;效果不稳定&quot;]
    C[&quot;工程约束:&lt;br/&gt;pre-commit hook&quot;] --&gt;|&quot;Agent 无法绕过&quot;| D[&quot;效果稳定&quot;]
    E[&quot;工具输出中的指导:&lt;br/&gt;错误信息包含修复建议&quot;] --&gt;|&quot;Agent 必然读取&quot;| F[&quot;效果最佳&quot;]
    
    style B fill:#ffcdd2
    style D fill:#c8e6c9
    style F fill:#a5d6a7</code></pre>
<h4 id="模式提炼：工程约束优于提示">模式提炼：工程约束优于提示</h4>
<p><strong>模式公式</strong>：<code>可靠性 = 工程强制(hook/lint/CI) &gt; 工具输出引导(错误信息) &gt; Prompt 指令(文字约束)</code></p>
<p><strong>迁移表</strong>：</p>
<table>
<thead>
<tr>
<th>约束需求</th>
<th>Prompt 方式</th>
<th>工程方式</th>
<th>推荐</th>
</tr>
</thead>
<tbody>
<tr>
<td>代码风格</td>
<td>“请遵循 ESLint 规范”</td>
<td><code>.eslintrc</code> + pre-commit hook</td>
<td>工程</td>
</tr>
<tr>
<td>测试执行与覆盖</td>
<td>“请确保测试通过并达到覆盖率”</td>
<td>CI pipeline + 覆盖率门禁</td>
<td>工程</td>
</tr>
<tr>
<td>提交规范</td>
<td>“请写好 commit message”</td>
<td>commitlint + husky</td>
<td>工程</td>
</tr>
<tr>
<td>安全检查</td>
<td>“请注意 SQL 注入”</td>
<td>SAST 工具 + pre-commit</td>
<td>工程</td>
</tr>
<tr>
<td>架构约束</td>
<td>“请遵循分层架构”</td>
<td>ArchUnit 测试</td>
<td>工程</td>
</tr>
</tbody>
</table>
<p><strong>核心洞察</strong>：当听到&quot;Agent 总是不遵守规范&quot;时，首先应该检查的不是 Prompt 是否写得够清楚，而是是否有工程手段来强制执行。每当 Agent 发明新的&quot;偷懒&quot;方式，就需要堵上这个漏洞——但总体来说，工程约束比 Prompt 指令更可靠。</p>
<h3 id="ai-友好设计：对人难的事-对-ai-也难">AI 友好设计：对人难的事，对 AI 也难</h3>
<p>有一个简单但常被忽视的事实：<strong>如果一个任务对人类开发者来说很难，那么它对当前的 AI 来说大概率也很难。</strong> 这个推论的深远意义在于：所有能提升人类开发者体验的工作，对 AI 同样有价值。</p>
<pre><code class="hljs mermaid">flowchart TB
    A[&quot;对人难的事&lt;br/&gt;对 AI 也难&quot;] --&gt; B[&quot;文档缺失&quot;]
    A --&gt; C[&quot;架构混乱&quot;]
    A --&gt; D[&quot;测试缓慢&quot;]
    A --&gt; E[&quot;错误信息模糊&quot;]
    
    B --&gt; B1[&quot;人: 花大量时间读源码猜意图&lt;br/&gt;AI: 反复搜索, 消耗上下文, 可能理解错误&quot;]
    C --&gt; C1[&quot;人: 不知道该改哪里&lt;br/&gt;AI: 改错文件, 遗漏同步修改&quot;]
    D --&gt; D1[&quot;人: 倾向于跳过测试&lt;br/&gt;AI: 等待超时, 浪费上下文&quot;]
    E --&gt; E1[&quot;人: 需要额外调试&lt;br/&gt;AI: 盲目搜索, 效率低下&quot;]
    
    style A fill:#fff3e0</code></pre>
<h4 id="双重投资回报">双重投资回报</h4>
<p>当投资于更好的文档、更清晰的架构、更快的测试时，获得的回报是双倍的：</p>
<pre><code class="hljs mermaid">flowchart LR
    subgraph 投资
        A[&quot;更好的文档&quot;]
        B[&quot;更清晰的架构&quot;]
        C[&quot;更快的测试&quot;]
        D[&quot;更好的错误信息&quot;]
    end
    
    subgraph 回报
        E[&quot;人类开发者更高效&quot;]
        F[&quot;AI 助手更高效&quot;]
    end
    
    A --&gt; E
    A --&gt; F
    B --&gt; E
    B --&gt; F
    C --&gt; E
    C --&gt; F
    D --&gt; E
    D --&gt; F
    
    style E fill:#c8e6c9
    style F fill:#b3e5fc</code></pre>
<p><strong>更好的文档</strong>：好的文档不仅帮助新人上手，也帮助 AI 快速建立正确的心智模型。架构决策记录（ADR）解释&quot;为什么这样设计&quot;，避免 AI 做出违背设计意图的修改。API 使用示例比纯粹的类型定义更有效。已知陷阱和常见错误直接告诉 AI 什么不该做。</p>
<p><strong>更清晰的代码结构</strong>：清晰的命名（<code>processUserData()</code> 而非 <code>doStuff()</code>）、单一职责（一个做一件事的函数）、显式依赖（依赖注入而非全局变量）——这些对 AI 的帮助和对人类一样大。</p>
<p><strong>更快的反馈循环</strong>：这可能是最容易被低估的一点。Agent Loop 的每一轮都需要等待工具执行完成。秒级的单元测试让 Agent 可以频繁验证、快速迭代；快速的增量构建让改动能立即得到反馈。</p>
<h4 id="专门为-ai-设计的优化">专门为 AI 设计的优化</h4>
<p>反过来的推论并不总是成立：对人来说简单的事，对 AI 未必简单。有时候需要专门为 AI 设计工具和接口。</p>
<p><strong>1. LLM 需要专门的信息架构</strong></p>
<p>LLM 是在现有的 CLI 工具上训练的，但这些工具是为人类设计的。需要为 Agent 增强这些工具，提供对 LLM 更有用的上下文：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在 .zshrc 中添加，帮助 Agent 快速定位</span><br><span class="hljs-function"><span class="hljs-title">command_not_found_handler</span></span>() &#123;<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;zsh: command not found: &#x27;<span class="hljs-variable">$1</span>&#x27;&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;zsh: current directory is <span class="hljs-variable">$PWD</span>&quot;</span><br>    <span class="hljs-built_in">return</span> 127<br>&#125;<br></code></pre></td></tr></table></figure>
<p>很多命令行工具都提供了 <code>--json</code> 或 <code>--porcelain</code> 选项，在给 Agent 使用的工具中优先使用这些格式——人类喜欢格式化的输出，但 AI 更擅长解析结构化数据。</p>
<p><strong>2. API 设计：在信息量和上下文消耗之间取得平衡</strong></p>
<p>为 Agent 设计工具接口时，需要在两个目标之间取得平衡：提供足够的信息（减少工具调用次数）和避免填满上下文（不要返回过多无关信息）。</p>
<p>一个好的实践是：提供便捷函数和底层函数两套 API，并通过工具描述引导 Agent 优先使用便捷函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_global_variable_at</span>(<span class="hljs-params">address: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">dict</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    获取指定地址的全局变量值。自动识别类型并返回最佳字符串表示。</span><br><span class="hljs-string">    这是读取全局变量的首选方法。</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 智能的、高层的实现</span><br>    ...<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">data_read_byte</span>(<span class="hljs-params">address: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    读取指定地址的 1 字节值。</span><br><span class="hljs-string">    仅在 get_global_variable_at 失败时使用此函数。</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 底层的、更通用的实现</span><br>    ...<br></code></pre></td></tr></table></figure>
<p><strong>3. 显式优于隐式</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 有状态的 API: AI 需要跟踪隐含状态变化</span><br>client.connect()<br>client.authenticate(user, password)<br>client.query(<span class="hljs-string">&quot;SELECT * FROM users&quot;</span>)<br><br><span class="hljs-comment"># 无状态的 API: AI 更容易正确使用</span><br>result = db.query(<br>    connection=&#123;<span class="hljs-string">&quot;host&quot;</span>: host, <span class="hljs-string">&quot;port&quot;</span>: port&#125;,<br>    auth=&#123;<span class="hljs-string">&quot;user&quot;</span>: user, <span class="hljs-string">&quot;password&quot;</span>: password&#125;,<br>    sql=<span class="hljs-string">&quot;SELECT * FROM users&quot;</span><br>)<br></code></pre></td></tr></table></figure>
<p><strong>4. 结构化的错误信息</strong></p>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs subunit"># 对人足够，对 AI 可能困惑<br><span class="hljs-keyword">Error: </span>Something went wrong. Please try again later.<br><br># 对 AI 更友好<br><span class="hljs-keyword">Error </span>[AUTH_TOKEN_EXPIRED]: Token expired at 2024<span class="hljs-string">-01</span><span class="hljs-string">-15</span>T10:30:00Z.<br>Call refreshToken() to obtain a new token. See: docs/auth.md#token-refresh<br></code></pre></td></tr></table></figure>
<h4 id="顺应-agent-的统计直觉">顺应 Agent 的统计直觉</h4>
<p>一个更微妙的发现：AI 认为合理的代码结构和命名，可能和人类的直觉不一致。</p>
<p>Agent 的命名&quot;直觉&quot;来自训练数据中学习到的概率分布。例如，<code>present()</code> 是 Flutter 等框架中双缓冲交换的常见命名，对于 Agent 来说是&quot;最可能&quot;的名字。当开发者用自己的命名 <code>swapScreens()</code> 覆盖它时，实际上是在对抗 Agent 的统计直觉——Agent 不能再从权重中找到答案，它必须记住人类的特殊习惯。</p>
<pre><code class="hljs mermaid">flowchart TB
    A[&quot;Agent 的统计直觉:&lt;br/&gt;present() 是双缓冲交换的常见命名&quot;] --&gt; B&#123;开发者干预?&#125;
    B --&gt;|&quot;改为 swapScreens()&quot;| C[&quot;Agent 后续反复寻找 present()&lt;br/&gt;找不到后才找到 swapScreens()&lt;br/&gt;浪费 token 和时间&quot;]
    B --&gt;|&quot;保留 present()&quot;| D[&quot;Agent 后续直接找到&lt;br/&gt;高效继续工作&quot;]
    
    style C fill:#ffcdd2
    style D fill:#c8e6c9</code></pre>
<p>实用的权衡策略：</p>
<ol>
<li><strong>不要过度干预</strong>：如果频繁地因为&quot;觉得这个名字更好&quot;而覆盖 Agent 的决策，可能反而在降低效率</li>
<li><strong>注意&quot;找不到&quot;的信号</strong>：如果 Agent 反复在某个地方&quot;找不到&quot;东西，考虑是否是命名和它的预期不一致</li>
<li><strong>拥抱常见模式</strong>：使用广泛使用的设计模式和命名约定，AI 的训练数据中更可能包含这些</li>
<li><strong>模块级的风格隔离</strong>：在 Agent 主导开发的模块中，可以考虑让 Agent 保持它自己的风格</li>
</ol>
<h4 id="模式提炼：统计直觉对齐">模式提炼：统计直觉对齐</h4>
<p><strong>模式公式</strong>：<code>Agent 效率 ∝ 代码库命名与训练数据统计分布的对齐程度</code></p>
<p><strong>迁移表</strong>：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>人类偏好</th>
<th>Agent 统计偏好</th>
<th>推荐策略</th>
</tr>
</thead>
<tbody>
<tr>
<td>函数命名</td>
<td>团队自定义术语</td>
<td>业界通用术语</td>
<td>优先使用通用术语</td>
</tr>
<tr>
<td>设计模式</td>
<td>自创模式</td>
<td>标准 GoF 模式</td>
<td>优先使用标准模式</td>
</tr>
<tr>
<td>文件布局</td>
<td>团队约定</td>
<td>框架默认布局</td>
<td>在 <a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a> 中明确说明</td>
</tr>
<tr>
<td>错误处理</td>
<td>自定义异常体系</td>
<td>标准异常体系</td>
<td>在 Skills 中提供映射</td>
</tr>
</tbody>
</table>
<p><strong>核心洞察</strong>：当听到&quot;Agent 总是用错误的方式做事&quot;时，考虑是否是项目的约定与 Agent 的统计直觉不一致。解决方案不是反复纠正 Agent，而是要么对齐约定，要么在 <a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a> 中显式说明。</p>
<h3 id="刻意练习：像学乐器一样学习-ai">刻意练习：像学乐器一样学习 AI</h3>
<p>为什么有些人说&quot;AI 对我不起作用&quot;，而另一些人却能用 AI 完成大量的工作？</p>
<p>这个问题需要区分来看。如果只在公司的大型私有代码库中使用过 AI，体验可能确实不好——那些代码库可能有古老的架构和专有模式，AI 的训练数据中根本没有这些。但关键问题是：有没有在个人项目中尝试过 AI？有没有进行刻意的、有意识的练习？</p>
<pre><code class="hljs mermaid">flowchart TB
    A[&quot;刻意练习的五个维度&quot;] --&gt; B[&quot;创造干净的实验环境&quot;]
    A --&gt; C[&quot;从失败中提取教训&quot;]
    A --&gt; D[&quot;观察和模仿高手&quot;]
    A --&gt; E[&quot;建立肌肉记忆&quot;]
    A --&gt; F[&quot;持续投入时间&quot;]
    
    B --&gt; B1[&quot;启动个人项目&lt;br/&gt;没有历史包袱&quot;]
    C --&gt; C1[&quot;Prompt 是否清晰?&lt;br/&gt;上下文是否充分?&lt;br/&gt;任务是否过大?&quot;]
    D --&gt; D1[&quot;关注公开分享工作流的开发者&lt;br/&gt;复制他们的技巧&quot;]
    E --&gt; E1[&quot;何时开始新对话?&lt;br/&gt;如何组织复杂 Prompt?&lt;br/&gt;哪种工具组合最有效?&quot;]
    F --&gt; F1[&quot;每天 30 分钟&lt;br/&gt;坚持几个月&lt;br/&gt;远超每周一次几小时&quot;]</code></pre>
<p>AI 工具就像一件乐器。那些从 AI 中获益最多的人，都投入了刻意练习。他们不会因为一次失败就下结论说&quot;它不行&quot;，然后假设这将是常态体验。他们会实验、会失败、会从失败中学习。</p>
<p><strong>从失败中提取教训的检查清单</strong>：</p>
<ul>
<li>Prompt 是否足够清晰？</li>
<li>是否提供了足够的上下文？</li>
<li>是否在一个对话里塞了太多任务？</li>
<li>这个错误是否揭示了 AI 的某个系统性弱点？</li>
<li>是否应该将这个教训沉淀到 <a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a> 或 Skills 中？</li>
</ul>
<p>每次失败都是一次学习机会。把它记录下来，下次避免同样的陷阱。</p>
<hr>
<h2 id="本质洞察：从-编写程序-到-编写职位描述">本质洞察：从&quot;编写程序&quot;到&quot;编写职位描述&quot;</h2>
<p>回到最初的问题：为什么一份 Markdown 就能定义一个智能体？</p>
<p>要回答这个问题，首先需要理解 Agent 与传统自动化（脚本、工作流引擎、CI/CD Pipeline）的本质区别。</p>
<h3 id="agent-与传统自动化的本质区别">Agent 与传统自动化的本质区别</h3>
<p>传统自动化是<strong>确定性的流程执行</strong>：给定输入 A，永远产出输出 B。每一个分支、每一个异常处理、每一个边界情况，都必须由开发者预先编码。而 Agent 是<strong>自主性的目标追求</strong>：给定一个目标描述，Agent 自行决定如何达成，包括选择工具、规划步骤、处理意外情况。</p>
<pre><code class="hljs mermaid">flowchart TB
    subgraph 传统自动化
        S1[&quot;预定义流程&quot;] --&gt; S2[&quot;步骤 1&quot;]
        S2 --&gt; S3&#123;&quot;条件判断&lt;br/&gt;(预编码)&quot;&#125;
        S3 --&gt;|分支A| S4[&quot;步骤 2a&quot;]
        S3 --&gt;|分支B| S5[&quot;步骤 2b&quot;]
        S4 --&gt; S6[&quot;步骤 3&quot;]
        S5 --&gt; S6
        S6 --&gt; S7&#123;&quot;异常?&lt;br/&gt;(预编码)&quot;&#125;
        S7 --&gt;|是| S8[&quot;预定义的错误处理&quot;]
        S7 --&gt;|否| S9[&quot;完成&quot;]
    end
    
    subgraph Agent
        A1[&quot;目标描述&quot;] --&gt; A2[&quot;LLM 推理:&lt;br/&gt;分析当前状态&quot;]
        A2 --&gt; A3[&quot;自主选择工具&quot;]
        A3 --&gt; A4[&quot;观察结果&quot;]
        A4 --&gt; A5&#123;&quot;目标达成?&lt;br/&gt;(LLM 判断)&quot;&#125;
        A5 --&gt;|否| A6[&quot;调整策略&quot;]
        A6 --&gt; A2
        A5 --&gt;|是| A7[&quot;完成&quot;]
    end
    
    style S1 fill:#e8eaf6
    style A1 fill:#e8f5e9
    style S3 fill:#e8eaf6
    style A5 fill:#e8f5e9</code></pre>
<table>
<thead>
<tr>
<th>维度</th>
<th>传统自动化</th>
<th>Agent</th>
</tr>
</thead>
<tbody>
<tr>
<td>流程定义</td>
<td>开发者预编码所有路径</td>
<td>LLM 实时推理决定路径</td>
</tr>
<tr>
<td>异常处理</td>
<td>只能处理预见的异常</td>
<td>可以尝试处理未预见的情况</td>
</tr>
<tr>
<td>适应性</td>
<td>输入格式变化即失败</td>
<td>可以理解语义等价的不同表述</td>
</tr>
<tr>
<td>可预测性</td>
<td>完全确定性</td>
<td>概率性（同样的输入可能不同输出）</td>
</tr>
<tr>
<td>适用场景</td>
<td>确定性、高频、安全关键</td>
<td>不确定性、需要推理、需要灵活性</td>
</tr>
</tbody>
</table>
<p>这个区别的核心在于<strong>自主性</strong>（Autonomy）。传统脚本的&quot;智能&quot;完全来自编写者的预见性——编写者预见了多少种情况，脚本就能处理多少种情况。Agent 的&quot;智能&quot;来自 LLM 的泛化能力——即使面对训练数据中未直接出现的情况，也能通过组合已知模式来尝试解决。</p>
<p>但自主性是一把双刃剑：它带来了灵活性，也带来了不可预测性。这就是为什么本文讨论的所有工程实践——Git hooks、类型检查、测试、<a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a> 约束——本质上都是在<strong>为 Agent 的自主性设置安全边界</strong>。</p>
<h3 id="从-编程-到-编写职位描述">从&quot;编程&quot;到&quot;编写职位描述&quot;</h3>
<p>理解了 Agent 的自主性本质后，&quot;为什么 Markdown 就够了&quot;这个问题就有了清晰的答案。</p>
<p>LLM 改变了&quot;智能&quot;的供给方式。在传统范式下，智能需要被<strong>编程</strong>——用代码一行一行地告诉计算机如何思考。在 LLM 范式下，智能是<strong>预训练好的</strong>——模型已经具备了通用的推理、规划和执行能力，只需要用自然语言告诉它&quot;你是谁、该做什么、不该做什么&quot;。</p>
<pre><code class="hljs mermaid">flowchart LR
    subgraph 传统范式
        A1[&quot;开发者&lt;br/&gt;(编程能力)&quot;] --&gt; A2[&quot;编写代码&lt;br/&gt;(编译部署)&quot;] --&gt; A3[&quot;Agent&lt;br/&gt;(运行)&quot;]
    end
    
    subgraph LLM范式
        B1[&quot;任何人&lt;br/&gt;(表达能力)&quot;] --&gt; B2[&quot;编写文档&lt;br/&gt;(.md 文件)&quot;] --&gt; B3[&quot;Agent&lt;br/&gt;(即时生效)&quot;]
    end
    
    style A1 fill:#e8eaf6
    style B1 fill:#e8f5e9</code></pre>
<table>
<thead>
<tr>
<th>维度</th>
<th>传统范式</th>
<th>LLM 范式</th>
</tr>
</thead>
<tbody>
<tr>
<td>创建者</td>
<td>程序员</td>
<td>任何能清晰表达的人</td>
</tr>
<tr>
<td>载体</td>
<td>代码</td>
<td>文档</td>
</tr>
<tr>
<td>生效方式</td>
<td>编译部署</td>
<td>保存即生效</td>
</tr>
<tr>
<td>迭代速度</td>
<td>天级别</td>
<td>秒级别</td>
</tr>
<tr>
<td>门槛</td>
<td>会编程 + 会部署</td>
<td>会写文档</td>
</tr>
</tbody>
</table>
<p>这就是为什么定义一个 Agent 的过程，从&quot;编写程序&quot;变成了&quot;编写职位描述&quot;。而 Markdown，恰好是编写职位描述的最佳格式。</p>
<p>但这并不意味着&quot;随便写写就行&quot;。正如一份好的职位描述需要精确地定义岗位职责、能力要求、工作流程和权限边界，一份好的 Agent 定义也需要精心设计：</p>
<ul>
<li><strong>关注点分离</strong>：<a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a> 管环境、Commands 管触发、Skills 管知识、Sub Agents 管执行</li>
<li><strong>最小权限原则</strong>：Sub Agent 的 <code>tools</code> 白名单和 Hook 机制确保每个 Agent 只能做它该做的事</li>
<li><strong>上下文隔离</strong>：Sub Agent 的独立上下文窗口防止信息泄漏和上下文污染</li>
<li><strong>渐进式复杂度</strong>：从简单的 <a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a> 到复杂的带 Hook 的 Sub Agent，根据需要选择合适的抽象层级</li>
</ul>
<hr>
<h2 id="模式速查表">模式速查表</h2>
<table>
<thead>
<tr>
<th>听到的需求关键词</th>
<th>对应模式</th>
<th>方案</th>
<th>口诀</th>
</tr>
</thead>
<tbody>
<tr>
<td>“AI 给了错误答案”</td>
<td>概率性推理</td>
<td>检查上下文是否充分，补充 <a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a></td>
<td>垃圾进垃圾出</td>
</tr>
<tr>
<td>“Agent 做了很多无用功”</td>
<td>感知-行动循环</td>
<td>用 Commands/Skills 减少摸索轮次</td>
<td>预定义工作流</td>
</tr>
<tr>
<td>“Agent 总是选错工具”</td>
<td>Agent 决策机制</td>
<td>优化工具描述，明确适用场景和区别</td>
<td>好描述胜过多工具</td>
</tr>
<tr>
<td>“Agent 陷入死循环”</td>
<td>Agent 决策机制</td>
<td>在错误输出中嵌入修复指导</td>
<td>工具输出即 Prompt</td>
</tr>
<tr>
<td>“Agent 声称修好了但没修好”</td>
<td>Agent 决策机制</td>
<td>依赖工程验证而非 Agent 自我评估</td>
<td>测试胜过自述</td>
</tr>
<tr>
<td>“复杂任务 Agent 做不好”</td>
<td>Agent 决策机制</td>
<td>拆分为 Sub Agent，每个子任务独立上下文</td>
<td>分而治之</td>
</tr>
<tr>
<td>“长对话中 Agent 越来越差”</td>
<td>上下文即工作记忆</td>
<td>拆分为多个短对话，使用 Sub Agent</td>
<td>短对话优于长对话</td>
</tr>
<tr>
<td>“Agent 不遵循项目规范”</td>
<td>分层配置</td>
<td>将规范写入 <a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a> 或 Skills</td>
<td>信息在正确时机出现</td>
</tr>
<tr>
<td>“不知道规范该写在哪一层”</td>
<td>三层提示机制</td>
<td>L1 安全/L2 项目/L3 任务，各司其职</td>
<td>内核-配置-输入分离</td>
</tr>
<tr>
<td>“需要集成多个外部工具”</td>
<td>MCP 协议</td>
<td>通过 MCP Server 标准化工具接入</td>
<td>USB-C 统一接口</td>
</tr>
<tr>
<td>“每次都要重复告诉 Agent”</td>
<td>知识外化</td>
<td>沉淀到 <a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a> / Memory / Skills</td>
<td>写一次用无数次</td>
</tr>
<tr>
<td>“改了文档/架构后 Agent 更好用了”</td>
<td>双重投资回报</td>
<td>持续投资开发者体验</td>
<td>帮人也帮 AI</td>
</tr>
<tr>
<td>“Agent 总是跳过测试”</td>
<td>工程约束优于提示</td>
<td>用 Git hooks / CI 强制执行</td>
<td>代码约束不可绕过</td>
</tr>
<tr>
<td>“Agent 总是用错误的命名”</td>
<td>统计直觉对齐</td>
<td>使用通用命名，或在 <a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a> 中说明</td>
<td>顺应而非对抗</td>
</tr>
</tbody>
</table>
<pre><code class="hljs mermaid">flowchart TB
    subgraph 模式组合示例
        A[&quot;大型项目重构&quot;] --&gt; B[&quot;分层配置&lt;br/&gt;+ 上下文隔离&lt;br/&gt;+ 知识外化&quot;]
        C[&quot;日常功能开发&quot;] --&gt; D[&quot;感知-行动循环&lt;br/&gt;+ 分层配置&lt;br/&gt;+ 双重投资回报&quot;]
        E[&quot;代码质量治理&quot;] --&gt; F[&quot;工程约束优于提示&lt;br/&gt;+ 统计直觉对齐&lt;br/&gt;+ 知识外化&quot;]
    end</code></pre>
<hr>
<h2 id="总结">总结</h2>
<p>AI 正在以惊人的速度发展。本文讨论的许多&quot;限制&quot;——上下文窗口的约束、会话间的失忆、中间区域的性能退化——很可能在未来几年内被大幅改善。但这并不意味着应该等待那一天的到来。</p>
<p>恰恰相反，正是这个充满限制的阶段，给了工程师极大的探索和成长空间。那些现在就开始深入理解 LLM 工作原理、积极实践最佳方法、在限制中寻找创造性解决方案的人，将在 AI 能力进一步释放时获得最大的杠杆效应。</p>
<p>从第一性原理理解 LLM 的本质，理解它们如何&quot;思考&quot;、如何受到上下文的限制、如何在 Agent Loop 中发挥作用——这些知识不会随着具体工具的迭代而过时。无论使用的是哪个 Coding Agent，无论模型如何更新换代，这些基础原理都将帮助更好地与 AI 协作。</p>
<p>而 Markdown 配置体系的分层设计——<a target="_blank" rel="noopener" href="http://CLAUDE.md">CLAUDE.md</a> 管环境、Commands 管触发、Skills 管知识、Sub Agents 管执行——这种关注点分离的思想，同样具有跨平台、跨时代的迁移价值。更进一步，理解三层提示机制（System Prompt 定内核、项目配置定规范、用户输入定任务）如何各司其职，理解 MCP 协议如何像 USB-C 一样标准化工具接入，这些认知框架将帮助在任何 AI 平台上快速建立有效的工作模式。</p>
<p>这个范式转换带来的深远影响是：<strong>Agent 的创建门槛从&quot;会编程&quot;降低到了&quot;会写文档&quot;。</strong> 任何能清晰描述一个工作流程的人——产品经理、项目经理、领域专家——都有能力定义一个专业的 AI 智能体。而对于程序员来说，理解这套 Markdown 配置体系的分层设计，就像理解 DDD 的战略设计一样重要——它决定了能否有效地组织和管理一个由多个 AI Agent 协作的复杂工作流。</p>
<p>去实验，去失败，去学习。像学习乐器一样学习 AI。这个过程本身，就是价值所在。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://magicliang.github.io">magicliang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://magicliang.github.io/2026/02/09/%E5%BD%93%E6%99%BA%E8%83%BD%E4%BD%93%E5%8F%98%E6%88%90%E4%B8%80%E4%BB%BD-Markdown-%E6%96%87%E6%A1%A3/">https://magicliang.github.io/2026/02/09/%E5%BD%93%E6%99%BA%E8%83%BD%E4%BD%93%E5%8F%98%E6%88%90%E4%B8%80%E4%BB%BD-Markdown-%E6%96%87%E6%A1%A3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/AI/">AI</a><a class="post-meta__tags" href="/tags/Agent/">Agent</a><a class="post-meta__tags" href="/tags/LLM/">LLM</a><a class="post-meta__tags" href="/tags/Agentic-Coding/">Agentic Coding</a><a class="post-meta__tags" href="/tags/Claude-Code/">Claude Code</a><a class="post-meta__tags" href="/tags/Prompt-Engineering/">Prompt Engineering</a></div><div class="post-share"><div class="social-share" data-image="/img/wall-paper-106.jpg" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2018/02/20/%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" title="推荐算法笔记"><img class="cover" src="/img/wall-paper-62.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-02-20</div><div class="info-item-2">推荐算法笔记</div></div><div class="info-2"><div class="info-item-1">分类的话： 用户画像算法 用户画像算法、聚类算法 分类算法： gbtd、随机森林 识别完了看哪个变量更重要。要有可解释性。 价格相关数据：体现在什么方面？一定要跟收入密切相关的。要对数据和业务的理解很重要。 分类项目：部分已知，有一部分训练集，用未知的和已知的做一个比较。打标签。寻找标签里最重要的因素。 gbtd（底层是很多决策树）。svm。dnn。可能解释性那么强。 决策树。xgbox。 输出是：分类的概率。 聚类项目：完全未知，从数据本身来发现特征。k-means。层次聚类。 输出是：不同类别的特征。 要理解商业逻辑。 </div></div></div></a><a class="pagination-related" href="/2024/11/01/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%9B%B8%E5%85%B3/" title="大模型相关"><img class="cover" src="/2024/11/01/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%9B%B8%E5%85%B3/%E5%A4%A7%E6%A8%A1%E5%9E%8B.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-01</div><div class="info-item-2">大模型相关</div></div><div class="info-2"><div class="info-item-1">世界线  大模型发展.xmind   RNN的雏形可以追溯到90年代Jeffrey L.Elman的经典文章：Finding Structure in Time（1990） 2013年Google提出的Word2Vec可能是最为人熟知的Embedding技术之一 Encoder-Decoder架构来自论文：Learning Phrase Representations using RNN Encoder-Decoder for Statistical Machine Translation（2014） 注意力机制参考论文：Neural Machine Translation by Jointly Learning to Align and Translate（2014） LLM的技术发展和相互关系：Harnessing the Power of LLMs in Practice: A Survey on ChatGPT and Beyond（2023） Transformer出自一篇经典论文：Attention Is All You Need（2017） 国外模型的对比可以参考大...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">当智能体变成一份 Markdown 文档</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E6%99%AF%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE"><span class="toc-number">1.1.</span> <span class="toc-text">全景思维导图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%80%BB%E8%A7%88"><span class="toc-number">1.2.</span> <span class="toc-text">模式总览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%80%A7%E5%8E%9F%E7%90%86%EF%BC%9A%E7%90%86%E8%A7%A3-agentic-coding-%E7%9A%84%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91"><span class="toc-number">1.3.</span> <span class="toc-text">第一性原理：理解 Agentic Coding 的底层逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#llm-%E7%9A%84%E6%9C%AC%E8%B4%A8%EF%BC%9A%E6%A6%82%E7%8E%87%E6%80%A7%E6%96%87%E6%9C%AC%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-number">1.3.1.</span> <span class="toc-text">LLM 的本质：概率性文本生成器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%8F%90%E7%82%BC%EF%BC%9A%E6%A6%82%E7%8E%87%E6%80%A7%E6%8E%A8%E7%90%86"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">模式提炼：概率性推理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#agent-loop%EF%BC%9A%E6%84%9F%E7%9F%A5-%E6%8E%A8%E7%90%86-%E8%A1%8C%E5%8A%A8%E7%9A%84%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.3.2.</span> <span class="toc-text">Agent Loop：感知-推理-行动的循环</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%8F%90%E7%82%BC%EF%BC%9A%E6%84%9F%E7%9F%A5-%E8%A1%8C%E5%8A%A8%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">模式提炼：感知-行动循环</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5-agent-loop%EF%BC%9A%E5%86%B3%E7%AD%96-%E6%8E%A8%E7%90%86%E4%B8%8E%E5%A4%B1%E8%B4%A5"><span class="toc-number">1.3.3.</span> <span class="toc-text">深入 Agent Loop：决策、推理与失败</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#agent-%E7%9A%84%E5%86%B3%E7%AD%96%E8%BF%87%E7%A8%8B%EF%BC%9Areact-%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">Agent 的决策过程：ReAct 模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E5%85%B7%E9%80%89%E6%8B%A9%EF%BC%9Aagent-%E5%A6%82%E4%BD%95%E5%86%B3%E5%AE%9A-%E7%94%A8%E5%93%AA%E4%B8%AA%E5%B7%A5%E5%85%B7"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">工具选择：Agent 如何决定&quot;用哪个工具&quot;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E5%AE%8C%E6%88%90%E5%88%A4%E6%96%AD%EF%BC%9Aagent-%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93-%E5%81%9A%E5%AE%8C%E4%BA%86"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">任务完成判断：Agent 如何知道&quot;做完了&quot;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#agent-%E7%9A%84%E8%A7%84%E5%88%92%E8%83%BD%E5%8A%9B%EF%BC%9A%E4%BB%BB%E5%8A%A1%E5%88%86%E8%A7%A3"><span class="toc-number">1.3.3.4.</span> <span class="toc-text">Agent 的规划能力：任务分解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#agent-%E7%9A%84%E5%B8%B8%E8%A7%81%E5%A4%B1%E8%B4%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.3.5.</span> <span class="toc-text">Agent 的常见失败模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%8F%90%E7%82%BC%EF%BC%9Aagent-%E5%86%B3%E7%AD%96%E6%9C%BA%E5%88%B6"><span class="toc-number">1.3.3.6.</span> <span class="toc-text">模式提炼：Agent 决策机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AA%97%E5%8F%A3%EF%BC%9Aagent-%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BF%86"><span class="toc-number">1.3.4.</span> <span class="toc-text">上下文窗口：Agent 的工作记忆</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AA%97%E5%8F%A3%E7%9A%84%E4%B8%89%E4%B8%AA%E5%85%B3%E9%94%AE%E7%89%B9%E6%80%A7"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">上下文窗口的三个关键特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E7%9A%84%E6%A0%B8%E5%BF%83%E7%AD%96%E7%95%A5"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">上下文管理的核心策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%8F%90%E7%82%BC%EF%BC%9A%E4%B8%8A%E4%B8%8B%E6%96%87%E5%8D%B3%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BF%86"><span class="toc-number">1.3.4.3.</span> <span class="toc-text">模式提炼：上下文即工作记忆</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#markdown-%E9%85%8D%E7%BD%AE%E4%BD%93%E7%B3%BB%EF%BC%9A%E7%94%A8%E6%96%87%E6%A1%A3%E5%AE%9A%E4%B9%89%E6%99%BA%E8%83%BD%E4%BD%93"><span class="toc-number">1.4.</span> <span class="toc-text">Markdown 配置体系：用文档定义智能体</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E6%99%AF%E8%A7%86%E8%A7%92%EF%BC%9A%E4%B8%89%E5%B1%82%E6%8F%90%E7%A4%BA%E6%9C%BA%E5%88%B6"><span class="toc-number">1.4.1.</span> <span class="toc-text">全景视角：三层提示机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E5%B1%82%E4%B8%BA%E4%BD%95%E4%B8%8D%E8%83%BD%E4%BA%92%E7%9B%B8%E6%9B%BF%E4%BB%A3"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">三层为何不能互相替代</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E5%B1%82%E5%8D%8F%E5%90%8C%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">三层协同示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#claude-md%EF%BC%9A%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BF%86%E4%B8%8E%E8%A1%8C%E4%B8%BA%E7%BA%A6%E6%9D%9F"><span class="toc-number">1.4.2.</span> <span class="toc-text">CLAUDE.md：项目记忆与行为约束</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B1%82%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">分层加载机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#claude-md-%E7%9A%84%E5%86%85%E5%AE%B9%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">CLAUDE.md 的内容结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E7%AC%AC%E4%B8%80%E6%80%A7%E5%8E%9F%E7%90%86%E7%90%86%E8%A7%A3-claude-md-%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">从第一性原理理解 CLAUDE.md 的设计</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#commands%EF%BC%9A%E5%8F%82%E6%95%B0%E5%8C%96%E7%9A%84%E6%8F%90%E7%A4%BA%E8%AF%8D%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.4.3.</span> <span class="toc-text">Commands：参数化的提示词模板</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#command-%E7%9A%84%E5%AE%9A%E4%B9%89%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">Command 的定义结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#command-%E4%B8%8E%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">Command 与上下文的关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#skills%EF%BC%9A%E5%8F%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E7%9F%A5%E8%AF%86%E5%8C%85"><span class="toc-number">1.4.4.</span> <span class="toc-text">Skills：可复用的知识包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#skill-%E7%9A%84%E5%AE%8C%E6%95%B4%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">Skill 的完整结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#skill-%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">Skill 的加载机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#skills-%E4%B8%8E-claude-md-%E7%9A%84%E5%88%86%E5%B7%A5"><span class="toc-number">1.4.4.3.</span> <span class="toc-text">Skills 与 CLAUDE.md 的分工</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sub-agents%EF%BC%9A%E7%8B%AC%E7%AB%8B%E6%89%A7%E8%A1%8C%E7%9A%84%E4%B8%93%E4%B8%9A%E8%A7%92%E8%89%B2"><span class="toc-number">1.4.5.</span> <span class="toc-text">Sub Agents：独立执行的专业角色</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sub-agent-%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.4.5.1.</span> <span class="toc-text">Sub Agent 的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E7%9A%84%E9%BB%98%E8%AE%A4-sub-agents"><span class="toc-number">1.4.5.2.</span> <span class="toc-text">内置的默认 Sub Agents</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sub-agent-%E7%9A%84%E8%B0%83%E7%94%A8%E8%83%BD%E5%8A%9B%E4%B8%8E%E9%99%90%E5%88%B6"><span class="toc-number">1.4.5.3.</span> <span class="toc-text">Sub Agent 的调用能力与限制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sub-agent-%E7%9A%84%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7"><span class="toc-number">1.4.5.4.</span> <span class="toc-text">Sub Agent 的高级特性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E7%A7%8D%E6%9C%BA%E5%88%B6%E7%9A%84-mece-%E5%AF%B9%E6%AF%94"><span class="toc-number">1.4.6.</span> <span class="toc-text">四种机制的 MECE 对比</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%A4%9A-agent-%E5%8D%8F%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.6.1.</span> <span class="toc-text">正确的多 Agent 协作模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E5%B1%82%E9%85%8D%E7%BD%AE%E4%BD%93%E7%B3%BB%E7%9A%84%E5%AE%8C%E6%95%B4%E5%AF%B9%E6%AF%94"><span class="toc-number">1.4.6.2.</span> <span class="toc-text">四层配置体系的完整对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E7%90%86%E8%A7%A3%EF%BC%9Askill-vs-sub-agent-%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.6.3.</span> <span class="toc-text">深度理解：Skill vs Sub Agent 的本质区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E5%8C%85%E5%90%AB%E5%85%B3%E7%B3%BB%E5%85%A8%E6%99%AF%E5%9B%BE"><span class="toc-number">1.4.6.4.</span> <span class="toc-text">组件包含关系全景图</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E7%A7%8D%E6%9C%BA%E5%88%B6%E7%9A%84%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C"><span class="toc-number">1.4.7.</span> <span class="toc-text">四种机制的协同工作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%85%B7%E6%89%A9%E5%B1%95%E5%B1%82%EF%BC%9Amcp-%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.4.8.</span> <span class="toc-text">工具扩展层：MCP 协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84"><span class="toc-number">1.4.8.1.</span> <span class="toc-text">三层架构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mcp-%E7%9A%84%E8%83%BD%E5%8A%9B%E5%8F%91%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="toc-number">1.4.8.2.</span> <span class="toc-text">MCP 的能力发现机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-mcp-%E8%80%8C%E9%9D%9E%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8-openapi"><span class="toc-number">1.4.8.3.</span> <span class="toc-text">为什么需要 MCP 而非直接使用 OpenAPI</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mcp-%E4%B8%8E-rag-graphql-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.4.8.4.</span> <span class="toc-text">MCP 与 RAG、GraphQL 的关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E5%8C%96-vs-%E7%BC%96%E7%A8%8B%E5%8C%96%EF%BC%9A%E4%B8%A4%E7%A7%8D%E6%9E%84%E5%BB%BA-agent-%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="toc-number">1.4.9.</span> <span class="toc-text">配置化 vs 编程化：两种构建 Agent 的路径</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E5%8C%96%E8%B7%AF%E5%BE%84%EF%BC%9Amarkdown-sub-agent"><span class="toc-number">1.4.9.1.</span> <span class="toc-text">配置化路径：Markdown Sub Agent</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E5%8C%96%E8%B7%AF%E5%BE%84%EF%BC%9A%E5%9F%BA%E4%BA%8E-sdk-%E6%9E%84%E5%BB%BA%E7%9A%84-agent"><span class="toc-number">1.4.9.2.</span> <span class="toc-text">编程化路径：基于 SDK 构建的 Agent</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AF%B9%E6%AF%94%E8%A1%A8"><span class="toc-number">1.4.9.3.</span> <span class="toc-text">关键对比表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E5%AF%B9%E6%AF%94%EF%BC%9A%E4%BB%8E%E7%AC%AC%E4%B8%80%E6%80%A7%E5%8E%9F%E7%90%86%E7%90%86%E8%A7%A3"><span class="toc-number">1.4.9.4.</span> <span class="toc-text">深度对比：从第一性原理理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9"><span class="toc-number">1.4.9.5.</span> <span class="toc-text">如何选择</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E4%BD%BF%E7%94%A8%EF%BC%9A%E4%B8%A4%E5%85%A8%E5%85%B6%E7%BE%8E%E7%9A%84%E6%96%B9%E6%A1%88"><span class="toc-number">1.4.9.6.</span> <span class="toc-text">混合使用：两全其美的方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%8F%90%E7%82%BC%EF%BC%9A%E9%85%8D%E7%BD%AE%E5%8C%96-vs-%E7%BC%96%E7%A8%8B%E5%8C%96"><span class="toc-number">1.4.9.7.</span> <span class="toc-text">模式提炼：配置化 vs 编程化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E5%B9%BF%E6%B3%9B%E7%9A%84%E8%A7%86%E8%A7%92-rules-%E5%92%8C-specs"><span class="toc-number">1.4.10.</span> <span class="toc-text">更广泛的视角:Rules 和 Specs</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#rules%EF%BC%9Aclaude-md-%E7%9A%84%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%AD%89%E4%BB%B7%E7%89%A9"><span class="toc-number">1.4.10.1.</span> <span class="toc-text">Rules：CLAUDE.md 的跨平台等价物</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#specs%EF%BC%9A%E9%9D%A2%E5%90%91%E4%BB%BB%E5%8A%A1%E7%9A%84%E9%9C%80%E6%B1%82%E6%96%87%E6%A1%A3"><span class="toc-number">1.4.10.2.</span> <span class="toc-text">Specs：面向任务的需求文档</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%8F%90%E7%82%BC%EF%BC%9A%E5%88%86%E5%B1%82%E9%85%8D%E7%BD%AE"><span class="toc-number">1.4.10.3.</span> <span class="toc-text">模式提炼：分层配置</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E6%93%8D%E6%96%B9%E6%B3%95%E8%AE%BA%EF%BC%9A%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E8%B7%B5"><span class="toc-number">1.5.</span> <span class="toc-text">实操方法论：从原理到实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%AF%9D%E7%AE%A1%E7%90%86%EF%BC%9A%E7%9F%AD%E5%AF%B9%E8%AF%9D%E4%BC%98%E4%BA%8E%E9%95%BF%E5%AF%B9%E8%AF%9D"><span class="toc-number">1.5.1.</span> <span class="toc-text">对话管理：短对话优于长对话</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%95%BF%E5%AF%B9%E8%AF%9D%E4%BC%9A%E5%A4%B1%E8%B4%A5"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">为什么长对话会失败</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E5%88%86%E8%A7%A3%E7%AD%96%E7%95%A5"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">任务分解策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%95%E6%97%B6%E5%BC%80%E5%A7%8B%E6%96%B0%E5%AF%B9%E8%AF%9D%E7%9A%84%E5%88%A4%E6%96%AD%E6%A0%87%E5%87%86"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">何时开始新对话的判断标准</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E6%B2%89%E6%B7%80%EF%BC%9A%E4%BB%8E%E4%BC%9A%E8%AF%9D%E8%AE%B0%E5%BF%86%E5%88%B0%E6%8C%81%E4%B9%85%E8%AE%B0%E5%BF%86"><span class="toc-number">1.5.2.</span> <span class="toc-text">知识沉淀：从会话记忆到持久记忆</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E6%B2%89%E6%B7%80%E7%9A%84%E4%B8%89%E4%B8%AA%E5%B1%82%E6%AC%A1"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">知识沉淀的三个层次</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%8F%E9%AA%8C%E5%A4%8D%E5%88%A9%E6%95%88%E5%BA%94"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">经验复利效应</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E7%A8%8B%E7%BA%A6%E6%9D%9F%EF%BC%9A%E7%94%A8%E4%BB%A3%E7%A0%81%E8%80%8C%E9%9D%9E%E6%96%87%E5%AD%97%E7%BA%A6%E6%9D%9F-agent"><span class="toc-number">1.5.3.</span> <span class="toc-text">工程约束：用代码而非文字约束 Agent</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%80%9F%E5%8A%A9-linters-formatters-%E5%92%8C-git-hooks"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">借助 Linters、Formatters 和 Git Hooks</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%A6%E6%88%AA-agent-%E7%9A%84-%E5%81%B7%E6%87%92-%E8%A1%8C%E4%B8%BA"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">拦截 Agent 的&quot;偷懒&quot;行为</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%8F%90%E7%82%BC%EF%BC%9A%E5%B7%A5%E7%A8%8B%E7%BA%A6%E6%9D%9F%E4%BC%98%E4%BA%8E%E6%8F%90%E7%A4%BA"><span class="toc-number">1.5.3.3.</span> <span class="toc-text">模式提炼：工程约束优于提示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ai-%E5%8F%8B%E5%A5%BD%E8%AE%BE%E8%AE%A1%EF%BC%9A%E5%AF%B9%E4%BA%BA%E9%9A%BE%E7%9A%84%E4%BA%8B-%E5%AF%B9-ai-%E4%B9%9F%E9%9A%BE"><span class="toc-number">1.5.4.</span> <span class="toc-text">AI 友好设计：对人难的事，对 AI 也难</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E9%87%8D%E6%8A%95%E8%B5%84%E5%9B%9E%E6%8A%A5"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">双重投资回报</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%93%E9%97%A8%E4%B8%BA-ai-%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">1.5.4.2.</span> <span class="toc-text">专门为 AI 设计的优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%94-agent-%E7%9A%84%E7%BB%9F%E8%AE%A1%E7%9B%B4%E8%A7%89"><span class="toc-number">1.5.4.3.</span> <span class="toc-text">顺应 Agent 的统计直觉</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%8F%90%E7%82%BC%EF%BC%9A%E7%BB%9F%E8%AE%A1%E7%9B%B4%E8%A7%89%E5%AF%B9%E9%BD%90"><span class="toc-number">1.5.4.4.</span> <span class="toc-text">模式提炼：统计直觉对齐</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%BB%E6%84%8F%E7%BB%83%E4%B9%A0%EF%BC%9A%E5%83%8F%E5%AD%A6%E4%B9%90%E5%99%A8%E4%B8%80%E6%A0%B7%E5%AD%A6%E4%B9%A0-ai"><span class="toc-number">1.5.5.</span> <span class="toc-text">刻意练习：像学乐器一样学习 AI</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E8%B4%A8%E6%B4%9E%E5%AF%9F%EF%BC%9A%E4%BB%8E-%E7%BC%96%E5%86%99%E7%A8%8B%E5%BA%8F-%E5%88%B0-%E7%BC%96%E5%86%99%E8%81%8C%E4%BD%8D%E6%8F%8F%E8%BF%B0"><span class="toc-number">1.6.</span> <span class="toc-text">本质洞察：从&quot;编写程序&quot;到&quot;编写职位描述&quot;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#agent-%E4%B8%8E%E4%BC%A0%E7%BB%9F%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%8C%BA%E5%88%AB"><span class="toc-number">1.6.1.</span> <span class="toc-text">Agent 与传统自动化的本质区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E-%E7%BC%96%E7%A8%8B-%E5%88%B0-%E7%BC%96%E5%86%99%E8%81%8C%E4%BD%8D%E6%8F%8F%E8%BF%B0"><span class="toc-number">1.6.2.</span> <span class="toc-text">从&quot;编程&quot;到&quot;编写职位描述&quot;</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E9%80%9F%E6%9F%A5%E8%A1%A8"><span class="toc-number">1.7.</span> <span class="toc-text">模式速查表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.8.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2017 - 2026 By magicliang</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional and Simplified Chinese">簡</button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><script src="/js/tw_cn.js?v=5.5.2"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="/"></script></div></body></html>