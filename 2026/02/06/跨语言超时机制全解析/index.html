<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>跨语言超时机制全解析 | 守株阁</title><meta name="author" content="magicliang"><meta name="copyright" content="magicliang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="从&quot;等不起&quot;到&quot;不想等&quot;：跨语言超时机制全解析  “A distributed system is one in which the failure of a computer you didn’t even know existed can render your own computer unusable.” —— Leslie Lamport 在分布式">
<meta property="og:type" content="article">
<meta property="og:title" content="跨语言超时机制全解析">
<meta property="og:url" content="https://magicliang.github.io/2026/02/06/%E8%B7%A8%E8%AF%AD%E8%A8%80%E8%B6%85%E6%97%B6%E6%9C%BA%E5%88%B6%E5%85%A8%E8%A7%A3%E6%9E%90/index.html">
<meta property="og:site_name" content="守株阁">
<meta property="og:description" content="从&quot;等不起&quot;到&quot;不想等&quot;：跨语言超时机制全解析  “A distributed system is one in which the failure of a computer you didn’t even know existed can render your own computer unusable.” —— Leslie Lamport 在分布式">
<meta property="og:locale">
<meta property="og:image" content="https://magicliang.github.io/2026/02/06/%E8%B7%A8%E8%AF%AD%E8%A8%80%E8%B6%85%E6%97%B6%E6%9C%BA%E5%88%B6%E5%85%A8%E8%A7%A3%E6%9E%90/go-channel%E8%B6%85%E6%97%B6.jpeg">
<meta property="article:published_time" content="2026-02-06T10:30:00.000Z">
<meta property="article:modified_time" content="2026-02-06T13:03:10.744Z">
<meta property="article:author" content="magicliang">
<meta property="article:tag" content="Go">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="JavaScript">
<meta property="article:tag" content="Ruby">
<meta property="article:tag" content="并发">
<meta property="article:tag" content="时间轮">
<meta property="article:tag" content="超时">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://magicliang.github.io/2026/02/06/%E8%B7%A8%E8%AF%AD%E8%A8%80%E8%B6%85%E6%97%B6%E6%9C%BA%E5%88%B6%E5%85%A8%E8%A7%A3%E6%9E%90/go-channel%E8%B6%85%E6%97%B6.jpeg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "跨语言超时机制全解析",
  "url": "https://magicliang.github.io/2026/02/06/%E8%B7%A8%E8%AF%AD%E8%A8%80%E8%B6%85%E6%97%B6%E6%9C%BA%E5%88%B6%E5%85%A8%E8%A7%A3%E6%9E%90/",
  "image": "https://magicliang.github.io/2026/02/06/%E8%B7%A8%E8%AF%AD%E8%A8%80%E8%B6%85%E6%97%B6%E6%9C%BA%E5%88%B6%E5%85%A8%E8%A7%A3%E6%9E%90/go-channel%E8%B6%85%E6%97%B6.jpeg",
  "datePublished": "2026-02-06T10:30:00.000Z",
  "dateModified": "2026-02-06T13:03:10.744Z",
  "author": [
    {
      "@type": "Person",
      "name": "magicliang",
      "url": "https://magicliang.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://magicliang.github.io/2026/02/06/%E8%B7%A8%E8%AF%AD%E8%A8%80%E8%B6%85%E6%97%B6%E6%9C%BA%E5%88%B6%E5%85%A8%E8%A7%A3%E6%9E%90/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: magicliang","link":"Link: ","source":"Source: 守株阁","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '跨语言超时机制全解析',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"><link rel="alternate" href="/atom.xml" title="守株阁" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      if ($loadingBox.classList.contains('loaded')) return
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()

  if (document.readyState === 'complete') {
    preloader.endLoading()
  } else {
    window.addEventListener('load', preloader.endLoading)
    document.addEventListener('DOMContentLoaded', preloader.endLoading)
    // Add timeout protection: force end after 7 seconds
    setTimeout(preloader.endLoading, 7000)
  }

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/2026/02/06/%E8%B7%A8%E8%AF%AD%E8%A8%80%E8%B6%85%E6%97%B6%E6%9C%BA%E5%88%B6%E5%85%A8%E8%A7%A3%E6%9E%90/go-channel%E8%B6%85%E6%97%B6.jpeg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">守株阁</span></a><a class="nav-page-title" href="/"><span class="site-name">跨语言超时机制全解析</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">跨语言超时机制全解析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2026-02-06T10:30:00.000Z" title="Created 2026-02-06 18:30:00">2026-02-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2026-02-06T13:03:10.744Z" title="Updated 2026-02-06 21:03:10">2026-02-06</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">15.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>67mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1>从&quot;等不起&quot;到&quot;不想等&quot;：跨语言超时机制全解析</h1>
<blockquote>
<p>“A distributed system is one in which the failure of a computer you didn’t even know existed can render your own computer unusable.”<br>
—— Leslie Lamport</p>
<p>在分布式系统中，超时是应用与混沌之间最后一道防线。没有超时的 RPC 调用，如同没有刹车的汽车——迟早会撞上墙。</p>
</blockquote>
<p>许多 Java 开发者对超时的认知停留在 <code>Future.get(timeout, unit)</code> 这一层，其底层依赖 <code>LockSupport.parkNanos</code> 和自旋等待。然而，翻阅 HSF/Dubbo 的源码会发现，这些 RPC 框架选择的是 <strong>HashedWheelTimer（时间轮）</strong>。</p>
<p>这就引出了一个值得深究的问题：为什么不直接用 <code>Future.get</code> 的超时版本？时间轮到底解决了什么问题？</p>
<p>事实上，仅 Java 一门语言就存在<strong>三种截然不同的超时实现范式</strong>。再放眼 Go、JavaScript、Ruby，每种语言对&quot;超时&quot;的理解和实现路径各有不同。本文试图从跨语言的视角，系统梳理这一主题。</p>
<h1>1. 超时的本质：一个工程哲学问题</h1>
<p>在进入具体实现之前，有必要先厘清一个基本问题：<strong>超时到底是什么？</strong></p>
<p>从最朴素的角度看，超时就是：<strong>&quot;调用方愿意等待，但不会永远等待。&quot;</strong></p>
<p>但&quot;等待&quot;这个动作，在不同的并发模型里有完全不同的含义：</p>
<table>
<thead>
<tr>
<th>并发模型</th>
<th>&quot;等待&quot;的含义</th>
<th>超时的实现方式</th>
<th>代表语言</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>线程模型</strong></td>
<td>线程阻塞（park/sleep）</td>
<td>唤醒阻塞的线程</td>
<td>Java</td>
</tr>
<tr>
<td><strong>CSP 模型</strong></td>
<td>goroutine 阻塞在 channel</td>
<td>select + timer channel</td>
<td>Go</td>
</tr>
<tr>
<td><strong>事件循环</strong></td>
<td>回调尚未触发</td>
<td>setTimeout / clearTimeout</td>
<td>JavaScript</td>
</tr>
<tr>
<td><strong>纤程/协程</strong></td>
<td>Fiber 让出执行权</td>
<td>Timeout 模块包装</td>
<td>Ruby</td>
</tr>
</tbody>
</table>
<pre><code class="hljs mermaid">mindmap
  root((超时))
    谁在等？
      线程 Thread
      协程 Goroutine
      事件循环 Event Loop
      纤程 Fiber
    等什么？
      IO 完成
      锁释放
      Future 就绪
      Channel 有数据
    怎么停？
      中断 Interrupt
      取消 Cancel
      超时异常 TimeoutError
      Channel 关闭
    谁来通知？
      等待者自己轮询
      调度器唤醒
      定时器回调
      时间轮扫描</code></pre>
<h2 id="1-1-超时的两个核心维度">1.1 超时的两个核心维度</h2>
<p>任何超时机制都需要回答两个问题：</p>
<p><strong>维度一：谁负责计时？</strong></p>
<pre><code class="hljs mermaid">graph LR
    A[计时策略] --&gt; B[等待者自己计时]
    A --&gt; C[外部定时器计时]
    B --&gt; D[&quot;自旋 + System.nanoTime()&quot;]
    B --&gt; E[&quot;parkNanos / sleep&quot;]
    C --&gt; F[&quot;ScheduledExecutorService&quot;]
    C --&gt; G[&quot;HashedWheelTimer&quot;]
    C --&gt; H[&quot;select + time.After&quot;]
    C --&gt; I[&quot;setTimeout&quot;]
    
    style B fill:#FFE0B2
    style C fill:#C8E6C9</code></pre>
<p><strong>维度二：超时后怎么处理？</strong></p>
<table>
<thead>
<tr>
<th>处理方式</th>
<th>描述</th>
<th>优点</th>
<th>缺点</th>
<th>典型场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>抛异常</strong></td>
<td><code>TimeoutException</code></td>
<td>调用方感知明确</td>
<td>需要 try-catch</td>
<td><code>Future.get(timeout)</code></td>
</tr>
<tr>
<td><strong>返回特殊值</strong></td>
<td>返回 <code>null</code>/<code>false</code>/<code>Optional.empty()</code></td>
<td>无异常开销</td>
<td>容易被忽略</td>
<td><code>BlockingQueue.poll(timeout)</code></td>
</tr>
<tr>
<td><strong>中断线程</strong></td>
<td>设置中断标志位</td>
<td>可以终止阻塞操作</td>
<td>需要任务配合检查</td>
<td><code>Thread.interrupt()</code></td>
</tr>
<tr>
<td><strong>取消任务</strong></td>
<td><code>Future.cancel(true)</code></td>
<td>语义清晰</td>
<td>不保证立即停止</td>
<td><code>CompletableFuture</code></td>
</tr>
<tr>
<td><strong>关闭 channel</strong></td>
<td>通过 channel 传递取消信号</td>
<td>天然适配 CSP</td>
<td>需要 select 配合</td>
<td>Go <code>context.WithTimeout</code></td>
</tr>
<tr>
<td><strong>清除回调</strong></td>
<td><code>clearTimeout</code></td>
<td>零成本取消</td>
<td>仅适用于事件循环</td>
<td>Node.js</td>
</tr>
</tbody>
</table>
<h2 id="1-2-四种语言的超时全景">1.2 四种语言的超时全景</h2>
<pre><code class="hljs mermaid">graph TB
    subgraph Java[&quot;Java - 线程模型&quot;]
        J1[&quot;方式1: 自旋 + parkNanos&lt;br/&gt;最底层，手动控制&quot;]
        J2[&quot;方式2: Future.get(timeout)&lt;br/&gt;最常用，阻塞等待&quot;]
        J3[&quot;方式3: HashedWheelTimer&lt;br/&gt;高吞吐，异步回调&quot;]
        J1 --&gt; J2
        J2 -.-&gt;|&quot;底层依赖&quot;| J1
        J3 -.-&gt;|&quot;独立机制&quot;| J1
    end
    
    subgraph Go[&quot;Go - CSP 模型&quot;]
        G1[&quot;context.WithTimeout&lt;br/&gt;标准做法，传播取消&quot;]
        G2[&quot;select + time.After&lt;br/&gt;channel 级超时&quot;]
        G3[&quot;time.AfterFunc&lt;br/&gt;回调式超时&quot;]
    end
    
    subgraph JS[&quot;JavaScript - 事件循环&quot;]
        JS1[&quot;Promise.race + setTimeout&lt;br/&gt;Promise 级超时&quot;]
        JS2[&quot;AbortController + signal&lt;br/&gt;fetch/stream 取消&quot;]
        JS3[&quot;AsyncLocalStorage&lt;br/&gt;上下文传播&quot;]
    end
    
    subgraph Ruby[&quot;Ruby - 纤程模型&quot;]
        R1[&quot;Timeout.timeout&lt;br/&gt;标准库，基于线程&quot;]
        R2[&quot;IO.select 超时&lt;br/&gt;IO 级超时&quot;]
        R3[&quot;Fiber + Timer&lt;br/&gt;协程式超时&quot;]
    end
    
    style Java fill:#FFF3E0
    style Go fill:#E8F5E9
    style JS fill:#FFFDE7
    style Ruby fill:#FCE4EC</code></pre>
<h1>2. Java：三种超时范式的深度剖析</h1>
<p>Java 的超时实现是最复杂的，因为其并发模型最&quot;重&quot;——每个并发单元都是一个操作系统线程。线程的阻塞和唤醒涉及用户态/内核态切换，成本不低。这直接影响了超时机制的设计选择。</p>
<h2 id="2-1-方式一：自旋-parknanos-最原始的超时">2.1 方式一：自旋 + parkNanos — 最原始的超时</h2>
<p>这是最底层的超时实现，也是其他所有 Java 超时机制的基石。核心思路：<strong>等待者自己计时，自己等待，时间到了自己醒来。</strong></p>
<h3 id="2-1-1-基本原理">2.1.1 基本原理</h3>
<pre><code class="hljs mermaid">sequenceDiagram
    participant Caller as 调用方线程
    participant OS as 操作系统
    participant Clock as 系统时钟
    
    Caller-&gt;&gt;Clock: 记录 deadline = now + timeout
    loop 自旋等待
        Caller-&gt;&gt;Caller: 检查条件是否满足？
        alt 条件满足
            Caller-&gt;&gt;Caller: return 结果
        else 条件未满足
            Caller-&gt;&gt;Clock: 计算 remaining = deadline - now
            alt remaining &lt;= 0
                Caller-&gt;&gt;Caller: throw TimeoutException
            else remaining &gt; 0
                Caller-&gt;&gt;OS: LockSupport.parkNanos(remaining)
                OS--&gt;&gt;Caller: 唤醒（超时/unpark/中断）
            end
        end
    end</code></pre>
<h3 id="2-1-2-aqs-中的超时等待：教科书级实现">2.1.2 AQS 中的超时等待：教科书级实现</h3>
<p><code>AbstractQueuedSynchronizer</code> 是 Java 并发包的基石，其 <code>doAcquireNanos</code> 方法是自旋+超时等待的标准实现。以下逐行拆解（为提升可读性，部分变量已重命名，如 <code>p</code> -&gt; <code>predecessor</code>、<code>s</code> -&gt; <code>currentState</code>、<code>q</code> -&gt; <code>waitNode</code>，实际 JDK 源码使用单字母变量名）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractQueuedSynchronizer.java (JDK 8)</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">doAcquireNanos</span><span class="hljs-params">(<span class="hljs-type">int</span> arg, <span class="hljs-type">long</span> nanosTimeout)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">if</span> (nanosTimeout &lt;= <span class="hljs-number">0L</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-comment">// 第一步：计算绝对截止时间</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> System.nanoTime() + nanosTimeout;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.EXCLUSIVE);<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123; <span class="hljs-comment">// 自旋</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">predecessor</span> <span class="hljs-operator">=</span> node.predecessor();<br>            <span class="hljs-keyword">if</span> (predecessor == head &amp;&amp; tryAcquire(arg)) &#123;<br>                <span class="hljs-comment">// 条件满足，获取成功</span><br>                setHead(node);<br>                predecessor.next = <span class="hljs-literal">null</span>;<br>                failed = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <br>            <span class="hljs-comment">// 第二步：计算剩余等待时间</span><br>            nanosTimeout = deadline - System.nanoTime();<br>            <span class="hljs-keyword">if</span> (nanosTimeout &lt;= <span class="hljs-number">0L</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 超时，返回 false</span><br>            <br>            <span class="hljs-comment">// 第三步：决定是 park 还是继续自旋</span><br>            <span class="hljs-comment">// spinForTimeoutThreshold = 1000ns = 1 微秒</span><br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(predecessor, node)<br>                    &amp;&amp; nanosTimeout &gt; spinForTimeoutThreshold)<br>                LockSupport.parkNanos(<span class="hljs-built_in">this</span>, nanosTimeout);<br>            <br>            <span class="hljs-comment">// 第四步：检查中断</span><br>            <span class="hljs-keyword">if</span> (Thread.interrupted())<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这段代码有几个精妙之处：</p>
<p><strong>精妙一：绝对时间 vs 相对时间</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用绝对时间（deadline）而非相对时间（remaining）</span><br><span class="hljs-comment">// 因为 parkNanos 可能被虚假唤醒（spurious wakeup），</span><br><span class="hljs-comment">// 如果用相对时间，每次虚假唤醒后都要重新计算</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> System.nanoTime() + nanosTimeout;<br><br><span class="hljs-comment">// 每次循环重新计算剩余时间</span><br>nanosTimeout = deadline - System.nanoTime();<br></code></pre></td></tr></table></figure>
<p>这里 <code>nanosTimeout</code> 变量扮演了<strong>双重角色</strong>：既是<strong>超时判断的依据</strong>（<code>&lt;= 0</code> 表示超时），也是<strong>park 等待的时长参数</strong>。这种设计确保了等待时间的精确性：</p>
<ol>
<li><strong>超时判断</strong>：<code>if (nanosTimeout &lt;= 0L) return false;</code> —— 剩余时间耗尽，判定超时</li>
<li><strong>等待时长</strong>：<code>LockSupport.parkNanos(this, nanosTimeout);</code> —— 用剩余时间作为 park 的参数</li>
</ol>
<p>关键在于理解 <code>deadline</code> 和 <code>nanosTimeout</code> 的区别：</p>
<ul>
<li><strong><code>deadline</code>（绝对时间）</strong>：循环开始时计算一次，之后不再改变。表示&quot;必须在哪个时间点之前完成&quot;，是一个固定的绝对时间戳</li>
<li><strong><code>nanosTimeout</code>（剩余时间）</strong>：每轮循环开始时重新计算，表示&quot;距离 deadline 还有多少纳秒&quot;。随着时间流逝，这个值会不断递减</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> System.nanoTime() + nanosTimeout;  <span class="hljs-comment">// deadline 在循环外只计算一次，固定不变</span><br><br><span class="hljs-keyword">for</span> (;;) &#123;<br>    <span class="hljs-comment">// 每次循环都重新计算剩余时间</span><br>    nanosTimeout = deadline - System.nanoTime();  <span class="hljs-comment">// nanosTimeout 逐轮递减</span><br>    <span class="hljs-keyword">if</span> (nanosTimeout &lt;= <span class="hljs-number">0L</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 剩余时间耗尽，判定超时</span><br>    <br>    LockSupport.parkNanos(<span class="hljs-built_in">this</span>, nanosTimeout);  <span class="hljs-comment">// 用本轮剩余时间作为 park 参数</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果使用固定时长（如 <code>parkNanos(3000)</code>）而不动态计算剩余时间，在多次循环后实际等待时间会超过原始超时限制。动态重算 <code>nanosTimeout</code> 的方式，即使经过 N 次虚假唤醒，累计等待时间也不会超过初始设定的 <code>timeout</code>。</p>
<p><strong>精妙二：自旋阈值</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 当剩余时间 &lt;= 1 微秒时，不再 park，直接自旋</span><br><span class="hljs-comment">// 因为 park/unpark 本身有上下文切换开销（通常 &gt; 1 微秒）</span><br><span class="hljs-comment">// park 一次再醒来，可能已经超过了 deadline</span><br><span class="hljs-keyword">if</span> (nanosTimeout &gt; spinForTimeoutThreshold)<br>    LockSupport.parkNanos(<span class="hljs-built_in">this</span>, nanosTimeout);<br><span class="hljs-comment">// else: 直接自旋，靠 CPU 空转等过最后这一点时间</span><br></code></pre></td></tr></table></figure>
<pre><code class="hljs mermaid">graph LR
    A[&quot;剩余时间&quot;] --&gt; B&#123;&quot;&gt; 1 微秒?&quot;&#125;
    B --&gt;|Yes| C[&quot;parkNanos&lt;br/&gt;让出 CPU，等待唤醒&quot;]
    B --&gt;|No| D[&quot;自旋&lt;br/&gt;CPU 空转等待&quot;]
    C --&gt; E[&quot;唤醒后重新检查&quot;]
    D --&gt; E
    E --&gt; F&#123;&quot;条件满足?&quot;&#125;
    F --&gt;|Yes| G[&quot;返回成功&quot;]
    F --&gt;|No| H&#123;&quot;已超时?&quot;&#125;
    H --&gt;|Yes| I[&quot;返回失败&quot;]
    H --&gt;|No| A
    
    style C fill:#C8E6C9
    style D fill:#FFE0B2</code></pre>
<p><strong>精妙三：中断响应</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// park 可能因为四种原因返回：</span><br><span class="hljs-comment">// 1. 超时到期</span><br><span class="hljs-comment">// 2. 被 unpark 唤醒（其他线程显式调用 LockSupport.unpark）</span><br><span class="hljs-comment">// 3. 被中断（设置了线程的中断标志）</span><br><span class="hljs-comment">// 4. 虚假唤醒（spurious wakeup，底层条件变量可能无原因返回）</span><br><span class="hljs-comment">// 因此醒来后必须检查中断标志</span><br><span class="hljs-keyword">if</span> (Thread.interrupted())<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br></code></pre></td></tr></table></figure>
<p>虚假唤醒是 POSIX 条件变量的已知行为，<code>LockSupport.parkNanos</code> 底层依赖 <code>pthread_cond_timedwait</code>，因此也可能发生虚假唤醒。代码通过循环结构自然地处理了这种情况——虚假唤醒后，线程会重新计算剩余时间并继续尝试获取锁或等待，而不会误判为超时。</p>
<h3 id="2-1-3-适用场景与局限">2.1.3 适用场景与局限</h3>
<table>
<thead>
<tr>
<th>维度</th>
<th>评价</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>精度</strong></td>
<td>纳秒级，最高精度</td>
</tr>
<tr>
<td><strong>开销</strong></td>
<td>每个等待者占用一个线程</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>锁获取、条件等待、底层同步原语</td>
</tr>
<tr>
<td><strong>不适用</strong></td>
<td>大量并发超时（如万级 RPC 请求）</td>
</tr>
</tbody>
</table>
<p><strong>核心局限</strong>：一个等待 = 一个线程。如果有 10000 个 RPC 请求同时在等超时，就需要 10000 个线程阻塞在 <code>parkNanos</code> 上。这正是 HSF/Dubbo 不采用此方式的根本原因。</p>
<h2 id="2-2-方式二：future-get-timeout-最常用的超时">2.2 方式二：Future.get(timeout) — 最常用的超时</h2>
<p>这是大多数 Java 开发者最熟悉的超时方式。本质上，它是方式一的一个<strong>上层封装</strong>。</p>
<h3 id="2-2-1-调用链路">2.2.1 调用链路</h3>
<pre><code class="hljs mermaid">graph TB
    A[&quot;future.get(3, SECONDS)&quot;] --&gt; B[&quot;FutureTask.get(timeout)&quot;]
    B --&gt; C[&quot;awaitDone(timed, nanos)&quot;]
    C --&gt; D&#123;&quot;state 已完成?&quot;&#125;
    D --&gt;|Yes| E[&quot;返回结果&quot;]
    D --&gt;|No| F[&quot;创建 WaitNode&quot;]
    F --&gt; G[&quot;LockSupport.parkNanos(nanos)&quot;]
    G --&gt; H&#123;&quot;唤醒原因?&quot;&#125;
    H --&gt;|&quot;任务完成 (unpark)&quot;| I[&quot;返回结果&quot;]
    H --&gt;|&quot;超时&quot;| J[&quot;throw TimeoutException&quot;]
    H --&gt;|&quot;中断&quot;| K[&quot;throw InterruptedException&quot;]
    
    style A fill:#E3F2FD
    style J fill:#FFCDD2
    style K fill:#FFCDD2</code></pre>
<h3 id="2-2-2-futuretask-awaitdone-源码剖析">2.2.2 FutureTask.awaitDone 源码剖析</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// FutureTask.java (JDK 8)</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">awaitDone</span><span class="hljs-params">(<span class="hljs-type">boolean</span> timed, <span class="hljs-type">long</span> nanos)</span><br>    <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> timed ? System.nanoTime() + nanos : <span class="hljs-number">0L</span>;<br>    <span class="hljs-type">WaitNode</span> <span class="hljs-variable">waitNode</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">queued</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">// 优先检查中断</span><br>        <span class="hljs-keyword">if</span> (Thread.interrupted()) &#123;<br>            removeWaiter(waitNode);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>        &#125;<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">currentState</span> <span class="hljs-operator">=</span> state;<br>        <br>        <span class="hljs-comment">// 已完成（正常/异常/取消）</span><br>        <span class="hljs-keyword">if</span> (currentState &gt; COMPLETING) &#123;<br>            <span class="hljs-keyword">if</span> (waitNode != <span class="hljs-literal">null</span>)<br>                waitNode.thread = <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">return</span> currentState;<br>        &#125;<br>        <span class="hljs-comment">// 正在设置结果，让出 CPU 等一下</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (currentState == COMPLETING)<br>            Thread.<span class="hljs-keyword">yield</span>();<br>        <span class="hljs-comment">// 创建等待节点</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (waitNode == <span class="hljs-literal">null</span>)<br>            waitNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WaitNode</span>();<br>        <span class="hljs-comment">// 入队</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!queued)<br>            queued = UNSAFE.compareAndSwapObject(<br>                <span class="hljs-built_in">this</span>, waitersOffset, waitNode.next = waiters, waitNode);<br>        <span class="hljs-comment">// 带超时的 park</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (timed) &#123;<br>            nanos = deadline - System.nanoTime();<br>            <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0L</span>) &#123;<br>                removeWaiter(waitNode);<br>                <span class="hljs-keyword">return</span> state; <span class="hljs-comment">// 超时，返回当前状态</span><br>            &#125;<br>            LockSupport.parkNanos(<span class="hljs-built_in">this</span>, nanos);<br>        &#125;<br>        <span class="hljs-comment">// 不带超时的 park</span><br>        <span class="hljs-keyword">else</span><br>            LockSupport.park(<span class="hljs-built_in">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>值得注意的设计：<strong>每次循环只做一件事</strong>。第一次循环创建 WaitNode，第二次循环入队，第三次循环才 park。这种&quot;渐进式&quot;设计避免了不必要的对象创建和队列操作——如果任务在前两次循环中就完成了，则无需 park。</p>
<h3 id="渐进式状态机模式-incremental-state-machine">渐进式状态机模式（Incremental State Machine）</h3>
<p>这种设计模式值得深入剖析，它体现了 Doug Lea 在并发编程中的精妙思想：</p>
<p><strong>核心设计理念：用循环驱动的状态机替代嵌套的条件分支</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (;;) &#123;<br>    <span class="hljs-comment">// 状态机：每次循环只推进一个状态</span><br>    <span class="hljs-comment">// 优先级从高到低：中断检查 &gt; 完成检查 &gt; 等待节点创建 &gt; 入队 &gt; 阻塞</span><br>    <br>    <span class="hljs-keyword">if</span> (Thread.interrupted()) &#123; ... &#125;                    <span class="hljs-comment">// 状态：中断</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (currentState &gt; COMPLETING) &#123; ... &#125;          <span class="hljs-comment">// 状态：已完成</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (currentState == COMPLETING) &#123; ... &#125;         <span class="hljs-comment">// 状态：正在完成</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (waitNode == <span class="hljs-literal">null</span>) &#123; ... &#125;                   <span class="hljs-comment">// 状态：需创建节点</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!queued) &#123; ... &#125;                            <span class="hljs-comment">// 状态：需入队</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (timed) &#123; ... &#125;                              <span class="hljs-comment">// 状态：需阻塞（带超时）</span><br>    <span class="hljs-keyword">else</span> &#123; ... &#125;                                         <span class="hljs-comment">// 状态：需阻塞（无限）</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>设计精妙之处</strong></p>
<ol>
<li>
<p><strong>渐进式推进（Incremental Progression）</strong></p>
<ul>
<li>不假设任何操作是原子的，每次循环只推进一个状态</li>
<li><code>waitNode == null</code> 创建节点 → <code>!queued</code> 入队 → <code>park</code> 阻塞</li>
<li>如果任务在任何一步之前完成，后续步骤都被跳过</li>
</ul>
</li>
<li>
<p><strong>状态可变性假设（State Volatility Assumption）</strong></p>
<ul>
<li>每次循环重新检查 <code>state</code>，假设其他线程可能已修改</li>
<li>即使已经创建了 <code>waitNode</code>，下一轮循环发现任务已完成，立即返回</li>
<li>这是<strong>乐观并发控制</strong>的典型应用</li>
</ul>
</li>
<li>
<p><strong>中断优先（Interruption First）</strong></p>
<ul>
<li>中断检查放在循环最前面，确保响应性</li>
<li>即使任务已完成，如果线程被中断，仍抛出 <code>InterruptedException</code></li>
</ul>
</li>
<li>
<p><strong>无锁入队（Lock-free Enqueue）</strong></p>
<ul>
<li>使用 <code>UNSAFE.compareAndSwapObject</code> 原子地将节点插入等待链表</li>
<li>失败则重试（下一轮循环），成功则标记 <code>queued = true</code></li>
</ul>
</li>
</ol>
<p><strong>与传统设计对比</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 传统设计（假设原子性，容易出错）</span><br><span class="hljs-keyword">if</span> (!completed) &#123;<br>    <span class="hljs-type">WaitNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WaitNode</span>();  <span class="hljs-comment">// 假设：创建后任务不会立即完成</span><br>    queue.add(node);                 <span class="hljs-comment">// 假设：入队后任务不会立即完成</span><br>    park();                          <span class="hljs-comment">// 假设：park 后任务不会立即完成</span><br>&#125;<br><span class="hljs-comment">// 问题：如果任务在 new WaitNode() 和 park() 之间完成，节点被浪费</span><br><br><span class="hljs-comment">// 渐进式设计（正确处理状态变化）</span><br><span class="hljs-keyword">for</span> (;;) &#123;<br>    <span class="hljs-keyword">if</span> (completed) <span class="hljs-keyword">return</span>;           <span class="hljs-comment">// 每次循环都检查，无假设</span><br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WaitNode</span>();<br>    <span class="hljs-keyword">if</span> (completed) <span class="hljs-keyword">return</span>;           <span class="hljs-comment">// 创建后再次检查</span><br>    <span class="hljs-keyword">if</span> (!queued) queued = enqueue(node);<br>    <span class="hljs-keyword">if</span> (completed) <span class="hljs-keyword">return</span>;           <span class="hljs-comment">// 入队后再次检查</span><br>    park();<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>适用场景</strong></p>
<p>这种模式适用于需要处理以下情况的并发场景：</p>
<ol>
<li><strong>状态可能被其他线程修改</strong>：每次循环重新读取状态</li>
<li><strong>操作可能失败或需要重试</strong>：如 CAS 入队</li>
<li><strong>需要快速响应中断</strong>：中断检查优先级最高</li>
<li><strong>希望避免不必要的资源消耗</strong>：渐进式推进，能省则省</li>
</ol>
<p><strong>借鉴要点</strong></p>
<p>在日常开发中，可以借鉴以下原则：</p>
<ul>
<li><strong>单次循环，单一职责</strong>：不要在一个循环里做太多事情</li>
<li><strong>状态检查前置</strong>：每次循环开始先检查是否可以提前返回</li>
<li><strong>乐观假设，防御验证</strong>：假设状态可能变化，每次都重新验证</li>
<li><strong>中断优先</strong>：长时间阻塞的操作必须先检查中断标志</li>
<li><strong>原子操作，失败重试</strong>：CAS 操作失败后，下一轮循环重试，而非自旋死等</li>
</ul>
<p>这种设计模式在 JDK 源码中多处出现，如 <code>AQS.doAcquireNanos</code>、<code>CountDownLatch.await</code>、<code>CyclicBarrier.await</code> 等，是 Java 并发包的核心设计范式。</p>
<h3 id="2-2-3-future-get-超时的问题">2.2.3 Future.get 超时的问题</h3>
<p><strong>问题一：超时不等于取消</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> future.get(<span class="hljs-number">3</span>, TimeUnit.SECONDS);<br>&#125; <span class="hljs-keyword">catch</span> (TimeoutException e) &#123;<br>    <span class="hljs-comment">// 超时了，但任务仍在运行</span><br>    <span class="hljs-comment">// future.get 超时只意味着&quot;调用方不再等待&quot;，而非&quot;任务停止执行&quot;</span><br>    <span class="hljs-comment">// Java 类库的做法：超时后直接抛出异常，不取消任务</span><br>    <span class="hljs-comment">// 如需取消任务，必须显式调用：</span><br>    future.cancel(<span class="hljs-literal">true</span>); <span class="hljs-comment">// true = 尝试中断执行线程</span><br>&#125;<br></code></pre></td></tr></table></figure>
<pre><code class="hljs mermaid">sequenceDiagram
    participant Caller as 调用方
    participant Future as FutureTask
    participant Worker as 工作线程
    
    Caller-&gt;&gt;Future: get(3s)
    Future-&gt;&gt;Caller: parkNanos(3s)
    
    Note over Worker: 任务执行中...
    
    Caller-&gt;&gt;Caller: 3秒到，TimeoutException
    
    Note over Worker: 任务仍在执行
    Note over Caller: 若不 cancel，&lt;br/&gt;工作线程将继续占用资源
    
    Caller-&gt;&gt;Future: cancel(true)
    Future-&gt;&gt;Worker: interrupt()
    Worker-&gt;&gt;Worker: 检查中断标志</code></pre>
<p><strong>问题二：一个 Future 一个线程</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 假设有 10000 个 RPC 请求</span><br>List&lt;Future&lt;Response&gt;&gt; futures = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>    futures.add(executor.submit(() -&gt; rpcCall()));<br>&#125;<br><br><span class="hljs-comment">// 方式A：逐个等待（串行超时，总时间 = N * timeout）</span><br><span class="hljs-comment">// 注意：Java 类库在超时后并不会自动取消任务，只是让调用方不再等待</span><br><span class="hljs-comment">// 如果需要取消任务，必须显式调用 future.cancel(true)</span><br><span class="hljs-keyword">for</span> (Future&lt;Response&gt; future : futures) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        future.get(<span class="hljs-number">3</span>, TimeUnit.SECONDS);<br>    &#125; <span class="hljs-keyword">catch</span> (TimeoutException e) &#123;<br>        <span class="hljs-comment">// Java 类库的做法：超时后直接返回，不取消任务</span><br>        <span class="hljs-comment">// future.cancel(true); // 如需取消，需显式调用</span><br>        <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 或 continue，取决于业务需求</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 方式B：用 CompletableFuture.allOf（但超时控制更复杂）</span><br>CompletableFuture&lt;Void&gt; allDone = CompletableFuture.allOf(<br>    futures.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletableFuture</span>[<span class="hljs-number">0</span>])<br>);<br>allDone.get(<span class="hljs-number">3</span>, TimeUnit.SECONDS); <span class="hljs-comment">// 整体超时</span><br></code></pre></td></tr></table></figure>
<p><code>CompletableFuture.allOf</code> 提供了一种更现代的批量任务等待方式。从超时控制的角度看，它的核心价值在于将&quot;逐个等待&quot;转变为&quot;整体等待&quot;，从而简化超时语义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 整体超时：所有任务必须在 3 秒内全部完成</span><br>CompletableFuture.allOf(futures.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletableFuture</span>[<span class="hljs-number">0</span>]))<br>    .orTimeout(<span class="hljs-number">3</span>, TimeUnit.SECONDS)           <span class="hljs-comment">// JDK 9+：整体超时</span><br>    .exceptionally(ex -&gt; &#123; log.error(<span class="hljs-string">&quot;Tasks failed or timed out&quot;</span>, ex); <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; &#125;)<br>    .join();<br><br><span class="hljs-comment">// 或者使用 get(timeout)</span><br>CompletableFuture.allOf(futures.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletableFuture</span>[<span class="hljs-number">0</span>]))<br>    .get(<span class="hljs-number">3</span>, TimeUnit.SECONDS);                <span class="hljs-comment">// 整体超时</span><br></code></pre></td></tr></table></figure>
<p>与逐个 <code>Future.get(timeout)</code> 相比，<code>allOf</code> 的超时语义更直观：逐个等待的总时间是 N x timeout（串行），而 <code>allOf</code> 的总时间是 max(各任务时间)（并行）。但需要注意，<code>allOf</code> 本身不提供超时功能，必须配合 <code>get(timeout)</code> 或 <code>orTimeout</code> 使用。关于 <code>CompletableFuture.allOf</code> 的更多设计细节（统一异常处理、组合式编程等），可参考 <a href="/2026/01/24/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0/">Java 线程池笔记</a> 中 CompletableFuture 章节的讨论。</p>
<p><strong>核心问题</strong>：<code>Future.get(timeout)</code> 是<strong>同步阻塞</strong>的。调用方线程在等待期间什么都做不了。如果存在大量并发请求需要超时控制，每个请求都阻塞一个线程来等待，线程资源很快就会耗尽。</p>
<h2 id="2-3-方式三：hashedwheeltimer-时间轮-高吞吐的超时">2.3 方式三：HashedWheelTimer（时间轮）— 高吞吐的超时</h2>
<p>这正是 HSF/Dubbo/Netty 选择的方案。它解决的核心问题是：<strong>当存在海量并发超时任务时，如何高效地管理它们？</strong></p>
<h3 id="2-3-1-为什么需要时间轮？">2.3.1 为什么需要时间轮？</h3>
<p>考虑一个真实场景：</p>
<blockquote>
<p>一个 Dubbo 服务端，QPS 10000，每个请求超时时间 3 秒。<br>
这意味着在任意时刻，有约 30000 个请求在&quot;等待超时&quot;。</p>
</blockquote>
<p>如果用 <code>Future.get(timeout)</code>：需要 30000 个线程阻塞等待。这显然不现实。</p>
<p>如果用 <code>ScheduledExecutorService</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 每个请求注册一个延迟任务</span><br><span class="hljs-keyword">for</span> (Request req : requests) &#123;<br>    scheduledExecutor.schedule(() -&gt; &#123;<br>        req.timeout();<br>    &#125;, <span class="hljs-number">3</span>, TimeUnit.SECONDS);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>ScheduledExecutorService</code> 底层是<strong>最小堆（DelayQueue）</strong>，每次插入/删除的时间复杂度是 <strong>O(log n)</strong>。30000 个任务，每次操作约 15 次比较。表面上看尚可接受。</p>
<p>但问题在于：大部分请求会在超时前正常返回，需要<strong>取消</strong>超时任务。取消操作同样是 O(log n)。而且 <code>DelayQueue</code> 的锁竞争在高并发下会成为瓶颈。</p>
<h4 id="scheduledexecutorservice-底层数据结构深度解析">ScheduledExecutorService 底层数据结构深度解析</h4>
<p>要理解为什么 <code>ScheduledExecutorService</code> 不适合高并发超时场景，需要深入其底层实现。</p>
<p><strong>组件架构图</strong></p>
<pre><code class="hljs mermaid">graph TB
    subgraph ScheduledThreadPoolExecutor[&quot;ScheduledThreadPoolExecutor 架构&quot;]
        direction TB
        
        CorePool[&quot;核心线程池&lt;br/&gt;ThreadPoolExecutor&quot;]
        DelayQueue[&quot;DelayedWorkQueue&lt;br/&gt;延迟队列（最小堆）&quot;]
        WorkerThreads[&quot;Worker 线程组&quot;]
        
        CorePool --&gt;|&quot;提交任务&quot;| DelayQueue
        DelayQueue --&gt;|&quot;获取到期任务&quot;| WorkerThreads
        WorkerThreads --&gt;|&quot;循环获取&quot;| DelayQueue
    end
    
    subgraph DelayedWorkQueueDetail[&quot;DelayedWorkQueue 内部结构&quot;]
        direction TB
        
        HeapArray[&quot;堆数组 RunnableScheduledFuture[]&quot;]
        ReentrantLock[&quot;ReentrantLock&lt;br/&gt;保证线程安全&quot;]
        Condition[&quot;Condition available&lt;br/&gt;任务可用通知&quot;]
        
        HeapArray --&gt;|&quot;索引计算&quot;| Index[&quot;parent = (i-1)/2&lt;br/&gt;left = 2*i+1&lt;br/&gt;right = 2*i+2&quot;]
        ReentrantLock --&gt;|&quot;保护&quot;| HeapArray
        Condition --&gt;|&quot;唤醒等待线程&quot;| WorkerThreads
    end
    
    CorePool -.-&gt;|&quot;内部使用&quot;| DelayedWorkQueueDetail
    
    style DelayQueue fill:#FFE0B2
    style HeapArray fill:#C8E6C9
    style ReentrantLock fill:#FFCDD2</code></pre>
<p><strong>DelayedWorkQueue 最小堆结构</strong></p>
<pre><code class="hljs mermaid">graph TB
    subgraph MinHeap[&quot;最小堆结构示意（小顶堆）&quot;]
        direction TB
        
        Root[&quot;[0] delay=100ms&lt;br/&gt;任务A&quot;]
        L1[&quot;[1] delay=200ms&lt;br/&gt;任务B&quot;]
        R1[&quot;[2] delay=300ms&lt;br/&gt;任务C&quot;]
        L2[&quot;[3] delay=400ms&lt;br/&gt;任务D&quot;]
        R2[&quot;[4] delay=500ms&lt;br/&gt;任务E&quot;]
        L3[&quot;[5] delay=600ms&lt;br/&gt;任务F&quot;]
        R3[&quot;[6] delay=700ms&lt;br/&gt;任务G&quot;]
        
        Root --&gt; L1
        Root --&gt; R1
        L1 --&gt; L2
        L1 --&gt; R2
        R1 --&gt; L3
        R1 --&gt; R3
    end
    
    subgraph HeapProperty[&quot;堆性质&quot;]
        P1[&quot;父节点 delay ≤ 子节点 delay&quot;]
        P2[&quot;根节点 [0] 始终是 delay 最小的任务&quot;]
        P3[&quot;插入/删除需要上浮/下沉调整&quot;]
    end
    
    style Root fill:#C8E6C9
    style HeapProperty fill:#E3F2FD</code></pre>
<p><strong>插入操作时序图</strong></p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant Caller as 调用线程
    participant Lock as ReentrantLock
    participant Heap as 堆数组
    participant Condition as available条件
    
    Caller-&gt;&gt;Lock: lock()
    activate Lock
    
    Caller-&gt;&gt;Heap: 检查容量，必要时扩容
    Caller-&gt;&gt;Heap: 新任务放入末尾 heap[size]
    Caller-&gt;&gt;Heap: siftUp(size) 上浮调整
    
    loop 上浮过程 O(log n)
        Heap-&gt;&gt;Heap: 与父节点比较 delay
        alt 当前节点 delay &lt; 父节点
            Heap-&gt;&gt;Heap: 交换位置
        else 当前节点 delay ≥ 父节点
            Heap-&gt;&gt;Heap: 停止上浮
        end
    end
    
    alt 新任务成为根节点（delay最小）
        Caller-&gt;&gt;Condition: signal() 唤醒等待线程
    end
    
    Caller-&gt;&gt;Lock: unlock()
    deactivate Lock
    
    Note over Caller,Condition: 插入复杂度：O(log n)&lt;br/&gt;比较次数：树高度 = log₂(n)</code></pre>
<p><strong>获取/删除操作时序图</strong></p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant Worker as Worker线程
    participant Lock as ReentrantLock
    participant Heap as 堆数组
    participant Condition as available条件
    
    Worker-&gt;&gt;Lock: lock()
    activate Lock
    
    loop 等待可用任务
        Worker-&gt;&gt;Heap: 检查堆顶任务
        alt 堆为空
            Worker-&gt;&gt;Condition: await() 释放锁，等待
            Condition--&gt;&gt;Worker: 被signal唤醒
        else 堆顶任务未到期
            Worker-&gt;&gt;Condition: awaitNanos(剩余delay)
            Condition--&gt;&gt;Worker: 超时或被signal唤醒
        else 堆顶任务已到期
            Worker-&gt;&gt;Worker: 跳出循环，继续执行
        end
    end
    
    Worker-&gt;&gt;Heap: 取出堆顶任务 result = heap[0]
    Worker-&gt;&gt;Heap: 末尾任务移到堆顶 heap[0] = heap[size-1]
    Worker-&gt;&gt;Heap: siftDown(0) 下沉调整
    
    loop 下沉过程 O(log n)
        Heap-&gt;&gt;Heap: 与左右子节点比较，找最小
        alt 当前节点 delay &gt; 最小子节点
            Heap-&gt;&gt;Heap: 交换位置
        else 当前节点 delay ≤ 子节点
            Heap-&gt;&gt;Heap: 停止下沉
        end
    end
    
    Worker-&gt;&gt;Lock: unlock()
    deactivate Lock
    Worker-&gt;&gt;Worker: 执行任务 run()
    
    Note over Worker,Heap: 删除复杂度：O(log n)&lt;br/&gt;需要维护堆性质</code></pre>
<p><strong>取消操作的问题</strong></p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant Caller as 调用线程
    participant Lock as ReentrantLock
    participant Heap as 堆数组
    participant Task as 待取消任务
    
    Caller-&gt;&gt;Lock: lock()
    activate Lock
    
    Caller-&gt;&gt;Task: cancel(false)
    Task--&gt;&gt;Caller: 标记取消状态
    
    Note over Caller,Task: 问题1：任务仍留在堆中！
    
    alt 任务恰好是堆顶
        Caller-&gt;&gt;Heap: 立即移除并调整堆
    else 任务在堆中间
        Note over Caller: 任务不会立即从堆中移除
        Note over Caller: 等到它成为堆顶时才被清理
    end
    
    Caller-&gt;&gt;Lock: unlock()
    deactivate Lock
    
    Note over Caller,Heap: 问题2：取消后堆大小不变&lt;br/&gt;内存泄漏风险直到任务到期</code></pre>
<p><strong>核心性能瓶颈分析</strong></p>
<table>
<thead>
<tr>
<th>操作</th>
<th>时间复杂度</th>
<th>实际开销</th>
<th>高并发问题</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>插入</strong></td>
<td>O(log n)</td>
<td>~15次比较 (n=30000)</td>
<td>锁竞争严重</td>
</tr>
<tr>
<td><strong>删除（take）</strong></td>
<td>O(log n)</td>
<td>~15次比较</td>
<td>单线程消费瓶颈</td>
</tr>
<tr>
<td><strong>取消</strong></td>
<td>O(log n) 或延迟</td>
<td>查找+调整或仅标记</td>
<td>任务残留，内存占用</td>
</tr>
<tr>
<td><strong>锁粒度</strong></td>
<td>全局锁</td>
<td>ReentrantLock</td>
<td>所有操作串行化</td>
</tr>
</tbody>
</table>
<pre><code class="hljs mermaid">graph TB
    subgraph Bottleneck[&quot;ScheduledExecutorService 瓶颈&quot;]
        B1[&quot;全局锁 ReentrantLock&quot;]
        B2[&quot;最小堆的 O(log n) 操作&quot;]
        B3[&quot;单线程消费模型&quot;]
        B4[&quot;取消不立即回收内存&quot;]
    end
    
    subgraph Impact[&quot;对 RPC 超时的影响&quot;]
        I1[&quot;10k QPS = 大量锁竞争&quot;]
        I2[&quot;30k 并发任务 = 频繁堆调整&quot;]
        I3[&quot;取消操作堆积，内存上涨&quot;]
        I4[&quot;延迟精度受调度影响&quot;]
    end
    
    B1 --&gt; I1
    B2 --&gt; I2
    B3 --&gt; I3
    B4 --&gt; I3
    
    style Bottleneck fill:#FFCDD2
    style Impact fill:#FFE0B2</code></pre>
<p><strong>时间轮的优势</strong>：插入和取消都是 <strong>O(1)</strong>。</p>
<h3 id="2-3-2-时间轮的工作原理">2.3.2 时间轮的工作原理</h3>
<p>时间轮的灵感来自钟表。设想一个有 512 个刻度的表盘，指针每 100ms 走一格：</p>
<h4 id="时间轮核心架构图">时间轮核心架构图</h4>
<pre><code class="hljs mermaid">graph TB
    subgraph HashedWheelTimerArchitecture[&quot;HashedWheelTimer 整体架构&quot;]
        direction TB
        
        subgraph CoreComponents[&quot;核心组件&quot;]
            WheelArray[&quot;wheel: HashedWheelBucket[]&lt;br/&gt;环形槽位数组&quot;]
            WorkerThread[&quot;Worker 线程&lt;br/&gt;单线程驱动&quot;]
            TimeoutQueue[&quot;timeouts: Queue&lt;br/&gt;新任务缓冲队列&quot;]
            CancelledTimeouts[&quot;cancelledTimeouts: Queue&lt;br/&gt;待取消任务队列&quot;]
        end
        
        subgraph SlotStructure[&quot;槽位结构&quot;]
            Bucket0[&quot;Bucket[0]&quot;]
            Bucket1[&quot;Bucket[1]&quot;]
            BucketN[&quot;Bucket[N-1]&quot;]
            
            subgraph BucketDetail[&quot;每个 Bucket 是双向链表&quot;]
                Head[&quot;head&lt;br/&gt;HashedWheelTimeout&quot;]
                Node1[&quot;timeout.next&quot;]
                Node2[&quot;timeout.next&quot;]
                Tail[&quot;tail&quot;]
                
                Head &lt;--&gt; Node1
                Node1 &lt;--&gt; Node2
                Node2 &lt;--&gt; Tail
            end
        end
        
        WheelArray --&gt; Bucket0
        WheelArray --&gt; Bucket1
        WheelArray --&gt; BucketN
        WorkerThread --&gt;|&quot;tick++&quot;| WheelArray
        TimeoutQueue --&gt;|&quot;transferTimeoutsToBuckets()&quot;| WheelArray
    end
    
    style WorkerThread fill:#C8E6C9
    style WheelArray fill:#E3F2FD
    style BucketDetail fill:#FFF3E0</code></pre>
<h4 id="时间轮工作动画示意">时间轮工作动画示意</h4>
<pre><code class="hljs mermaid">graph LR
    subgraph TimeWheelAnimation[&quot;时间轮运转示意（ticksPerWheel=8）&quot;]
        direction LR
        
        T0[&quot;tick=0&lt;br/&gt;指针位置&quot;]:::current
        T1[&quot;tick=1&quot;]
        T2[&quot;tick=2&quot;]
        T3[&quot;tick=3&quot;]
        T4[&quot;tick=4&quot;]
        T5[&quot;tick=5&quot;]
        T6[&quot;tick=6&quot;]
        T7[&quot;tick=7&quot;]
        
        T0 --&gt;|&quot;tickDuration&quot;| T1
        T1 --&gt;|&quot;tickDuration&quot;| T2
        T2 --&gt;|&quot;tickDuration&quot;| T3
        T3 --&gt;|&quot;tickDuration&quot;| T4
        T4 --&gt;|&quot;tickDuration&quot;| T5
        T5 --&gt;|&quot;tickDuration&quot;| T6
        T6 --&gt;|&quot;tickDuration&quot;| T7
        T7 --&gt;|&quot;tickDuration&lt;br/&gt;取模回到&quot;| T0
    end
    
    subgraph TaskPlacement[&quot;任务分布示例&quot;]
        TaskA[&quot;任务A&lt;br/&gt;delay=100ms&lt;br/&gt;tick=1, rounds=0&quot;]
        TaskB[&quot;任务B&lt;br/&gt;delay=850ms&lt;br/&gt;tick=5, rounds=1&quot;]
        TaskC[&quot;任务C&lt;br/&gt;delay=150ms&lt;br/&gt;tick=2, rounds=0&quot;]
        TaskD[&quot;任务D&lt;br/&gt;delay=1700ms&lt;br/&gt;tick=3, rounds=2&quot;]
    end
    
    TaskA -.-&gt;|&quot;放入&quot;| T1
    TaskB -.-&gt;|&quot;放入&quot;| T5
    TaskC -.-&gt;|&quot;放入&quot;| T2
    TaskD -.-&gt;|&quot;放入&quot;| T3
    
    classDef current fill:#FF9800,color:#fff
    classDef future fill:#E8F5E9</code></pre>
<h4 id="关键计算公式">关键计算公式</h4>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs tap">给定参数：<br>- tickDuration = 100ms（每格时间）<br>- ticksPerWheel = 512（轮子大小）<br>- mask = 511（用于快速取模：index &amp; mask）<br><br>对于延迟 delay = 3000ms 的任务：<br><br>1. 计算需要的 tick 数：<br>   ticks = delay / tickDuration =<span class="hljs-number"> 3000 </span>/<span class="hljs-number"> 100 </span>= 30<br><br>2. 计算槽位索引（假设当前 tick = 42）：<br>   targetTick =<span class="hljs-number"> 42 </span>+<span class="hljs-number"> 30 </span>= 72<br>   slotIndex = targetTick &amp; mask =<span class="hljs-number"> 72 </span>&amp;<span class="hljs-number"> 511 </span>= 72<br><br>3. 计算 rounds（需要转几圈）：<br>   rounds = targetTick / ticksPerWheel - currentRound<br>          =<span class="hljs-number"> 72 </span>/<span class="hljs-number"> 512 </span>-<span class="hljs-number"> 0 </span>= 0（本圈内到期）<br></code></pre></td></tr></table></figure>
<h4 id="添加任务时序图">添加任务时序图</h4>
<pre><code class="hljs mermaid">sequenceDiagram
    participant App as 应用线程
    participant Timer as HashedWheelTimer
    participant Queue as timeouts队列
    participant Worker as Worker线程
    participant Bucket as HashedWheelBucket
    
    App-&gt;&gt;Timer: newTimeout(task, 3000ms)
    Timer-&gt;&gt;Timer: 计算 deadline = nanoTime + 3s
    
    Note over Timer: 不直接操作wheel&lt;br/&gt;避免并发竞争
    
    Timer-&gt;&gt;Queue: offer(newTimeout)
    Queue--&gt;&gt;Timer: 加入成功
    
    Timer--&gt;&gt;App: 返回 Timeout 对象
    
    Note over Worker: Worker线程每tick周期
    
    Worker-&gt;&gt;Queue: transferTimeoutsToBuckets()
    
    loop 批量转移（每次最多10000个）
        Queue-&gt;&gt;Worker: poll()
        Worker-&gt;&gt;Worker: 计算目标槽位 index
        Worker-&gt;&gt;Worker: 计算剩余轮数 rounds
        
        alt rounds == 0 且 槽位已过期
            Worker-&gt;&gt;Worker: 立即执行任务
        else
            Worker-&gt;&gt;Bucket: add(timeout)
            Bucket--&gt;&gt;Worker: 插入双向链表尾部
        end
    end
    
    Note over Worker: 复杂度：O(1) 添加</code></pre>
<h4 id="worker-线程主循环时序图">Worker 线程主循环时序图</h4>
<pre><code class="hljs mermaid">sequenceDiagram
    participant Worker as Worker线程
    participant Clock as 系统时钟
    participant Wheel as wheel数组
    participant Bucket as 当前Bucket
    participant Timeout as HashedWheelTimeout
    
    loop 无限循环（直到shutdown）
        Worker-&gt;&gt;Clock: waitForNextTick()
        Clock--&gt;&gt;Worker: sleep到下一个tick
        
        Note over Worker: 阶段1：转移新任务
        Worker-&gt;&gt;Worker: transferTimeoutsToBuckets()
        
        Note over Worker: 阶段2：处理到期任务
        Worker-&gt;&gt;Worker: 计算当前槽位 bucketIdx = tick &amp; mask
        Worker-&gt;&gt;Wheel: wheel[bucketIdx]
        Wheel--&gt;&gt;Worker: 返回 Bucket
        
        Worker-&gt;&gt;Bucket: expireTimeouts(deadline)
        
        loop 遍历链表
            Bucket-&gt;&gt;Timeout: 取出节点
            
            alt timeout.remainingRounds &lt;= 0
                Bucket-&gt;&gt;Timeout: expire() 执行超时回调
            else if timeout.isCancelled()
                Bucket-&gt;&gt;Bucket: remove(timeout) 从链表移除
            else
                Timeout-&gt;&gt;Timeout: remainingRounds--
            end
        end
        
        Worker-&gt;&gt;Worker: tick++
    end</code></pre>
<h4 id="任务到期判断逻辑详解">任务到期判断逻辑详解</h4>
<pre><code class="hljs mermaid">graph TB
    subgraph ExpireLogic[&quot;到期判断流程&quot;]
        Start[&quot;获取当前槽位 Bucket&quot;] --&gt; CheckNode&#123;&quot;链表有节点?&quot;&#125;
        
        CheckNode --&gt;|Yes| GetNode[&quot;取出 timeout 节点&quot;]
        CheckNode --&gt;|No| EndLoop[&quot;结束处理&quot;]
        
        GetNode --&gt; CheckRounds&#123;&quot;remainingRounds &lt;= 0?&quot;&#125;
        
        CheckRounds --&gt;|Yes| CheckCancelled1&#123;&quot;isCancelled?&quot;&#125;
        CheckRounds --&gt;|No| Decrement[&quot;remainingRounds--&lt;br/&gt;本轮未到期&quot;]
        
        CheckCancelled1 --&gt;|Yes| Remove1[&quot;从链表移除&lt;br/&gt;跳过执行&quot;]
        CheckCancelled1 --&gt;|No| Execute[&quot;expire()&lt;br/&gt;执行超时回调&quot;]
        
        Decrement --&gt; NextNode1[&quot;下一个节点&quot;]
        Remove1 --&gt; NextNode2[&quot;下一个节点&quot;]
        Execute --&gt; NextNode3[&quot;下一个节点&quot;]
        
        NextNode1 --&gt; CheckNode
        NextNode2 --&gt; CheckNode
        NextNode3 --&gt; CheckNode
        
        EndLoop --&gt; End[&quot;等待下一tick&quot;]
    end
    
    subgraph RoundsExplanation[&quot;轮数概念解释&quot;]
        R0[&quot;remainingRounds = 0&lt;br/&gt;当前轮到期，立即执行&quot;]
        R1[&quot;remainingRounds = 1&lt;br/&gt;下一轮到期，等待一圈&quot;]
        R2[&quot;remainingRounds = 2&lt;br/&gt;下两轮到期，等待两圈&quot;]
        
        Example[&quot;例子：ticksPerWheel=8&lt;br/&gt;任务 delay=900ms, tickDuration=100ms&lt;br/&gt;ticks=9, slot=(current+9)%8=1&lt;br/&gt;rounds=9/8=1&quot;]
    end
    
    style Execute fill:#C8E6C9
    style Decrement fill:#FFE0B2
    style Remove1 fill:#FFCDD2</code></pre>
<h4 id="取消任务时序图">取消任务时序图</h4>
<pre><code class="hljs mermaid">sequenceDiagram
    participant Caller as 调用线程
    participant Timeout as HashedWheelTimeout
    participant State as state字段
    participant Worker as Worker线程
    
    Caller-&gt;&gt;Timeout: cancel()
    Timeout-&gt;&gt;State: 原子操作：ST_INIT → ST_CANCELLED
    
    Note over Timeout: 仅标记状态，不从链表中移除！
    
    alt 尚未加入wheel（在timeouts队列中）
        Timeout--&gt;&gt;Caller: 返回 true
        Note over Timeout: 不会被加入wheel
    else 已在wheel中
        Timeout--&gt;&gt;Caller: 返回 true
        Note over Worker: 等待Worker清理
    end
    
    Note over Worker: 当Worker遍历到该slot时
    
    Worker-&gt;&gt;Timeout: isCancelled()
    Timeout--&gt;&gt;Worker: true
    
    Worker-&gt;&gt;Worker: 从链表移除节点
    
    Note over Caller,Worker: 懒删除策略&lt;br/&gt;O(1) 取消，无锁操作</code></pre>
<p><strong>添加任务</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 超时时间 3000ms，tickDuration 100ms</span><br><span class="hljs-comment">// 需要的 ticks = 3000 / 100 = 30</span><br><span class="hljs-comment">// slot = (currentTick + 30) % 512 = (42 + 30) % 512 = 72</span><br><span class="hljs-comment">// 直接放入 slot 72 的链表 -&gt; O(1)</span><br></code></pre></td></tr></table></figure>
<p><strong>触发超时</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Worker 线程每 100ms 推进一格</span><br><span class="hljs-comment">// 到达 slot 72 时，遍历链表，执行所有到期任务</span><br><span class="hljs-comment">// 如果任务的 remainingRounds &gt; 0，说明还没到期，rounds--</span><br></code></pre></td></tr></table></figure>
<p><strong>取消任务</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 请求正常返回了，取消超时</span><br><span class="hljs-comment">// 直接标记 timeout.cancel() -&gt; O(1)</span><br><span class="hljs-comment">// Worker 线程遍历到该任务时跳过</span><br></code></pre></td></tr></table></figure>
<h3 id="2-3-3-netty-hashedwheeltimer-核心源码">2.3.3 Netty HashedWheelTimer 核心源码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// io.netty.util.HashedWheelTimer (简化)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashedWheelTimer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Timer</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HashedWheelBucket[] wheel;      <span class="hljs-comment">// 环形数组</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> tickDuration;               <span class="hljs-comment">// 每格时间</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> mask;                        <span class="hljs-comment">// wheel.length - 1，用于取模</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Worker</span> <span class="hljs-variable">worker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>();     <span class="hljs-comment">// 单线程</span><br>    <br>    <span class="hljs-comment">// 添加超时任务 - O(1)</span><br>    <span class="hljs-keyword">public</span> Timeout <span class="hljs-title function_">newTimeout</span><span class="hljs-params">(TimerTask task, <span class="hljs-type">long</span> delay, TimeUnit unit)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> System.nanoTime() + unit.toNanos(delay);<br>        <span class="hljs-type">HashedWheelTimeout</span> <span class="hljs-variable">timeout</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashedWheelTimeout</span>(<span class="hljs-built_in">this</span>, task, deadline);<br>        <span class="hljs-comment">// 不直接放入 wheel，而是放入 queue，由 worker 线程统一处理</span><br>        <span class="hljs-comment">// 避免并发竞争</span><br>        timeouts.add(timeout);<br>        <span class="hljs-keyword">return</span> timeout;<br>    &#125;<br>    <br>    <span class="hljs-comment">// Worker 线程的核心循环</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">while</span> (workerState == WORKER_STATE_STARTED) &#123;<br>                <span class="hljs-comment">// 1. 等待到下一个 tick</span><br>                <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> waitForNextTick();<br>                <br>                <span class="hljs-comment">// 2. 把 queue 中的新任务转移到 wheel 中</span><br>                transferTimeoutsToBuckets();<br>                <br>                <span class="hljs-comment">// 3. 处理当前 slot 中到期的任务</span><br>                <span class="hljs-type">HashedWheelBucket</span> <span class="hljs-variable">bucket</span> <span class="hljs-operator">=</span> wheel[(<span class="hljs-type">int</span>)(tick &amp; mask)];<br>                bucket.expireTimeouts(deadline);<br>                <br>                tick++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// Bucket 是一个双向链表</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashedWheelBucket</span> &#123;<br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">expireTimeouts</span><span class="hljs-params">(<span class="hljs-type">long</span> deadline)</span> &#123;<br>            <span class="hljs-type">HashedWheelTimeout</span> <span class="hljs-variable">timeout</span> <span class="hljs-operator">=</span> head;<br>            <span class="hljs-keyword">while</span> (timeout != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-type">HashedWheelTimeout</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> timeout.next;<br>                <span class="hljs-keyword">if</span> (timeout.remainingRounds &lt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">// 到期了，执行回调</span><br>                    timeout.expire();<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (timeout.isCancelled()) &#123;<br>                    <span class="hljs-comment">// 已取消，移除</span><br>                    remove(timeout);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    timeout.remainingRounds--;<br>                &#125;<br>                timeout = next;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-3-4-为什么-hsf-dubbo-选择时间轮？">2.3.4 为什么 HSF/Dubbo 选择时间轮？</h3>
<pre><code class="hljs mermaid">graph TB
    subgraph Comparison[&quot;三种超时方案对比&quot;]
        subgraph ParkNanos[&quot;方式1: parkNanos&quot;]
            P1[&quot;每个请求占一个线程&quot;]
            P2[&quot;10000 QPS = 30000 线程&quot;]
            P3[&quot;线程资源耗尽&quot;]
        end
        
        subgraph FutureGet[&quot;方式2: Future.get(timeout)&quot;]
            F1[&quot;调用方线程阻塞等待&quot;]
            F2[&quot;同步模型，无法复用线程&quot;]
            F3[&quot;不适合异步 RPC&quot;]
        end
        
        subgraph WheelTimer[&quot;方式3: HashedWheelTimer&quot;]
            W1[&quot;单线程管理所有超时&quot;]
            W2[&quot;O(1) 添加/取消&quot;]
            W3[&quot;完美适配高吞吐 RPC&quot;]
        end
    end
    
    style ParkNanos fill:#FFCDD2
    style FutureGet fill:#FFE0B2
    style WheelTimer fill:#C8E6C9</code></pre>
<table>
<thead>
<tr>
<th>维度</th>
<th>parkNanos</th>
<th>Future.get(timeout)</th>
<th>HashedWheelTimer</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>线程消耗</strong></td>
<td>每个等待占一个线程</td>
<td>调用方线程阻塞</td>
<td>仅 1 个 Worker 线程</td>
</tr>
<tr>
<td><strong>添加超时</strong></td>
<td>N/A</td>
<td>N/A</td>
<td>O(1)</td>
</tr>
<tr>
<td><strong>取消超时</strong></td>
<td>unpark</td>
<td>cancel</td>
<td>O(1)</td>
</tr>
<tr>
<td><strong>精度</strong></td>
<td>纳秒级</td>
<td>纳秒级</td>
<td>tickDuration 级（通常 100ms）</td>
</tr>
<tr>
<td><strong>适用并发量</strong></td>
<td>低（&lt; 100）</td>
<td>中（&lt; 1000）</td>
<td>高（&gt; 10000）</td>
</tr>
<tr>
<td><strong>编程模型</strong></td>
<td>同步阻塞</td>
<td>同步阻塞</td>
<td>异步回调</td>
</tr>
<tr>
<td><strong>典型使用者</strong></td>
<td>AQS, ReentrantLock</td>
<td>业务代码</td>
<td>Netty, Dubbo, HSF</td>
</tr>
</tbody>
</table>
<p><strong>关键洞察</strong>：时间轮牺牲了精度（100ms 级），换来了吞吐量。对于 RPC 超时来说，3 秒的超时差 100ms 完全可以接受。但如果需要微秒级精度的超时（比如锁等待），时间轮就不合适了。</p>
<h3 id="2-3-5-dubbo-中的超时实现">2.3.5 Dubbo 中的超时实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// org.apache.dubbo.remoting.exchange.support.DefaultFuture (简化)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultFuture</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CompletableFuture</span>&lt;Object&gt; &#123;<br>    <br>    <span class="hljs-comment">// 全局时间轮，所有请求共享</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">HashedWheelTimer</span> <span class="hljs-variable">TIMER</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashedWheelTimer</span>(<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">NamedThreadFactory</span>(<span class="hljs-string">&quot;dubbo-future-timeout&quot;</span>, <span class="hljs-literal">true</span>),<br>        <span class="hljs-number">30</span>,          <span class="hljs-comment">// tickDuration: 30ms</span><br>        TimeUnit.MILLISECONDS,<br>        <span class="hljs-number">512</span>          <span class="hljs-comment">// ticksPerWheel: 512 slots</span><br>    );<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">DefaultFuture</span><span class="hljs-params">(Channel channel, Request request, <span class="hljs-type">int</span> timeout)</span> &#123;<br>        <span class="hljs-built_in">this</span>.channel = channel;<br>        <span class="hljs-built_in">this</span>.request = request;<br>        <span class="hljs-built_in">this</span>.id = request.getId();<br>        <span class="hljs-built_in">this</span>.timeout = timeout;<br>        <br>        <span class="hljs-comment">// 注册超时任务到时间轮</span><br>        TIMER.newTimeout(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TimeoutCheckTask</span>(id), timeout, TimeUnit.MILLISECONDS);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 请求正常返回时</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">received</span><span class="hljs-params">(Response response)</span> &#123;<br>        <span class="hljs-type">DefaultFuture</span> <span class="hljs-variable">future</span> <span class="hljs-operator">=</span> FUTURES.remove(response.getId());<br>        <span class="hljs-keyword">if</span> (future != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 正常完成，超时任务会在下次 tick 时被跳过</span><br>            future.complete(response.getResult());<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 超时检查任务</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TimeoutCheckTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TimerTask</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Long requestId;<br>        <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(Timeout timeout)</span> &#123;<br>            <span class="hljs-type">DefaultFuture</span> <span class="hljs-variable">future</span> <span class="hljs-operator">=</span> FUTURES.get(requestId);<br>            <span class="hljs-keyword">if</span> (future == <span class="hljs-literal">null</span> || future.isDone()) &#123;<br>                <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 已经正常返回</span><br>            &#125;<br>            <span class="hljs-comment">// 超时，构造超时异常</span><br>            future.completeExceptionally(<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimeoutException</span>(<span class="hljs-string">&quot;Waiting server-side response timeout by scan timer.&quot;</span>));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<pre><code class="hljs mermaid">sequenceDiagram
    participant Client as 客户端线程
    participant Future as DefaultFuture
    participant Timer as HashedWheelTimer
    participant Server as 远程服务
    
    Client-&gt;&gt;Future: 创建 Future
    Future-&gt;&gt;Timer: newTimeout(3s)
    Client-&gt;&gt;Server: 发送 RPC 请求
    
    Note over Client: 客户端线程可以去做别的事&lt;br/&gt;（异步模型，不阻塞）
    
    alt 正常返回（&lt; 3s）
        Server--&gt;&gt;Future: received(response)
        Future-&gt;&gt;Future: complete(result)
        Note over Timer: 下次 tick 时发现已完成，跳过
    else 超时（&gt;= 3s）
        Timer-&gt;&gt;Future: TimeoutCheckTask.run()
        Future-&gt;&gt;Future: completeExceptionally(TimeoutException)
    end
    
    Client-&gt;&gt;Future: whenComplete / get</code></pre>
<h2 id="2-4-java-超时机制选择决策树">2.4 Java 超时机制选择决策树</h2>
<pre><code class="hljs mermaid">graph TB
    Start[&quot;需要超时控制&quot;] --&gt; Q1&#123;&quot;并发量多大?&quot;&#125;
    
    Q1 --&gt;|&quot;&lt; 100&quot;| Q2&#123;&quot;需要纳秒精度?&quot;&#125;
    Q2 --&gt;|Yes| A1[&quot;方式1: parkNanos&lt;br/&gt;如 ReentrantLock.tryLock(timeout)&quot;]
    Q2 --&gt;|No| A2[&quot;方式2: Future.get(timeout)&lt;br/&gt;简单直接&quot;]
    
    Q1 --&gt;|&quot;100 ~ 1000&quot;| Q3&#123;&quot;同步还是异步?&quot;&#125;
    Q3 --&gt;|同步| A2
    Q3 --&gt;|异步| Q4&#123;&quot;需要高精度?&quot;&#125;
    Q4 --&gt;|Yes| A3[&quot;ScheduledExecutorService&lt;br/&gt;O(log n) 但精度高&quot;]
    Q4 --&gt;|No| A4[&quot;方式3: HashedWheelTimer&lt;br/&gt;O(1) 但精度低&quot;]
    
    Q1 --&gt;|&quot;&gt; 1000&quot;| A4
    
    style A1 fill:#E3F2FD
    style A2 fill:#E8F5E9
    style A3 fill:#FFF3E0
    style A4 fill:#F3E5F5</code></pre>
<h2 id="2-5-展望：virtual-thread-与-structured-concurrency">2.5 展望：Virtual Thread 与 Structured Concurrency</h2>
<p>前文反复提到 Java 超时机制复杂的根本原因：<strong>线程太重</strong>。JDK 21 引入的 Virtual Thread（虚拟线程）和 Structured Concurrency（结构化并发）正在从根本上改变这一局面。</p>
<h3 id="virtual-thread-对超时的影响">Virtual Thread 对超时的影响</h3>
<p>虚拟线程的创建成本极低（约几百字节栈空间），使得&quot;一个请求一个线程&quot;在 Java 中也变得可行——这与 Go 的 goroutine 模型非常接近。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// JDK 21+：虚拟线程 + Future.get(timeout)</span><br><span class="hljs-comment">// 由于虚拟线程极其轻量，阻塞等待不再是资源瓶颈</span><br><span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newVirtualThreadPerTaskExecutor()) &#123;<br>    Future&lt;String&gt; future = executor.submit(() -&gt; slowRpcCall());<br>    <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> future.get(<span class="hljs-number">3</span>, TimeUnit.SECONDS); <span class="hljs-comment">// 阻塞的是虚拟线程，不是平台线程</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>在虚拟线程模型下，<code>Future.get(timeout)</code> 的&quot;一个等待占一个线程&quot;问题不再严重，因为虚拟线程的阻塞不会占用操作系统线程。但这<strong>并不意味着时间轮失去了价值</strong>——时间轮解决的是&quot;高效管理大量定时任务&quot;的问题（O(1) 添加/取消），而非线程资源问题。在高吞吐 RPC 框架中，时间轮仍然是更优的选择。</p>
<h3 id="structured-concurrency：java-版的-context-传播">Structured Concurrency：Java 版的 context 传播</h3>
<p>JDK 21 的 <code>StructuredTaskScope</code>（预览特性）提供了一种与 Go <code>context.WithTimeout</code> 语义接近的超时模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// JDK 21+ (Preview): 结构化并发 + 超时</span><br><span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StructuredTaskScope</span>.ShutdownOnFailure()) &#123;<br>    Subtask&lt;String&gt; userTask = scope.fork(() -&gt; fetchUser(userId));<br>    Subtask&lt;List&lt;Order&gt;&gt; ordersTask = scope.fork(() -&gt; fetchOrders(userId));<br>    <br>    <span class="hljs-comment">// 带超时的 join：所有子任务必须在 3 秒内完成</span><br>    scope.joinUntil(Instant.now().plusSeconds(<span class="hljs-number">3</span>));<br>    scope.throwIfFailed();<br>    <br>    <span class="hljs-comment">// 此处所有子任务已完成</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>(userTask.get(), ordersTask.get());<br>&#125;<br><span class="hljs-comment">// scope 关闭时，未完成的子任务会被自动取消</span><br></code></pre></td></tr></table></figure>
<p>这种模式的关键优势：</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>传统 Java</th>
<th>Structured Concurrency</th>
<th>Go context</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>超时传播</strong></td>
<td>手动传递</td>
<td>scope 自动管理</td>
<td>context 树自动传播</td>
</tr>
<tr>
<td><strong>取消联动</strong></td>
<td>需显式 cancel</td>
<td>scope 关闭时自动取消子任务</td>
<td>父 context 取消级联子 context</td>
</tr>
<tr>
<td><strong>资源泄漏</strong></td>
<td>容易忘记 cancel</td>
<td>scope 保证清理</td>
<td>defer cancel() 保证清理</td>
</tr>
<tr>
<td><strong>可观测性</strong></td>
<td>线程栈分散</td>
<td>结构化的父子关系</td>
<td>context 树</td>
</tr>
</tbody>
</table>
<p>Structured Concurrency 的出现意味着 Java 正在向 Go 的超时哲学靠拢：<strong>超时和取消应该是结构化的、可传播的、自动清理的</strong>。这是 Java 并发模型自 JDK 5 引入 <code>java.util.concurrent</code> 以来最重要的范式转变。</p>
<h1>3. Go：超时是一等公民</h1>
<p>如果说 Java 的超时是&quot;在线程模型上打补丁&quot;，那么 Go 的超时则是&quot;从语言层面原生支持&quot;。Go 的 CSP（Communicating Sequential Processes）模型让超时变得异常优雅。</p>
<h2 id="3-1-select-time-after：最基础的超时">3.1 select + time.After：最基础的超时</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fetchWithTimeout</span><span class="hljs-params">(url <span class="hljs-type">string</span>, timeout time.Duration)</span></span> (<span class="hljs-type">string</span>, <span class="hljs-type">error</span>) &#123;<br>    resultChan := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>, <span class="hljs-number">1</span>)<br>    errChan := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">error</span>, <span class="hljs-number">1</span>)<br>    <br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        resp, err := http.Get(url)<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            errChan &lt;- err<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        <span class="hljs-keyword">defer</span> resp.Body.Close()<br>        body, _ := io.ReadAll(resp.Body)<br>        resultChan &lt;- <span class="hljs-type">string</span>(body)<br>    &#125;()<br>    <br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> result := &lt;-resultChan:<br>        <span class="hljs-keyword">return</span> result, <span class="hljs-literal">nil</span><br>    <span class="hljs-keyword">case</span> err := &lt;-errChan:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, err<br>    <span class="hljs-keyword">case</span> &lt;-time.After(timeout):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, fmt.Errorf(<span class="hljs-string">&quot;request timeout after %v&quot;</span>, timeout)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>原理</strong>：<code>time.After(d)</code> 返回一个 channel，在 <code>d</code> 时间后会收到一个值。<code>select</code> 同时监听多个 channel，哪个先就绪就走哪个分支。</p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant G as Goroutine
    participant RC as resultChan
    participant TC as time.After(3s)
    participant S as select
    
    G-&gt;&gt;G: 发起 HTTP 请求
    
    Note over S: select 同时监听两个 channel
    
    alt 请求先返回
        G-&gt;&gt;RC: 写入结果
        RC-&gt;&gt;S: 就绪
        S-&gt;&gt;S: 走 resultChan 分支
    else 超时先到
        TC-&gt;&gt;S: 3秒到，写入时间值
        S-&gt;&gt;S: 走 time.After 分支
        Note over G: goroutine 仍在运行&lt;br/&gt;（与 Java Future.get 超时相同的问题）
    end</code></pre>
<p><strong>注意</strong>：在 Go 1.23 之前，<code>time.After</code> 存在内存泄漏风险。每次调用都会创建一个 <code>Timer</code>，如果在循环中使用且大部分不会触发超时，这些 Timer 直到触发后才会被 GC。从 Go 1.23 开始，未被引用的 Timer 即使尚未触发也可以被 GC 回收，这个问题已得到修复。但在使用较旧版本的 Go 时，仍应优先使用 <code>context.WithTimeout</code> 或手动管理 <code>time.NewTimer</code>。</p>
<h2 id="3-2-context-withtimeout：go-的标准答案">3.2 context.WithTimeout：Go 的标准答案</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fetchWithContext</span><span class="hljs-params">(ctx context.Context, url <span class="hljs-type">string</span>)</span></span> (<span class="hljs-type">string</span>, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-comment">// 创建带超时的 context</span><br>    ctx, cancel := context.WithTimeout(ctx, <span class="hljs-number">3</span>*time.Second)<br>    <span class="hljs-keyword">defer</span> cancel() <span class="hljs-comment">// 防止 context 泄漏</span><br>    <br>    req, err := http.NewRequestWithContext(ctx, <span class="hljs-string">&quot;GET&quot;</span>, url, <span class="hljs-literal">nil</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, err<br>    &#125;<br>    <br>    resp, err := http.DefaultClient.Do(req)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-comment">// 如果是超时，err 会包含 context.DeadlineExceeded</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, err<br>    &#125;<br>    <span class="hljs-keyword">defer</span> resp.Body.Close()<br>    <br>    body, err := io.ReadAll(resp.Body)<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(body), err<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>context 的精髓</strong>：超时可以<strong>传播</strong>。</p>
<pre><code class="hljs mermaid">graph TB
    subgraph ContextTree[&quot;Context 传播树&quot;]
        Root[&quot;Background Context&quot;]
        Root --&gt; C1[&quot;WithTimeout(3s)&lt;br/&gt;API Handler&quot;]
        C1 --&gt; C2[&quot;WithTimeout(2s)&lt;br/&gt;DB Query&quot;]
        C1 --&gt; C3[&quot;WithTimeout(2s)&lt;br/&gt;Redis Get&quot;]
        C1 --&gt; C4[&quot;WithTimeout(1s)&lt;br/&gt;RPC Call&quot;]
        C4 --&gt; C5[&quot;WithTimeout(500ms)&lt;br/&gt;子服务调用&quot;]
    end
    
    Cancel[&quot;父 context 取消&lt;br/&gt;-&gt; 所有子 context 自动取消&quot;]
    
    C1 -.-&gt;|&quot;3s 到期&quot;| Cancel
    Cancel -.-&gt; C2
    Cancel -.-&gt; C3
    Cancel -.-&gt; C4
    Cancel -.-&gt; C5
    
    style Cancel fill:#FFCDD2
    style Root fill:#E3F2FD</code></pre>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 超时传播示例</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handleRequest</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>    <span class="hljs-comment">// 整个请求 5 秒超时</span><br>    ctx, cancel := context.WithTimeout(r.Context(), <span class="hljs-number">5</span>*time.Second)<br>    <span class="hljs-keyword">defer</span> cancel()<br>    <br>    <span class="hljs-comment">// 子操作共享父 context，任何一个超时都会级联取消</span><br>    userChan := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *User, <span class="hljs-number">1</span>)<br>    orderChan := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> []*Order, <span class="hljs-number">1</span>)<br>    <br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        user, _ := fetchUser(ctx, userID)     <span class="hljs-comment">// 继承 5s 超时</span><br>        userChan &lt;- user<br>    &#125;()<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        orders, _ := fetchOrders(ctx, userID) <span class="hljs-comment">// 继承 5s 超时</span><br>        orderChan &lt;- orders<br>    &#125;()<br>    <br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>        http.Error(w, <span class="hljs-string">&quot;request timeout&quot;</span>, http.StatusGatewayTimeout)<br>    <span class="hljs-keyword">case</span> user := &lt;-userChan:<br>        orders := &lt;-orderChan<br>        render(w, user, orders)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="3-3-go-vs-java：超时哲学对比">3.3 Go vs Java：超时哲学对比</h2>
<table>
<thead>
<tr>
<th>维度</th>
<th>Java</th>
<th>Go</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>并发单元</strong></td>
<td>线程（重量级，MB 级栈）</td>
<td>goroutine（轻量级，KB 级栈）</td>
</tr>
<tr>
<td><strong>超时代价</strong></td>
<td>阻塞一个线程</td>
<td>阻塞一个 goroutine（几乎免费）</td>
</tr>
<tr>
<td><strong>超时传播</strong></td>
<td>需要手动传递</td>
<td>context 自动传播</td>
</tr>
<tr>
<td><strong>取消机制</strong></td>
<td><code>Future.cancel()</code> / <code>Thread.interrupt()</code></td>
<td><code>context.cancel()</code> / channel close</td>
</tr>
<tr>
<td><strong>标准做法</strong></td>
<td>没有统一标准</td>
<td><code>context.WithTimeout</code> 是唯一标准</td>
</tr>
<tr>
<td><strong>语言支持</strong></td>
<td>库级别</td>
<td>语言级别（select 是关键字）</td>
</tr>
</tbody>
</table>
<p><strong>核心差异</strong>：Go 的 goroutine 极其轻量（创建成本约 2KB），因此&quot;一个请求一个 goroutine&quot;完全可行。Java 的线程是操作系统线程（创建成本约 1MB），因此必须用线程池复用，超时管理也因此更复杂。</p>
<p>这也解释了为什么 Go 不需要时间轮：goroutine 足够便宜，每个超时任务用一个 goroutine + timer 就够了。</p>
<h1>4. JavaScript：事件循环中的超时</h1>
<p>JavaScript 是单线程的，没有&quot;阻塞等待&quot;的概念。所有的&quot;等待&quot;都是通过事件循环和回调实现的。这让超时的实现反而变得简单——因为根本不需要&quot;唤醒&quot;任何东西。</p>
<h2 id="4-1-settimeout：最原始的超时">4.1 setTimeout：最原始的超时</h2>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 回调风格</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchWithTimeout</span>(<span class="hljs-params">url, timeoutMs, callback</span>) &#123;<br>    <span class="hljs-keyword">let</span> timedOut = <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        timedOut = <span class="hljs-literal">true</span>;<br>        <span class="hljs-title function_">callback</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Request timeout after <span class="hljs-subst">$&#123;timeoutMs&#125;</span>ms`</span>), <span class="hljs-literal">null</span>);<br>    &#125;, timeoutMs);<br>    <br>    <span class="hljs-title function_">fetch</span>(url)<br>        .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.<span class="hljs-title function_">json</span>())<br>        .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (!timedOut) &#123;<br>                <span class="hljs-built_in">clearTimeout</span>(timer);<br>                <span class="hljs-title function_">callback</span>(<span class="hljs-literal">null</span>, data);<br>            &#125;<br>        &#125;)<br>        .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (!timedOut) &#123;<br>                <span class="hljs-built_in">clearTimeout</span>(timer);<br>                <span class="hljs-title function_">callback</span>(err, <span class="hljs-literal">null</span>);<br>            &#125;<br>        &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="4-2-promise-race：现代-javascript-的超时">4.2 Promise.race：现代 JavaScript 的超时</h2>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">withTimeout</span>(<span class="hljs-params">promise, timeoutMs, errorMessage</span>) &#123;<br>    <span class="hljs-keyword">const</span> timeoutPromise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">_, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(errorMessage || <span class="hljs-string">`Timeout after <span class="hljs-subst">$&#123;timeoutMs&#125;</span>ms`</span>));<br>        &#125;, timeoutMs);<br>    &#125;);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([promise, timeoutPromise]);<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchUser</span>(<span class="hljs-params">userId</span>) &#123;<br>    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">withTimeout</span>(<br>        <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`/api/users/<span class="hljs-subst">$&#123;userId&#125;</span>`</span>),<br>        <span class="hljs-number">3000</span>,<br>        <span class="hljs-string">&#x27;Fetch user timeout&#x27;</span><br>    );<br>    <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">json</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<pre><code class="hljs mermaid">sequenceDiagram
    participant EL as 事件循环
    participant P1 as fetch Promise
    participant P2 as timeout Promise
    participant Race as Promise.race
    
    EL-&gt;&gt;P1: 发起 fetch
    EL-&gt;&gt;P2: 注册 setTimeout(3000)
    EL-&gt;&gt;Race: 监听两个 Promise
    
    alt fetch 先完成
        P1-&gt;&gt;Race: resolve(response)
        Race-&gt;&gt;EL: 返回 response
        Note over P2: setTimeout 仍会触发&lt;br/&gt;但 race 已 settled，无影响
    else 超时先到
        P2-&gt;&gt;Race: reject(TimeoutError)
        Race-&gt;&gt;EL: 抛出 TimeoutError
        Note over P1: fetch 仍在进行&lt;br/&gt;（无法真正取消）
    end</code></pre>
<h2 id="4-3-abortcontroller：真正的取消">4.3 AbortController：真正的取消</h2>
<p><code>Promise.race</code> 的问题与 Java <code>Future.get(timeout)</code> 相同：<strong>超时不等于取消</strong>。fetch 请求仍在进行。<code>AbortController</code> 解决了这个问题：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchWithAbort</span>(<span class="hljs-params">url, timeoutMs</span>) &#123;<br>    <span class="hljs-keyword">const</span> controller = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbortController</span>();<br>    <span class="hljs-keyword">const</span> &#123; signal &#125; = controller;<br>    <br>    <span class="hljs-comment">// 超时后真正取消请求</span><br>    <span class="hljs-keyword">const</span> timeoutId = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> controller.<span class="hljs-title function_">abort</span>(), timeoutMs);<br>    <br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(url, &#123; signal &#125;);<br>        <span class="hljs-built_in">clearTimeout</span>(timeoutId);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();<br>    &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>        <span class="hljs-built_in">clearTimeout</span>(timeoutId);<br>        <span class="hljs-keyword">if</span> (err.<span class="hljs-property">name</span> === <span class="hljs-string">&#x27;AbortError&#x27;</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Request aborted: timeout after <span class="hljs-subst">$&#123;timeoutMs&#125;</span>ms`</span>);<br>        &#125;<br>        <span class="hljs-keyword">throw</span> err;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<pre><code class="hljs mermaid">graph LR
    A[&quot;AbortController&quot;] --&gt;|&quot;创建&quot;| B[&quot;AbortSignal&quot;]
    B --&gt;|&quot;传递给&quot;| C[&quot;fetch()&quot;]
    B --&gt;|&quot;传递给&quot;| D[&quot;ReadableStream&quot;]
    B --&gt;|&quot;传递给&quot;| E[&quot;EventTarget&quot;]
    
    F[&quot;setTimeout&quot;] --&gt;|&quot;超时触发&quot;| G[&quot;controller.abort()&quot;]
    G --&gt;|&quot;设置 signal.aborted = true&quot;| B
    B --&gt;|&quot;触发 abort 事件&quot;| C
    C --&gt;|&quot;真正取消网络请求&quot;| H[&quot;AbortError&quot;]
    
    style G fill:#FFCDD2
    style H fill:#FFCDD2</code></pre>
<h2 id="4-4-node-js-中的-abortsignal-timeout-现代方式">4.4 Node.js 中的 AbortSignal.timeout（现代方式）</h2>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Node.js 17.3+ / 现代浏览器</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchModern</span>(<span class="hljs-params">url</span>) &#123;<br>    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(url, &#123;<br>        <span class="hljs-attr">signal</span>: <span class="hljs-title class_">AbortSignal</span>.<span class="hljs-title function_">timeout</span>(<span class="hljs-number">3000</span>) <span class="hljs-comment">// 一行搞定</span><br>    &#125;);<br>    <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">json</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<h1>5. Ruby：优雅但有陷阱</h1>
<p>Ruby 的超时实现看起来最简洁，但暗藏玄机。</p>
<h2 id="5-1-timeout-timeout：标准库的甜蜜陷阱">5.1 Timeout.timeout：标准库的甜蜜陷阱</h2>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">require</span> <span class="hljs-string">&#x27;timeout&#x27;</span><br><span class="hljs-keyword">require</span> <span class="hljs-string">&#x27;net/http&#x27;</span><br><br><span class="hljs-keyword">begin</span><br>  result = <span class="hljs-title class_">Timeout</span>.timeout(<span class="hljs-number">3</span>) <span class="hljs-keyword">do</span><br>    <span class="hljs-title class_">Net</span><span class="hljs-symbol">:</span><span class="hljs-symbol">:HTTP</span>.get(<span class="hljs-variable constant_">URI</span>(<span class="hljs-string">&#x27;https://slow-api.example.com/data&#x27;</span>))<br>  <span class="hljs-keyword">end</span><br>  puts result<br><span class="hljs-keyword">rescue</span> <span class="hljs-title class_">Timeout</span><span class="hljs-symbol">:</span><span class="hljs-symbol">:Error</span> =&gt; e<br>  puts <span class="hljs-string">&quot;Request timed out: <span class="hljs-subst">#&#123;e.message&#125;</span>&quot;</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>
<p>看起来很优雅，但 <code>Timeout.timeout</code> 的实现方式是<strong>危险的</strong>：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-comment"># Ruby 标准库 timeout.rb 的核心实现（简化）</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">timeout</span>(<span class="hljs-params">sec, klass = <span class="hljs-literal">nil</span></span>)<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">yield</span> <span class="hljs-keyword">if</span> sec.<span class="hljs-literal">nil</span>? |<span class="hljs-params"></span>| sec.zero?<br>  <br>  exception = klass |<span class="hljs-params"></span>| <span class="hljs-title class_">Timeout</span><span class="hljs-symbol">:</span><span class="hljs-symbol">:Error</span><br>  <br>  current_thread = <span class="hljs-title class_">Thread</span>.current<br>  <br>  <span class="hljs-comment"># 创建一个新线程来计时</span><br>  timer_thread = <span class="hljs-title class_">Thread</span>.new <span class="hljs-keyword">do</span><br>    sleep sec<br>    <span class="hljs-comment"># 时间到了，向调用 timeout 的线程抛出异常</span><br>    current_thread.<span class="hljs-keyword">raise</span> exception, <span class="hljs-string">&quot;execution expired&quot;</span><br>  <span class="hljs-keyword">end</span><br>  <br>  <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">yield</span><br>  <span class="hljs-keyword">ensure</span><br>    timer_thread.kill  <span class="hljs-comment"># 清理计时线程</span><br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>
<pre><code class="hljs mermaid">sequenceDiagram
    participant Main as 主线程
    participant Timer as 计时线程
    participant Block as 代码块
    
    Main-&gt;&gt;Timer: Thread.new &#123; sleep(3) &#125;
    Main-&gt;&gt;Block: yield（执行代码块）
    
    alt 代码块先完成
        Block-&gt;&gt;Main: 返回结果
        Main-&gt;&gt;Timer: timer_thread.kill
    else 超时先到
        Timer-&gt;&gt;Timer: sleep(3) 结束
        Timer-&gt;&gt;Main: current_thread.raise(Timeout::Error)
        Note over Main: 异常可能在任何地方被抛出&lt;br/&gt;包括 ensure 块内部
    end</code></pre>
<h3 id="5-1-1-为什么说它危险？">5.1.1 为什么说它危险？</h3>
<p><strong>问题：异常可能在任何位置被抛出</strong>，包括 <code>ensure</code>（相当于 Java 的 <code>finally</code>）块内部：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-comment"># 危险示例</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">transfer_money</span>(<span class="hljs-params">from, to, amount</span>)<br>  <span class="hljs-title class_">Timeout</span>.timeout(<span class="hljs-number">5</span>) <span class="hljs-keyword">do</span><br>    from.debit(amount)<br>    <span class="hljs-comment"># 如果超时异常恰好在这里抛出...</span><br>    to.credit(amount)  <span class="hljs-comment"># 这行不会执行</span><br>    <span class="hljs-comment"># 结果：钱扣了但没加</span><br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">rescue</span> <span class="hljs-title class_">Timeout</span><span class="hljs-symbol">:</span><span class="hljs-symbol">:Error</span><br>  <span class="hljs-comment"># 无法可靠地回滚，因为不知道执行到哪了</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment"># 更危险的情况</span><br><span class="hljs-title class_">Timeout</span>.timeout(<span class="hljs-number">5</span>) <span class="hljs-keyword">do</span><br>  mutex.synchronize <span class="hljs-keyword">do</span><br>    <span class="hljs-comment"># 如果超时异常在 synchronize 内部抛出</span><br>    <span class="hljs-comment"># mutex 可能不会被正确释放（取决于实现）</span><br>    do_something_slow<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>
<h2 id="5-2-更安全的替代方案">5.2 更安全的替代方案</h2>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-comment"># 方式1：IO.select 超时（仅适用于 IO 操作）</span><br>socket = <span class="hljs-title class_">TCPSocket</span>.new(<span class="hljs-string">&#x27;example.com&#x27;</span>, <span class="hljs-number">80</span>)<br>ready = <span class="hljs-variable constant_">IO</span>.select([socket], <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, <span class="hljs-number">3</span>) <span class="hljs-comment"># 3秒超时</span><br><span class="hljs-keyword">if</span> ready<br>  data = socket.read<br><span class="hljs-keyword">else</span><br>  puts <span class="hljs-string">&quot;IO timeout&quot;</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment"># 方式2：使用支持超时的库 API</span><br><span class="hljs-keyword">require</span> <span class="hljs-string">&#x27;net/http&#x27;</span><br>http = <span class="hljs-title class_">Net::HTTP</span>.new(<span class="hljs-string">&#x27;example.com&#x27;</span>, <span class="hljs-number">443</span>)<br>http.open_timeout = <span class="hljs-number">3</span>   <span class="hljs-comment"># 连接超时</span><br>http.read_timeout = <span class="hljs-number">5</span>   <span class="hljs-comment"># 读取超时</span><br>http.write_timeout = <span class="hljs-number">3</span>  <span class="hljs-comment"># 写入超时（Ruby 2.6+）</span><br>response = http.get(<span class="hljs-string">&#x27;/&#x27;</span>)<br></code></pre></td></tr></table></figure>
<h1>6. 跨语言对比：超时机制全景表</h1>
<pre><code class="hljs mermaid">graph TB
    subgraph Spectrum[&quot;超时机制光谱&quot;]
        direction LR
        Low[&quot;底层&lt;br/&gt;手动控制&quot;] --&gt; Mid[&quot;中层&lt;br/&gt;框架封装&quot;] --&gt; High[&quot;高层&lt;br/&gt;语言原生&quot;]
    end
    
    subgraph Mechanisms[&quot;各语言定位&quot;]
        J1[&quot;Java: parkNanos&quot;] -.-&gt; Low
        J2[&quot;Java: Future.get&quot;] -.-&gt; Mid
        J3[&quot;Java: 时间轮&quot;] -.-&gt; Mid
        G1[&quot;Go: context&quot;] -.-&gt; High
        JS1[&quot;JS: AbortController&quot;] -.-&gt; Mid
        R1[&quot;Ruby: Timeout&quot;] -.-&gt; High
    end
    
    style Low fill:#FFCDD2
    style Mid fill:#FFE0B2
    style High fill:#C8E6C9</code></pre>
<h2 id="6-1-终极对比表">6.1 终极对比表</h2>
<table>
<thead>
<tr>
<th>维度</th>
<th>Java parkNanos</th>
<th>Java Future.get</th>
<th>Java 时间轮</th>
<th>Go context</th>
<th>JS Promise.race</th>
<th>JS AbortController</th>
<th>Ruby Timeout</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>并发模型</strong></td>
<td>线程</td>
<td>线程</td>
<td>线程</td>
<td>goroutine</td>
<td>事件循环</td>
<td>事件循环</td>
<td>线程</td>
</tr>
<tr>
<td><strong>阻塞方式</strong></td>
<td>OS 级阻塞</td>
<td>OS 级阻塞</td>
<td>不阻塞</td>
<td>goroutine 阻塞</td>
<td>不阻塞</td>
<td>不阻塞</td>
<td>OS 级阻塞</td>
</tr>
<tr>
<td><strong>精度</strong></td>
<td>纳秒</td>
<td>纳秒</td>
<td>毫秒</td>
<td>纳秒</td>
<td>毫秒</td>
<td>毫秒</td>
<td>秒</td>
</tr>
<tr>
<td><strong>资源消耗</strong></td>
<td>高（1线程/等待）</td>
<td>高</td>
<td>低（1线程/全部）</td>
<td>极低</td>
<td>极低</td>
<td>极低</td>
<td>高（1线程/超时）</td>
</tr>
<tr>
<td><strong>取消支持</strong></td>
<td>interrupt</td>
<td>cancel</td>
<td>cancel</td>
<td>context.cancel</td>
<td>无</td>
<td>abort</td>
<td>Thread.kill</td>
</tr>
<tr>
<td><strong>传播能力</strong></td>
<td>无</td>
<td>无</td>
<td>无</td>
<td>context 树</td>
<td>无</td>
<td>signal 传递</td>
<td>无</td>
</tr>
<tr>
<td><strong>安全性</strong></td>
<td>高</td>
<td>高</td>
<td>高</td>
<td>高</td>
<td>中</td>
<td>高</td>
<td><strong>低</strong></td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>锁/同步原语</td>
<td>通用业务</td>
<td>高吞吐RPC</td>
<td>所有场景</td>
<td>通用异步</td>
<td>网络请求</td>
<td>简单脚本</td>
</tr>
</tbody>
</table>
<h2 id="6-2-各语言的最佳实践">6.2 各语言的最佳实践</h2>
<pre><code class="hljs mermaid">graph TB
    subgraph BestPractice[&quot;各语言超时最佳实践&quot;]
        Java[&quot;Java&quot;]
        Go[&quot;Go&quot;]
        JS[&quot;JavaScript&quot;]
        Ruby[&quot;Ruby&quot;]
    end
    
    Java --&gt; JP[&quot;业务代码: CompletableFuture.orTimeout() (JDK 9+)&lt;br/&gt;RPC框架: HashedWheelTimer&lt;br/&gt;锁等待: tryLock(timeout)&quot;]
    Go --&gt; GP[&quot;统一使用 context.WithTimeout&lt;br/&gt;通过 context 传播超时&lt;br/&gt;defer cancel() 防泄漏&quot;]
    JS --&gt; JSP[&quot;网络请求: AbortSignal.timeout()&lt;br/&gt;通用异步: Promise.race&lt;br/&gt;Node.js: AbortController&quot;]
    Ruby --&gt; RP[&quot;IO操作: 使用库自带的超时参数&lt;br/&gt;避免 Timeout.timeout&lt;br/&gt;考虑 IO.select&quot;]
    
    style JP fill:#FFF3E0
    style GP fill:#E8F5E9
    style JSP fill:#FFFDE7
    style RP fill:#FCE4EC</code></pre>
<h3 id="java-9-的-completablefuture-ortimeout">Java 9+ 的 CompletableFuture.orTimeout</h3>
<p>值得一提的是，Java 9 在 <code>CompletableFuture</code> 上增加了原生超时支持：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// JDK 9+</span><br>CompletableFuture&lt;String&gt; future = CompletableFuture<br>    .supplyAsync(() -&gt; slowRpcCall())<br>    .orTimeout(<span class="hljs-number">3</span>, TimeUnit.SECONDS)           <span class="hljs-comment">// 超时抛 TimeoutException</span><br>    .exceptionally(ex -&gt; <span class="hljs-string">&quot;fallback value&quot;</span>);    <span class="hljs-comment">// 降级</span><br><br><span class="hljs-comment">// 或者用 completeOnTimeout 提供默认值</span><br>CompletableFuture&lt;String&gt; future = CompletableFuture<br>    .supplyAsync(() -&gt; slowRpcCall())<br>    .completeOnTimeout(<span class="hljs-string">&quot;default&quot;</span>, <span class="hljs-number">3</span>, TimeUnit.SECONDS);<br></code></pre></td></tr></table></figure>
<p><code>orTimeout</code> 底层基于 <code>ScheduledThreadPoolExecutor</code>（<code>CompletableFuture.Delayer</code> 静态内部类），本质上是向一个全局共享的守护线程池提交延迟任务。这与 JavaScript 的 <code>Promise.race + setTimeout</code> 在 API 层面趋于一致，但底层机制截然不同：</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>Java <code>orTimeout</code></th>
<th>JavaScript <code>setTimeout</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>定时器</strong></td>
<td><code>ScheduledThreadPoolExecutor</code>（线程池 + DelayQueue）</td>
<td>事件循环内置定时器（libuv / 浏览器引擎）</td>
</tr>
<tr>
<td><strong>线程安全</strong></td>
<td>需要 CAS 保证原子性</td>
<td>单线程，天然无竞态</td>
</tr>
<tr>
<td><strong>资源开销</strong></td>
<td>全局 1 个守护线程 + 堆操作</td>
<td>零额外线程</td>
</tr>
<tr>
<td><strong>取消原始任务</strong></td>
<td>不会自动取消</td>
<td>不会自动取消</td>
</tr>
</tbody>
</table>
<p>二者的共同缺陷是：超时后原始任务都不会被真正取消。Java 需要配合 <code>cancel(true)</code> + 中断检查，JavaScript 需要使用 <code>AbortController</code>。关于 <code>orTimeout</code> 底层实现的详细源码分析，可参考 <a href="/2026/01/24/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0/">Java 线程池笔记</a> 中 CompletableFuture 超时机制的深入讨论。</p>
<h1>7. 深入：超时后的&quot;善后&quot;问题</h1>
<p>超时只是故事的一半。另一半是：<strong>超时后，原来的任务怎么办？</strong></p>
<p>这是所有语言都要面对的共同难题。</p>
<h2 id="7-1-超时不等于取消：一个跨语言的通病">7.1 超时不等于取消：一个跨语言的通病</h2>
<pre><code class="hljs mermaid">graph TB
    subgraph Problem[&quot;超时后任务仍在运行&quot;]
        T[&quot;超时触发&quot;] --&gt; Q&#123;&quot;任务停了吗?&quot;&#125;
        Q --&gt;|&quot;Java Future.get&quot;| N1[&quot;否，需要 cancel(true)&quot;]
        Q --&gt;|&quot;Go select&quot;| N2[&quot;否，goroutine 仍在运行&quot;]
        Q --&gt;|&quot;JS Promise.race&quot;| N3[&quot;否，fetch 仍在进行&quot;]
        Q --&gt;|&quot;Ruby Timeout&quot;| Y1[&quot;是，通过 Thread.raise&quot;]
    end
    
    subgraph Solution[&quot;正确做法&quot;]
        S1[&quot;Java: future.cancel(true) + 检查中断&quot;]
        S2[&quot;Go: 传递 context，检查 ctx.Done()&quot;]
        S3[&quot;JS: AbortController.abort()&quot;]
        S4[&quot;Ruby: 但 Thread.raise 本身不安全&quot;]
    end
    
    N1 --&gt; S1
    N2 --&gt; S2
    N3 --&gt; S3
    Y1 --&gt; S4
    
    style N1 fill:#FFCDD2
    style N2 fill:#FFCDD2
    style N3 fill:#FFCDD2
    style Y1 fill:#C8E6C9
    style S4 fill:#FFCDD2</code></pre>
<h2 id="7-2-java-的中断协作模型">7.2 Java 的中断协作模型</h2>
<p>Java 的取消是<strong>协作式</strong>的。<code>Thread.interrupt()</code> 只是设置一个标志位，任务必须主动检查：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CooperativeCancellation</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;String&gt; &#123;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; i++) &#123;<br>            <span class="hljs-comment">// 必须主动检查中断标志</span><br>            <span class="hljs-keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;<br>                <span class="hljs-comment">// 清理资源</span><br>                cleanup();<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>(<span class="hljs-string">&quot;Task cancelled&quot;</span>);<br>            &#125;<br>            <br>            result.append(processItem(i));<br>            <br>            <span class="hljs-comment">// 阻塞操作（如 sleep, wait, IO）会自动响应中断</span><br>            <span class="hljs-comment">// 抛出 InterruptedException</span><br>            Thread.sleep(<span class="hljs-number">1</span>); <br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> result.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="7-3-go-的-context-检查">7.3 Go 的 context 检查</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longRunningTask</span><span class="hljs-params">(ctx context.Context)</span></span> <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; i++ &#123;<br>        <span class="hljs-keyword">select</span> &#123;<br>        <span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>            <span class="hljs-comment">// context 被取消（超时或手动取消）</span><br>            cleanup()<br>            <span class="hljs-keyword">return</span> ctx.Err() <span class="hljs-comment">// context.DeadlineExceeded 或 context.Canceled</span><br>        <span class="hljs-keyword">default</span>:<br>            processItem(i)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="7-4-超时善后对比">7.4 超时善后对比</h2>
<table>
<thead>
<tr>
<th>语言</th>
<th>取消机制</th>
<th>是否协作式</th>
<th>能否真正停止任务</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Java</strong></td>
<td><code>Thread.interrupt()</code></td>
<td>是</td>
<td>取决于任务是否检查中断</td>
</tr>
<tr>
<td><strong>Go</strong></td>
<td><code>context.cancel()</code></td>
<td>是</td>
<td>取决于任务是否检查 ctx.Done()</td>
</tr>
<tr>
<td><strong>JavaScript</strong></td>
<td><code>AbortController.abort()</code></td>
<td>是</td>
<td>取决于 API 是否支持 signal</td>
</tr>
<tr>
<td><strong>Ruby</strong></td>
<td><code>Thread.raise()</code></td>
<td>否（强制）</td>
<td>能，但可能破坏状态</td>
</tr>
</tbody>
</table>
<p><strong>结论</strong>：除了 Ruby 的 <code>Thread.raise</code>（不安全），所有现代语言都采用<strong>协作式取消</strong>。这意味着：<strong>编写任务的开发者有责任在适当的位置检查取消信号。</strong></p>
<h1>8. 超时与时钟：一个被忽视的深层问题</h1>
<p>前面讨论的所有超时机制都隐含了一个假设：<strong>时钟是准确的</strong>。但在真实的分布式系统中，这个假设往往不成立。时钟的不准确性会从根本上影响超时的语义和正确性。</p>
<h2 id="8-1-两种时钟：墙上时钟与单调时钟">8.1 两种时钟：墙上时钟与单调时钟</h2>
<p>操作系统提供两种截然不同的时钟源，它们的特性直接决定了超时实现的正确性：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>墙上时钟（Wall Clock）</th>
<th>单调时钟（Monotonic Clock）</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>含义</strong></td>
<td>“现在几点了？”</td>
<td>“过了多久？”</td>
</tr>
<tr>
<td><strong>Java API</strong></td>
<td><code>System.currentTimeMillis()</code></td>
<td><code>System.nanoTime()</code></td>
</tr>
<tr>
<td><strong>Go API</strong></td>
<td><code>time.Now()</code> (含墙上时钟分量)</td>
<td><code>time.Since()</code> / <code>time.Until()</code></td>
</tr>
<tr>
<td><strong>JS API</strong></td>
<td><code>Date.now()</code></td>
<td><code>performance.now()</code></td>
</tr>
<tr>
<td><strong>Ruby API</strong></td>
<td><code>Time.now</code></td>
<td><code>Process.clock_gettime(CLOCK_MONOTONIC)</code></td>
</tr>
<tr>
<td><strong>是否可回退</strong></td>
<td><strong>是</strong>（NTP 校时可能回拨）</td>
<td><strong>否</strong>（只会单调递增）</td>
</tr>
<tr>
<td><strong>是否受闰秒影响</strong></td>
<td><strong>是</strong></td>
<td><strong>否</strong></td>
</tr>
<tr>
<td><strong>适合超时计算</strong></td>
<td><strong>否</strong></td>
<td><strong>是</strong></td>
</tr>
</tbody>
</table>
<pre><code class="hljs mermaid">graph TB
    subgraph WallClock[&quot;墙上时钟 (Wall Clock)&quot;]
        W1[&quot;System.currentTimeMillis()&quot;]
        W2[&quot;基于 UTC，可被 NTP 调整&quot;]
        W3[&quot;可能向前跳跃或向后回拨&quot;]
        W4[&quot;适用于：日志时间戳、业务时间&quot;]
    end
    
    subgraph MonoClock[&quot;单调时钟 (Monotonic Clock)&quot;]
        M1[&quot;System.nanoTime()&quot;]
        M2[&quot;基于 CPU 计数器，不受 NTP 影响&quot;]
        M3[&quot;保证单调递增，永不回退&quot;]
        M4[&quot;适用于：超时计算、性能度量&quot;]
    end
    
    NTP[&quot;NTP 校时事件&quot;] --&gt;|&quot;可能回拨数秒&quot;| WallClock
    NTP -.-&gt;|&quot;无影响&quot;| MonoClock
    
    style WallClock fill:#FFCDD2
    style MonoClock fill:#C8E6C9
    style NTP fill:#FFE0B2</code></pre>
<h3 id="8-1-1-ntp-回拨导致的超时异常">8.1.1 NTP 回拨导致的超时异常</h3>
<p>考虑以下使用墙上时钟实现超时的<strong>错误</strong>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 错误示范：使用墙上时钟计算超时</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">waitWithWallClock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeoutMillis)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> System.currentTimeMillis() + timeoutMillis;<br>    <br>    <span class="hljs-keyword">while</span> (!conditionMet()) &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">remaining</span> <span class="hljs-operator">=</span> deadline - System.currentTimeMillis();<br>        <span class="hljs-keyword">if</span> (remaining &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 超时</span><br>        &#125;<br>        Thread.sleep(remaining);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果在等待期间发生 NTP 校时，<code>System.currentTimeMillis()</code> 可能突然向前跳跃或向后回拨：</p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant App as 应用程序
    participant WC as 墙上时钟
    participant NTP as NTP 服务器
    
    App-&gt;&gt;WC: currentTimeMillis() = 1000
    App-&gt;&gt;App: deadline = 1000 + 3000 = 4000
    App-&gt;&gt;App: sleep(3000)
    
    Note over NTP,WC: NTP 校时：时钟回拨 5 秒
    NTP-&gt;&gt;WC: 调整时钟 -5000ms
    
    App-&gt;&gt;WC: currentTimeMillis() = -1000 (相对)
    App-&gt;&gt;App: remaining = 4000 - (-1000) = 5000
    Note over App: 本应超时，却还要再等 5 秒！</code></pre>
<p><strong>正确做法</strong>：使用单调时钟。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 正确示范：使用单调时钟计算超时</span><br><span class="hljs-comment">// 这正是 AQS.doAcquireNanos 的做法</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">waitWithMonotonicClock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeoutNanos)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> System.nanoTime() + timeoutNanos;<br>    <br>    <span class="hljs-keyword">while</span> (!conditionMet()) &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">remaining</span> <span class="hljs-operator">=</span> deadline - System.nanoTime();<br>        <span class="hljs-keyword">if</span> (remaining &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 超时</span><br>        &#125;<br>        LockSupport.parkNanos(remaining);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="8-1-2-各语言超时-api-的时钟选择">8.1.2 各语言超时 API 的时钟选择</h3>
<p>值得注意的是，成熟的超时 API 内部都使用单调时钟：</p>
<table>
<thead>
<tr>
<th>API</th>
<th>使用的时钟</th>
<th>安全性</th>
</tr>
</thead>
<tbody>
<tr>
<td>Java <code>LockSupport.parkNanos()</code></td>
<td>单调时钟</td>
<td>安全</td>
</tr>
<tr>
<td>Java <code>Object.wait(timeout)</code></td>
<td>取决于 JVM 实现和平台</td>
<td><strong>视版本而定</strong></td>
</tr>
<tr>
<td>Java <code>Thread.sleep(millis)</code></td>
<td>取决于 JVM 实现和平台</td>
<td><strong>视版本而定</strong></td>
</tr>
<tr>
<td>Java <code>System.nanoTime()</code></td>
<td>单调时钟</td>
<td>安全</td>
</tr>
<tr>
<td>Go <code>time.After()</code></td>
<td>单调时钟</td>
<td>安全</td>
</tr>
<tr>
<td>Go <code>context.WithTimeout()</code></td>
<td>单调时钟</td>
<td>安全</td>
</tr>
<tr>
<td>JS <code>setTimeout()</code></td>
<td>事件循环 tick</td>
<td>安全（单线程）</td>
</tr>
<tr>
<td>Ruby <code>Timeout.timeout()</code></td>
<td><code>sleep</code>（墙上时钟）</td>
<td><strong>不安全</strong></td>
</tr>
</tbody>
</table>
<p><strong>关键发现</strong>：Java 的 <code>Object.wait(timeout)</code> 和 <code>Thread.sleep(millis)</code> 的时钟行为取决于 JVM 实现和操作系统平台。在较旧的 JDK 版本和某些平台上，它们基于 <code>CLOCK_REALTIME</code>（墙上时钟），可能受 NTP 回拨影响；在较新的 HotSpot 实现中（尤其是 Linux 平台），已逐步迁移到 <code>CLOCK_MONOTONIC</code>。但由于行为的平台依赖性，Doug Lea 在 <code>java.util.concurrent</code> 中全面采用 <code>System.nanoTime()</code> 和 <code>LockSupport.parkNanos()</code>，从 API 层面消除了这种不确定性。</p>
<h2 id="8-2-分布式超时：当时钟不可信时">8.2 分布式超时：当时钟不可信时</h2>
<p>在单机环境中，单调时钟足以保证超时的正确性。但在分布式系统中，问题变得更加复杂：<strong>不同机器的时钟可能不一致</strong>。</p>
<h3 id="8-2-1-分布式超时的困境">8.2.1 分布式超时的困境</h3>
<pre><code class="hljs mermaid">sequenceDiagram
    participant Client as 客户端&lt;br/&gt;时钟: 10:00:00.000
    participant Server as 服务端&lt;br/&gt;时钟: 10:00:00.300
    
    Note over Client,Server: 两台机器的时钟差 300ms
    
    Client-&gt;&gt;Server: RPC 请求 (timeout=1000ms)
    Note over Client: 客户端 deadline = 10:00:01.000
    
    Server-&gt;&gt;Server: 处理请求...耗时 800ms
    
    Note over Server: 服务端视角：10:00:01.100 完成
    Server--&gt;&gt;Client: 返回响应
    
    Note over Client: 客户端视角：10:00:01.200 收到响应
    Note over Client: 10:00:01.200 &gt; deadline(10:00:01.000)
    Note over Client: 判定超时！但服务端其实在 800ms 内完成了</code></pre>
<p>这个例子揭示了一个根本性问题：<strong>分布式超时的判定依赖于本地时钟，而非全局一致的时间</strong>。在实践中，RPC 框架的超时通常是从客户端发出请求的那一刻开始计时（使用本地单调时钟），这避免了跨机器时钟不一致的问题。</p>
<h3 id="8-2-2-google-truetime：当时钟成为-api">8.2.2 Google TrueTime：当时钟成为 API</h3>
<p>Google 的 Spanner 数据库面临了一个更极端的问题：它需要全球范围内的事务一致性，而这依赖于<strong>全局有序的时间戳</strong>。</p>
<p>传统的时钟 API 返回一个时间点：<code>now() = t</code>。但 Google 认为这是一个谎言——任何时钟都有误差。于是 TrueTime 返回的是一个<strong>时间区间</strong>：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">TrueTime<span class="hljs-selector-class">.now</span>() = <span class="hljs-selector-attr">[earliest, latest]</span><br><span class="hljs-comment">// 含义：真实时间一定在 [earliest, latest] 之间</span><br><span class="hljs-comment">// 误差通常在 1~7ms 之间（依赖 GPS 和原子钟）</span><br></code></pre></td></tr></table></figure>
<pre><code class="hljs mermaid">graph TB
    subgraph Traditional[&quot;传统时钟 API&quot;]
        T1[&quot;now() = 10:00:00.000&quot;]
        T2[&quot;假装精确，实际有未知误差&quot;]
    end
    
    subgraph TrueTime[&quot;Google TrueTime API&quot;]
        TT1[&quot;now() = [10:00:00.000, 10:00:00.007]&quot;]
        TT2[&quot;诚实地暴露不确定性&quot;]
        TT3[&quot;误差范围: 1~7ms (GPS + 原子钟)&quot;]
    end
    
    subgraph Impact[&quot;对超时的影响&quot;]
        I1[&quot;传统: deadline = now + timeout&lt;br/&gt;可能因时钟误差而不准&quot;]
        I2[&quot;TrueTime: deadline = now.latest + timeout&lt;br/&gt;保守但正确&quot;]
    end
    
    Traditional --&gt; I1
    TrueTime --&gt; I2
    
    style Traditional fill:#FFCDD2
    style TrueTime fill:#C8E6C9</code></pre>
<p>Spanner 利用 TrueTime 实现了一个关键的等待机制：<strong>commit-wait</strong>。在提交事务后，Spanner 会等待 TrueTime 的不确定性窗口过去，以确保后续事务的时间戳一定大于当前事务。这本质上是一种<strong>基于时钟不确定性的超时等待</strong>：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// Spanner commit-wait 伪代码</span><br>func <span class="hljs-built_in">commitTransaction</span>(txn) &#123;<br>    commitTimestamp = TrueTime<span class="hljs-selector-class">.now</span>()<span class="hljs-selector-class">.latest</span><br>    txn<span class="hljs-selector-class">.setTimestamp</span>(commitTimestamp)<br>    <br>    <span class="hljs-comment">// 等待直到 TrueTime.now().earliest &gt; commitTimestamp</span><br>    <span class="hljs-comment">// 即确保真实时间已经超过了 commitTimestamp</span><br>    while TrueTime<span class="hljs-selector-class">.now</span>()<span class="hljs-selector-class">.earliest</span> &lt;= commitTimestamp &#123;<br>        <span class="hljs-built_in">sleep</span>(TrueTime<span class="hljs-selector-class">.now</span>()<span class="hljs-selector-class">.latest</span> - TrueTime<span class="hljs-selector-class">.now</span>().earliest)<br>    &#125;<br>    <br>    <span class="hljs-comment">// 现在可以安全地让其他事务看到这个提交</span><br>    txn<span class="hljs-selector-class">.makeVisible</span>()<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="8-2-3-超时与因果序-causal-ordering">8.2.3 超时与因果序（Causal Ordering）</h3>
<p>在分布式系统中，还有一个更深层的问题：<strong>超时判定的因果正确性</strong>。</p>
<p>Leslie Lamport 在 1978 年提出的逻辑时钟（Logical Clock）揭示了一个关键洞察：在分布式系统中，重要的不是&quot;事件发生在什么时间&quot;，而是&quot;事件之间的因果关系&quot;。</p>
<pre><code class="hljs mermaid">graph LR
    subgraph PhysicalTime[&quot;物理时钟视角&quot;]
        PT1[&quot;事件A: 10:00:00.000&quot;] --&gt; PT2[&quot;事件B: 10:00:00.001&quot;]
        PT3[&quot;问题: A 真的在 B 之前吗?&lt;br/&gt;如果时钟有 10ms 误差呢?&quot;]
    end
    
    subgraph LogicalTime[&quot;逻辑时钟视角&quot;]
        LT1[&quot;事件A: LC=5&quot;] --&gt;|&quot;消息传递&quot;| LT2[&quot;事件B: LC=6&quot;]
        LT3[&quot;结论: A 因果先于 B&lt;br/&gt;与物理时钟无关&quot;]
    end
    
    style PhysicalTime fill:#FFCDD2
    style LogicalTime fill:#C8E6C9</code></pre>
<p>这对超时机制的启示是：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>物理时钟超时</th>
<th>逻辑时钟/因果序</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>单机超时</strong></td>
<td>单调时钟足够</td>
<td>不需要</td>
</tr>
<tr>
<td><strong>RPC 超时</strong></td>
<td>客户端本地单调时钟</td>
<td>不需要（单次请求-响应）</td>
</tr>
<tr>
<td><strong>分布式事务超时</strong></td>
<td>需要 TrueTime 级别的保证</td>
<td>可用向量时钟辅助</td>
</tr>
<tr>
<td><strong>分布式锁超时</strong></td>
<td>物理时钟不可靠</td>
<td>需要 fencing token 等机制</td>
</tr>
</tbody>
</table>
<p><strong>分布式锁的超时陷阱</strong>：</p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant C1 as 客户端1
    participant Lock as 分布式锁(Redis)
    participant DB as 数据库
    
    C1-&gt;&gt;Lock: 获取锁 (TTL=3s)
    Note over C1: 开始处理...
    Note over C1: GC 停顿 5 秒！
    Note over Lock: 3秒后锁自动过期
    
    Note over Lock: 客户端2 获取了锁
    
    C1-&gt;&gt;DB: 写入数据（以为自己还持有锁）
    Note over DB: 数据被覆盖！</code></pre>
<p>这个问题的根源在于：<strong>超时（TTL）是基于物理时钟的，但进程的执行可能因 GC、页面换出等原因暂停任意长时间</strong>。解决方案不是更精确的时钟，而是引入因果序机制（如 fencing token）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用 fencing token 保证因果正确性</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SafeDistributedLock</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doWork</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 获取锁时同时获取一个单调递增的 fencing token</span><br>        <span class="hljs-type">LockResult</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> redisLock.acquire(<span class="hljs-string">&quot;resource&quot;</span>, <span class="hljs-number">3</span>, TimeUnit.SECONDS);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">fencingToken</span> <span class="hljs-operator">=</span> lock.getFencingToken(); <span class="hljs-comment">// 例如: 42</span><br>        <br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 所有写操作都携带 fencing token</span><br>            <span class="hljs-comment">// 存储层拒绝 token 小于已见最大值的写入</span><br>            database.write(data, fencingToken);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            redisLock.release(<span class="hljs-string">&quot;resource&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="8-3-时钟问题总结">8.3 时钟问题总结</h2>
<pre><code class="hljs mermaid">graph TB
    subgraph ClockSummary[&quot;时钟与超时：决策指南&quot;]
        Q1&#123;&quot;超时场景?&quot;&#125; --&gt; |&quot;单机&quot;| A1[&quot;使用单调时钟&lt;br/&gt;Java: System.nanoTime()&lt;br/&gt;Go: time.Since()&quot;]
        Q1 --&gt; |&quot;RPC&quot;| A2[&quot;客户端本地单调时钟&lt;br/&gt;不依赖服务端时钟&quot;]
        Q1 --&gt; |&quot;分布式事务&quot;| A3[&quot;需要 TrueTime 或&lt;br/&gt;逻辑时钟辅助&quot;]
        Q1 --&gt; |&quot;分布式锁&quot;| A4[&quot;TTL + fencing token&lt;br/&gt;不能仅依赖超时&quot;]
    end
    
    style A1 fill:#C8E6C9
    style A2 fill:#C8E6C9
    style A3 fill:#FFE0B2
    style A4 fill:#FFCDD2</code></pre>
<p><strong>核心要点</strong>：</p>
<ul>
<li><strong>单机超时</strong>：始终使用单调时钟（<code>System.nanoTime()</code>），避免 NTP 回拨影响</li>
<li><strong>RPC 超时</strong>：基于客户端本地单调时钟计时，与服务端时钟无关</li>
<li><strong>分布式场景</strong>：物理时钟不可完全信任，需要结合逻辑时钟或 fencing token 等因果序机制</li>
<li><strong>TrueTime 的启示</strong>：与其假装时钟精确，不如诚实地暴露不确定性</li>
</ul>
<h1>9. 总结：超时的设计哲学</h1>
<pre><code class="hljs mermaid">graph TB
    subgraph Philosophy[&quot;超时设计的四个层次&quot;]
        L1[&quot;第一层：能超时&lt;br/&gt;至少有一种机制让等待不会永远持续&quot;]
        L2[&quot;第二层：能取消&lt;br/&gt;超时后能真正停止底层任务&quot;]
        L3[&quot;第三层：能传播&lt;br/&gt;超时/取消信号能沿调用链传递&quot;]
        L4[&quot;第四层：时钟正确&lt;br/&gt;超时计算不受时钟漂移/回拨影响&quot;]
    end
    
    L1 --&gt; L2 --&gt; L3 --&gt; L4
    
    L1 -.-&gt; E1[&quot;所有语言都能做到&quot;]
    L2 -.-&gt; E2[&quot;需要协作式设计&quot;]
    L3 -.-&gt; E3[&quot;Go (context) 和 JS (AbortSignal) 原生支持&quot;]
    L4 -.-&gt; E4[&quot;需要单调时钟 + 分布式场景需要额外机制&quot;]
    
    style L1 fill:#C8E6C9
    style L2 fill:#FFE0B2
    style L3 fill:#E3F2FD
    style L4 fill:#F3E5F5</code></pre>
<p>回到最初的问题：<strong>为什么 HSF/Dubbo 用时间轮而不是 <code>Future.get(timeout)</code>？</strong></p>
<p>答案可以从四个维度来理解：</p>
<ol>
<li><strong>资源效率</strong>：<code>Future.get(timeout)</code> 每个等待占一个线程；时间轮用一个线程管理所有超时</li>
<li><strong>编程模型</strong>：<code>Future.get</code> 是同步阻塞的；时间轮是异步回调的，天然适配 Netty 的异步 IO 模型</li>
<li><strong>性能</strong>：时间轮的添加/取消是 O(1)；<code>ScheduledExecutorService</code> 是 O(log n)</li>
<li><strong>精度权衡</strong>：RPC 超时通常是秒级，100ms 的精度损失完全可以接受</li>
</ol>
<p><strong>每种超时机制都有其最佳适用场景</strong>。没有银弹，只有 trade-off。理解这些 trade-off，才能在面对具体问题时做出正确的选择。</p>
<hr>
<p><strong>参考资料</strong>：</p>
<ol>
<li>Doug Lea, <em>Concurrent Programming in Java</em>, Addison-Wesley</li>
<li><a target="_blank" rel="noopener" href="https://github.com/netty/netty/blob/4.1/common/src/main/java/io/netty/util/HashedWheelTimer.java">Netty HashedWheelTimer 源码</a></li>
<li><a target="_blank" rel="noopener" href="https://pkg.go.dev/context">Go context 包文档</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/AbortController">MDN AbortController</a></li>
<li><a target="_blank" rel="noopener" href="https://www.mikeperham.com/2015/05/08/timeout-rubys-most-dangerous-api/">Ruby Timeout 的问题</a></li>
<li>George Varghese &amp; Tony Lauck, <em>Hashed and Hierarchical Timing Wheels</em>, IEEE/ACM Transactions on Networking, 1997</li>
<li><a target="_blank" rel="noopener" href="https://dubbo.apache.org/zh/docs/">Dubbo 超时机制源码分析</a></li>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">美团技术团队：Java 线程池实践</a></li>
<li>Leslie Lamport, <em>Time, Clocks, and the Ordering of Events in a Distributed System</em>, 1978</li>
<li>James C. Corbett et al., <em>Spanner: Google’s Globally-Distributed Database</em>, OSDI 2012</li>
<li>Martin Kleppmann, <em>Designing Data-Intensive Applications</em>, O’Reilly, Chapter 8: The Trouble with Distributed Systems</li>
<li><a target="_blank" rel="noopener" href="https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html">How to do distributed locking - Martin Kleppmann</a></li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://magicliang.github.io">magicliang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://magicliang.github.io/2026/02/06/%E8%B7%A8%E8%AF%AD%E8%A8%80%E8%B6%85%E6%97%B6%E6%9C%BA%E5%88%B6%E5%85%A8%E8%A7%A3%E6%9E%90/">https://magicliang.github.io/2026/02/06/%E8%B7%A8%E8%AF%AD%E8%A8%80%E8%B6%85%E6%97%B6%E6%9C%BA%E5%88%B6%E5%85%A8%E8%A7%A3%E6%9E%90/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/JavaScript/">JavaScript</a><a class="post-meta__tags" href="/tags/Go/">Go</a><a class="post-meta__tags" href="/tags/Ruby/">Ruby</a><a class="post-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91/">并发</a><a class="post-meta__tags" href="/tags/%E8%B6%85%E6%97%B6/">超时</a><a class="post-meta__tags" href="/tags/%E6%97%B6%E9%97%B4%E8%BD%AE/">时间轮</a></div><div class="post-share"><div class="social-share" data-image="/2026/02/06/%E8%B7%A8%E8%AF%AD%E8%A8%80%E8%B6%85%E6%97%B6%E6%9C%BA%E5%88%B6%E5%85%A8%E8%A7%A3%E6%9E%90/go-channel%E8%B6%85%E6%97%B6.jpeg" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/07/29/HTTP-%E8%AF%B7%E6%B1%82%E4%BD%93%E5%8F%AA%E8%AF%BB%E4%B8%80%E6%AC%A1%E4%B9%8B%E8%B0%9C/" title="HTTP 请求体只读一次之谜——Go 与 Java 的应对之道"><img class="cover" src="/img/wall-paper-119.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-29</div><div class="info-item-2">HTTP 请求体只读一次之谜——Go 与 Java 的应对之道</div></div><div class="info-2"><div class="info-item-1">在后端开发中，日志记录、签名验证、请求重放等场景都需要在中间件（Middleware/Filter）中读取 HTTP 请求体（Request Body）。然而，请求体在被读取一次后便无法再次获取——后续处理程序收到的是一个空的 Body，导致逻辑中断。 这并非 Bug，而是网络 I/O 流处理的基本特性。本文将从操作系统内核的 Socket 缓冲区出发，剖析这一现象的根源，并详细对比 Go 和 Java 在&quot;可重复读 Body&quot;问题上的解决方案及其背后截然不同的设计哲学。 第一部分：问题的根源——流的&quot;阅后即焚&quot;本质 为什么 HTTP 请求体默认只能读取一次？ 请求体本质上是一个从网络连接中实时到达的字节流，而非一块已经完整存放在内存或磁盘上的数据块。理解这一点是理解&quot;只读一次&quot;问题的关键。 操作系统层面：Socket 读取缓冲区 当客户端发送 HTTP 请求时，数据通过 TCP 连接到达服务器的网络套接字（Socket）。操作系统内核维护着一个接收缓冲区（Receive Buffer），TCP 数据包到达后被暂存在这里...</div></div></div></a><a class="pagination-related" href="/2026/02/07/Java-%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91/" title="Java 结构化并发"><img class="cover" src="/img/wall-paper-152.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-02-07</div><div class="info-item-2">Java 结构化并发</div></div><div class="info-2"><div class="info-item-1">结构化并发（Structured Concurrency） 结构化并发是 Java 并发编程的重要演进方向，与虚拟线程紧密配合，旨在解决传统并发编程中的线程泄漏、错误处理困难等问题。 1. 历史背景 1.1 结构化并发的起源与核心类比 术语起源 “结构化并发”（Structured Concurrency）这个术语由 Martin Sústrik（ZeroMQ 作者）在 2016 年首次提出。随后，Nathaniel J. Smith 在 2018 年发表了著名的文章《Notes on structured concurrency, or: Go statement considered harmful》，系统性地阐述了结构化并发的理论基础。 timeline     title 结构化并发发展历程     2016 : Martin Sústrik 首创术语          : 在 250bpm.com 发表系列文章     2018 : Nathaniel J. Smith 发表核心论文          : &quot;Go statement considered ha...</div></div></div></a><a class="pagination-related" href="/2017/10/23/%E6%98%82%E8%B4%B5%E7%9A%84%E5%BC%82%E5%B8%B8/" title="昂贵的异常"><img class="cover" src="/img/wall-paper-28.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-10-23</div><div class="info-item-2">昂贵的异常</div></div><div class="info-2"><div class="info-item-1">抛出问题 Joshua Bloch 在《Effective Java》的 Item 57 里明确地提到过，不要试图用 Exception 的跳转来代替正常的程序控制流。他列举了很多原因，但特别提到了抛出异常会使得整个程序运行变慢。抛出异常远比普通的 return、break 等操作对控制流、数据流的性能影响要大，它就只适合拿来作异常分支的控制语句，而不能拿来编写正常的逻辑。  Throwing exception is expensive.  这句话在 Java 的程序员世界里面已经成为老生常谈，却很少有人谈及到底抛出异常比正常的程序跳转返回慢在哪里，有多慢。&quot;不要滥用异常&quot;好像一个猴子定律，人们知道不能这么做，却不明白为什么不能这么做。 此前读了一位同事写的好文《Java虚拟机是如何处理异常的》，深入地分析了 JVM 对异常跳转的处理过程：JVM 会通过异常表的机制，优化异常抛出和正常返回之间的性能差异。仅从程序计数器的移动上来讲，抛出一个异常对栈帧的弹栈并不比直接返回更昂贵。写在前头的结论是：&quot;try-catch 语句块几乎不会影响程序运行性能！...</div></div></div></a><a class="pagination-related" href="/2017/11/30/Java%E4%B8%AD%E7%9A%84%E5%B9%BD%E7%81%B5%E7%B1%BB%E5%9E%8B/" title="Java中的幽灵类型"><img class="cover" src="/img/wall-paper-77.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-11-30</div><div class="info-item-2">Java中的幽灵类型</div></div><div class="info-2"><div class="info-item-1">什么是幽灵类型 先上结论：幽灵类型（Phantom Type）顾名思义，就是幽灵般的类型，这种类型往往在运行时可以消失，因为在运行时没有任何作用，它们最大的特点就是没有任何实例（Java 的 Void 就是一个不可实例化类型的例子，常被用作幽灵类型的类型参数，如 Future&lt;Void&gt;）。幽灵类型是一种可以把有些运行时才能检测到的错误，在编译时检测出来的技巧。按照有些老外的观点，就是&quot;Making Wrong Code Look Wrong&quot;。在面向对象的编程语言之中，幽灵类型的实现，往往与状态模式较为接近，但比状态模式提供了更强的纠错功能。在 Java 5 以后的版本里，程序员可以使用泛型。通过泛型的类型参数，Java 中也拥有了幽灵类型的能力。 上面的阐述是不是很难看懂？直接进入具体的例子。假设有一个飞机控制程序，操作飞机起飞或者落地。这个程序有一个非常强的业务约束，就是必须保证飞机一开始必须出现在地上，只有在地上的飞机可以起飞，只有起飞的飞机可以落地，那么应该怎样设计程序（主要是类型关系），来保证这个约束必然成立呢？ 定义状态接口 先来定义...</div></div></div></a><a class="pagination-related" href="/2018/05/29/JPA-%E7%9A%84-id-%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5/" title="JPA 的 id 生成策略"><img class="cover" src="/img/wall-paper-56.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-05-29</div><div class="info-item-2">JPA 的 id 生成策略</div></div><div class="info-2"><div class="info-item-1">JPA 有一个@GeneratedValue注解，有一个strategy attribute，如 @GeneratedValue(strategy = GenerationType.IDENTITY)。 常见的可选策略主要有IDENTITY和SEQUENCE。 GenerationType.IDENTITY 要求底层有一个 integer 或者 bigint 类型的自增列（ auto-incremented column)。自增列的赋值必须在插入操作之后发生，因为这个原因，Hibernate 无法进行各种优化（特别是 JDBC 的 batch 处理，一次 flush 操作会产生很多条insert 语句，分别执行）。如果事务回滚，自增列的值就会被丢弃。数据库在这个自增操作上有个高度优化的轻量级锁机制，性能非常棒。 MySQL 支持这种 id 生成策略， 使用 MySQL 应该尽量使用这个策略，即使它无法优化。 JPA 用它生成 id，会一条一条地插入新的 entity。 GenerationType.SEQUENCE 数据库有一个所谓的 sequence 对象，可以通过 selec...</div></div></div></a><a class="pagination-related" href="/2018/06/19/%E5%A6%82%E4%BD%95%E5%81%9A%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8B%E7%9A%84%E7%AD%94%E6%A1%88/" title="如何做性能测试的问题下的答案"><img class="cover" src="/img/wall-paper-100.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-06-19</div><div class="info-item-2">如何做性能测试的问题下的答案</div></div><div class="info-2"><div class="info-item-1">试着回答一下这个问题。 首先要划分系统类型：有状态还是无状态，业务系统还是存储系统。根据不同的业务场景，设立性能测试的目标：是要测 QPS，还是 TPS 还是 TPS，还是任何其他【性能】-从广义来讲，一个存储系统到底能够以多高的平均时延来管理大多的存储空间，可能也是性能的一种。 有了性能测试的目标，接下来就是拆解用例。如果把性能测试归为测试的话，测试就需要测试用例，测试用例只是用例的形式化表达。把用户的使用场景勾勒出来，把每一步拆解成的流程图或者时序图–我们已经得到了一个纸上的集成测试计划，只是没有跟性能挂上钩。 接下来就进入真正写测试用例的环节了。 我们的测试报告如果要涵盖足够立体的信息，则既要了解每一个环节/接口/API 的性能指标，又要了解整体的性能指标。 这个时候测试工具的覆盖面就很重要了。如果我们选择偏黑盒的测试工具，apache ab /JMeter，则我们的测试用例就要围绕着对外交互的 API写，也只能测到外围接口的性能。这样的测试用例写起来最简单，无需侵入任何内部代码中。 如果我们使用了 JMH 一类的工具，则可以自由编写对任何方法的测试用例。但需要对系统有非常...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">从&quot;等不起&quot;到&quot;不想等&quot;：跨语言超时机制全解析</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">1. 超时的本质：一个工程哲学问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E8%B6%85%E6%97%B6%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%A0%B8%E5%BF%83%E7%BB%B4%E5%BA%A6"><span class="toc-number">2.1.</span> <span class="toc-text">1.1 超时的两个核心维度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E5%9B%9B%E7%A7%8D%E8%AF%AD%E8%A8%80%E7%9A%84%E8%B6%85%E6%97%B6%E5%85%A8%E6%99%AF"><span class="toc-number">2.2.</span> <span class="toc-text">1.2 四种语言的超时全景</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">2. Java：三种超时范式的深度剖析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E8%87%AA%E6%97%8B-parknanos-%E6%9C%80%E5%8E%9F%E5%A7%8B%E7%9A%84%E8%B6%85%E6%97%B6"><span class="toc-number">3.1.</span> <span class="toc-text">2.1 方式一：自旋 + parkNanos — 最原始的超时</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">3.1.1.</span> <span class="toc-text">2.1.1 基本原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-aqs-%E4%B8%AD%E7%9A%84%E8%B6%85%E6%97%B6%E7%AD%89%E5%BE%85%EF%BC%9A%E6%95%99%E7%A7%91%E4%B9%A6%E7%BA%A7%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.1.2.</span> <span class="toc-text">2.1.2 AQS 中的超时等待：教科书级实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%8E%E5%B1%80%E9%99%90"><span class="toc-number">3.1.3.</span> <span class="toc-text">2.1.3 适用场景与局限</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9Afuture-get-timeout-%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84%E8%B6%85%E6%97%B6"><span class="toc-number">3.2.</span> <span class="toc-text">2.2 方式二：Future.get(timeout) — 最常用的超时</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-%E8%B0%83%E7%94%A8%E9%93%BE%E8%B7%AF"><span class="toc-number">3.2.1.</span> <span class="toc-text">2.2.1 调用链路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-futuretask-awaitdone-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="toc-number">3.2.2.</span> <span class="toc-text">2.2.2 FutureTask.awaitDone 源码剖析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%90%E8%BF%9B%E5%BC%8F%E7%8A%B6%E6%80%81%E6%9C%BA%E6%A8%A1%E5%BC%8F-incremental-state-machine"><span class="toc-number">3.2.3.</span> <span class="toc-text">渐进式状态机模式（Incremental State Machine）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3-future-get-%E8%B6%85%E6%97%B6%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">3.2.4.</span> <span class="toc-text">2.2.3 Future.get 超时的问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E6%96%B9%E5%BC%8F%E4%B8%89%EF%BC%9Ahashedwheeltimer-%E6%97%B6%E9%97%B4%E8%BD%AE-%E9%AB%98%E5%90%9E%E5%90%90%E7%9A%84%E8%B6%85%E6%97%B6"><span class="toc-number">3.3.</span> <span class="toc-text">2.3 方式三：HashedWheelTimer（时间轮）— 高吞吐的超时</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%97%B6%E9%97%B4%E8%BD%AE%EF%BC%9F"><span class="toc-number">3.3.1.</span> <span class="toc-text">2.3.1 为什么需要时间轮？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#scheduledexecutorservice-%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90"><span class="toc-number">3.3.1.1.</span> <span class="toc-text">ScheduledExecutorService 底层数据结构深度解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-%E6%97%B6%E9%97%B4%E8%BD%AE%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">3.3.2.</span> <span class="toc-text">2.3.2 时间轮的工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E8%BD%AE%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84%E5%9B%BE"><span class="toc-number">3.3.2.1.</span> <span class="toc-text">时间轮核心架构图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E8%BD%AE%E5%B7%A5%E4%BD%9C%E5%8A%A8%E7%94%BB%E7%A4%BA%E6%84%8F"><span class="toc-number">3.3.2.2.</span> <span class="toc-text">时间轮工作动画示意</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F"><span class="toc-number">3.3.2.3.</span> <span class="toc-text">关键计算公式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E4%BB%BB%E5%8A%A1%E6%97%B6%E5%BA%8F%E5%9B%BE"><span class="toc-number">3.3.2.4.</span> <span class="toc-text">添加任务时序图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#worker-%E7%BA%BF%E7%A8%8B%E4%B8%BB%E5%BE%AA%E7%8E%AF%E6%97%B6%E5%BA%8F%E5%9B%BE"><span class="toc-number">3.3.2.5.</span> <span class="toc-text">Worker 线程主循环时序图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E5%88%B0%E6%9C%9F%E5%88%A4%E6%96%AD%E9%80%BB%E8%BE%91%E8%AF%A6%E8%A7%A3"><span class="toc-number">3.3.2.6.</span> <span class="toc-text">任务到期判断逻辑详解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%96%E6%B6%88%E4%BB%BB%E5%8A%A1%E6%97%B6%E5%BA%8F%E5%9B%BE"><span class="toc-number">3.3.2.7.</span> <span class="toc-text">取消任务时序图</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-3-netty-hashedwheeltimer-%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81"><span class="toc-number">3.3.3.</span> <span class="toc-text">2.3.3 Netty HashedWheelTimer 核心源码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-4-%E4%B8%BA%E4%BB%80%E4%B9%88-hsf-dubbo-%E9%80%89%E6%8B%A9%E6%97%B6%E9%97%B4%E8%BD%AE%EF%BC%9F"><span class="toc-number">3.3.4.</span> <span class="toc-text">2.3.4 为什么 HSF&#x2F;Dubbo 选择时间轮？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-5-dubbo-%E4%B8%AD%E7%9A%84%E8%B6%85%E6%97%B6%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.3.5.</span> <span class="toc-text">2.3.5 Dubbo 中的超时实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-java-%E8%B6%85%E6%97%B6%E6%9C%BA%E5%88%B6%E9%80%89%E6%8B%A9%E5%86%B3%E7%AD%96%E6%A0%91"><span class="toc-number">3.4.</span> <span class="toc-text">2.4 Java 超时机制选择决策树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E5%B1%95%E6%9C%9B%EF%BC%9Avirtual-thread-%E4%B8%8E-structured-concurrency"><span class="toc-number">3.5.</span> <span class="toc-text">2.5 展望：Virtual Thread 与 Structured Concurrency</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#virtual-thread-%E5%AF%B9%E8%B6%85%E6%97%B6%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">3.5.1.</span> <span class="toc-text">Virtual Thread 对超时的影响</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#structured-concurrency%EF%BC%9Ajava-%E7%89%88%E7%9A%84-context-%E4%BC%A0%E6%92%AD"><span class="toc-number">3.5.2.</span> <span class="toc-text">Structured Concurrency：Java 版的 context 传播</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">3. Go：超时是一等公民</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-select-time-after%EF%BC%9A%E6%9C%80%E5%9F%BA%E7%A1%80%E7%9A%84%E8%B6%85%E6%97%B6"><span class="toc-number">4.1.</span> <span class="toc-text">3.1 select + time.After：最基础的超时</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-context-withtimeout%EF%BC%9Ago-%E7%9A%84%E6%A0%87%E5%87%86%E7%AD%94%E6%A1%88"><span class="toc-number">4.2.</span> <span class="toc-text">3.2 context.WithTimeout：Go 的标准答案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-go-vs-java%EF%BC%9A%E8%B6%85%E6%97%B6%E5%93%B2%E5%AD%A6%E5%AF%B9%E6%AF%94"><span class="toc-number">4.3.</span> <span class="toc-text">3.3 Go vs Java：超时哲学对比</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">4. JavaScript：事件循环中的超时</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-settimeout%EF%BC%9A%E6%9C%80%E5%8E%9F%E5%A7%8B%E7%9A%84%E8%B6%85%E6%97%B6"><span class="toc-number">5.1.</span> <span class="toc-text">4.1 setTimeout：最原始的超时</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-promise-race%EF%BC%9A%E7%8E%B0%E4%BB%A3-javascript-%E7%9A%84%E8%B6%85%E6%97%B6"><span class="toc-number">5.2.</span> <span class="toc-text">4.2 Promise.race：现代 JavaScript 的超时</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-abortcontroller%EF%BC%9A%E7%9C%9F%E6%AD%A3%E7%9A%84%E5%8F%96%E6%B6%88"><span class="toc-number">5.3.</span> <span class="toc-text">4.3 AbortController：真正的取消</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-node-js-%E4%B8%AD%E7%9A%84-abortsignal-timeout-%E7%8E%B0%E4%BB%A3%E6%96%B9%E5%BC%8F"><span class="toc-number">5.4.</span> <span class="toc-text">4.4 Node.js 中的 AbortSignal.timeout（现代方式）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">5. Ruby：优雅但有陷阱</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-timeout-timeout%EF%BC%9A%E6%A0%87%E5%87%86%E5%BA%93%E7%9A%84%E7%94%9C%E8%9C%9C%E9%99%B7%E9%98%B1"><span class="toc-number">6.1.</span> <span class="toc-text">5.1 Timeout.timeout：标准库的甜蜜陷阱</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E5%AE%83%E5%8D%B1%E9%99%A9%EF%BC%9F"><span class="toc-number">6.1.1.</span> <span class="toc-text">5.1.1 为什么说它危险？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E6%9B%B4%E5%AE%89%E5%85%A8%E7%9A%84%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88"><span class="toc-number">6.2.</span> <span class="toc-text">5.2 更安全的替代方案</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">6. 跨语言对比：超时机制全景表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E7%BB%88%E6%9E%81%E5%AF%B9%E6%AF%94%E8%A1%A8"><span class="toc-number">7.1.</span> <span class="toc-text">6.1 终极对比表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E5%90%84%E8%AF%AD%E8%A8%80%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">7.2.</span> <span class="toc-text">6.2 各语言的最佳实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#java-9-%E7%9A%84-completablefuture-ortimeout"><span class="toc-number">7.2.1.</span> <span class="toc-text">Java 9+ 的 CompletableFuture.orTimeout</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">7. 深入：超时后的&quot;善后&quot;问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E8%B6%85%E6%97%B6%E4%B8%8D%E7%AD%89%E4%BA%8E%E5%8F%96%E6%B6%88%EF%BC%9A%E4%B8%80%E4%B8%AA%E8%B7%A8%E8%AF%AD%E8%A8%80%E7%9A%84%E9%80%9A%E7%97%85"><span class="toc-number">8.1.</span> <span class="toc-text">7.1 超时不等于取消：一个跨语言的通病</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-java-%E7%9A%84%E4%B8%AD%E6%96%AD%E5%8D%8F%E4%BD%9C%E6%A8%A1%E5%9E%8B"><span class="toc-number">8.2.</span> <span class="toc-text">7.2 Java 的中断协作模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-go-%E7%9A%84-context-%E6%A3%80%E6%9F%A5"><span class="toc-number">8.3.</span> <span class="toc-text">7.3 Go 的 context 检查</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-%E8%B6%85%E6%97%B6%E5%96%84%E5%90%8E%E5%AF%B9%E6%AF%94"><span class="toc-number">8.4.</span> <span class="toc-text">7.4 超时善后对比</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">9.</span> <span class="toc-text">8. 超时与时钟：一个被忽视的深层问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-%E4%B8%A4%E7%A7%8D%E6%97%B6%E9%92%9F%EF%BC%9A%E5%A2%99%E4%B8%8A%E6%97%B6%E9%92%9F%E4%B8%8E%E5%8D%95%E8%B0%83%E6%97%B6%E9%92%9F"><span class="toc-number">9.1.</span> <span class="toc-text">8.1 两种时钟：墙上时钟与单调时钟</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-1-ntp-%E5%9B%9E%E6%8B%A8%E5%AF%BC%E8%87%B4%E7%9A%84%E8%B6%85%E6%97%B6%E5%BC%82%E5%B8%B8"><span class="toc-number">9.1.1.</span> <span class="toc-text">8.1.1 NTP 回拨导致的超时异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-2-%E5%90%84%E8%AF%AD%E8%A8%80%E8%B6%85%E6%97%B6-api-%E7%9A%84%E6%97%B6%E9%92%9F%E9%80%89%E6%8B%A9"><span class="toc-number">9.1.2.</span> <span class="toc-text">8.1.2 各语言超时 API 的时钟选择</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-%E5%88%86%E5%B8%83%E5%BC%8F%E8%B6%85%E6%97%B6%EF%BC%9A%E5%BD%93%E6%97%B6%E9%92%9F%E4%B8%8D%E5%8F%AF%E4%BF%A1%E6%97%B6"><span class="toc-number">9.2.</span> <span class="toc-text">8.2 分布式超时：当时钟不可信时</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-1-%E5%88%86%E5%B8%83%E5%BC%8F%E8%B6%85%E6%97%B6%E7%9A%84%E5%9B%B0%E5%A2%83"><span class="toc-number">9.2.1.</span> <span class="toc-text">8.2.1 分布式超时的困境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-2-google-truetime%EF%BC%9A%E5%BD%93%E6%97%B6%E9%92%9F%E6%88%90%E4%B8%BA-api"><span class="toc-number">9.2.2.</span> <span class="toc-text">8.2.2 Google TrueTime：当时钟成为 API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-3-%E8%B6%85%E6%97%B6%E4%B8%8E%E5%9B%A0%E6%9E%9C%E5%BA%8F-causal-ordering"><span class="toc-number">9.2.3.</span> <span class="toc-text">8.2.3 超时与因果序（Causal Ordering）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-%E6%97%B6%E9%92%9F%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93"><span class="toc-number">9.3.</span> <span class="toc-text">8.3 时钟问题总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">10.</span> <span class="toc-text">9. 总结：超时的设计哲学</span></a></li></ol></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2017 - 2026 By magicliang</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional and Simplified Chinese">簡</button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><script src="/js/tw_cn.js?v=5.5.2"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="/"></script></div></body></html>