<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>重述双亲委派模型 | 守株阁</title><meta name="author" content="magicliang"><meta name="copyright" content="magicliang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="何时加载类  遇到 new、getstatic、putstatic 等指令时。 对类进行反射调用的时候。 初始化某个类的子类的时候。 虚拟机启动时会先加载设置的程序主类。 使用 dynamic 动态语言支持等相关特性时。  从 Java 到 cpp 源码分析  JVM 默认用于加载用户程序的ClassLoader为AppClassLoader，不过无论是什么ClassLoader，它的根父类都是j">
<meta property="og:type" content="article">
<meta property="og:title" content="重述双亲委派模型">
<meta property="og:url" content="https://magicliang.github.io/2019/09/05/%E9%87%8D%E8%BF%B0%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/index.html">
<meta property="og:site_name" content="守株阁">
<meta property="og:description" content="何时加载类  遇到 new、getstatic、putstatic 等指令时。 对类进行反射调用的时候。 初始化某个类的子类的时候。 虚拟机启动时会先加载设置的程序主类。 使用 dynamic 动态语言支持等相关特性时。  从 Java 到 cpp 源码分析  JVM 默认用于加载用户程序的ClassLoader为AppClassLoader，不过无论是什么ClassLoader，它的根父类都是j">
<meta property="og:locale">
<meta property="og:image" content="https://magicliang.github.io/img/wall-paper-168.jpg">
<meta property="article:published_time" content="2019-09-05T06:41:05.000Z">
<meta property="article:modified_time" content="2025-10-22T08:01:31.918Z">
<meta property="article:author" content="magicliang">
<meta property="article:tag" content="JVM">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://magicliang.github.io/img/wall-paper-168.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "重述双亲委派模型",
  "url": "https://magicliang.github.io/2019/09/05/%E9%87%8D%E8%BF%B0%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/",
  "image": "https://magicliang.github.io/img/wall-paper-168.jpg",
  "datePublished": "2019-09-05T06:41:05.000Z",
  "dateModified": "2025-10-22T08:01:31.918Z",
  "author": [
    {
      "@type": "Person",
      "name": "magicliang",
      "url": "https://magicliang.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://magicliang.github.io/2019/09/05/%E9%87%8D%E8%BF%B0%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: magicliang","link":"Link: ","source":"Source: 守株阁","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '重述双亲委派模型',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="守株阁" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/wall-paper-168.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">守株阁</span></a><a class="nav-page-title" href="/"><span class="site-name">重述双亲委派模型</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">重述双亲委派模型</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2019-09-05T06:41:05.000Z" title="Created 2019-09-05 14:41:05">2019-09-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-10-22T08:01:31.918Z" title="Updated 2025-10-22 16:01:31">2025-10-22</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">1.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>7mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="何时加载类">何时加载类</h2>
<ol>
<li>遇到 new、getstatic、putstatic 等指令时。</li>
<li>对类进行反射调用的时候。</li>
<li>初始化某个类的子类的时候。</li>
<li>虚拟机启动时会先加载设置的程序主类。</li>
<li>使用 dynamic 动态语言支持等相关特性时。</li>
</ol>
<h2 id="从-java-到-cpp-源码分析">从 Java 到 cpp 源码分析</h2>
<blockquote>
<p>JVM<br>
默认用于加载用户程序的ClassLoader为AppClassLoader，不过无论是什么ClassLoader，它的根父类都是java.lang.ClassLoader。在上面那个例子中，loadClass（）方法最终会调用到ClassLoader.definClass1（）中，这是一个<br>
Native 方法。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> Class&lt;?&gt; defineClass1(ClassLoader loader, String name, <span class="hljs-type">byte</span>[] b, <span class="hljs-type">int</span> off, <span class="hljs-type">int</span> len,<br>                                        ProtectionDomain pd, String source); <br></code></pre></td></tr></table></figure>
<blockquote>
<p>definClass1（）对应的 JNI 方法为 Java_java_lang_ClassLoader_defineClass1（）。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">JNIEXPORT jclass JNICALL<br><span class="hljs-title function_">Java_java_lang_ClassLoader_defineClass1</span><span class="hljs-params">(JNIEnv *env,</span><br><span class="hljs-params">                                        jclass cls,</span><br><span class="hljs-params">                                        jobject loader,</span><br><span class="hljs-params">                                        jstring name,</span><br><span class="hljs-params">                                        jbyteArray data,</span><br><span class="hljs-params">                                        jint offset,</span><br><span class="hljs-params">                                        jint length,</span><br><span class="hljs-params">                                        jobject pd,</span><br><span class="hljs-params">                                        jstring source)</span><br>&#123;<br>    ......<br>    result = JVM_DefineClassWithSource(env, utfName, loader, body, length, pd, utfSource);<br>    ......<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>Java_java_lang_ClassLoader_defineClass1<br>
主要是调用了JVM_DefineClassWithSource（）加载类，跟着源码往下走，会发现最终调用的是 jvm.cpp 中的<br>
jvm_define_class_common（）方法。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> jclass <span class="hljs-title">jvm_define_class_common</span><span class="hljs-params">(JNIEnv *env, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name,</span></span><br><span class="hljs-params"><span class="hljs-function">                                      jobject loader, <span class="hljs-type">const</span> jbyte *buf,</span></span><br><span class="hljs-params"><span class="hljs-function">                                      jsize len, jobject pd, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *source,</span></span><br><span class="hljs-params"><span class="hljs-function">                                      TRAPS)</span> </span>&#123;<br>  ......<br>  <span class="hljs-function">ClassFileStream <span class="hljs-title">st</span><span class="hljs-params">((u1*)buf, len, source, ClassFileStream::verify)</span></span>;<br>  <span class="hljs-function">Handle <span class="hljs-title">class_loader</span> <span class="hljs-params">(THREAD, JNIHandles::resolve(loader))</span></span>;<br>  <span class="hljs-keyword">if</span> (UsePerfData) &#123;<br>    <span class="hljs-built_in">is_lock_held_by_thread</span>(class_loader,<br>                           ClassLoader::<span class="hljs-built_in">sync_JVMDefineClassLockFreeCounter</span>(),<br>                           THREAD);<br>  &#125;<br>  <span class="hljs-function">Handle <span class="hljs-title">protection_domain</span> <span class="hljs-params">(THREAD, JNIHandles::resolve(pd))</span></span>;<br>  Klass* k = SystemDictionary::<span class="hljs-built_in">resolve_from_stream</span>(class_name,<br>                                                   class_loader,<br>                                                   protection_domain,<br>                                                   &amp;st,<br>                                                   CHECK_NULL);<br>  ......<br><br>  <span class="hljs-keyword">return</span> (jclass) JNIHandles::<span class="hljs-built_in">make_local</span>(env, k-&gt;<span class="hljs-built_in">java_mirror</span>());<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其上的步骤细分下来共三步：</p>
<ol>
<li>将 class 文件转化为字节流。</li>
<li>求当前线程是否持有锁，并且显式地进入 protection_domain。</li>
<li>将字节流转化成 Klass 的实例（class 文件在 JVM 中的内存代表），注册进 SystemDictionary 里。</li>
</ol>
<p>Klass 是 JVM 用来定义 Java Class 的数据结构。不过 Klass 只是一个基类，Java Class 真正的数据结构定义在 InstanceKlass 中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">InstanceKlass</span>: <span class="hljs-keyword">public</span> Klass &#123;<br> <br> <span class="hljs-keyword">protected</span>:<br> <br>  Annotations*    _annotations;<br>  ......<br>  ConstantPool* _constants;<br>  ......<br>  Array&lt;jushort&gt;* _inner_classes;<br>  ......<br>  Array&lt;Method*&gt;* _methods;<br>  Array&lt;Method*&gt;* _default_methods;<br>  ......<br>  Array&lt;u2&gt;*      _fields;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个类型定义了 Java 类的所有属性，包括注解、常量、内部类、方法、内部方法、字段等信息。<strong>这些信息本来被记录在 Class 文件中，</strong>，InstanceKlass 是 它的内存形式。</p>
<p>可以和 Class 文件的结构图对比看。</p>
<p><img src="https://s2.ax1x.com/2019/09/05/nmR3gP.jpg" alt="此处输入图片的描述"></p>
<p>可以看到，在 class 文件里的 constant pool，只能映射到 InstanceKlass 里的 constant 上。</p>
<h2 id="resolve-from-stream-详解">resolve_from_stream 详解</h2>
<h3 id="判断是否允许并行加载类-并根据判断结果进行加锁">判断是否允许并行加载类，并根据判断结果进行加锁</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">bool</span> DoObjectLock = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_parallelCapable</span>(class_loader)) &#123;<br>  DoObjectLock = <span class="hljs-literal">false</span>;<br>&#125;<br>ClassLoaderData* loader_data = <span class="hljs-built_in">register_loader</span>(class_loader, CHECK_NULL);<br>Handle lockObject = <span class="hljs-built_in">compute_loader_lock_object</span>(class_loader, THREAD);<br><span class="hljs-built_in">check_loader_lock_contention</span>(lockObject, THREAD);<br><span class="hljs-function">ObjectLocker <span class="hljs-title">ol</span><span class="hljs-params">(lockObject, THREAD, DoObjectLock)</span></span>;<br></code></pre></td></tr></table></figure>
<p>**如果允许并行加载，则不会对ClassLoader进行加锁，只对SystemDictionary加锁。否则，便会利用 ObjectLocker 对ClassLoader 加锁，保证同一个ClassLoader在同一时刻只能加载一个类。**ObjectLocker 会在其构造函数中获取锁，并在析构函数中释放锁。</p>
<p>允许并行加载的好处便是精细化了锁粒度，这样可以在同一时刻加载多个Class文件。</p>
<h3 id="解析文件流-生成-instanceklass">解析文件流，生成 InstanceKlass</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">InstanceKlass* k = <span class="hljs-literal">NULL</span>;<br><br>k = KlassFactory::<span class="hljs-built_in">create_from_stream</span>(st,<br>                                         class_name,<br>                                         loader_data,<br>                                         protection_domain,<br>                                         <span class="hljs-literal">NULL</span>, <span class="hljs-comment">// host_klass</span><br>                                         <span class="hljs-literal">NULL</span>, <span class="hljs-comment">// cp_patches</span><br>                                         CHECK_NULL);<br></code></pre></td></tr></table></figure>
<h3 id="利用systemdictionary注册生成的-klass">利用SystemDictionary注册生成的 Klass</h3>
<blockquote>
<p>SystemDictionary 是用来帮助保存 ClassLoader 加载过的类信息的。准确点说，SystemDiction<br>
并不是一个容器，真正用来保存类信息的容器是 Dictionary，每个 ClassLoaderData 都保存着一个私有的<br>
Dictionary，而 SystemDictionary 只是一个拥有很多静态方法的工具类而已。</p>
</blockquote>
<p>注册的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_parallelCapable</span>(class_loader)) &#123;<br>  InstanceKlass* defined_k = <span class="hljs-built_in">find_or_define_instance_class</span>(h_name, class_loader, k, THREAD);<br>  <span class="hljs-keyword">if</span> (!HAS_PENDING_EXCEPTION &amp;&amp; defined_k != k) &#123;<br>    <span class="hljs-comment">// If a parallel capable class loader already defined this class, register &#x27;k&#x27; for cleanup.</span><br>    <span class="hljs-built_in">assert</span>(defined_k != <span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;Should have a klass if there&#x27;s no exception&quot;</span>);<br>    loader_data-&gt;<span class="hljs-built_in">add_to_deallocate_list</span>(k);<br>    k = defined_k;<br>  &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-built_in">define_instance_class</span>(k, THREAD);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果允许并行加载，那么前面就不会对 ClassLoader 加锁，所以在同一时刻，可能对同一 Class 文件加载多次-但同一个 Class 必须在同一 ClassLoader 里保持唯一，所以先利用 SystemDictionary 查询 ClassLoader 是否已经加载过相同 Class。</p>
<ul>
<li>如果已经加载过，那么就将刚刚加载的 InstanceKlass 加入待回收列表，并将 InstanceKlass * k 重新指向利用 SystemDictionary 查询到的 InstanceKlass。（<strong>允许重复加载，弃新存旧</strong>）</li>
<li>如果没有查询到，那么就将刚刚加载的 InstanceKlass 注册到 ClassLoader的 Dictionary 中 中。</li>
</ul>
<p>如果禁止了并行加载，那么直接利用SystemDictionary将 InstanceKlass 注册到 ClassLoader的 Dictionary 中即可。<strong>此时由锁保证数据唯一性。</strong></p>
<h2 id="classfileparser">ClassFileParser</h2>
<p>resolve_from_stream（）最重要的是第二步，从文件流生成InstanceKlass，这依赖于调用 KlassFactory::create_from_stream（）方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ClassFileParser <span class="hljs-title">parser</span><span class="hljs-params">(stream,</span></span><br><span class="hljs-params"><span class="hljs-function">                       name,</span></span><br><span class="hljs-params"><span class="hljs-function">                       loader_data,</span></span><br><span class="hljs-params"><span class="hljs-function">                       protection_domain,</span></span><br><span class="hljs-params"><span class="hljs-function">                       host_klass,</span></span><br><span class="hljs-params"><span class="hljs-function">                       cp_patches,</span></span><br><span class="hljs-params"><span class="hljs-function">                       ClassFileParser::BROADCAST, <span class="hljs-comment">// publicity level</span></span></span><br><span class="hljs-params"><span class="hljs-function">                       CHECK_NULL)</span></span>;<br><br>InstanceKlass* result = parser.<span class="hljs-built_in">create_instance_klass</span>(old_stream != stream, CHECK_NULL);<br></code></pre></td></tr></table></figure>
<p>这又依赖于 ClassFileParser。</p>
<p><strong>ClassFileParser 加载Class文件的入口便是 create_instance_klass（）。顾名思义，用来创建InstanceKlass的。</strong></p>
<p>create_instance_klass（）主要就干了两件事：</p>
<ol>
<li>为 InstanceKlass 分配内存：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">InstanceKlass* <span class="hljs-type">const</span> ik =<br>    InstanceKlass::<span class="hljs-built_in">allocate_instance_klass</span>(*<span class="hljs-keyword">this</span>, CHECK_NULL);<br></code></pre></td></tr></table></figure>
<p>内存分配代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> size = InstanceKlass::<span class="hljs-built_in">size</span>(parser.<span class="hljs-built_in">vtable_size</span>(),<br>                                       parser.<span class="hljs-built_in">itable_size</span>(),<br>                                       <span class="hljs-built_in">nonstatic_oop_map_size</span>(parser.<span class="hljs-built_in">total_oop_map_count</span>()),<br>                                       parser.<span class="hljs-built_in">is_interface</span>(),<br>                                       parser.<span class="hljs-built_in">is_anonymous</span>(),<br>                                       <span class="hljs-built_in">should_store_fingerprint</span>(parser.<span class="hljs-built_in">is_anonymous</span>()));<br>ClassLoaderData* loader_data = parser.<span class="hljs-built_in">loader_data</span>();<br>InstanceKlass* ik;<br>ik = <span class="hljs-built_in">new</span> (loader_data, size, THREAD) <span class="hljs-built_in">InstanceKlass</span>(parser, InstanceKlass::_misc_kind_other);<br></code></pre></td></tr></table></figure>
<p>这里首先计算了InstanceKlass在内存中的大小，要知道，这个大小在Class 文件编译后就被确定了。</p>
<p>然后便 new 了一个新的 InstanceKlass 对象。这里并不是简单的在堆上分配内存，要注意的是Klass 对 new 操作符进行了重载：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span>* Klass::<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size, ClassLoaderData* loader_data, <span class="hljs-type">size_t</span> word_size, TRAPS)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> Metaspace::<span class="hljs-built_in">allocate</span>(loader_data, word_size, MetaspaceObj::ClassType, THREAD);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>分配 InstanceKlass 的时候调用了 Metaspace::allocate（）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">MetaWord* <span class="hljs-title">Metaspace::allocate</span><span class="hljs-params">(ClassLoaderData* loader_data, <span class="hljs-type">size_t</span> word_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                              MetaspaceObj::Type type, TRAPS)</span> </span>&#123;<br>  ......<br>  MetadataType mdtype = (type == MetaspaceObj::ClassType) ? ClassType : NonClassType;<br>  ......<br>  MetaWord* result = loader_data-&gt;<span class="hljs-built_in">metaspace_non_null</span>()-&gt;<span class="hljs-built_in">allocate</span>(word_size, mdtype);<br>  ......<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>*<em>由此可见，InstanceKlass 是分配在 ClassLoader的 Metaspace（元空间） 的方法区中。从 JDK8 开始，HotSpot 就没有了永久代，类都分配在 Metaspace 中。Metaspace 和永久代不一样，采用的是 Native Memory，永久代由于受限于 MaxPermSize，所以当内存不够时会内存溢出。</em></p>
<ol start="2">
<li>分析Class文件，填充 InstanceKlass 内存区域：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">fill_instance_klass</span>(ik, changed_by_loadhook, CHECK_NULL);<br></code></pre></td></tr></table></figure>
<p>ClassFileParser 在构造的时候就会开始分析Class文件，所以fill_instance_klass（）中只需要填充即可。填充结束后，还会调用 java_lang_Class::create_mirror（）创建 InstanceKlass 在Java 层的 Class 对象。<strong>双层对象。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClassFileParser::fill_instance_klass</span><span class="hljs-params">(InstanceKlass* ik, <span class="hljs-type">bool</span> changed_by_loadhook, TRAPS)</span> </span>&#123;<br>  .....<br>  ik-&gt;<span class="hljs-built_in">set_class_loader_data</span>(_loader_data);<br>  ik-&gt;<span class="hljs-built_in">set_nonstatic_field_size</span>(_field_info-&gt;nonstatic_field_size);<br>  ik-&gt;<span class="hljs-built_in">set_has_nonstatic_fields</span>(_field_info-&gt;has_nonstatic_fields);<br>  ik-&gt;<span class="hljs-built_in">set_static_oop_field_count</span>(_fac-&gt;count[STATIC_OOP]);<br>  ik-&gt;<span class="hljs-built_in">set_name</span>(_class_name);<br>  ......<br><br>  java_lang_Class::<span class="hljs-built_in">create_mirror</span>(ik,<br>                                 <span class="hljs-built_in">Handle</span>(THREAD, _loader_data-&gt;<span class="hljs-built_in">class_loader</span>()),<br>                                 module_handle,<br>                                 _protection_domain,<br>                                 CHECK);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>至此，系统保证了“不同ClassLoader加载的类是互相隔离的”。其基本流程为：每一个 classloader 有一个私有的 Dictionary，在加载类的过程中，Dictionary 有锁机制保证 InstanceKlass 的唯一性。如果存在不同的 ClassLoader 加载同一个 Class 文件，就会在内存里保存多份 InstanceKlass。而不同的 InstanceKlass 之间是不能相互强制转换的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        URL url[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>[<span class="hljs-number">1</span>];<br>        url[<span class="hljs-number">0</span>] = Thread.currentThread().getContextClassLoader().getResource(<span class="hljs-string">&quot;&quot;</span>);<br><br>        <span class="hljs-type">CustomClassloader</span> <span class="hljs-variable">customClassloader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomClassloader</span>(url);<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> customClassloader.loadClass(<span class="hljs-string">&quot;a.b.c&quot;</span>);<br><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> (Student) clazz.newInstance();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>上述代码运行一定会出错。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;main&quot;</span> java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.ClassCastException</span>:<br>     <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.b</span><span class="hljs-selector-class">.c</span> cannot be cast to <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.b</span>.c<br></code></pre></td></tr></table></figure>
<p>那是因为目标 a.b.c 类型存在于当前类加载器中，而 clazz 这个Class实例则存在于 customClassloader 中，它的 clazz.newInstance() 的类型本身不能跨类加载器相互转化。</p>
<h2 id="一种-hack-技巧">一种 hack 技巧</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        URL url[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>[<span class="hljs-number">1</span>];<br>        url[<span class="hljs-number">0</span>] = Thread.currentThread().getContextClassLoader().getResource(<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">CustomClassloader</span> <span class="hljs-variable">customClassloader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomClassloader</span>(url);<br>        Thread.currentThread().setContextClassLoader(customClassloader);<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> customClassloader.loadClass(<span class="hljs-string">&quot;a.b.c&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> clazz.newInstance();<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> clazz.getDeclaredMethod(<span class="hljs-string">&quot;test&quot;</span>);<br>        method.invoke(object);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>注意，这里面并不直接调用 c c = clazz.newInstance()，而是调用<br>
Object object = clazz.newInstance()，并且必须使用反射才能调用 test。因为如果显式地使用了 C 这个类型，进行常量解析时，还是会跑到系统默认的 ClassLoader 加载的 C。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://magicliang.github.io">magicliang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://magicliang.github.io/2019/09/05/%E9%87%8D%E8%BF%B0%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/">https://magicliang.github.io/2019/09/05/%E9%87%8D%E8%BF%B0%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JVM/">JVM</a><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post-share"><div class="social-share" data-image="/img/wall-paper-168.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2017/10/23/%E6%98%82%E8%B4%B5%E7%9A%84%E5%BC%82%E5%B8%B8/" title="昂贵的异常"><img class="cover" src="/img/wall-paper-117.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-10-23</div><div class="info-item-2">昂贵的异常</div></div><div class="info-2"><div class="info-item-1">抛出问题   Joshua Bloch 在《Effective Java》的 Item 57 里明确地提到过，不要试图用 Exception 的跳转来代替正常的程序控制流。他列举了很多原因，但特别提到了抛出异常会使得整个程序运行变慢。抛出异常远比普通的 return , break 等操作对控制流、数据流的性能影响要大，它就只适合拿来作异常分支的控制语句，而不能拿来编写正常的逻辑。  Throwing exception is expensive.    这句话在 Java 的程序员世界里面已经成为老生常谈。却很少有人谈及，但到底抛出异常比正常的程序跳转返回慢在哪里，有多慢。“不要滥用异常”好像一个猴子定律，人们忘记了为什么不能这么做，却不明白为什么不能这么做。   这几天读了一位同事写的好文[《Java虚拟机是如何处理异常的》][2]，深入地分析了 JVM 对异常跳转的处理过程: JVM 会通过异常表的机制，优化异常抛出和正常返回之间的性能差异。仅从程序计数器的移动上来讲，抛出一个异常对栈帧的弹栈并不比直接返回更昂贵。写在前头的结论是：“try-catch语句块几乎不会影响程序...</div></div></div></a><a class="pagination-related" href="/2017/11/10/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/" title="线程安全与锁优化"><img class="cover" src="/img/wall-paper-175.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-11-10</div><div class="info-item-2">线程安全与锁优化</div></div><div class="info-2"><div class="info-item-1">线程安全 什么是线程安全 “当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方法进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象就是线程安全的。” 相对的线程安全，可以分成五个等级： 线程安全的分类 不可变 不可变的数据，都是线程安全的。不可变的对象引用，加上所有field都是不可变的。如果有得选，尽量连方法都是final的。 绝对线程安全 Vector不是线程安全的。它也会出现并发修改时 Out of Range 的异常（注意，不是 ConcurrentModification 的异常）。 相对线程安全 需要保证对这个对象的单独操作是线程安全的，在调用的时候不需要加上额外的保障措施。对于特定顺序的连续操作，就需要额外的同步来保证调用的正确性了。 线程兼容 可以通过特殊手段做到线程安全的普通类，绝大部分类都属于相对线程安全的。 线程对立 线程对立，是不管调用端是否采取了同步措施，都无法在多线程环境中使用的代码。常见的线程对立的操作还有 suspend()，resume()， System....</div></div></div></a><a class="pagination-related" href="/2018/10/13/%E5%8D%A1%E8%A1%A8%E5%92%8C-RSet/" title="卡表和 RSet"><img class="cover" src="/img/wall-paper-114.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-10-13</div><div class="info-item-2">卡表和 RSet</div></div><div class="info-2"><div class="info-item-1">上下文 卡表和 RSet（Remember Set），是 JVM 为了解决分代收集时，live set 扫描需要穿梭到不同的代的时候的效率问题。 使用缓存表来提高查询效率，是化顺序查找为部分随机查找的一种常用的设计思路。 例如，在传统的计算机体系结构中，当我们把内存分成页以后，会有一个页表，页表又会有一个快表，作为一个中间缓存项，来帮助我们查找我们需要使用的页表项（table entry）。 JVM 在进行垃圾收集的时候，有一项非常重要的工作就是确定这一次垃圾收集的对象到底有多少个，即确定 live set 的范围。 对于新生代垃圾收集器而言，这个问题又有其特殊之处。根据 JVM 的弱分代收集假设（weak generational hypothesis）的存在，每次垃圾收集的时候，新生代的扫描范围可能很大，但新生代的 live set 不应该太大。card table/Remember Set 的设计目的，就是尽量减少无用的垃圾扫描范围，使用类似操作系统或者数据库的脏页表的形式，来做类似快表的查询。 卡表（card table）  卡表是 CMS 的解决方案。 卡表通常在 JV...</div></div></div></a><a class="pagination-related" href="/2018/10/22/JDWP-%E4%B8%8E%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/" title="JDWP 与远程调试"><img class="cover" src="/img/wall-paper-144.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-10-22</div><div class="info-item-2">JDWP 与远程调试</div></div><div class="info-2"><div class="info-item-1">JDWP（Java Debug Wire Protocol），它提供了调试器和目标 JVM （target vm）之间的调试协议。 在 target vm 启动时，增加这个 JAVA_OPTS： 1JAVA_OPTS=&quot;-Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=26310&quot; 在服务器端，增加 remote debuging 的时候使用如下配置： 12345678# Java 9 以上-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:8000# Java 5-8-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=8000# Java 1.4.x -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,addre...</div></div></div></a><a class="pagination-related" href="/2020/03/08/JMX-%E6%B7%B1%E5%BA%A6%E5%8E%86%E9%99%A9/" title="JMX 深度历险"><img class="cover" src="/img/wall-paper-57.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-03-08</div><div class="info-item-2">JMX 深度历险</div></div><div class="info-2"><div class="info-item-1">JMX 常见指标 JVM 指标 系统指标    System 相关指标 描述     system.load.average 系统load，如果是docker，此指标收集的物理机的load   cpu.system.load.percent 系统所有进程占用cpu的百分比   cpu.jvm.load.percent jvm占用cpu的百分比   system.process.used.phyical.memory 系统使用的物理内存   system.process.used.swap.size 系统使用的swap内存    JVM 内存指标    JVM相关指标 描述     jvm.gc.count GC的次数   jvm.gc.time GC的时间，单位毫秒   jvm.younggc.count 年轻代GC的次数 ，包括的GC算法（Copy，ParNew，PS Scavenge，G1 Young Generation）   jvm.younggc.time 年轻代GC的时间，单位毫秒   jvm.fullgc.count 年老代GC的次数，包括的GC算法   jvm.f...</div></div></div></a><a class="pagination-related" href="/2020/09/27/%E7%8E%B0%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/" title="现代垃圾收集器"><img class="cover" src="/2020/09/27/%E7%8E%B0%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/%E6%94%B6%E9%9B%86%E5%99%A8%E5%88%86%E7%B1%BB.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-27</div><div class="info-item-2">现代垃圾收集器</div></div><div class="info-2"><div class="info-item-1">所有的垃圾收集器，都基于弱分代假设。实际的垃圾回收效率取决于堆内对象的分布状况。垃圾回收并不能解决内存泄漏或者应用程序逻辑的不良分配习惯问题，要处理 JVM 内存回收问题的根本方法是对程序进行调优。 有几个常用原则：  减少临时对象，尽量复用内存。 使用对象池。 主动提前释放对象。 主动 gc。 好的代码比 tuning 更重要。 选 gc 算法比 tuning 参数重要，tuning 参数是最后一步。  其他情况，可以通过 tuning garbage collector 来解决。 操作系统的影响  SWAP 可能会显著增加 GC 时间，因为被换出的堆还要被换入。  美团的实践 参考：  《从实际案例聊聊Java应用的GC优化》 《Java中9种常见的CMS GC问题分析与解决》   Minor GC Major GC Full GC  垃圾收集器分类    可以看到一个现象：在大部分时候，g1 比 CMS 快，但极端的百分位里，CMS 比 g1 快。 出处见这里。 常用工具 命令行终端   标准终端类：jps、jinfo、jstat、jstack、jmap 功能整合类：jcm...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%95%E6%97%B6%E5%8A%A0%E8%BD%BD%E7%B1%BB"><span class="toc-number">1.</span> <span class="toc-text">何时加载类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E-java-%E5%88%B0-cpp-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">从 Java 到 cpp 源码分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#resolve-from-stream-%E8%AF%A6%E8%A7%A3"><span class="toc-number">3.</span> <span class="toc-text">resolve_from_stream 详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E5%85%81%E8%AE%B8%E5%B9%B6%E8%A1%8C%E5%8A%A0%E8%BD%BD%E7%B1%BB-%E5%B9%B6%E6%A0%B9%E6%8D%AE%E5%88%A4%E6%96%AD%E7%BB%93%E6%9E%9C%E8%BF%9B%E8%A1%8C%E5%8A%A0%E9%94%81"><span class="toc-number">3.1.</span> <span class="toc-text">判断是否允许并行加载类，并根据判断结果进行加锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E6%96%87%E4%BB%B6%E6%B5%81-%E7%94%9F%E6%88%90-instanceklass"><span class="toc-number">3.2.</span> <span class="toc-text">解析文件流，生成 InstanceKlass</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8systemdictionary%E6%B3%A8%E5%86%8C%E7%94%9F%E6%88%90%E7%9A%84-klass"><span class="toc-number">3.3.</span> <span class="toc-text">利用SystemDictionary注册生成的 Klass</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#classfileparser"><span class="toc-number">4.</span> <span class="toc-text">ClassFileParser</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E7%A7%8D-hack-%E6%8A%80%E5%B7%A7"><span class="toc-number">5.</span> <span class="toc-text">一种 hack 技巧</span></a></li></ol></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2017 - 2025 By magicliang</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional and Simplified Chinese">簡</button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>