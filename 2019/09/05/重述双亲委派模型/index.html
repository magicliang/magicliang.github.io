<!DOCTYPE html>

<html lang="zh-Hans">
    <head>
    <meta charset="utf-8">
    <!--
        hexo-theme-suka © SukkaW
        GitHub: https://github.com/SukkaW/hexo-theme-suka
    -->

    <!-- ### Resource Hint ### -->

    <!-- ## DNS Prefetch ## -->
    <meta http-equiv="x-dns-prefetch-control" content="on">

<!-- busuanzi -->

    <link rel="dns-prefetch" href="//busuanzi.ibruce.info">


<!-- comment -->







<!-- analytics -->







    <!-- ## Preload ## -->
    
    <!-- Busuanzi -->
    
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/busuanzi@2.3.0/bsz.pure.mini.js" as="script">







    <!-- ### Meta & Title & Info ### -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, maximum-scale=5, viewport-fit=cover">
    <meta name="renderer" content="webkit">

    <!-- Title -->
    <title>重述双亲委派模型 | 守株阁</title>

    <!-- Favicons -->
    <link rel="icon" type="image&#x2F;ico" href="/img/suka-favicon.ico">

    <!-- ### Import File ### -->
    <link rel="stylesheet" href="/lib/spectre/spectre.min.css"><style>
    body {
        background-color: #f8f9fa;
    }

    a, a:visited {
        color: #0070ff;
    }

    a:active, a:focus, a:hover {
        color: #0070ff;
        opacity: .75;
    }

    #post-content a,
    #post-content a:hover,
    #post-content a:focus,
    #post-content a:visited {
        color: #005eb9;
        opacity: 1;
    }

    

    .post-entry .card-body a {
        color: #0070ff;
    }

    .avatar {
        background: #444;
    }

    .navbar-link,
    .navbar-link:visited,
    .timeline .timeline-item .timeline-icon.icon-lg {
        color: #0070ff;
    }

    .navbar-link:hover {
        color: #0070ff;
        opacity: .8;
    }

    #search-input .btn,
    #disqus_click_btn,
    #disqus-switch-to-direct,
    #disqus-loadmore-button {
        background: #727e96;
        border-color: #727e96;
        color: #fff;
    }

    #post-toc a.post-toc-link,
    #post-toc a.post-toc-link:visited,
    .share-menu.menu .menu-item>a {
        color: #727e96;
    }

    .share-menu.menu .menu-item>a:hover,
    .share-menu.menu .menu-item>a:focus,
    .share-menu.menu .menu-item>a:visited {
        color: #50596c;
        background: #f8f9fa;
        opacity: .85;
    }
</style><link rel="stylesheet" href="/css/style.min.css">








    <!-- Prettify Theme -->
    
    <link rel="preload" href="/css/highlight/github.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="/css/highlight/github.min.css"></noscript>





<script>
/*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
!function(t){"use strict";t.loadCSS||(t.loadCSS=function(){});var e=loadCSS.relpreload={};if(e.support=function(){var e;try{e=t.document.createElement("link").relList.supports("preload")}catch(t){e=!1}return function(){return e}}(),e.bindMediaToggle=function(t){var e=t.media||"all";function a(){t.addEventListener?t.removeEventListener("load",a):t.attachEvent&&t.detachEvent("onload",a),t.setAttribute("onload",null),t.media=e}t.addEventListener?t.addEventListener("load",a):t.attachEvent&&t.attachEvent("onload",a),setTimeout(function(){t.rel="stylesheet",t.media="only x"}),setTimeout(a,3e3)},e.poly=function(){if(!e.support())for(var a=t.document.getElementsByTagName("link"),n=0;n<a.length;n++){var o=a[n];"preload"!==o.rel||"style"!==o.getAttribute("as")||o.getAttribute("data-loadcss")||(o.setAttribute("data-loadcss",!0),e.bindMediaToggle(o))}},!e.support()){e.poly();var a=t.setInterval(e.poly,500);t.addEventListener?t.addEventListener("load",function(){e.poly(),t.clearInterval(a)}):t.attachEvent&&t.attachEvent("onload",function(){e.poly(),t.clearInterval(a)})}"undefined"!=typeof exports?exports.loadCSS=loadCSS:t.loadCSS=loadCSS}("undefined"!=typeof global?global:this);
</script>

    <!-- ### Site Verification ### -->
    


    <link rel="alternate" type="application/atom+xml" href="/atom.xml"><meta name="mobile-web-app-capable" content="yes"><meta name="application-name" content="守株阁"><meta name="msapplication-starturl" content="http://magicliang.github.io"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="守株阁"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <!-- ### The Open Graph & Twitter Card Protocol ### -->
    <meta property="og:title" content="重述双亲委派模型 | 守株阁"><meta property="og:site_name" content="守株阁"><meta property="og:type" content="article"><meta property="og:url" content="http://magicliang.github.io/2019/09/05/%E9%87%8D%E8%BF%B0%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/"><meta property="og:locale" content="zh-Hans"><meta name="description" content="何时加载类 遇到 new、getstatic、putstatic 等指令时。 对类进行反射调用的时候。 初始化某个类的子类的时候。 虚拟机启动时会先加载设置的程序主类。 使用 dynamic 动态语言支持等相关特性时。  从 Java 到 cpp 源码分析 JVM默认用于加载用户程序的ClassLoader为AppClassLoader，不过无论是什么ClassLoader，它的根父类都是java - magicliang - 守株阁"><meta name="keywords" content="JVM, Java"><meta property="og:image" content="https://s2.ax1x.com/2019/09/05/nmR3gP.jpg"><meta property="article:published_time" content="2019-09-05T06:41:05.000Z"><meta property="article:modified_time" content="2019-09-09T13:35:42.000Z"><meta property="og:updated_time" content="2019-09-09T13:35:42.000Z"><meta property="article:author" content="magicliang"><meta property="article:tag" content="JVM, Java"><meta name="twitter:card" content="summary">

    

    <!-- ### Canonical link ### -->
    <link rel="canonical" href="http://magicliang.github.io/2019/09/05/%E9%87%8D%E8%BF%B0%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/">

    <meta name="generator" content="Hexo 6.0.0">

    <!-- ### Analytics ### -->
    







    <!-- ### Structured Data ### -->
    



<script type="application/ld+json">
{
    "@context": "http://schema.org",
    "url": "http://magicliang.github.io/2019/09/05/%E9%87%8D%E8%BF%B0%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/",
    "@type": "BlogPosting",
    "logo": "http://magicliang.github.io/img/suka-favicon.ico",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "http://magicliang.github.io/2019/09/05/%E9%87%8D%E8%BF%B0%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/"
    },
    "headline": "重述双亲委派模型 | 守株阁",
    
    "image": {
        "@type": "ImageObject",
        "url": "http://magicliang.github.io/img/suka-favicon.ico"
    },
    
    "datePublished": "2019-09-05T06:41:05.000Z",
    "dateModified": "2019-09-09T13:35:42.000Z",
    "author": {
        "@type": "Person",
        "name": "magicliang",
        "image": {
            "@type": "ImageObject",
            "url": "http://magicliang.github.io/img/default_avatar.png"
        },
        "description": "Hi, nice to meet you."
    },
    "publisher": {
        "@type": "Organization",
        "name": "守株阁",
        "logo": {
            "@type": "ImageObject",
            "url": "http://magicliang.github.io/img/suka-favicon.ico"
        }
    },
    
    "potentialAction": {
        "@type": "SearchAction",
        "target": "http://magicliang.github.io/search?s={search_term_string}",
        "query-input": "required name=search_term_string"
    },
    
    "keywords": "JVM, Java",
    "description": "何时加载类 遇到 new、getstatic、putstatic 等指令时。 对类进行反射调用的时候。 初始化某个类的子类的时候。 虚拟机启动时会先加载设置的程序主类。 使用 dynamic 动态语言支持等相关特性时。  从 Java 到 cpp 源码分析 JVM默认用于加载用户程序的ClassLoader为AppClassLoader，不过无论是什么ClassLoader，它的根父类都是java - magicliang - 守株阁"
}
</script>



    <!-- ### Custom Head ### -->
    
</head>

    <body>
            

            <!-- ### Main content ### -->
            <!-- ## Header ##-->
<header>
    <h1 class="header-title text-center"><a href="/">守株阁</a></h1>

    <p class="text-center header-slogan">
        
            
                Hi, nice to meet you.
            
        
    </p>

    <nav class="navbar-section text-center">
    
        <a href="/" class="navbar-link">Home</a>
    
    
        <a href="/archives/" class="navbar-link">Archives</a>
    
    
        <a href="/search" class="navbar-link">Search</a>
    
    
    
        <div class="dropdown dropdown-right">
    <a class="navbar-link dropdown-toggle" tabindex="0">Share</a>
    <ul class="menu share-menu">

        <!-- Share Weibo -->
        
        <li class="menu-item">
            <a href="http://service.weibo.com/share/share.php?appkey=&title=守株阁&url=http://magicliang.github.io&pic=http://magicliang.github.io/img/suka-favicon.ico&searchPic=false&style=simple" target="_blank" rel="external noopener noreferrer nofollow">Share to Weibo</a>
        </li>
        

        <!-- Share Twitter -->
        
        <li class="menu-item">
            <a href="https://twitter.com/intent/tweet?text=守株阁&url=http://magicliang.github.io&via=magicliang" target="_blank" rel="external noopener noreferrer nofollow">Share to Twitter</a>
        </li>
        

        <!-- Share Facebook -->
        
        <li class="menu-item">
            <a href="https://www.facebook.com/sharer/sharer.php?u=http://magicliang.github.io" target="_blank" rel="external noopener noreferrer nofollow">Share to Facebook</a>
        </li>
        

        <!-- Share Google+ -->
        
        <li class="menu-item">
            <a href="https://plus.google.com/share?url=http://magicliang.github.io" target="_blank" rel="external noopener noreferrer nofollow">Share to Google+</a>
        </li>
        

        <!-- Share LinkedIn -->
        
        <li class="menu-item">
            <a href="https://www.linkedin.com/shareArticle?mini=true&url=http://magicliang.github.io&title=重述双亲委派模型" target="_blank" rel="external noopener noreferrer nofollow">Share to LinkedIn</a>
        </li>
        

        <!-- Share QQ -->
        
        <li class="menu-item">
            <a href="http://connect.qq.com/widget/shareqq/index.html?site=守株阁&title=重述双亲委派模型&summary=关于技术以及人生&pics=http://magicliang.github.io/img/suka-favicon.ico&url=http://magicliang.github.io" target="_blank" rel="external noopener noreferrer nofollow"> Share to QQ</a>
        </li>
        

        <!-- Share Telegram -->
        
        <li class="menu-item">
            <a href="https://t.me/share/url?url=http://magicliang.github.io&text=重述双亲委派模型" target="_blank" rel="external noopener noreferrer nofollow">Share to Telegram</a>
        </li>
        

        <!-- QRCode -->
        
        <li class="menu-item">
            <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMQAAADECAAAAADlzdG3AAADMklEQVR42u3aUW7rMAwF0ex/0+1vUFi8Q9lU02L8815bx/YJQIsi+fr6B8dLhAgRIkSMI17F8X7O+7lX/8c3vrhHda/yuUSIGEKsbnZ14dXff96g+my6Dz5fhIhBxCrYrh5u9bDVjVPAkgAXIeJTEKsgrR6OLm7V9USI+GTEKsBXv6sWwKvPpheLCBGnESRxu7rgagOVrr/7NxEiTiBIUvYb/z5W7RAhooGgxS4ajCm5W70cyPW3q+IiRDT7EzRxSwVlEoykqICfR4SIQQTZwNPArQrNqWDW+lmEiAEEObmTsFWNxqq5Um24ltcQIeIAorPIpU0+KSpUmJQYihAxhSBJXBWQ1eYmDbrQzVVZPBMh4mEESco6RWRSkCYPmV48IkRMIEhAkuIzKUyT4Ui6oIoQMYUgm/1u0TkNrBAESTxFiJhApICjmxqyEUrXTi8XESJOI0iDpTOU1d300KK0CBGTiLRYpSAm56YGJE0SW1VxESIeQJDmYioEV4GcEjuaRIoQMYnoDpfsFAxS0518obF4JkLEIII0EdMCSJrxVSMGNSNFiBhC0OHEctMOAjEtninJbO3sRIi4iaCBmRavFMA02SRJoAgRU4iUCNKGeefzZFGLmy0RIgYQaWEhA1xVQ4YspmQxRENbIkQ8iKAPtBpoJA0UUrymA2AiREwhSGGXLFCkAEe+GFJ8EyHiBKK7sNGNE2lqdpqRIkRMI9DAYHGh1cLXabR0m/QiREwi6EJUJWMkeasGUMh1bxXPRIjYmHeqBglJI5EsliTAyQCXCBHTCDp8uBP0q4Cvfo+HwUSIGEKgZAs2UVBzhDZR0pcqQsQQopvgVYG7u6kiDZ74dhIh4iEECdRuM4VuiroFOhEiphGdglYqCnQaJXc/L0LEFCIdpIHYCexu8wUNvIsQ8SCCDA+SYa0OdPUSqYa6YpNFhIgHEXRzRAoG3fNpAipCxGlEFZikuLsz5NIZekdTNiJEHEKkQfXUZKfFgFTAKxNAESIOIqqbd5opqYlCE0YRIk4gqsJwFWBVMkcGXGiB7VYWK0JEE5E2/HR4MTVoyELX2nCJEDGA+MuHCBEiRIgYO74BcYqfDI1NJRgAAAAASUVORK5CYII=" alr="QRCode">
        </li>
        

    </ul>
</div>
    
    
</nav>
</header>

            
    <!-- ## Post ## -->
    <div class="post-container">
    <div id="post-card" class="card">
        
        <div class="card-item-container">
            <div class="card-inner-cell">
                <!-- # Post Header Info # -->
                <div class="card-header">
                    
    <h1 class="card-title h3 mb-2">重述双亲委派模型</h1>




<div class="post-header-info">
    <p class="post-header-info-left text-gray">
        <img class="author-thumb lazyload" data-src="/img/default_avatar.png" src="/img/suka-lazyload.gif" alt="magicliang's Avatar">
        <span>2019-09-05</span>
        
        
            <!-- Busuanzi Post Views -->
<span id="busuanzi_container_page_pv" hidden>
    <span class="suka-devide-dot"></span>
    <span></span>
    <span id="busuanzi_value_page_pv"></span>
    <span>Views</span>
</span>
        
        
    </p>
    <div class="post-header-info-right">
        
            <div class="dropdown dropdown-right">
<a class="dropdown-toggle" tabindex="0">Share the post</a>
<ul class="menu share-menu">
    <!-- Share Weibo -->
    
    <li class="menu-item">
        <a href="http://service.weibo.com/share/share.php?appkey=&title=重述双亲委派模型&url=http://magicliang.github.io/2019/09/05/%E9%87%8D%E8%BF%B0%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/&pic=http://magicliang.github.io/img/suka-favicon.ico&searchPic=false&style=simple" target="_blank" rel="external noopener noreferrer nofollow">Share to Weibo</a>
    </li>
    

    <!-- Share Twitter -->
    
    <li class="menu-item">
        <a href="https://twitter.com/intent/tweet?text=重述双亲委派模型&url=http://magicliang.github.io/2019/09/05/%E9%87%8D%E8%BF%B0%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/&via=magicliang" target="_blank" rel="external noopener noreferrer nofollow">Share to Twitter</a>
    </li>
    

    <!-- Share Facebook -->
    
    <li class="menu-item">
        <a href="https://www.facebook.com/sharer/sharer.php?u=http://magicliang.github.io/2019/09/05/%E9%87%8D%E8%BF%B0%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/" target="_blank" rel="external noopener noreferrer nofollow">Share to Facebook</a>
    </li>
    

    <!-- Share Google+ -->
    
    <li class="menu-item">
        <a href="https://plus.google.com/share?url=http://magicliang.github.io/2019/09/05/%E9%87%8D%E8%BF%B0%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/" target="_blank" rel="external noopener noreferrer nofollow">Share to Google+</a>
    </li>
    

    <!-- Share LinkedIn -->
    
    <li class="menu-item">
        <a href="https://www.linkedin.com/shareArticle?mini=true&url=http://magicliang.github.io/2019/09/05/%E9%87%8D%E8%BF%B0%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/&title=守株阁" target="_blank" rel="external noopener noreferrer nofollow">Share to LinkedIn</a>
    </li>
    

    <!-- Share QQ -->
    
    <li class="menu-item">
        <a href="http://connect.qq.com/widget/shareqq/index.html?site=守株阁&title=守株阁&summary=关于技术以及人生&pics=http://magicliang.github.io/img/suka-favicon.ico&url=http://magicliang.github.io/2019/09/05/%E9%87%8D%E8%BF%B0%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/" target="_blank" rel="external noopener noreferrer nofollow"> Share to QQ</a>
    </li>
    

    <!-- Share Telegram -->
    
    <li class="menu-item">
        <a href="https://t.me/share/url?url=http://magicliang.github.io/2019/09/05/%E9%87%8D%E8%BF%B0%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/&text=守株阁" target="_blank" rel="external noopener noreferrer nofollow">Share to Telegram</a>
    </li>
    

    <!-- QRCode -->
    
    <li class="menu-item">
        <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMQAAADECAAAAADlzdG3AAADMklEQVR42u3aUW7rMAwF0ex/0+1vUFi8Q9lU02L8815bx/YJQIsi+fr6B8dLhAgRIkSMI17F8X7O+7lX/8c3vrhHda/yuUSIGEKsbnZ14dXff96g+my6Dz5fhIhBxCrYrh5u9bDVjVPAkgAXIeJTEKsgrR6OLm7V9USI+GTEKsBXv6sWwKvPpheLCBGnESRxu7rgagOVrr/7NxEiTiBIUvYb/z5W7RAhooGgxS4ajCm5W70cyPW3q+IiRDT7EzRxSwVlEoykqICfR4SIQQTZwNPArQrNqWDW+lmEiAEEObmTsFWNxqq5Um24ltcQIeIAorPIpU0+KSpUmJQYihAxhSBJXBWQ1eYmDbrQzVVZPBMh4mEESco6RWRSkCYPmV48IkRMIEhAkuIzKUyT4Ui6oIoQMYUgm/1u0TkNrBAESTxFiJhApICjmxqyEUrXTi8XESJOI0iDpTOU1d300KK0CBGTiLRYpSAm56YGJE0SW1VxESIeQJDmYioEV4GcEjuaRIoQMYnoDpfsFAxS0518obF4JkLEIII0EdMCSJrxVSMGNSNFiBhC0OHEctMOAjEtninJbO3sRIi4iaCBmRavFMA02SRJoAgRU4iUCNKGeefzZFGLmy0RIgYQaWEhA1xVQ4YspmQxRENbIkQ8iKAPtBpoJA0UUrymA2AiREwhSGGXLFCkAEe+GFJ8EyHiBKK7sNGNE2lqdpqRIkRMI9DAYHGh1cLXabR0m/QiREwi6EJUJWMkeasGUMh1bxXPRIjYmHeqBglJI5EsliTAyQCXCBHTCDp8uBP0q4Cvfo+HwUSIGEKgZAs2UVBzhDZR0pcqQsQQopvgVYG7u6kiDZ74dhIh4iEECdRuM4VuiroFOhEiphGdglYqCnQaJXc/L0LEFCIdpIHYCexu8wUNvIsQ8SCCDA+SYa0OdPUSqYa6YpNFhIgHEXRzRAoG3fNpAipCxGlEFZikuLsz5NIZekdTNiJEHEKkQfXUZKfFgFTAKxNAESIOIqqbd5opqYlCE0YRIk4gqsJwFWBVMkcGXGiB7VYWK0JEE5E2/HR4MTVoyELX2nCJEDGA+MuHCBEiRIgYO74BcYqfDI1NJRgAAAAASUVORK5CYII=" alt="QRCode">
    </li>
    

</ul>
</div>
        
    </div>
</div>
                </div>
                <div class="card-body">
                    
                        
                        
                            <div id="post-toc"><ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%BD%95%E6%97%B6%E5%8A%A0%E8%BD%BD%E7%B1%BB"><span class="post-toc-number">1.</span> <span class="post-toc-text">何时加载类</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%BB%8E-Java-%E5%88%B0-cpp-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="post-toc-number">2.</span> <span class="post-toc-text">从 Java 到 cpp 源码分析</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#resolve-from-stream-%E8%AF%A6%E8%A7%A3"><span class="post-toc-number">3.</span> <span class="post-toc-text">resolve_from_stream 详解</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E5%85%81%E8%AE%B8%E5%B9%B6%E8%A1%8C%E5%8A%A0%E8%BD%BD%E7%B1%BB%EF%BC%8C%E5%B9%B6%E6%A0%B9%E6%8D%AE%E5%88%A4%E6%96%AD%E7%BB%93%E6%9E%9C%E8%BF%9B%E8%A1%8C%E5%8A%A0%E9%94%81"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">判断是否允许并行加载类，并根据判断结果进行加锁</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E8%A7%A3%E6%9E%90%E6%96%87%E4%BB%B6%E6%B5%81%EF%BC%8C%E7%94%9F%E6%88%90-InstanceKlass"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">解析文件流，生成 InstanceKlass</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%88%A9%E7%94%A8SystemDictionary%E6%B3%A8%E5%86%8C%E7%94%9F%E6%88%90%E7%9A%84-Klass"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">利用SystemDictionary注册生成的 Klass</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#ClassFileParser"><span class="post-toc-number">4.</span> <span class="post-toc-text">ClassFileParser</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%B8%80%E7%A7%8D-hack-%E6%8A%80%E5%B7%A7"><span class="post-toc-number">5.</span> <span class="post-toc-text">一种 hack 技巧</span></a></li></ol></div>
                        
                    
                    <article id="post-content">
                        <h2 id="何时加载类"><a href="#何时加载类" class="headerlink" title="何时加载类"></a>何时加载类</h2><ol>
<li>遇到 new、getstatic、putstatic 等指令时。</li>
<li>对类进行反射调用的时候。</li>
<li>初始化某个类的子类的时候。</li>
<li>虚拟机启动时会先加载设置的程序主类。</li>
<li>使用 dynamic 动态语言支持等相关特性时。</li>
</ol>
<h2 id="从-Java-到-cpp-源码分析"><a href="#从-Java-到-cpp-源码分析" class="headerlink" title="从 Java 到 cpp 源码分析"></a>从 Java 到 cpp 源码分析</h2><blockquote>
<p>JVM<br>默认用于加载用户程序的ClassLoader为AppClassLoader，不过无论是什么ClassLoader，它的根父类都是java.lang.ClassLoader。在上面那个例子中，loadClass（）方法最终会调用到ClassLoader.definClass1（）中，这是一个<br>Native 方法。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">native</span> Class&lt;?&gt; defineClass1(ClassLoader loader, String name, <span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len,</span><br><span class="line">                                        ProtectionDomain pd, String source); </span><br></pre></td></tr></table></figure>

<blockquote>
<p>definClass1（）对应的 JNI 方法为 Java_java_lang_ClassLoader_defineClass1（）。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">JNIEXPORT jclass JNICALL</span></span><br><span class="line"><span class="function"><span class="title">Java_java_lang_ClassLoader_defineClass1</span><span class="params">(JNIEnv *env,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        jclass cls,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        jobject loader,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        jstring name,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        jbyteArray data,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        jint offset,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        jint length,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        jobject pd,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        jstring source)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    result = JVM_DefineClassWithSource(env, utfName, loader, body, length, pd, utfSource);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Java_java_lang_ClassLoader_defineClass1<br>主要是调用了JVM_DefineClassWithSource（）加载类，跟着源码往下走，会发现最终调用的是 jvm.cpp 中的<br>jvm_define_class_common（）方法。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jclass <span class="title">jvm_define_class_common</span><span class="params">(JNIEnv *env, <span class="keyword">const</span> <span class="keyword">char</span> *name,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      jobject loader, <span class="keyword">const</span> jbyte *buf,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      jsize len, jobject pd, <span class="keyword">const</span> <span class="keyword">char</span> *source,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      TRAPS)</span> </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">  <span class="function">ClassFileStream <span class="title">st</span><span class="params">((u1*)buf, len, source, ClassFileStream::verify)</span></span>;</span><br><span class="line">  <span class="function">Handle <span class="title">class_loader</span> <span class="params">(THREAD, JNIHandles::resolve(loader))</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (UsePerfData) &#123;</span><br><span class="line">    <span class="built_in">is_lock_held_by_thread</span>(class_loader,</span><br><span class="line">                           ClassLoader::<span class="built_in">sync_JVMDefineClassLockFreeCounter</span>(),</span><br><span class="line">                           THREAD);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">Handle <span class="title">protection_domain</span> <span class="params">(THREAD, JNIHandles::resolve(pd))</span></span>;</span><br><span class="line">  Klass* k = SystemDictionary::<span class="built_in">resolve_from_stream</span>(class_name,</span><br><span class="line">                                                   class_loader,</span><br><span class="line">                                                   protection_domain,</span><br><span class="line">                                                   &amp;st,</span><br><span class="line">                                                   CHECK_NULL);</span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (jclass) JNIHandles::<span class="built_in">make_local</span>(env, k-&gt;<span class="built_in">java_mirror</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其上的步骤细分下来共三步：</p>
<ol>
<li>将 class 文件转化为字节流。</li>
<li>求当前线程是否持有锁，并且显式地进入 protection_domain。</li>
<li>将字节流转化成 Klass 的实例（class 文件在 JVM 中的内存代表），注册进 SystemDictionary 里。</li>
</ol>
<p>Klass 是 JVM 用来定义 Java Class 的数据结构。不过 Klass 只是一个基类，Java Class 真正的数据结构定义在 InstanceKlass 中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InstanceKlass</span>:</span> <span class="keyword">public</span> Klass &#123;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line"> </span><br><span class="line">  Annotations*    _annotations;</span><br><span class="line">  ......</span><br><span class="line">  ConstantPool* _constants;</span><br><span class="line">  ......</span><br><span class="line">  Array&lt;jushort&gt;* _inner_classes;</span><br><span class="line">  ......</span><br><span class="line">  Array&lt;Method*&gt;* _methods;</span><br><span class="line">  Array&lt;Method*&gt;* _default_methods;</span><br><span class="line">  ......</span><br><span class="line">  Array&lt;u2&gt;*      _fields;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个类型定义了 Java 类的所有属性，包括注解、常量、内部类、方法、内部方法、字段等信息。<strong>这些信息本来被记录在 Class 文件中，</strong>，InstanceKlass 是 它的内存形式。</p>
<p>可以和 Class 文件的结构图对比看。</p>
<p><img src="https://s2.ax1x.com/2019/09/05/nmR3gP.jpg" alt="此处输入图片的描述"></p>
<p>可以看到，在 class 文件里的 constant pool，只能映射到 InstanceKlass 里的 constant 上。</p>
<h2 id="resolve-from-stream-详解"><a href="#resolve-from-stream-详解" class="headerlink" title="resolve_from_stream 详解"></a>resolve_from_stream 详解</h2><h3 id="判断是否允许并行加载类，并根据判断结果进行加锁"><a href="#判断是否允许并行加载类，并根据判断结果进行加锁" class="headerlink" title="判断是否允许并行加载类，并根据判断结果进行加锁"></a>判断是否允许并行加载类，并根据判断结果进行加锁</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> DoObjectLock = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">is_parallelCapable</span>(class_loader)) &#123;</span><br><span class="line">  DoObjectLock = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">ClassLoaderData* loader_data = <span class="built_in">register_loader</span>(class_loader, CHECK_NULL);</span><br><span class="line">Handle lockObject = <span class="built_in">compute_loader_lock_object</span>(class_loader, THREAD);</span><br><span class="line"><span class="built_in">check_loader_lock_contention</span>(lockObject, THREAD);</span><br><span class="line"><span class="function">ObjectLocker <span class="title">ol</span><span class="params">(lockObject, THREAD, DoObjectLock)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>如果允许并行加载，则不会对ClassLoader进行加锁，只对SystemDictionary加锁。否则，便会利用 ObjectLocker 对ClassLoader 加锁，保证同一个ClassLoader在同一时刻只能加载一个类。</strong>ObjectLocker 会在其构造函数中获取锁，并在析构函数中释放锁。</p>
<p>允许并行加载的好处便是精细化了锁粒度，这样可以在同一时刻加载多个Class文件。</p>
<h3 id="解析文件流，生成-InstanceKlass"><a href="#解析文件流，生成-InstanceKlass" class="headerlink" title="解析文件流，生成 InstanceKlass"></a>解析文件流，生成 InstanceKlass</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">InstanceKlass* k = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">k = KlassFactory::<span class="built_in">create_from_stream</span>(st,</span><br><span class="line">                                         class_name,</span><br><span class="line">                                         loader_data,</span><br><span class="line">                                         protection_domain,</span><br><span class="line">                                         <span class="literal">NULL</span>, <span class="comment">// host_klass</span></span><br><span class="line">                                         <span class="literal">NULL</span>, <span class="comment">// cp_patches</span></span><br><span class="line">                                         CHECK_NULL);</span><br></pre></td></tr></table></figure>

<h3 id="利用SystemDictionary注册生成的-Klass"><a href="#利用SystemDictionary注册生成的-Klass" class="headerlink" title="利用SystemDictionary注册生成的 Klass"></a>利用SystemDictionary注册生成的 Klass</h3><blockquote>
<p>SystemDictionary 是用来帮助保存 ClassLoader 加载过的类信息的。准确点说，SystemDiction<br>并不是一个容器，真正用来保存类信息的容器是 Dictionary，每个 ClassLoaderData 都保存着一个私有的<br>Dictionary，而 SystemDictionary 只是一个拥有很多静态方法的工具类而已。</p>
</blockquote>
<p>注册的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">is_parallelCapable</span>(class_loader)) &#123;</span><br><span class="line">  InstanceKlass* defined_k = <span class="built_in">find_or_define_instance_class</span>(h_name, class_loader, k, THREAD);</span><br><span class="line">  <span class="keyword">if</span> (!HAS_PENDING_EXCEPTION &amp;&amp; defined_k != k) &#123;</span><br><span class="line">    <span class="comment">// If a parallel capable class loader already defined this class, register &#x27;k&#x27; for cleanup.</span></span><br><span class="line">    <span class="built_in">assert</span>(defined_k != <span class="literal">NULL</span>, <span class="string">&quot;Should have a klass if there&#x27;s no exception&quot;</span>);</span><br><span class="line">    loader_data-&gt;<span class="built_in">add_to_deallocate_list</span>(k);</span><br><span class="line">    k = defined_k;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">define_instance_class</span>(k, THREAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果允许并行加载，那么前面就不会对 ClassLoader 加锁，所以在同一时刻，可能对同一 Class 文件加载多次-但同一个 Class 必须在同一 ClassLoader 里保持唯一，所以先利用 SystemDictionary 查询 ClassLoader 是否已经加载过相同 Class。 </p>
<ul>
<li>如果已经加载过，那么就将刚刚加载的 InstanceKlass 加入待回收列表，并将 InstanceKlass * k 重新指向利用 SystemDictionary 查询到的 InstanceKlass。（<strong>允许重复加载，弃新存旧</strong>）</li>
<li>如果没有查询到，那么就将刚刚加载的 InstanceKlass 注册到 ClassLoader的 Dictionary 中 中。</li>
</ul>
<p>如果禁止了并行加载，那么直接利用SystemDictionary将 InstanceKlass 注册到 ClassLoader的 Dictionary 中即可。<strong>此时由锁保证数据唯一性。</strong></p>
<h2 id="ClassFileParser"><a href="#ClassFileParser" class="headerlink" title="ClassFileParser"></a>ClassFileParser</h2><p>resolve_from_stream（）最重要的是第二步，从文件流生成InstanceKlass，这依赖于调用 KlassFactory::create_from_stream（）方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ClassFileParser <span class="title">parser</span><span class="params">(stream,</span></span></span><br><span class="line"><span class="params"><span class="function">                       name,</span></span></span><br><span class="line"><span class="params"><span class="function">                       loader_data,</span></span></span><br><span class="line"><span class="params"><span class="function">                       protection_domain,</span></span></span><br><span class="line"><span class="params"><span class="function">                       host_klass,</span></span></span><br><span class="line"><span class="params"><span class="function">                       cp_patches,</span></span></span><br><span class="line"><span class="params"><span class="function">                       ClassFileParser::BROADCAST, <span class="comment">// publicity level</span></span></span></span><br><span class="line"><span class="params"><span class="function">                       CHECK_NULL)</span></span>;</span><br><span class="line"></span><br><span class="line">InstanceKlass* result = parser.<span class="built_in">create_instance_klass</span>(old_stream != stream, CHECK_NULL);</span><br></pre></td></tr></table></figure>

<p>这又依赖于 ClassFileParser。</p>
<p><strong>ClassFileParser 加载Class文件的入口便是 create_instance_klass（）。顾名思义，用来创建InstanceKlass的。</strong></p>
<p>create_instance_klass（）主要就干了两件事：</p>
<ol>
<li>为 InstanceKlass 分配内存：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InstanceKlass* <span class="keyword">const</span> ik =</span><br><span class="line">    InstanceKlass::<span class="built_in">allocate_instance_klass</span>(*<span class="keyword">this</span>, CHECK_NULL);</span><br></pre></td></tr></table></figure>

<p>内存分配代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> size = InstanceKlass::<span class="built_in">size</span>(parser.<span class="built_in">vtable_size</span>(),</span><br><span class="line">                                       parser.<span class="built_in">itable_size</span>(),</span><br><span class="line">                                       <span class="built_in">nonstatic_oop_map_size</span>(parser.<span class="built_in">total_oop_map_count</span>()),</span><br><span class="line">                                       parser.<span class="built_in">is_interface</span>(),</span><br><span class="line">                                       parser.<span class="built_in">is_anonymous</span>(),</span><br><span class="line">                                       <span class="built_in">should_store_fingerprint</span>(parser.<span class="built_in">is_anonymous</span>()));</span><br><span class="line">ClassLoaderData* loader_data = parser.<span class="built_in">loader_data</span>();</span><br><span class="line">InstanceKlass* ik;</span><br><span class="line">ik = <span class="built_in"><span class="keyword">new</span></span> (loader_data, size, THREAD) <span class="built_in">InstanceKlass</span>(parser, InstanceKlass::_misc_kind_other);</span><br></pre></td></tr></table></figure>

<p>这里首先计算了InstanceKlass在内存中的大小，要知道，这个大小在Class 文件编译后就被确定了。</p>
<p>然后便 new 了一个新的 InstanceKlass 对象。这里并不是简单的在堆上分配内存，要注意的是Klass 对 new 操作符进行了重载：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* Klass::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size, ClassLoaderData* loader_data, <span class="keyword">size_t</span> word_size, TRAPS)</span> <span class="title">throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Metaspace::<span class="built_in">allocate</span>(loader_data, word_size, MetaspaceObj::ClassType, THREAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分配 InstanceKlass 的时候调用了 Metaspace::allocate（）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MetaWord* <span class="title">Metaspace::allocate</span><span class="params">(ClassLoaderData* loader_data, <span class="keyword">size_t</span> word_size,</span></span></span><br><span class="line"><span class="params"><span class="function">                              MetaspaceObj::Type type, TRAPS)</span> </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">  MetadataType mdtype = (type == MetaspaceObj::ClassType) ? ClassType : NonClassType;</span><br><span class="line">  ......</span><br><span class="line">  MetaWord* result = loader_data-&gt;<span class="built_in">metaspace_non_null</span>()-&gt;<span class="built_in">allocate</span>(word_size, mdtype);</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>*<em>由此可见，InstanceKlass 是分配在 ClassLoader的 Metaspace（元空间） 的方法区中。从 JDK8 开始，HotSpot 就没有了永久代，类都分配在 Metaspace 中。Metaspace 和永久代不一样，采用的是 Native Memory，永久代由于受限于 MaxPermSize，所以当内存不够时会内存溢出。</em></p>
<ol start="2">
<li>分析Class文件，填充 InstanceKlass 内存区域：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fill_instance_klass</span>(ik, changed_by_loadhook, CHECK_NULL);</span><br></pre></td></tr></table></figure>

<p>ClassFileParser 在构造的时候就会开始分析Class文件，所以fill_instance_klass（）中只需要填充即可。填充结束后，还会调用 java_lang_Class::create_mirror（）创建 InstanceKlass 在Java 层的 Class 对象。<strong>双层对象。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClassFileParser::fill_instance_klass</span><span class="params">(InstanceKlass* ik, <span class="keyword">bool</span> changed_by_loadhook, TRAPS)</span> </span>&#123;</span><br><span class="line">  .....</span><br><span class="line">  ik-&gt;<span class="built_in">set_class_loader_data</span>(_loader_data);</span><br><span class="line">  ik-&gt;<span class="built_in">set_nonstatic_field_size</span>(_field_info-&gt;nonstatic_field_size);</span><br><span class="line">  ik-&gt;<span class="built_in">set_has_nonstatic_fields</span>(_field_info-&gt;has_nonstatic_fields);</span><br><span class="line">  ik-&gt;<span class="built_in">set_static_oop_field_count</span>(_fac-&gt;count[STATIC_OOP]);</span><br><span class="line">  ik-&gt;<span class="built_in">set_name</span>(_class_name);</span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">  java_lang_Class::<span class="built_in">create_mirror</span>(ik,</span><br><span class="line">                                 <span class="built_in">Handle</span>(THREAD, _loader_data-&gt;<span class="built_in">class_loader</span>()),</span><br><span class="line">                                 module_handle,</span><br><span class="line">                                 _protection_domain,</span><br><span class="line">                                 CHECK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，系统保证了“不同ClassLoader加载的类是互相隔离的”。其基本流程为：每一个 classloader 有一个私有的 Dictionary，在加载类的过程中，Dictionary 有锁机制保证 InstanceKlass 的唯一性。如果存在不同的 ClassLoader 加载同一个 Class 文件，就会在内存里保存多份 InstanceKlass。而不同的 InstanceKlass 之间是不能相互强制转换的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        URL url[] = <span class="keyword">new</span> URL[<span class="number">1</span>];</span><br><span class="line">        url[<span class="number">0</span>] = Thread.currentThread().getContextClassLoader().getResource(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        CustomClassloader customClassloader = <span class="keyword">new</span> CustomClassloader(url);</span><br><span class="line">        Class clazz = customClassloader.loadClass(<span class="string">&quot;a.b.c&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Student student = (Student) clazz.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码运行一定会出错。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.ClassCastException:</span><br><span class="line">     a.b.c cannot be cast to a.b.c</span><br></pre></td></tr></table></figure>

<p>那是因为目标 a.b.c 类型存在于当前类加载器中，而 clazz 这个Class实例则存在于 customClassloader 中，它的 clazz.newInstance() 的类型本身不能跨类加载器相互转化。</p>
<h2 id="一种-hack-技巧"><a href="#一种-hack-技巧" class="headerlink" title="一种 hack 技巧"></a>一种 hack 技巧</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        URL url[] = <span class="keyword">new</span> URL[<span class="number">1</span>];</span><br><span class="line">        url[<span class="number">0</span>] = Thread.currentThread().getContextClassLoader().getResource(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> CustomClassloader customClassloader = <span class="keyword">new</span> CustomClassloader(url);</span><br><span class="line">        Thread.currentThread().setContextClassLoader(customClassloader);</span><br><span class="line">        Class clazz = customClassloader.loadClass(<span class="string">&quot;a.b.c&quot;</span>);</span><br><span class="line">        Object object = clazz.newInstance();</span><br><span class="line">        Method method = clazz.getDeclaredMethod(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        method.invoke(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意，这里面并不直接调用 c c = clazz.newInstance()，而是调用<br> Object object = clazz.newInstance()，并且必须使用反射才能调用 test。因为如果显式地使用了 C 这个类型，进行常量解析时，还是会跑到系统默认的 ClassLoader 加载的 C。</p>

                    </article>
                    


    <blockquote id="date-expire-notification" class="post-expired-notify">This article was last updated on <span id="date-expire-num"></span> days ago, and the information described in the article may have changed.</blockquote>
    <script>
    (function() {
        var dateUpdate = Date.parse("2019-09-09");
        var nowDate = new Date();
        var a = nowDate.getTime();
        var b = a - dateUpdate;
        var daysUpdateExpire = Math.floor(b/(24*3600*1000));
        if (daysUpdateExpire >= 120) {
            document.getElementById('date-expire-num').innerHTML = daysUpdateExpire;
        } else {
            document.getElementById('date-expire-notification').style.display = 'none';
        }
    })();
    </script>


<p class="post-footer-info mb-0 pt-0">Published at&nbsp;<time datetime="2019-09-05T06:41:05.000Z" itemprop="datePublished">2019-09-05</time>

    , Updated at&nbsp;<time datetime="2019-09-09T13:35:42.000Z" itemprop="dateModified">2019-09-09</time>

</p>
<p class="post-footer-info mb-0 pt-2">



<span class="post-tags-list mt-2">

<a class="post-tags-list-item" href="/tags/JVM/" rel="tag">#&nbsp;JVM</a>

<a class="post-tags-list-item" href="/tags/Java/" rel="tag">#&nbsp;Java</a>

</span>


</p>

                </div>
                <div class="post-nav px-2 bg-gray">
<ul class="pagination">
    <!-- Prev Nav -->
    
        <li class="page-item page-prev">
            <a href="/2019/09/05/%E6%8A%80%E6%9C%AF%E5%8F%91%E5%B1%95%E5%88%86%E6%9C%9F/" rel="prev">
                <div class="page-item-title"><i class="icon icon-back" aria-hidden="true"></i></div>
                <div class="page-item-subtitle">技术发展分期</div>
            </a>
        </li>
    

    <!-- Next Nav -->
    
        <li class="page-item page-next">
            <a href="/2019/09/02/%E3%80%8A%E6%B5%81%E6%B0%B4%E5%9E%8B-FO%E3%80%8B%E7%AC%94%E8%AE%B0/" rel="next">
                <div class="page-item-title"><i class="icon icon-forward" aria-hidden="true"></i></div>
                <div class="page-item-subtitle">《流水型 FO》笔记</div>
            </a>
        </li>
    
</ul>
</div>

                
                    <!-- # Comment # -->
                    
                
            </div>
        </div>
    </div>
</div>

            <!-- ### Footer ### -->
            <footer class="text-center">
    <!-- footer copyright -->
    
        <p class="footer-copyright mb-0">Copyright&nbsp;©&nbsp;<span id="copyright-year"></span>
            <a class="footer-copyright-a" href="http://magicliang.github.io">守株阁</a>
        </p>

    <!-- footer custom text -->
    <p class="footer-text mb-0">
    
    </p>
    <!-- footer develop info -->
    <p class="footer-develop mb-0">
        
    <!-- Busuanzi User Views -->
    <span id="busuanzi_container_site_uv" hidden>
        <span></span>
        <span id="busuanzi_value_site_uv"></span>
        <span>Viewers</span>
        
            <span>|</span>
        
    </span>




        
        Powered by&nbsp;<!--
         --><a href="https://hexo.io" target="_blank" class="footer-develop-a" rel="external nofollow noopener noreferrer">Hexo</a><span class="footer-develop-divider"></span>Theme&nbsp;-&nbsp;<!--
         --><a href="https://github.com/SukkaW/hexo-theme-suka" target="_blank" class="footer-develop-a" rel="external noopener">Suka</a>
    </p>
</footer>


        <!-- ### Import File ### -->
        <!-- ### Footer JS Import ### -->

<script>

    
window.lazyLoadOptions = {
    elements_selector: ".lazyload",
    threshold: 50
};
document.getElementById('copyright-year').textContent = new Date().getFullYear();
console.log('\n %c Suka Theme (hexo-theme-suka) | © SukkaW | Verision 1.3.3 %c https://github.com/SukkaW/hexo-theme-suka \n', 'color: #fff; background: #444; padding:5px 0;', 'background: #bbb; padding:5px 0;');

</script>

<script src="/lib/vanilla-lazyload/lazyload.min.js" async></script>
    <script src="https://cdn.jsdelivr.net/npm/busuanzi@2.3.0/bsz.pure.mini.js" async></script>


<!-- Offset -->




<!-- Comment -->


<!-- ### Custom Footer ### -->

    </body>

</html>