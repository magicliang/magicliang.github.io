<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Redis 笔记之十-哨兵 Sentinel | 守株阁</title><meta name="author" content="magicliang"><meta name="copyright" content="magicliang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Redis 有若干套高可用实现方案。2.8 开始提供哨兵功能（不要使用更低版本的哨兵，可能有 bug）。 基本概念  主从复制模式的问题 Redis 天然就带有主从复制的功能，但主从复制有若干缺点：  需要手工干预，缺乏自动 FO 机制-分布式高可用问题。 单机的写能力有限-分布式容量问题。 单机的存储能力有限-分布式容量问题。  一个经典的高可用场景 当一个主从集群的 主节点 失效的时候，经典的">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis 笔记之十-哨兵 Sentinel">
<meta property="og:url" content="https://magicliang.github.io/2019/10/30/Redis-%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8D%81-%E5%93%A8%E5%85%B5-Sentinel/index.html">
<meta property="og:site_name" content="守株阁">
<meta property="og:description" content="Redis 有若干套高可用实现方案。2.8 开始提供哨兵功能（不要使用更低版本的哨兵，可能有 bug）。 基本概念  主从复制模式的问题 Redis 天然就带有主从复制的功能，但主从复制有若干缺点：  需要手工干预，缺乏自动 FO 机制-分布式高可用问题。 单机的写能力有限-分布式容量问题。 单机的存储能力有限-分布式容量问题。  一个经典的高可用场景 当一个主从集群的 主节点 失效的时候，经典的">
<meta property="og:locale">
<meta property="og:image" content="https://magicliang.github.io/img/wall-paper-18.jpg">
<meta property="article:published_time" content="2019-10-30T14:20:55.000Z">
<meta property="article:modified_time" content="2026-01-24T07:32:06.748Z">
<meta property="article:author" content="magicliang">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://magicliang.github.io/img/wall-paper-18.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Redis 笔记之十-哨兵 Sentinel",
  "url": "https://magicliang.github.io/2019/10/30/Redis-%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8D%81-%E5%93%A8%E5%85%B5-Sentinel/",
  "image": "https://magicliang.github.io/img/wall-paper-18.jpg",
  "datePublished": "2019-10-30T14:20:55.000Z",
  "dateModified": "2026-01-24T07:32:06.748Z",
  "author": [
    {
      "@type": "Person",
      "name": "magicliang",
      "url": "https://magicliang.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://magicliang.github.io/2019/10/30/Redis-%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8D%81-%E5%93%A8%E5%85%B5-Sentinel/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: magicliang","link":"Link: ","source":"Source: 守株阁","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Redis 笔记之十-哨兵 Sentinel',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"><link rel="alternate" href="/atom.xml" title="守株阁" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      if ($loadingBox.classList.contains('loaded')) return
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()

  if (document.readyState === 'complete') {
    preloader.endLoading()
  } else {
    window.addEventListener('load', preloader.endLoading)
    document.addEventListener('DOMContentLoaded', preloader.endLoading)
    // Add timeout protection: force end after 7 seconds
    setTimeout(preloader.endLoading, 7000)
  }

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/wall-paper-18.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">守株阁</span></a><a class="nav-page-title" href="/"><span class="site-name">Redis 笔记之十-哨兵 Sentinel</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">Redis 笔记之十-哨兵 Sentinel</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2019-10-30T14:20:55.000Z" title="Created 2019-10-30 22:20:55">2019-10-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2026-01-24T07:32:06.748Z" title="Updated 2026-01-24 15:32:06">2026-01-24</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">2.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>9mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>Redis 有若干套高可用实现方案。2.8 开始提供哨兵功能（不要使用更低版本的哨兵，可能有 bug）。</p>
<h1>基本概念</h1>
<p><img src="https://s2.ax1x.com/2019/10/19/KmgbkD.png" alt="名词"></p>
<h2 id="主从复制模式的问题">主从复制模式的问题</h2>
<p>Redis 天然就带有主从复制的功能，但主从复制有若干缺点：</p>
<ul>
<li>需要手工干预，缺乏自动 FO 机制-分布式高可用问题。</li>
<li>单机的写能力有限-分布式容量问题。</li>
<li>单机的存储能力有限-分布式容量问题。</li>
</ul>
<h2 id="一个经典的高可用场景">一个经典的高可用场景</h2>
<p>当一个主从集群的 主节点 失效的时候，经典的恢复步骤如下：</p>
<ol>
<li>主节点失效。</li>
<li>选出新的从节点，<code>slaveof no one</code>。</li>
<li>先更新应用方的连接。</li>
<li>再让其他从节点换主。</li>
<li>再把恢复好的主节点作为新的从节点复制新的主节点。</li>
</ol>
<p>3 和 4 的步骤可以互换。这种需要手工介入的运行机制不能被当作高可用的。而 sentinel 的作用是把这些经典步骤从<strong>手工实现为自动</strong>。</p>
<h2 id="sentinel-的高可用性">Sentinel 的高可用性</h2>
<p>Sentinel 方案是在原生的 Master-Slave 集群之外加上一个 Sentinel 集群。</p>
<p>每个 Sentinel 节点会监控其他 Sentinel 节点和所有 Redis 节点。任何一个不可达的节点，它都会将其做下线标识。</p>
<p>如果标识的是主节点，它还会：</p>
<ol>
<li>与其他 Sentinel 节点进行“协商”（negotiate），当大多数 Sentinel节点认为主节点都认为主节点不可达时。。</li>
<li>会先选举出一个 leader Sentinel 节点来完成自动的 FO 工作。。</li>
<li>把集群变化通知 Redis 应用方。</li>
</ol>
<p><img src="https://s2.ax1x.com/2019/10/19/KmW2tS.jpg" alt="哨兵集群在主动监控主从集群"></p>
<ol>
<li>monitor</li>
<li>negotiate、vote、self-election</li>
<li>slaveof no one、slave of new master</li>
<li>notify client</li>
</ol>
<h1>sentinel 的部署和启动</h1>
<h2 id="单个-sentinel-节点的配置文件">单个 sentinel 节点的配置文件</h2>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 常见参数有 4 个。这四个参数可以配置多套，每套 my_redis_master 可以监控不同的主从</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># my_redis_master 是主节点的别名，redis1 是主节点的域名，当前 sentinel 起始就要监控一个 redis 节点，意味着 sentinel 的拓扑结构受 redis 集群的拓扑结构影响。3 意味着 quorum 是 3 ，3个节点认为 master 不可达才形成决议。</span><br><span class="hljs-comment"># Redis 集群应该和其他集群一样，尽量设置为大于等于 3 的奇数，兼顾高可用和选举领导的需要</span><br><span class="hljs-comment"># 只有集群里的节点达到 max(quorum, num(sentinel)/2 + 1) ，选举才成立。在大多数情况下 quorum = num(sentinel)/2 + 1</span><br><span class="hljs-attr">sentinel</span> <span class="hljs-string">monitor my_redis_master redis1 6379 3</span><br><span class="hljs-comment"># sentinel 会定期发送 ping 到 master（其实也包括所有其他节点），3000 毫秒不回应就意味着不可达</span><br><span class="hljs-attr">sentinel</span> <span class="hljs-string">down-after-milliseconds my_redis_master 3000</span><br><span class="hljs-comment"># redis 同时对从节点进行故障转移的复制的并发度。并发度高会消耗新 master 的系统带宽-网络和磁盘。</span><br><span class="hljs-attr">sentinel</span> <span class="hljs-string">parallel-syncs my_redis_master 1</span><br><span class="hljs-comment"># 集群故障转移四个阶段的任何一个步骤的失败时延，如果超过这个时间则会重新发起新故障转移</span><br><span class="hljs-attr">sentinel</span> <span class="hljs-string">failover-timeout my_redis_master 10000</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 辅助参数</span><br><span class="hljs-attr">port</span> <span class="hljs-string">26379</span><br><span class="hljs-comment"># 写了这个文件就会导致 stdout 不再输出</span><br><span class="hljs-attr">logfile</span> <span class="hljs-string">&quot;sentinel.log&quot;</span><br><span class="hljs-comment"># 不要乱用镜像中不存在的路径</span><br><span class="hljs-comment">#dir /opt/soft/redis/data</span><br></code></pre></td></tr></table></figure>
<p>实际上每个 sentinel 节点的配置文件都可以写成这样，但每个文件必须单独存在，<strong>因为 sentinel 文件会在启动时重写各自的配置文件</strong>，写入 config-epoch/leader-epoch。</p>
<p>通过域名/容器名，来标定唯一 ip + port 标识的 redis 进程，是容易被忽略的管理集群的方法。这里的配置只配了 master name，通过与 master 协商，可以很快地理解整个 M/S 的拓扑结构。</p>
<p>quorum 是最小结合，而不是陪审团总大小的意思。quorum 达到一半加 1 即客观。要选出 leader sentinel 需要 max(quorum, num(sentinels)/2 + 1)个节点举行选举。</p>
<p>这个文件里有不少的配置都是调大变严格， 调小变宽松，严格的成本比较高。</p>
<p>此外，还有如下有意思的命令：</p>
<ol>
<li>sentinel notification-script <master-name> <script-path>：这个命令要求能用 msg=$* 来解析消息格式，如 +sdown master mymaster 127.0.0.1 6379</li>
<li>sentinel client-reconfig-script <master-name> <script-path>：这个脚本可以接收故障转移结果</li>
</ol>
<p>这些命令对脚本化运维是很有帮助的。sentinel 本身是角色的，我们可以看到 leader observer sentinel。</p>
<h2 id="启动命令">启动命令</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 这两种启动方法本质上是一样的</span><br>redis-server /etc/redis-conf/sentinel.conf --sentinel<br>redis-sentinel /etc/redis-conf/sentinel.conf<br></code></pre></td></tr></table></figure>
<p>sentinel 本质上只是一种特殊的 Redis 节点。因此可以使用如下的命令查看哨兵的已知信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">redis-cli -p 26379 info sentinel<br></code></pre></td></tr></table></figure>
<p>sentinel （使用 info 子命令）可以清楚地知道当前监控了多少个集群，集群里有多少个主从节点，一共有几个哨兵节点。</p>
<p><img src="https://s2.ax1x.com/2019/10/27/KysZ79.png" alt="info sentinel 试图向我们描述的东西"></p>
<h2 id="监控多个集群">监控多个集群</h2>
<p>一套 Sentinel 可以监控多个 Redis 集群，只要准备多套<code>sentinel monitor my_redis_master redis1 6379 3</code>里的 master name my_redis_master 即可。</p>
<h2 id="配置调整">配置调整</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sentinel <span class="hljs-built_in">set</span> xxx xxx<br></code></pre></td></tr></table></figure>
<p>需要注意：</p>
<ol>
<li>sentinel set 只对当前节点有效。</li>
<li>sentinel set 命令执行完成以后会立即刷新配置文件，这点和普通节点需要使用<code>config rewrite</code>。</li>
<li>所有节点的配置应该一致。注意 1。</li>
<li>sentinel 对外不支持 config 命令</li>
</ol>
<h2 id="部署技巧">部署技巧</h2>
<ol>
<li>sentinel 节点应该在物理机层面做隔离，这样才客观，能实现真正的高可用。</li>
<li>sentinel 集群应该有超过 3 个的奇数节点。</li>
<li>奇数节点对选举的效果是最优的。</li>
<li>可以一套 sentinel 监控多套集群，也可以多套 sentinel 监控多套集群。取舍的时候需要考虑的是：是否 sentinel 节点自身的失败需要被隔离。最佳的方案是：一个业务一套 sentinel。但实践中似乎有些大厂采用多套业务一套 sentinel，在成本和高可用之间，倾向于成本。</li>
</ol>
<h2 id="api">API</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在 cli 内</span><br>sentinel masters<br>sentinel master master-name<br>sentinel slaves slave-name<br><br><span class="hljs-comment"># 强制失效转移</span><br>sentinel failover master-name<br><br><span class="hljs-comment"># 校验 quorum 是否稳定</span><br>sentinel ckquorum master-name<br><br><span class="hljs-comment"># 配置刷盘</span><br>sentinel flushconfig<br><br><span class="hljs-comment"># 取消 sentinel 对集群的监控</span><br>sentinel remove master-name<br><br><span class="hljs-comment"># 增加 sentinel 对集群的监控</span><br>sentinel monitor &lt;master-name&gt; &lt;host&gt; &lt;port&gt; &lt;quorum&gt;<br></code></pre></td></tr></table></figure>
<h2 id="如何实现一个好的客户端">如何实现一个好的客户端</h2>
<p>服务端拥有管理元数据的功能，也有通知的功能，也有自动介入的功能。而 client 要同 sentinel 集群保持密切联系，才能保持对 Redis  master 的联系。但 sentinel 方案本身并不像 Zookeeper，没有主动广播的机会。</p>
<p>jedis-client 本身是使用 common-pool + 遍历 sentinel 集群各个节点的方式来维持一个 resource 池的。而遍历 sentinel 集群是通过发布-订阅 sentinel 的特有频道来实现的。</p>
<h1>实现原理</h1>
<p><img src="Sentinel%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB%E7%9A%84%E5%8E%9F%E7%90%86.png" alt="Sentinel故障转移的原理.png"><br>
<a href="Sentinel%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB%E7%9A%84%E5%8E%9F%E7%90%86.xmind">Sentinel故障转移的原理.xmind</a></p>
<h2 id="三个定时任务">三个定时任务</h2>
<ul>
<li>每隔 10s，sentinel 往所有 M/S 发 info 获取最新的拓扑结构</li>
<li>从主节点可以实时获知从节点的信息</li>
</ul>
<p><img src="info%E4%BB%BB%E5%8A%A1.png" alt="info任务"></p>
<ul>
<li>每隔 2s，sentinel 节点会向 Redis 数据节点的 <em>sentinel</em>:hello 频道上发送改 Sentinel 节点对主节点的判断，以及当前 Sentinel 节点的信息。同时每隔 Sentinel 节点也会订阅该频道，来了解其他 Sentinel 节点以及它们对主节点的判断。</li>
<li>sentinel 可以通过这个频道获取 sentinel 之间的信息</li>
<li>交换主节点的状态，可以作为后续<strong>客观下线</strong>和领导者选举操作的依据：</li>
</ul>
<p><img src="%E5%8F%91%E5%B8%83%E6%84%8F%E8%A7%81%E4%BB%BB%E5%8A%A1.png" alt="发布意见任务.png"></p>
<ul>
<li>每隔 1s，sentinel 会向M/S和其他 Sentinel 发送一条 ping 命令做一次心跳检测，来确认节点是否可达。</li>
</ul>
<p><img src="ping%E4%BB%BB%E5%8A%A1.png" alt="ping任务"></p>
<h2 id="主观下线和客观下线">主观下线和客观下线</h2>
<h3 id="主观下线-odown">主观下线（odown）</h3>
<p>任意sentinel ping master 超时（sentinel down-after-milliseconds my_redis_master 3000），就可以单节点认为该节点已失败。</p>
<p>任何一个节点进入主观下线状态时，都会使用<code>new_epoch</code>让当前纪元加一。</p>
<h3 id="客观下线-sdown">客观下线（sdown）</h3>
<p>sentinel 一进入主观下线状态，就会发送<code>SENTINEL is-master-down-by-addr &lt;masterip&gt; &lt;masterport&gt; &lt;sentinel.current_epoch&gt; *</code> 命令<strong>直接询问</strong>其他哨兵节点对主节点的判断，<strong>当主观下线的 哨兵数量超过<quorum>的个数（不一定要超过半数）</strong>，Sentinel 节点认为主节点确实有问题，这时候 Sentinel 就可以客观下线的决定。第一个进入主观下线状态的节点，往往成为进入客观下线的节点-这点特别像 Raft。</p>
<p><img src="%E4%B8%BB%E8%A7%82%E4%B8%8B%E7%BA%BF%E5%92%8C%E5%AE%A2%E8%A7%82%E4%B8%8B%E7%BA%BF.jpg" alt="主观下线和客观下线"></p>
<p>runId等于*时，sentinel 交换的是主节点下线的判定；runId 等于哨兵的runId时，哨兵请求的是其他节点同意它成为领导者。</p>
<h3 id="客观下线必须举行-sentinel-节点选举">客观下线必须举行 Sentinel 节点选举</h3>
<p><strong>主观下线和客观下线本质上只是对 Redis 主节点的一个状态标记，并不会天然将自己标记为领导者，更不会自动故障转移。</strong></p>
<ol>
<li>确定进入客观状态的 Sentinel 节点会成为一个 candidate，立刻发送一个<code>SENTINEL is-master-down-by-addr &lt;masterip&gt; &lt;masterport&gt; &lt;sentinel.current_epoch&gt; 自己的 runid</code></li>
<li>每个 sentinel 节点在收到该命令的后，如果没有同意过其他 Sentinel 节点的 sentinel is-master-down-by-addr 命令，将同意该请求，否则拒绝（<strong>raft 里每个节点每轮选举只能有一票</strong>）。</li>
<li>发起选举的 Sentinel 要么成为领导者，<strong>要么进入下一轮选举（或者恢复到主观下线以前的状态？）</strong>。</li>
</ol>
<h2 id="故障转移">故障转移</h2>
<p>所有的故障转移其实只是执行命令，把手动步骤编程为自动步骤而已。</p>
<p>具体步骤为：</p>
<ul>
<li>在从节点列表中选择一个节点作为新的主节点。因为从节点本身是有状态的，所以实际上是使用<strong>综合考虑权重、优先级和一致性的类负载均衡选择算</strong>法：</li>
<li>过滤不健康节点：主观下线、断线、5s 内没有回复过 Sentinel 的 ping 命令、与主节点失联超过 down-after-miliseconds。</li>
<li>选择 slave-priority 最高的节点（如何配置？）。</li>
<li>选择偏移量最大的从节点-复制最完整。</li>
<li>选择 runid 最小的从节点。</li>
<li>对选出的节点发出 slave of no one 命令，从节点升为主节点。</li>
<li>对剩下的从节点发出命令，让它们成为主节点的从节点，复制规则和 parallel-sync 参数有关。</li>
<li>（<strong>最后</strong>）Sentinel 节点集合会将原来主节点更新为从节点，（这样线上先止血成功），然后持续对其关注，待其恢复后命令其去复制新的主节点。</li>
</ul>
<h2 id="全流程">全流程</h2>
<p><img src="redis%E5%AE%A2%E8%A7%82%E4%B8%8B%E7%BA%BF%E6%B5%81%E7%A8%8B.png" alt="redis客观下线流程"></p>
<h1>节点运维</h1>
<h2 id="节点下线">节点下线</h2>
<ul>
<li>临时下线：暂时将节点关掉，之后还会重新启动，继续提供服务。</li>
<li>永久下线：将节点关掉不再使用，需要做一些清理工作，如删除配置文件，持久化文件、日志文件。</li>
</ul>
<h3 id="主节点下线">主节点下线</h3>
<ol>
<li>
<p>将一个合适的从节点（如高性能）的 priority 设置为 0。可参考 <a target="_blank" rel="noopener" href="https://redis.io/topics/sentinel">sentinel</a> 中的 Replicas priority section。</p>
</li>
<li>
<p>在任意一个 sentinel 上，执行<code>sentinel failover master-name</code>。</p>
</li>
</ol>
<h3 id="从节点或-sentinel-节点下线">从节点或 sentinel 节点下线</h3>
<p>如果使用了读写分离，要确保读写分离机制能够自动感知拓扑结构的变化。<br>
如果只是临时下线（命令下线、kill），sentinel 会对下线节点念念不忘，也就是会不断地对这些节点进行 monitor，浪费硬盘和网络资源，这种时候可以考虑永久下线。</p>
<h2 id="节点上线">节点上线</h2>
<h3 id="从节点上线">从节点上线</h3>
<p>配置节点 slave of [masterIp] [masterPort] 让节点上线。master 收到链接后，主从就会自动相互注册发现，而 sentinel 也会自动发现新的从节点。</p>
<h3 id="sentinel-节点上线">Sentinel 节点上线</h3>
<p>sentinel 只要配了 sentinel monitor，它就会连上 master，进而被 sentinel 网络互相理解发现。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://magicliang.github.io">magicliang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://magicliang.github.io/2019/10/30/Redis-%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8D%81-%E5%93%A8%E5%85%B5-Sentinel/">https://magicliang.github.io/2019/10/30/Redis-%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8D%81-%E5%93%A8%E5%85%B5-Sentinel/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Redis/">Redis</a></div><div class="post-share"><div class="social-share" data-image="/img/wall-paper-18.jpg" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2019/11/09/Redis-%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8D%81%E4%B8%80-%E9%9B%86%E7%BE%A4-Cluster/" title="Redis 笔记之十一-集群 Cluster"><img class="cover" src="/img/wall-paper-92.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2019-11-09</div><div class="info-item-2">Redis 笔记之十一-集群 Cluster</div></div><div class="info-2"><div class="info-item-1">背景 在 Redis Cluster 方案诞生以前，在 Redis 集群遇到单机资源和流量瓶颈时，有两种常见分布式解决方案：  客户端方案：需要自己处理分区逻辑、路由、故障转移（有时候 Routing、LB 和 Failover是同一个问题，都需要通过 routing 技术来切换流量的 endpoint）。 代理方案：减轻了客户端的职责和压力，架构上的负担过重。  Redis Cluster 的出现，极大地降低了架构师的负担，解放了生产力。 数据分布 数据分布理论 |分区方式|特点|代表产品|取舍逻辑| |:–:|:–:|:–:| |哈希分区| 离散度好 数据分布业务无关 无法顺序访问| KV型 Redis Cluster Cassandra Dynamo Elastic Search|如果需要平衡地存储大量数据而只有随机访问其中的若干条，则可以使用简单的哈希分区| |顺序分区|离散度易倾斜 数据分布业务相关 可顺序访问| 表型 Bigtable HBase Hypertable|如果需要存储大量数据且需要支持区间查找，则也需要使用简单的顺序分区，如果要解决负载均衡的问题可能需要...</div></div></div></a><a class="pagination-related" href="/2022/01/13/Redis-%E7%AC%94%E8%AE%B0%E4%B9%8B%EF%BC%9A%E5%86%85%E5%AD%98%E8%B0%83%E4%BC%98/" title="Redis 笔记之：内存调优"><img class="cover" src="/img/wall-paper-70.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-13</div><div class="info-item-2">Redis 笔记之：内存调优</div></div><div class="info-2"><div class="info-item-1">Redis 的 memory info Redis 的内存使用状况可以使用info memory来获取。 需要重点关注的值是 used_memory_rss（用于存储消耗的物理内存），used_memory（用于存储消耗的内存= 物理内存 + 硬盘），以及他们的比值mem_fragmentation_ratio（used_memory_rss/used_memory）。 used_memory_rss或者used_memory很高时，意味着当前的 Redis 实例正在蚕食系统中的内存/硬盘资源。 当这个mem_fragmentation_ratio大于 1 的时候，意味着用于存储消耗的物理内存超过了 Redis 自己掌控的内存值，也就意味着当前有些未能回收的内存泄漏或者碎片。 当这个mem_fragmentation_ratio小于 1 的时候，这意味着有一部分用于存储的内存，实际上是在使用虚拟内存中的 swap 空间，此时 Redis 的性能会非常差。 Redis 的内存轮廓 memory_used = 进程自身消耗的内存 + 存储对象的内存（大头） + buffer 内存 m...</div></div></div></a><a class="pagination-related" href="/2024/11/04/Redis-%E5%BC%80%E5%8F%91%E4%B8%8E%E8%BF%90%E7%BB%B4/" title="Redis 开发与运维"><img class="cover" src="/2024/11/04/Redis-%E5%BC%80%E5%8F%91%E4%B8%8E%E8%BF%90%E7%BB%B4/cover.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-04</div><div class="info-item-2">Redis 开发与运维</div></div><div class="info-2"><div class="info-item-1">Redis 特性 Redis 高性能的原因 Redis 的读写性能达到 10w/s，主要基于以下原因：  数据主要放在内存中。 Redis 使用距离 OS “层次更近”的 C 语言实现。 Redis 使用单线程架构，没有很高的 lock contention。 IO 多路复用技术 Redis 的代码实现得优雅而兼顾性能  Redis 的数据结构 Redis 本身是 Remote Dictionary Server 的简称，其中，老的、常见的数据结构有：  字符串 哈希 列表 set（集合） zset（有序集合）  但后来追加了几种新颖的数据机构，包括：bitmap、hyperloglog，更后来更添加了 GEO 地理信息相关的工具。 基于这些数据结构，我们可以实现一些常见的功能：  键过期，可以用来实现缓存，进而实现分布式锁。 发布订阅功能，进而实现消息系统（TODO）。 Lua 脚本功能，可以实现自定义的 Redis 命令（TODO）。 实现简单的事务功能，能在一定程度上实现事务特性。 提供流水线功能，能够让客户端一次性把一批命令一次性上传到 Redis 里，能够合并 IO 并...</div></div></div></a><a class="pagination-related" href="/2025/07/28/Redis-%E7%9A%84%E7%A5%9E%E5%A5%87%E7%94%A8%E4%BE%8B/" title="Redis 经典用例全解：从数据结构到系统设计"><img class="cover" src="/img/wall-paper-67.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-28</div><div class="info-item-2">Redis 经典用例全解：从数据结构到系统设计</div></div><div class="info-2"><div class="info-item-1">Redis 不只是缓存。它是一把瑞士军刀——凭借五种基础数据结构和若干扩展模块，Redis 能解决从分布式锁到社交网络、从排行榜到消息队列的几乎所有高频系统设计问题。 本文的目标是：建立一套从业务问题到 Redis 数据结构的映射思维。对于每个用例，我们都会回答三个问题：  业务问题是什么？ 需求的本质是什么操作？ 为什么选 Redis？ 相比 MySQL、MQ 等方案，Redis 的优势和代价是什么？ 怎么设计？ 用哪种数据结构，Key 怎么命名，核心命令是什么？  mindmap   root((Redis 用例全景))     基础存储       缓存策略         Cache-Aside         穿透/击穿/雪崩       分布式会话         Session 共享         验证码/短链接       分布式 ID         INCR 自增         日期分段     并发控制       分布式锁         SET NX         Redlock         看门狗续期       计数器与限流        ...</div></div></div></a><a class="pagination-related" href="/2025/07/29/%E7%BC%93%E5%AD%98%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" title="缓存系统设计——从穿透到雪崩的完整攻略"><img class="cover" src="/img/wall-paper-5.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-29</div><div class="info-item-2">缓存系统设计——从穿透到雪崩的完整攻略</div></div><div class="info-2"><div class="info-item-1">缓存是提升系统性能的第一利器，但也是引发故障的第一杀手。缓存穿透、缓存击穿、缓存雪崩——这三大问题几乎是每个后端工程师都会遇到的挑战。本文将系统性地剖析缓存系统的设计原则、经典问题及其解决方案，从单机缓存到分布式缓存，从理论到生产实践。  Part 1: 缓存的基本原理 为什么需要缓存    存储介质 访问延迟 吞吐量 成本     CPU L1 Cache ~1 ns — 极高   CPU L3 Cache ~10 ns — 高   内存（RAM） ~100 ns ~10 GB/s 中   SSD ~100 μs ~500 MB/s 低   HDD ~10 ms ~100 MB/s 极低   网络（同机房） ~500 μs — —   网络（跨机房） ~50 ms — —    内存访问比 SSD 快 1000 倍，比 HDD 快 100,000 倍。缓存的本质就是用更快的存储介质保存热点数据的副本。 缓存的命中率 命中率 = 命中次数 / (命中次数 + 未命中次数)    命中率 效果 说明     &lt; 50% 差 缓存几乎没有意义   50-80% 一般 有一定效果...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.</span> <span class="toc-text">主从复制模式的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E7%BB%8F%E5%85%B8%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.2.</span> <span class="toc-text">一个经典的高可用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sentinel-%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7"><span class="toc-number">1.3.</span> <span class="toc-text">Sentinel 的高可用性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">sentinel 的部署和启动</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%B8%AA-sentinel-%E8%8A%82%E7%82%B9%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">2.1.</span> <span class="toc-text">单个 sentinel 节点的配置文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">2.2.</span> <span class="toc-text">启动命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%91%E6%8E%A7%E5%A4%9A%E4%B8%AA%E9%9B%86%E7%BE%A4"><span class="toc-number">2.3.</span> <span class="toc-text">监控多个集群</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E8%B0%83%E6%95%B4"><span class="toc-number">2.4.</span> <span class="toc-text">配置调整</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%83%A8%E7%BD%B2%E6%8A%80%E5%B7%A7"><span class="toc-number">2.5.</span> <span class="toc-text">部署技巧</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#api"><span class="toc-number">2.6.</span> <span class="toc-text">API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%A5%BD%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">2.7.</span> <span class="toc-text">如何实现一个好的客户端</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1"><span class="toc-number">3.1.</span> <span class="toc-text">三个定时任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E8%A7%82%E4%B8%8B%E7%BA%BF%E5%92%8C%E5%AE%A2%E8%A7%82%E4%B8%8B%E7%BA%BF"><span class="toc-number">3.2.</span> <span class="toc-text">主观下线和客观下线</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A7%82%E4%B8%8B%E7%BA%BF-odown"><span class="toc-number">3.2.1.</span> <span class="toc-text">主观下线（odown）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E8%A7%82%E4%B8%8B%E7%BA%BF-sdown"><span class="toc-number">3.2.2.</span> <span class="toc-text">客观下线（sdown）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E8%A7%82%E4%B8%8B%E7%BA%BF%E5%BF%85%E9%A1%BB%E4%B8%BE%E8%A1%8C-sentinel-%E8%8A%82%E7%82%B9%E9%80%89%E4%B8%BE"><span class="toc-number">3.2.3.</span> <span class="toc-text">客观下线必须举行 Sentinel 节点选举</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB"><span class="toc-number">3.3.</span> <span class="toc-text">故障转移</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">3.4.</span> <span class="toc-text">全流程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">节点运维</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E4%B8%8B%E7%BA%BF"><span class="toc-number">4.1.</span> <span class="toc-text">节点下线</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%8A%82%E7%82%B9%E4%B8%8B%E7%BA%BF"><span class="toc-number">4.1.1.</span> <span class="toc-text">主节点下线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E8%8A%82%E7%82%B9%E6%88%96-sentinel-%E8%8A%82%E7%82%B9%E4%B8%8B%E7%BA%BF"><span class="toc-number">4.1.2.</span> <span class="toc-text">从节点或 sentinel 节点下线</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E4%B8%8A%E7%BA%BF"><span class="toc-number">4.2.</span> <span class="toc-text">节点上线</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E8%8A%82%E7%82%B9%E4%B8%8A%E7%BA%BF"><span class="toc-number">4.2.1.</span> <span class="toc-text">从节点上线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sentinel-%E8%8A%82%E7%82%B9%E4%B8%8A%E7%BA%BF"><span class="toc-number">4.2.2.</span> <span class="toc-text">Sentinel 节点上线</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2017 - 2026 By magicliang</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional and Simplified Chinese">簡</button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><script src="/js/tw_cn.js?v=5.5.2"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="/"></script></div></body></html>