<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>git 难点知识汇总 | 守株阁</title><meta name="author" content="magicliang"><meta name="copyright" content="magicliang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Git基础.xmind  初始化命令 配置用户、remote 和 branch 123456789101112131415161718192021222324252627282930313233343536git config --global user.name &quot;magicliang&quot;                    # 请换成你自己的名字git config --g">
<meta property="og:type" content="article">
<meta property="og:title" content="git 难点知识汇总">
<meta property="og:url" content="https://magicliang.github.io/2019/12/25/git-%E9%9A%BE%E7%82%B9%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/index.html">
<meta property="og:site_name" content="守株阁">
<meta property="og:description" content="Git基础.xmind  初始化命令 配置用户、remote 和 branch 123456789101112131415161718192021222324252627282930313233343536git config --global user.name &quot;magicliang&quot;                    # 请换成你自己的名字git config --g">
<meta property="og:locale">
<meta property="og:image" content="https://magicliang.github.io/2019/12/25/git-%E9%9A%BE%E7%82%B9%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/How-To-Change-Git-Remote-Origin.jpeg">
<meta property="article:published_time" content="2019-12-25T07:52:48.000Z">
<meta property="article:modified_time" content="2025-10-22T08:01:32.097Z">
<meta property="article:author" content="magicliang">
<meta property="article:tag" content="git">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://magicliang.github.io/2019/12/25/git-%E9%9A%BE%E7%82%B9%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/How-To-Change-Git-Remote-Origin.jpeg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "git 难点知识汇总",
  "url": "https://magicliang.github.io/2019/12/25/git-%E9%9A%BE%E7%82%B9%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/",
  "image": "https://magicliang.github.io/2019/12/25/git-%E9%9A%BE%E7%82%B9%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/How-To-Change-Git-Remote-Origin.jpeg",
  "datePublished": "2019-12-25T07:52:48.000Z",
  "dateModified": "2025-10-22T08:01:32.097Z",
  "author": [
    {
      "@type": "Person",
      "name": "magicliang",
      "url": "https://magicliang.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://magicliang.github.io/2019/12/25/git-%E9%9A%BE%E7%82%B9%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: magicliang","link":"Link: ","source":"Source: 守株阁","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'git 难点知识汇总',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="守株阁" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/2019/12/25/git-%E9%9A%BE%E7%82%B9%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/How-To-Change-Git-Remote-Origin.jpeg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">守株阁</span></a><a class="nav-page-title" href="/"><span class="site-name">git 难点知识汇总</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">git 难点知识汇总</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2019-12-25T07:52:48.000Z" title="Created 2019-12-25 15:52:48">2019-12-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-10-22T08:01:32.097Z" title="Updated 2025-10-22 16:01:32">2025-10-22</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">25.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>88mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p><a href="Git%E5%9F%BA%E7%A1%80.xmind">Git基础.xmind</a><br>
<img src="Git%E5%9F%BA%E7%A1%80.png" alt="Git基础"></p>
<h1>初始化命令</h1>
<h2 id="配置用户-remote-和-branch">配置用户、remote 和 branch</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;magicliang&quot;</span>                    <span class="hljs-comment"># 请换成你自己的名字</span><br>git config --global user.email <span class="hljs-string">&quot;magicliang@qq.com&quot;</span>    <span class="hljs-comment"># 请换成你自己的邮箱</span><br>git config --global push.default simple     <span class="hljs-comment"># 我们要求 Git 版本 1.9.5 以上</span><br>git config --global core.autocrlf <span class="hljs-literal">false</span>     <span class="hljs-comment"># 让Git不要管 Windows/Unix 换行符转换的事</span><br><br>git config --global --list<br><br>ssh git@gitlab.abc<br><br>git init<br>git add .<br>git commit -m <span class="hljs-string">&quot;First commit&quot;</span><br><br><span class="hljs-comment"># 对 remote 进行 remove 和 add</span><br><br>git remote remove origin<br><span class="hljs-comment"># 设置本仓库的 origin</span><br><span class="hljs-comment"># 没有 ssh:// 这个协议 scheme</span><br>git remote add origin git@git.somecompany.com/someuser/somerepo.git<br><br><span class="hljs-comment"># Your branch is ahead of &#x27;origin/main&#x27; by 1 commit.</span><br><span class="hljs-comment"># Your branch is behind &#x27;origin/main&#x27; by 1 commit.</span><br>git push<br><br><span class="hljs-comment"># 如果遇上冲突，使用。git pull 一次只会拉取一个分支（而不是全部）的 commit，但是大仓开发会让一个分支拉取非常慢</span><br>git pull origin master --allow-unrelated-histories<br><br><span class="hljs-comment"># 查看远程仓库的可视化内容</span><br>git remote -v<br><br><span class="hljs-comment"># 在推送途中设置 origin 分支为 diy1</span><br>git push --set-upstream origin diy1<br><span class="hljs-comment"># 有一个设置方法：git branch -u origin/serverfix</span><br><br><span class="hljs-comment"># 修改已经存在的 origin</span><br>git remote set-url origin git@github.com:magicliang/opentelemetry-java-docs.git<br></code></pre></td></tr></table></figure>
<h2 id="凭空产生空的-git-repo">凭空产生空的 git repo</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;# SpringBootMVCUI&quot;</span> &gt;&gt; README.md<br>git init<br>git add README.md<br>git commit -m <span class="hljs-string">&quot;first commit&quot;</span><br>git remote add origin git@github.com:magicliang/SpringBootMVCUI.git<br>git push -u origin master<br></code></pre></td></tr></table></figure>
<h2 id="变换remote-repo">变换remote repo</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> existing_folder<br>git remote rename origin old-origin<br>git remote add origin git@gitrepo.com:user/project.git<br>git push --set-upstream origin --all<br>git push --set-upstream origin --tags<br></code></pre></td></tr></table></figure>
<h2 id="把已经存在的-repo-push-上-remote">把已经存在的 repo push 上 remote</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote add origin git@github.com:magicliang/SpringBootMVCUI.git<br>git push -u origin master<br></code></pre></td></tr></table></figure>
<h1>areas</h1>
<ul>
<li>
<p>已修改表示修改了文件，但还没保存到数据库中。</p>
</li>
<li>
<p>已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</p>
</li>
<li>
<p>已提交表示数据已经安全地保存在本地数据库中。</p>
</li>
</ul>
<p><img src="areas.png" alt="就这里我们可以看出 add 和 commit 实际上是把 fixes 放入两个区域里"></p>
<p>staging area 也叫 index。add 就是把文件 index/staging 的过程。git 里经常混用 index 这个单词。</p>
<p>git 的这些区域都存在于 .git 文件夹下。用 clone 命令得到远端仓库的文件是得到远端仓库的每一个版本，不会遗漏。所以<code>除了server hook 以外，仓库可以这样被保存和重建</code>。git 是 version-based 的 cvs，而不是 delta based 的 cvs，在实际使用过程中也相当轻量级。</p>
<p>如果加上 untracked，则 area 有四种，而且最后一种 unmodified 被放在中间：</p>
<p><img src="%E5%9B%9B%E7%A7%8D%E5%8C%BA%E5%9F%9F.png" alt="文件的状态变化周期"></p>
<p>Working Directory = Working Tree，指你当前正在工作的文件系统目录，其中包含了你正在处理的项目的文件。这些文件可以是未跟踪的、已跟踪的、已修改的或未修改的。</p>
<ul>
<li>Untracked files: 被修改，但不是 Modified 的文件（modified 状态只存在于 tracked 文件中。这是因为只有 Git 已经在跟踪的文件，才能被检测到是否发生了修改。）。
<ul>
<li>被忽略的文件 是通过 .gitignore 文件显式指定的，不会被 Git 跟踪。</li>
<li>未跟踪文件 是尚未被 Git 跟踪的文件，会出现在 git status 输出中，除非被添加到 .gitignore 文件中。</li>
</ul>
</li>
<li>Tracked files：在 index 或者在 history 里的文件，git 会一直跟踪它们的修改。</li>
</ul>
<p>git worktree 命令允许你在同一个 Git 仓库中创建多个工作树（worktrees）。每个工作树可以独立地检出不同的分支或提交，这使得你可以在同一个仓库的不同分支上并行工作，而无需频繁地切换分支。</p>
<h1>分支</h1>
<p>HEAD 指向的 commit，是当前分支的顶端，哪怕这个 commit 后面还有很多其他 commit-也就是说一个分支并不是一个链表的终点，分支后续还可能有分支，但是分支是自己这个链表的 last commit 的 alias，然后 HEAD 是这个 alias 的 alias。</p>
<p>所以新创建分支的时候 HEAD 还在当前分支上。</p>
<p><img src="head-to-master.png" alt="HEAD 指向当前所在的分支"></p>
<p>但切换分支后 HEAD 指向的是新分支了。</p>
<p><img src="head-to-testing.png" alt="指向当前所在的分支"></p>
<p>HEAD = current checkout lastest commit，不是未提交的变更，也不是倒数第几个变更，也不是当前提交链条上的最远 commit，<strong>也不必然是 branch</strong>（所以在 rebase 之类的操作过程中，HEAD 会移动，会移动到某个没有 branch alias 的 commit 上方）。在 checkout branch 的时候，等于 branch lastest commit。HEAD <strong>分支随着提交操作自动向前移动</strong>。在分支之间切换，你需要的命令只有 branch、checkout 和 commit。</p>
<h1>修改提交</h1>
<h2 id="查看历史">查看历史</h2>
<h3 id="普通的历史">普通的历史</h3>
<p>用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</p>
<h3 id="只有本地才能看到的历史">只有本地才能看到的历史</h3>
<p>要重返未来，用<code>git reflog</code> 查看命令历史，以便确定要回到未来的哪个版本。这个命令的本质，是阅读“每当你的 HEAD 所指向的位置发生了变化，Git 就会将这个信息存储到引用日志这个历史记录里”的历史。</p>
<p>所以看到就是一系列 HEAD 列表：<code>HEAD@&#123;0&#125;</code>、<code>HEAD@&#123;1&#125;</code>，内部有<code>checkout</code>/<code>rebase</code>/<code>commit</code>。</p>
<p>关于 log <a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%80%89%E6%8B%A9%E4%BF%AE%E8%AE%A2%E7%89%88%E6%9C%AC">有一个复杂的用法解释</a>，可以让我们看到我们平时使用的ui底层是怎样仅基于<code>log</code>和<code>reflog</code>命令就查看一个/多个分支的多时间区间/多点提交记录的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># commit ranges problem</span><br><br><span class="hljs-comment"># Double Dot: 在 experiment 分支中而不在 master 分支中的提交</span><br>git <span class="hljs-built_in">log</span> master..experiment<br><span class="hljs-comment"># 在 master 分支中而不在 experiment 分支中的提交</span><br>git <span class="hljs-built_in">log</span> experiment..master<br><br><span class="hljs-comment"># Triple Dot：选择出被两个引用 之一 包含但又不被两者同时包含的提交</span><br>git <span class="hljs-built_in">log</span> master...experiment<br><br><span class="hljs-comment"># Multiple Points</span><br><span class="hljs-comment"># 查看哪些提交是被包含在某些分支中的一个，但是不在你当前的分支上。 Git 允许你在任意引用前加上 ^ 字符或者 --not 来指明你不希望提交被包含其中的分支。 </span><br>git <span class="hljs-built_in">log</span> refA..refB<br>git <span class="hljs-built_in">log</span> ^refA refB<br>git <span class="hljs-built_in">log</span> refB --not refA<br><span class="hljs-comment"># 看所有被 refA 或 refB 包含的但是不被 refC 包含的提交</span><br>git <span class="hljs-built_in">log</span> refA refB ^refC<br>git <span class="hljs-built_in">log</span> refA refB --not refC<br></code></pre></td></tr></table></figure>
<p>这里面有一句话值得铭记：</p>
<blockquote>
<p><strong>将引用日志想作 Git 版的 shell 历史记录</strong><br>
如果你有 UNIX 或者 Linux 的背景，不妨将引用日志想作 Git 版的 shell 历史记录， 重点在于仅与你和你的会话相关，而与他人无关。</p>
</blockquote>
<p>这句话的隐藏含义是，reflog 不会被 push 到远端，只有本地 repo 才留存。这个日志能够帮助修复那些 reset 导致的丢失，log（实际上是 commit log）是会被修改的，reflog 记录了 HEAD 的变动历史，而不只是 commit log。</p>
<h4 id="另一种双点">另一种双点</h4>
<p><code>b7ba61b5..ecee4f91  main       -&gt; origin/main</code></p>
<p><code>git pull</code>让 main 从 b7ba61b5 进展到 ecee4f91，而这一更新来自 origin/main。</p>
<h2 id="reset">reset</h2>
<p>三个选项的区别是：是否调整 HEAD <strong>与 branch</strong>、丢掉 staging area 的修改、丢掉 Working Directory 的修改。回退：commit（相当于 branch）、add、modified 这三个最重要的操作（这个三部曲正向也叫做 edit，stage，commit）。</p>
<p>大多数的时候的回退操作是 reset 操作：</p>
<p>大部分情况下，我们可以使用<code>git reset --hard commit_id</code>（这里的commit id 也可以是某种 ref，比如分支名 origin/main） 的方式来调整当前整个 git 仓库内的内容，这个操作会把代码仓库里的多余内容抹掉。**<code>git reset --hard</code>大部分时间没什么用，因为 HEAD 本来已经是 HEAD 了，但它会把 Working Directory 里的内容给丢掉。**这个操作是最危险的，其他reset都可以再调整，这个操作会丢失数据。<code>git reset --hard HEAD~</code><strong>对于错误的merge有撤销的功能</strong>，缺点是会重写历史，这对 public 分支是有害的。</p>
<p>如果我们想把代码回滚到特定的版本，但保留 commit 之间的修改，则可以使用<code>git -c core.quotepath=false -c log.showSignature=false reset --soft 6ef50b9f2186fbb0f89b100dfe7399c2b918446d</code> 命令，这样特定版本之间的修改，会停留在 staged 区域，等待再次被修改为一个 commit 并提交。<strong>同样是保留文件修改，soft 会帮你做好 add 动作</strong>。<code>git reset --soft HEAD~2</code><strong>会把最近2次 commit 都放在 index 里，这样我们一次 commit  就压缩了这2次 commit</strong>。</p>
<p><code>git -c core.quotepath=false -c log.showSignature=false reset --mixed 6ef50b9f2186fbb0f89b100dfe7399c2b918446d</code>，则 commit 之间的代码会被放到 Working Directory（而不是 staging area），等待 add 和 commit。<strong>同样是保留文件修改，mixed 连 add 都不会帮你做。而且，它是 reset 的默认选项</strong>。</p>
<p>等价于：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 这就把 add 的文件拿出 staging area（取消了暂存），放回 Working Directory。</span><br>git reset HEAD CONTRIBUTING.md<br>Unstaged changes after reset:<br>M CONTRIBUTING.md<br></code></pre></td></tr></table></figure>
<p><code> git -c core.quotepath=false -c log.showSignature=false reset --keep 6ef50b9f2186fbb0f89b100dfe7399c2b918446d</code> 看不出这个命令和<code>hard</code>有什么区别。</p>
<p>reset 命令会以特定的顺序重写这三个区域（WD是扁平的文件区域、index是 .git 目录下的一个缓冲文件，branch 的 heads/ref（注意小写 heads）的引用的指针指向 ），在你指定以下选项时停止：</p>
<ul>
<li>branch 是一定会被重写的（被拿走的修改在其他区域里（WD、index）取决于不同选项）</li>
<li>移动 HEAD 的指向 （若指定了 --soft，则只把 HEAD 在 commit 的树对象链表的位置移动了。变更留在 index 和 WD 里，也就意味着这是一次已经有了快照的等待提交的commit，只要再次提交就会得到新的 commit，不再需要 add。这时候再次提交就只能主要修改提交消息，也就起到了 --amend 类似的作用）<img src="reset-soft.png" alt="reset-soft"></li>
<li>使索引看起来像 HEAD （若未指定 --hard，即指定了 mix，则 idex 也被抹去，变更留在 WD 里，所以这是取消了 commit 和 add）<img src="reset-mixed.png" alt="reset-mixed"></li>
<li>使工作目录看起来像索引（若指定了 --hard，丢弃一切变更）<img src="reset-hard.png" alt="reset-hard"></li>
</ul>
<p>上面的图还有一个特点，在正常情况下，三个区域是逐次增加和逐次回退的。v3 覆写 v2 是从右到左；而 v2 覆写 v3，则是先从链表里面用 HEAD 的父节点 HEAD~ 来覆写 HEAD，再从 HEAD 往右覆写。</p>
<p>有一个衍生操作：想让文件从 index 里回到 WD 怎么办？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset file.txt<br></code></pre></td></tr></table></figure>
<p><img src="reset-path1.png" alt="reset file 修改 index，不修改 wd"><br>
<img src="reset-path3.png" alt="reset file 修改 index，不修改 wd"></p>
<h3 id="强制对齐远程分支">强制对齐远程分支</h3>
<p>有些 git pull 会产生多余的垃圾代码，这时候可以使用强制更新来去除 WIP，而且对齐远端。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset --hard origin/main<br><span class="hljs-comment"># 如果对齐不了还可以这样</span><br>git clean -d --force<br></code></pre></td></tr></table></figure>
<h2 id="checkout">checkout</h2>
<p><img src="reset-checkout-%E9%80%9F%E6%9F%A5%E8%A1%A8.jpg" alt="reset-checkout-速查表"></p>
<ol>
<li>checkout 创造了一种只移动 HEAD <strong>但 branch 纹丝不动的操作</strong>。</li>
<li>reset 移动了branch，也移动了 HEAD。</li>
</ol>
<p>git checkout最简单的用法，显示工作区，暂存区和 HEAD 的差异。</p>
<p>注意 checkout 本身不是 reset，纯粹的 checkout 会导致 HEAD 指针比 branch 的最后头指针更加 behind（因为 checkout 始终都是往已有的历史里 checkout）。因为 HEAD 等于 current checkout commit 的定义，<strong>凡是不是 latest 的 commit，HEAD 都会因此进入 detached HEAD STATE。因为 checkout 本来是拿来移动 HEAD 的，HEAD 不指向 branch 的时候就是 detached</strong>。</p>
<p><strong>我们在 detached HEAD 上乱修改，也可以产生提交。但这个提交是不能当做任何一个 branch 的内容的，也就是在一个匿名的 branch 内</strong>。但我们可以再做一次<code>checkout -b</code>，新建出真正的分支（还有一个不常用的简写操作<code>git checkout --track origin/serverfix</code>）。大多数时候我们会忘记这样给匿名分支命名，因为我们回溯到某些checkout 的时候往往是我们 rebase 的时候，这时候我们想着的不是给旧分支分叉，而是想办法把旧分支的内容修改为我们想要的某些版本。</p>
<p>似乎可以这么理解，git checkout 历史版本，是为了<strong>在历史版本上创建新分支而不是更正当前版本</strong>而存在的。如果不是rebase而进入这些commit，系统进入悬垂态是必须要解决的。</p>
<p>因为 checkout 总是被用来切换分支，所以它会导致 local modification 被覆盖，所以我们在 checkout 的时候，总是要先 commit 或者 stash 一下我们的修改。</p>
<h3 id="对分支">对分支</h3>
<p>首先不同于 reset --hard，checkout（一个分支） <strong>对工作目录是安全的，它会通过检查来确保不会将已更改的文件弄丢</strong>（在某些工具里会有 smart checkout 和 force checkout 的区别）。 其实它还更聪明一些。它会在工作目录中先试着简单合并一下，这样所有 还未修改过的文件都会被更新。 而 reset --hard 则会不做检查就全面地替换所有东西。</p>
<p>第二个重要的区别是 checkout 如何更新 HEAD。 <strong>reset 会移动 HEAD 分支的指向，而 checkout 只会移动 HEAD 自身来指向另一个分支</strong>。</p>
<h3 id="对文件">对文件</h3>
<p>运行 checkout 的另一种方式就是指定一个文件路径，这（会像 reset 一样？）不会移动 HEAD。 它就像 git reset [branch] file 那样用该次提交（<strong>该分支的 last commit</strong>）中的那个文件来更新索引，但是它也会覆盖工作目录中对应的文件。 它就像是 git reset --hard [branch] file（如果 reset 允许你这样运行的话）， 这样对工作目录并不安全，它也不会移动 HEAD。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># -- 符号在这里用于明确区分文件名 CONTRIBUTING.md 和任何可能的 Git 分支名或提交哈希。虽然在这个特定例子中可能不是严格必要的，但使用 -- 是一个好的实践，可以避免潜在的歧义，特别是当你处理的文件名与分支名或提交哈希相同时。</span><br>git checkout -- CONTRIBUTING.md<br></code></pre></td></tr></table></figure>
<p>对于 staged 文件来讲，checkout；对于 commit 的文件来讲，reset --hard。在git里，checkout意味着 Working Directory 的重置。checkout后面可以接的有文件名、commit 和分支名（实际上和commit一样都是一个版本快照的hash指针）。</p>
<p><img src="reset-checkout.png" alt="reset-checkout"><br>
<code>reset</code>会把分支这种类似 alias 的内容也给改了。在git的术语里，<strong>reset will move the branch HEAD points to, checkout moves HEAD itself</strong>。<strong>reset 也因此可以起到修复分支的作用，而我们平时checkout是为了修复 WD 中的某些 path</strong>。checkout 比较轻量级。</p>
<h2 id="revert">revert</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># idea 的用法</span><br><span class="hljs-comment"># core.quotepath 是一个 Git 配置选项，用于控制路径名中的特殊字符如何被转义。false 表示禁用路径名的特殊字符转义。这在处理包含非 ASCII 字符的路径时特别有用，可以避免路径名被错误地转义。</span><br><span class="hljs-comment"># -c log.showSignature=false：log.showSignature 是一个 Git 配置选项，用于控制 git log 命令是否显示 GPG 签名信息。false 表示在显示提交日志时不显示 GPG 签名信息。</span><br><span class="hljs-comment"># --no-commit 这个选项告诉 Git 不要自动创建撤销提交，而是将撤销的更改暂存。</span><br>git -c core.quotepath=<span class="hljs-literal">false</span> -c log.showSignature=<span class="hljs-literal">false</span> revert 6ef50b9f2186fbb0f89b100dfe7399c2b918446d --no-commit<br></code></pre></td></tr></table></figure>
<p>产生一个反 commit。这样可以提交反操作，而不丢失正操作的 commit。这样做的好处是，commit 历史是 append only 的，不会被修改。</p>
<p>在这里要重新解释三个区域：</p>
<table>
<thead>
<tr>
<th style="text-align:center">区域</th>
<th style="text-align:center">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">HEAD</td>
<td style="text-align:center">某个 commit heads/ref（branch）的别名，所以可以在不同 branch之间移动：提交会自动移动 HEAD，上一次提交的快照，下一次提交的父节点。</td>
</tr>
<tr>
<td style="text-align:center">Index（staging area）</td>
<td style="text-align:center">扁平文件：预期的下一次提交的快照，生成树对象的源泉，write-tree<strong>从这里</strong>把变更生成树对象，commit-tree 再（不从这里）把树对象提交乘 commit 对象。有人把这个地方叫 index tree（不如 working tree 流行），这个叫法似乎是错的</td>
</tr>
<tr>
<td style="text-align:center">Working Directory（WD）</td>
<td style="text-align:center">沙盒，平凡文件系统。有些文献把这个地方叫 working tree</td>
</tr>
</tbody>
</table>
<p><strong>运行 git status 会没有输出，意味着三棵树变得相同了</strong>。</p>
<p>revert 可以把2个分支的 merge 只 revert 一半：</p>
<blockquote>
<p>git revert -m 1 HEAD<br>
[master b1d8379] Revert “Merge branch ‘topic’”</p>
</blockquote>
<p>-m 1 标记指出 “mainline” 需要被保留下来的父节点。 当你引入一个合并到 HEAD（git merge topic），新提交有两个父节点：第一个是 HEAD（C6），第二个是将要合并入分支的最新提交（C4）。 在本例中，我们想要撤消所有由父节点 #2（C4）合并引入的修改，同时保留从父节点 #1（C6）开始的所有内容。</p>
<p>1 是指 #1</p>
<p><img src="undomerge-revert.png" alt="undomerge-revert"></p>
<p>新的提交 ^M 与 C6 有完全一样的内容，所以从这儿开始就像合并从未发生过，除了“现在还没合并”的提交依然在 HEAD 的历史中。 如果你尝试再次合并 topic 到 master Git 会感到困惑：</p>
<blockquote>
<p>git merge topic<br>
Already up-to-date.</p>
</blockquote>
<h2 id="amend">amend</h2>
<p>我们的 amend 主要是用（修改过 message 和 文件） commit2 来代替 commit1：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit -m <span class="hljs-string">&#x27;initial commit&#x27;</span><br>git add forgotten_file<br><span class="hljs-comment"># 这会修改最近一次提交（即 &#x27;initial commit&#x27; 提交），将暂存区中的更改（包括 forgotten_file）包含在这个提交中，并允许你修改提交信息。</span><br>git commit --amend<br></code></pre></td></tr></table></figure>
<h2 id="restore">restore</h2>
<p>对于误删除的文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git restore --staged  arthas/README.md\n<br>git restore arthas/README.md\n<br></code></pre></td></tr></table></figure>
<h1>主要命令</h1>
<h2 id="merge">merge</h2>
<p>merge 的用途是把一个分支的内容合入另一个分支。</p>
<p>要把 master 的代码合并入 feature。</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment"># 方法一</span><br>git checkout feature<br>git merge <span class="hljs-keyword">master</span><br><br><span class="hljs-title"># 方法二</span><br><span class="hljs-title">git</span> merge <span class="hljs-keyword">master</span> <span class="hljs-title">feature</span><br></code></pre></td></tr></table></figure>
<h3 id="非快进合并">非快进合并</h3>
<p>git merge 通常会产生一个多余的 commit，而且如果有冲突的话，还必须在这个 commit 里修改，化解冲突。我们在工程上倒是可以规定所有的 merge 都必须是 no conflict 的，这就要求我们合并里的 source 分支，反而要先 merge target 分支。</p>
<p><img src="basic-merging-2.png" alt="--no-ff merge会产生至少两个前向指针，表示源分支和目标分支"></p>
<p>这种非快进合并按照 mergify 的说法，应该也叫做 three-way merges（the current main branch, your commits to be merged, and a common ancestor of the two）。</p>
<p><img src="3-way-merge.png" alt="3-way-merge"></p>
<p>这里的 tip 是尖端的意思。</p>
<h3 id="快进合并">快进合并</h3>
<p>快进合并即 Fast-forward merge，是一种特殊的合并方式，用于将一个分支的提交直接应用到另一个分支，而不会创建一个新的合并提交-效果如果 rebase。如分支 a 有c1c2c3提交，分支 b 有c1c2c3c4c5提交，checkout a 然后 merge b，就是把 a 指向 b。<strong>ff 只会发生在 a 是 b 的子集前提下</strong>，这样3-way就变成2-way。</p>
<p><strong>这种合并会让我们删除分支 b 以后，会看不到分支 b 的痕迹</strong>，因为分支信息作为非必须信息，没有被保留。</p>
<h3 id="配置快进">配置快进</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global merge.ff <span class="hljs-literal">false</span>   <span class="hljs-comment"># 禁用快进合并</span><br>git config pull.ff only<br></code></pre></td></tr></table></figure>
<ul>
<li>true（默认值）：允许快进合并。</li>
<li>false：禁止快进合并，总是创建一个新的合并提交。</li>
<li>only：只允许快进合并，如果不能进行快进合并，则拒绝相应操作。</li>
</ul>
<h3 id="压缩合并">压缩合并</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 这样修改会把 dev 的原始分支通过压缩的方式merge进当前分支，在当前分支的历史上则看不见原分支的提交了</span><br>git merge --squash dev<br></code></pre></td></tr></table></figure>
<h2 id="rebase">rebase</h2>
<p><strong>本节最重要的标准流程是应该是 feature rebase onto master，然后 master merge from feature</strong>。</p>
<p>git rebase/merge master 的宾语都是 master，都是基于，但基底分支是feature/master。从句式来看，这是 merge from 和 rebase onto 的区别。</p>
<p>rebase 的用途也是把一个分支的内容合入另一个分支。作为 merge 的替代选择，它会产生一个非常整洁的提交记录。让本来并行的开发记录看起来像是串行的一样。</p>
<p>变基的主流程是：</p>
<ol>
<li>先找到共同祖先。</li>
<li>再找到基底分支和当前分支的全部提交。</li>
<li>将当前分支的提交逐步应用到基地分支上去。</li>
</ol>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-comment"># 经典变基</span><br>git checkout feature<br>git rebase master<br><br><span class="hljs-comment"># 交互式变基</span><br><br><span class="hljs-comment"># 进入编辑窗口后，除了最上的 commit 不能够 squash，其他全部都可以 squash。然后提交还会出现一个重新修改注释的地方。</span><br><span class="hljs-comment"># pick：选择该提交并将其应用。这是默认操作，表示保留提交不变。</span><br><span class="hljs-comment"># reword：选择该提交并允许你修改提交信息。提交的内容保持不变。</span><br><span class="hljs-comment"># edit：选择该提交并在应用时暂停，以便你可以对提交进行修改。你可以在暂停时进行额外的更改、修复或其他调整。</span><br><span class="hljs-comment"># squash：将该提交与前一个提交合并，并允许你修改合并后的提交信息。</span><br><span class="hljs-comment"># fixup：类似于 squash，但不允许你修改合并后的提交信息。它会使用前一个提交的信息。</span><br><span class="hljs-comment"># exec：在应用该提交后执行指定的 shell 命令。这可以用于自动化某些操作。</span><br><span class="hljs-comment"># drop：从提交历史中删除该提交。它会从变基后的历史中完全移除。</span><br>git rebase -i 还可以加上要变基的最后一个 commit（开区间）<br><br><span class="hljs-comment"># 如果出了问题，可以用这个命令退出</span><br>git rebase <span class="hljs-comment">--abort</span><br></code></pre></td></tr></table></figure>
<p>rebase 的本质，顾名思义，<strong>是改变当前分支的 branch out 的位置</strong>。即，把当前 feature 整个移动到 master 的 ALIAS 之后（尽量不 branch out），即所谓的 rebase onto。</p>
<p>我们可以看看最基础的分支演进图：</p>
<p><img src="basic-rebase-1.png" alt="我们把这种分歧（而不是 fork，实际上区块链里的 fork 在 git 里就是 divergent history）叫作 Simple divergent history"></p>
<p>最简单的操作就是 merge，我们把这个叫做<br>
The easiest way to integrate the branches, as we’ve already covered, is the merge command.</p>
<p><img src="basic-rebase-2.png" alt="Merging to integrate diverged work history"></p>
<p>rebase 导致最后的项目历史呈现出完美的线性——你可以从项目终点到起点浏览而不需要任何的 fork。这时候我们的 experiment 分支变成直线了。</p>
<p><img src="basic-rebase-3.png" alt="Rebasing the change introduced in C4 onto C3  我们通过改写experiment分支的历史，让c4的历史变化了"></p>
<p>但我们这里 rebase 的当前分支是experiment，是为了 master 更好地 merge 而服务的，<strong>而不是让 master rebase onto experiment</strong>。</p>
<p><img src="basic-rebase-4.png" alt="这样我们就可以快速让 master merge（fast forward merge），而 master 里没有任何的合并标记分支 Fast-forwarding the master branch"></p>
<p>这个故事的完整操作是：</p>
<blockquote>
<p>git checkout experiment<br>
git rebase master<br>
First, rewinding head to replay your work on top of it…<br>
Applying: added staged command git<br>
checkout master<br>
git merge experiment</p>
</blockquote>
<p>rebase 因为会修改 branch 的历史，所以 never use it on public branches，<strong>use it on experiment branch</strong>。因为这会给其他人的开发分支带来分歧。</p>
<p>而如果我们使用交互式的 rebase，就是把<code>git rebase -i master</code>，则允许我们把要 branch out 的 commit 做一个整理。</p>
<h3 id="强制推送会毁灭推送历史">强制推送会毁灭推送历史</h3>
<p>如果你想把 rebase 之后的 master 分支推送到远程仓库，Git 会阻止你这么做，因为两个分支包含冲突。但你可以传入 --force 标记来强行推送。就像下面一样：</p>
<figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nsis"><span class="hljs-comment"># 小心使用这个命令！</span><br>git <span class="hljs-keyword">push</span> --<span class="hljs-literal">force</span><br></code></pre></td></tr></table></figure>
<p>它会重写远程的 master 分支来匹配你仓库中 rebase 之后的 master 分支，对于团队中其他成员来说这看上去很诡异。所以，务必小心这个命令，只有当你知道你在做什么的时候再使用。<strong>如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基。</strong></p>
<p><img src="merge-from-other-team-1.jpg" alt="假设team1的修改已经进入本地分支"></p>
<p>这时候 team1 rebase 丢弃一些分支，就会产生意想不到的后果。</p>
<p><img src="%E5%8F%8CC4.jpg" alt="理论上会有作者、内容、提交日期、日志一样但 commit hash 完全不一样的两个 C4"></p>
<p><img src="%E5%8F%98%E5%9F%BA%E4%BC%9A%E5%88%B6%E9%80%A0%E9%87%8D%E5%A4%8D.jpg" alt="变基会制造重复"></p>
<p>**变基只能让被变基的分支干净，也许能让master干净，但不会让以前pull过的分支干净。**我们会看到内容一样，作者和时间一样但 hash 不一样的提交，产生 no diff 式的困惑。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1</span><br>git pull --rebase <br><span class="hljs-comment"># 2</span><br>git config --global pull.rebase <span class="hljs-literal">true</span><br><span class="hljs-comment"># 3</span><br>git fetch<br>git rebase teamone/master。<br></code></pre></td></tr></table></figure>
<p>这两种方法可以拉取被人rebase过的公共分支，而不丢失修改，而且不会产生重复的commit。而如果被 <code>push --force</code>的分支的外部 clone 者不这么做，则他们的历史里仍然有“无差别的重复分歧”。</p>
<p><img src="rebase-by-rebase.jpg" alt="我们的c2、c3本身也要变基，这样就可以拉平 history"></p>
<p><strong>所以要消除 divergence 就要gplr！</strong></p>
<h3 id="补丁式-onto-在三个分支上变基">补丁式 onto（在三个分支上变基）</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git rebase --onto master server client<br></code></pre></td></tr></table></figure>
<p>这是一个三分支的变基操作。</p>
<p>以上命令的意思是：“取出 client 分支，找出它从 server 分支分歧之后的补丁， 然后把这些补丁在 master 分支上重放一遍，让 client 看起来像直接基于 master 修改一样”。</p>
<p>然后</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout master<br>git merge client<br></code></pre></td></tr></table></figure>
<p><img src="interesting-rebase-2.png" alt="先改写 client"><br>
<img src="interesting-rebase-3.png" alt="再让master和client对齐（rebase的目的是让master和所有feature都没有分叉，尽量在一条直线上）"></p>
<p>变基操作的实质是丢弃一些现有的提交（重复的提交存在于 server上，但因为重复来源于变基，所以是可以抛弃的），<strong>然后相应地新建一些内容一样但上 commit id 不同的提交。在变基后，所有的patch commit都变了</strong>，c3变成c3~，c4变成c4~，类似区块链，<strong>所以这会修改commit的 committer date，而保留 author date</strong>。</p>
<h2 id="fetch">fetch</h2>
<ul>
<li>git fetch 默认会拉取远程仓库（默认的 remote 是 origin，也可以选择其他remote，但一次只能拉取一个（通常是当前活动的 remote））的<strong>所有分支和标签的最新信息</strong>。<strong>这意味着它会获取远程仓库中所有分支的最新提交历史</strong>。</li>
<li>它会更新本地的远程跟踪分支。
<ul>
<li>如果本地原本没有全量的 origin/branch 列表，fetch 会拉取全部的列表</li>
</ul>
</li>
<li>它不会自动合并或修改当前分支的工作目录。
<ul>
<li>git pull 相当于
<ul>
<li>git fetch 全部远程跟踪分支的提交（也就包括当前分支的 origin upstream，但只是这个分支，如果使用大仓+leflow模式每次就会拉取非常多的 commit）</li>
<li>git merge 当前分支的 origin upstream</li>
</ul>
</li>
</ul>
</li>
<li>你可以使用参数来指定特定的分支或标签进行拉取。
<ul>
<li>idea 更新某个非当前分支的操作：<code>git fetch origin develop:develop --recurse-submodules=no --progress --prune</code></li>
</ul>
</li>
</ul>
<h3 id="两个分支">两个分支</h3>
<p>master 是本地分支。<br>
origin/master (远程跟踪分支)是远程 master 分支在你本地的缓存副本。这个副本不会自动更新，需要显式执行 git fetch 来更新。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch -r<br>    <br><br>  origin/HEAD -&gt; origin/main<br>  origin/dependabot/npm_and_yarn/babel/traverse-7.23.6<br>  origin/dependabot/npm_and_yarn/braces-3.0.3<br>  origin/dependabot/npm_and_yarn/decode-uri-component-0.2.2<br>  origin/dependabot/npm_and_yarn/ejs-3.1.10<br>  origin/dependabot/npm_and_yarn/json5-2.2.3<br>  origin/dependabot/npm_and_yarn/nunjucks-3.2.4<br>  origin/dependabot/npm_and_yarn/semver-5.7.2<br>  origin/gh-pages<br>  origin/main<br>  <br>git branch<br>* main<br></code></pre></td></tr></table></figure>
<p>所以：</p>
<ol>
<li>不要<code>git merge origin/master # 合并最新的远程变更</code></li>
<li>需要<code>git pull origin master  # 相当于 fetch + merge</code></li>
</ol>
<h2 id="remote">remote</h2>
<p><img src="centr-decentr.png" alt="去中心化"></p>
<p>Note that this repo is only considered to be the central one (since Git is a DVCS, there is no such thing as a central repo at a technical level)。</p>
<p>Git是一个分布式版本控制系统（DVCS），而之前的系统大多是集中式的。<strong>分布式模型允许每个开发者拥有完整的代码库副本，这为轻量级分支和合并提供了基础</strong>。</p>
<p>在Git之前，版本控制系统的设计更多地关注于集中式管理和简单的线性开发模型。随着开源项目和分布式团队的兴起，对更灵活的分支和合并需求变得更加迫切。</p>
<p>Technically, this means nothing more than that Alice has defined a Git remote, named bob, pointing to Bob’s repository, and vice versa.</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-meta"># 列出所有远程仓库</span><br>git remote -v<br><br><span class="hljs-meta"># 增加一个 ssh 协议/git 协议的 git repo，命名为 pb（通常还是命名为 origin）。</span><br>git remote add pb git:<span class="hljs-comment">//github.com/paulboone/ticgit.git</span><br><br><span class="hljs-meta"># 从远程仓库 pb 获取信息，git fetch --all 可以获取全部的 remotes</span><br>git fetch pb<br><br><span class="hljs-meta"># 推送修改到 origin 里，可以修改这个参数推送到不同的 origin 里</span><br>git <span class="hljs-keyword">push</span> origin master<br><br><span class="hljs-meta"># 显示远程仓库</span><br>git remote <span class="hljs-keyword">show</span> origin<br><br><span class="hljs-meta"># 重命名</span><br>git remote rename pb paul<br><br><span class="hljs-meta"># 删除</span><br>git remote rm paul<br><br><span class="hljs-meta"># push 到不同名分支，产生的 ref 是：refs/heads/serverfix:refs/heads/awesomebranch</span><br>git <span class="hljs-keyword">push</span> origin serverfix:awesomebranch<br></code></pre></td></tr></table></figure>
<p>git fetch origin 在<strong>本地生成一个远程分支</strong> origin/serverfix，指向服务器的 serverfix 分支的引用。这是一个指针，而不是可编辑的副本（拷贝），除非使用 checkout -b 的方式。</p>
<h2 id="commit">commit</h2>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"># 多行注释<br>git <span class="hljs-keyword">commit</span> -m &quot;<br>多行注释<br>&quot;<br><br># 修改最近一次提交的 <span class="hljs-keyword">comment</span>，会把现在在 staging 里的修改纳入本次 <span class="hljs-keyword">commit</span><br># 如果要修改多个 <span class="hljs-keyword">commit</span> 的注释，要先 rebase 到一个 <span class="hljs-keyword">commit</span>，在交互过程中修改<br>git <span class="hljs-keyword">commit</span> <span class="hljs-comment">--amend</span><br></code></pre></td></tr></table></figure>
<h2 id="rm">rm</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 删除文件并从暂存区移除:</span><br><span class="hljs-comment"># 删除文件并将其从暂存区移除。</span><br>git <span class="hljs-built_in">rm</span> filename.txt<br><br><span class="hljs-comment"># 仅从暂存区移除文件:</span><br><span class="hljs-comment"># 使用 --cached 选项仅从暂存区移除文件，但保留在工作目录中。</span><br>git <span class="hljs-built_in">rm</span> --cached filename.txt<br></code></pre></td></tr></table></figure>
<h1>（命令）别名</h1>
<p>在创建你认为应该存在的命令时这个技术会很有用。 例如，为了解决取消暂存文件的易用性问题，可以向 Git 中添加你自己的取消暂存别名：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global alias.unstage <span class="hljs-string">&#x27;reset HEAD --&#x27;</span><br></code></pre></td></tr></table></figure>
<p>这会使下面的两个命令等价：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git unstage fileA<br>git reset HEAD -- fileA<br></code></pre></td></tr></table></figure>
<p>这个操作似乎不如在 shell 里面 alias 统一。</p>
<h1>特殊技巧</h1>
<h2 id="交互式提交">交互式提交</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add -i<br></code></pre></td></tr></table></figure>
<p>其中update是暂存整个文件，patch是暂存其他几行。</p>
<p>只 staged 几个文件的结果就是</p>
<blockquote>
<p>Update&gt;&gt;<br>
updated 2 paths</p>
</blockquote>
<p>updated path 意味着暂存了几个文件。</p>
<p>具体的例子见<a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E4%BA%A4%E4%BA%92%E5%BC%8F%E6%9A%82%E5%AD%98">7.2 Git 工具 - 交互式暂存</a>。</p>
<h2 id="储藏">储藏</h2>
<p>在 git 术语里，暂存（stage）和储藏（stash）有很大不同。</p>
<p>git stash 大致上等于 git stash push。按顺序压入栈。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git stash list<br>stash@&#123;0&#125;: WIP on master: 049d078 added the index file<br>stash@&#123;1&#125;: WIP on master: c264051 Revert <span class="hljs-string">&quot;added file_size&quot;</span><br>stash@&#123;2&#125;: WIP on master: 21d80a5 added number to <span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure>
<p>这里的 WIP 是 work in progress 的意思，有编号意味着可以从命令里引用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># apply 不是出栈，只是应用</span><br>git stash apply<br>git stash apply stash@&#123;2&#125;<br><span class="hljs-comment"># 等于 apply + drop</span><br>git stash pop<br></code></pre></td></tr></table></figure>
<p><code>--index</code>意味着，staging 的状态也会被 stash 起来，而不是在pop的时候变成 unstaging 状态。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git stash apply --index<br></code></pre></td></tr></table></figure>
<h2 id="怎样把一些-commit-从当前分支-通常是-master-移到另一个分支">怎样把一些 commit 从当前分支（通常是 master）移到另一个分支</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 移走而不是复制</span><br>git branch newbranch      <span class="hljs-comment"># Create a new branch, saving the desired commits</span><br><span class="hljs-comment"># 销毁本分支的提交</span><br>git reset --hard HEAD~3   <span class="hljs-comment"># Move master back by 3 commits (GONE from master)</span><br>git checkout newbranch    <span class="hljs-comment"># Go to the new branch that still has the desired commits</span><br></code></pre></td></tr></table></figure>
<h2 id="怎样把当前分支的提交直接复制到其他分支">怎样把当前分支的提交直接复制到其他分支</h2>
<p>一共有三类补丁操作 cherry-pick/rebase（git rebase 命令基本是是一个自动化的 cherry-pick 命令。 它计算出一系列的提交，然后再以它们在其他地方以同样的顺序一个一个的 cherry-picks 出它们）/revert（git revert 命令本质上就是一个逆向的 git cherry-pick 操作）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 用 cherry-pick 挑选一个 branch 上的 commit 单独 apply 到另一个 branch 上。</span><br>git checkout master<br><span class="hljs-comment"># 这里的 --no-commit 选项告诉 Git 在应用每个选定的提交后不要自动创建新的提交。</span><br>git cherry-pick --no-commit d0的哈希 d1的哈希 d2的哈希<br>git commit -m <span class="hljs-string">&quot;merged commit&quot;</span><br><br><span class="hljs-comment"># merge squash</span><br><span class="hljs-comment"># 用于将分支 d2 的更改合并到当前分支中，但不会创建一个合并提交。相反，它会将所有的更改“压缩”成一个未提交的快照，等待你手动提交。这在你希望将多个提交合并为一个提交时非常有用。</span><br>git merge d2 --squash<br></code></pre></td></tr></table></figure>
<h2 id="基于某一个分支压缩本分支上的修改">基于某一个分支压缩本分支上的修改</h2>
<figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-comment"># 这样本分支就可以基于对 master 的 HEAD 的指针变化，衍生一套新的 commit 集合，在这个集合生成的时候可以使用 squash。</span><br><span class="hljs-comment"># 常见的模式：对于最顶的 commit 进行 pick，其他全部都 squash，squash指南里写的 previous 是上方的提交</span><br><span class="hljs-comment"># --rebase-merges（或简写为 -r）选项用于在变基过程中保留合并提交（即 merge 提交）。默认情况下，普通的 git rebase 会丢弃所有的合并提交，并尝试将它们的更改线性地应用到新的基点上。使用 --rebase-merges 可以保留这些合并提交的结构和信息，使得变基后的历史记录更加接近原始的历史记录。</span><br><span class="hljs-string">git</span> <span class="hljs-string">rebase</span> <span class="hljs-built_in">--interactive</span> <span class="hljs-built_in">--rebase-merges</span> <span class="hljs-string">refs</span>/<span class="hljs-string">heads</span>/<span class="hljs-string">master</span><br><br><span class="hljs-comment"># 基底 squash rebase，记得选 s commit</span><br><span class="hljs-string">git</span> <span class="hljs-string">rebase</span> <span class="hljs-built_in">--interactive</span> <span class="hljs-built_in">--rebase-merges</span> 基底-<span class="hljs-string">commit-id</span><br></code></pre></td></tr></table></figure>
<p>这里面涉及两个参数，<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903757608648712">–preserve-merges和–rebase-merges</a>。在较新版本的 Git 中，–preserve-merges 已经被标记为弃用，并且在未来的版本中可能会被移除。<br>
Git 官方推荐使用 --rebase-merges 来替代它。<code>--rebase-merges</code>可以与<code>--interactive</code> 结合使用。</p>
<h2 id="怎样彻头彻尾地-ignore-不需要的文件-但仍把它保留在-wd-里">怎样彻头彻尾地 ignore 不需要的文件（但仍把它保留在 WD 里）</h2>
<p>参考<a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-GitLab">gitignore.io</a>。</p>
<ol>
<li>Edit .gitignore to match the file you want to ignore</li>
<li><code>git rm --cached /path/to/file</code>，用于从暂存区（index）中移除文件，但保留在工作目录（working directory）中。这意味着文件将不再被 Git 跟踪，但仍然存在于你的文件系统中。</li>
</ol>
<h2 id="处理经典的双提交冲突">处理经典的双提交冲突</h2>
<p>问题：</p>
<blockquote>
<p>On branch main Your branch and ‘origin/main’ have diverged, and have 1<br>
and 3 different commits each, respectively.   (use “git pull” to merge<br>
the remote branch into yours)</p>
<p>nothing to commit, working tree clean</p>
</blockquote>
<p>一般的冲突文件格式是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;&lt;&lt;&lt;&lt;&lt;&lt; <span class="hljs-string">HEAD:index.html</span><br><span class="hljs-string">&lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt;</span><br><span class="hljs-string">=======</span><br><span class="hljs-string">&lt;div id=&quot;footer&quot;&gt;</span><br><span class="hljs-string"> please contact us at support@github.com</span><br><span class="hljs-string">&lt;/div&gt;</span><br><span class="hljs-string">&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html</span><br></code></pre></td></tr></table></figure>
<p>a merge b 遇到冲突，下方就是b的文件，而上方是 a 的文件。</p>
<p>这时候如果直接 git pull 的话，fast forward 有一定概率会失败，需要进入<code>git pull --rebase</code> 的模式，基于 rebase 进行拉取。</p>
<p>然后</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># add 并不只是新增文件的意思，是 index/stage 文件到 staging区域的意思</span><br>git add .<br>git rebase --<span class="hljs-built_in">continue</span><br>git pull<br></code></pre></td></tr></table></figure>
<h2 id="稀疏检出">稀疏检出</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> --no-checkout git@git.xxx.com:user1/project1.git<br><span class="hljs-built_in">cd</span> project1<br><br><span class="hljs-comment"># Git 2.25 及以后版本的命令。</span><br><span class="hljs-comment"># 它启用稀疏检出功能，并设置为锥形模式（cone mode）。</span><br><span class="hljs-comment"># 锥形模式限制了模式匹配的复杂性，但提供了更好的性能，特别是在大型仓库中。</span><br><span class="hljs-comment"># 在锥形模式下，你只能指定目录路径，不能使用通配符。</span><br><span class="hljs-comment"># git config core.sparsecheckout true 这是较旧的启用稀疏检出的方法。</span><br>。它只是简单地启用稀疏检出功能，但不设置任何特定模式。使用这种方法后，你需要手动编辑 .git/info/sparse-checkout 文件来定义检出规则。<br>git sparse-checkout init --cone<br><br><span class="hljs-comment"># 这一步至关重要，没有开头的 /</span><br>git sparse-checkout <span class="hljs-built_in">set</span> a/b/c<br>git checkout master<br>git pull orgin master<br></code></pre></td></tr></table></figure>
<p>这样会产生这样的  .git/info/sparse-checkout</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs crystal">/*<br>!<span class="hljs-regexp">/*/</span><br><span class="hljs-regexp">/a/</span><br>!<span class="hljs-regexp">/a/</span>*<span class="hljs-regexp">/</span><br><span class="hljs-regexp">/a</span><span class="hljs-regexp">/b/</span><br>!<span class="hljs-regexp">/a/b</span><span class="hljs-regexp">/*/</span><br><span class="hljs-regexp">/a/b</span><span class="hljs-regexp">/c/</span><br></code></pre></td></tr></table></figure>
<p>配置了稀疏检出 (sparse checkout) 之后，<code>git fetch</code>的行为在拉取 commit 和 commit 历史方面，与没有配置稀疏检出时基本没有区别。</p>
<p><code>git fetch</code>仍然会拉取：</p>
<ul>
<li>所有被请求的引用 (references) 的更新: 例如，如果你<code>git fetch origin main</code>，它会更新你本地的 origin/main 远程跟踪分支，使其指向远程仓库 origin 上 main 分支最新的 commit。 如果你<code>git fetch origin --all</code>，它会更新所有远程分支和标签的远程跟踪分支。</li>
<li>所有为了完成这些引用更新所需要的 commit 和对象 (objects): 为了更新远程跟踪分支，git fetch 需要下载远程仓库中新的 <strong>commit 对象、tree 对象、blob 对象</strong>等。 它会拉取从你本地仓库已知的 commit 历史到远程仓库最新 commit 之间 所有 的 commit 和对象。</li>
<li>关键点：稀疏检出<strong>不影响`git fetch拉取 commit 和历史的行为</strong>。</li>
</ul>
<p>稀疏检出只影响：</p>
<ul>
<li>你的工作目录 (Working Directory) 的内容: 配置稀疏检出后，Git 只会在你的工作目录中检出和维护你指定的文件和目录。 工作目录中只会显示<code>sparse checkout</code> 配置中包含的文件和目录。</li>
<li><code>git checkout</code>和<code>git reset --hard</code>等命令的行为: 当你使用<code>git checkout</code>切换分支或 <code>commit</code>，或者使用<code>git reset --hard</code>重置工作目录时，Git 会根据<code>sparse checkout</code> 配置来决定哪些文件需要检出到工作目录。</li>
</ul>
<h3 id="关于文件大小的辨析">关于文件大小的辨析</h3>
<ul>
<li>git 的 commit 里包含完整的文件的各个版本的 blob，所以拉取完整的 git history 意味着稀疏检出和非稀疏检出的 .git <strong>文件夹大小是一样大的</strong>。</li>
<li>为什么还要下载所有对象：
<ul>
<li>保持历史完整性：允许在需要时访问完整历史。</li>
<li>支持灵活性：可以随时更改稀疏检出规则，而无需重新下载数据。</li>
<li>确保操作一致性：像 merge、rebase 等操作需要访问完整的仓库状态。</li>
</ul>
</li>
<li>稀疏检出会让 Working Directory 变小：
<ul>
<li>磁盘空间：虽然所有对象都被下载，但工作目录中只有符合稀疏检出规则的文件被实际检出。在大型仓库中，这可能会显著减少工作目录的大小。</li>
<li>网络带宽：初次克隆时仍需下载所有对象，但后续的 fetch 和 pull 操作可能会更高效，因为 Git 可以更智能地处理稀疏检出的情况。</li>
<li>计算资源：Git 的某些操作（如 status）可以更快，因为它们只需要考虑检出的文件。</li>
</ul>
</li>
</ul>
<h2 id="shallow-clone-浅克隆">Shallow Clone（浅克隆）</h2>
<p>Git 有一些额外的优化，如部分克隆（partial clone），可以进一步减少初始下载的数据量。</p>
<ul>
<li>定义：只克隆仓库的最近一次提交历史，而不是完整的提交历史。</li>
<li>特点：
<ul>
<li>通过 --depth 参数指定克隆的深度，例如 git clone --depth 1 &lt;仓库地址&gt; 只克隆最近一次提交。</li>
<li>适用于不需要完整历史记录的场景，可以显著减少克隆时间和存储空间。</li>
<li>无法查看或操作克隆深度之外的提交历史。</li>
</ul>
</li>
<li>适用场景：
<ul>
<li>快速获取最新代码。</li>
<li>CI/CD 构建环境中，不需要完整历史记录。</li>
</ul>
</li>
</ul>
<h2 id="partial-clone">partial clone</h2>
<ul>
<li>定义：只克隆仓库的部分内容，例如只克隆某些分支、目录或文件。</li>
<li>特点：
<ul>
<li>通过 --filter 参数实现，例如 git clone --filter=blob:none &lt;仓库地址&gt;</li>
<li>只克隆元数据，不下载文件内容。</li>
<li>文件内容在需要时按需下载（称为 “lazy fetch”）。</li>
<li>适用于大型仓库，可以减少初始克隆的时间和存储空间。</li>
</ul>
</li>
<li>适用场景：
<ul>
<li>大型仓库中只关注部分内容。</li>
<li>需要按需加载文件的场景。</li>
</ul>
</li>
</ul>
<h1>文件系统优化</h1>
<p>btrfs 和 overlayfs 可以加速 git clone。</p>
<p>如果对机器进行内存标签负载均衡，可以降低构建耗时。</p>
<h1>使用git调试</h1>
<h2 id="git-diff-的输出">git diff 的输出</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">git diff<br>diff --cc hello.rb<br>index 0399cd5,59727f0..0000000<br>--- a/hello.rb<br>+++ b/hello.rb<br>@@@ -1,7 -1,7 +1,11 @@@<br>  <span class="hljs-comment">#! /usr/bin/env ruby</span><br><br>  def hello<br>++&lt;&lt;&lt;&lt;&lt;&lt;&lt; <span class="hljs-string">HEAD</span><br><span class="hljs-string"> +  puts &#x27;hola world&#x27;</span><br><span class="hljs-string">++=======</span><br><span class="hljs-string">+   puts &#x27;hello mundo&#x27;</span><br><span class="hljs-string">++&gt;&gt;&gt;&gt;&gt;&gt;&gt; mundo</span><br><span class="hljs-string">  end</span><br><span class="hljs-string"></span><br><span class="hljs-string">  hello()</span><br></code></pre></td></tr></table></figure>
<p>这段 Git 输出是使用 git diff 命令生成的，它显示了文件 hello.rb 在版本控制中的不同版本之间的差异。这里的输出显示了一个合并冲突（merge conflict），这通常发生在尝试合并两个分支时，如果两个分支在相同的文件的相同部分有冲突的更改。</p>
<p>下面是输出的逐行解释：</p>
<ol>
<li><code>diff --cc hello.rb</code>：这是 Git 使用的颜色冲突（cc）diff 格式，用于显示文件 hello.rb 中的合并冲突。</li>
<li><code>index 0399cd5,59727f0..0000000</code>：这行显示了冲突发生时的索引状态。0399cd5 和 59727f0 是冲突发生前两个不同版本的 SHA-1 哈希值，而 0000000 表示当前工作区的版本-0000000 通常表示一个合并冲突的状态。在这种情况下，它并不代表一个实际的提交哈希，而是一个占位符，表示当前文件处于未解决的冲突状态-在 Git 中，0000000 是一个特殊的哈希值，表示空对象或不存在的对象。</li>
<li><code>--- a/hello.rb</code>：这表示冲突发生前的一个版本-旧版本。</li>
<li><code>+++ b/hello.rb</code>：这表示当前工作区中的版本-新版本。</li>
<li><code>@@@ -1,7 -1,7 +1,11 @@@</code>：这是 diff 的统一格式，显示了冲突发生的位置。-1,7 表示在旧版本中从第1行到第7行，-1,7 表示在新版本（另一个合并分支）中也是从第1行到第7行，<strong>+1,11 表示在当前工作区中从第1行到第11行</strong>。- 符号表示旧版本中的行范围。+ 符号表示**新版本（当前工作区）**中的行范围。在合并冲突的情况下，Git 会在文件中插入冲突标记，这些标记会导致行数增加。因此，合并后的行数（+1,11）通常大于或等于原始行数（-1,7 和 -1,7），因为冲突标记占用了额外的行。</li>
<li><code>#! /usr/bin/env ruby</code>：这是 Ruby 脚本的 shebang 行，告诉系统这个文件应该用 Ruby 来执行。</li>
<li><code>def hello</code>：这是 Ruby 方法的定义。</li>
<li><code>+&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code>：这是 Git 合并冲突的标记（marker），表示接下来的代码块是 HEAD（当前分支）中的版本。</li>
<li><code>+  puts 'hola world'</code>：这是 HEAD 分支中的代码，打印 “hola world”。</li>
<li><code>+=======</code>：这是 Git 合并冲突的分隔符，表示接下来的代码块是另一个分支中的版本。</li>
<li><code>+  puts 'hello mundo'</code>：这是另一个分支中的代码，打印 “hello mundo”。</li>
<li><code>+&gt;&gt;&gt;&gt;&gt;&gt;&gt; mundo</code>：这是 Git 合并冲突的结尾标记，表示另一个分支的代码块结束。</li>
<li><code>end</code>：这是 Ruby 方法的结束。</li>
</ol>
<p>在正常合并的情况下，顶部（&lt;&lt;&lt;&lt;&lt;&lt;&lt;）显示您的本地更改，而底部（&gt;&gt;&gt;&gt;&gt;&gt;&gt;）显示项目上游所做的更改。当在尝试重新定基期间发生冲突时，顶部将显示您的上游更改，而底部显示主题分支更改。</p>
<p>要解决这个合并冲突，你需要决定保留哪个版本的代码，或者合并两个版本的代码。一旦你解决了冲突，你需要使用 git add 命令来标记文件为已解决，然后可以继续合并操作或者提交更改。</p>
<h2 id="文件标注-类似idea里的annotate-或者我们常说的-blame">文件标注（类似idea里的annotate，或者我们常说的 blame）</h2>
<p>元数据的三大要素：作者、时间和提交hash。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 以下示例用 git blame 确定了 Linux 内核源码顶层的 Makefile 中每一行分别来自哪个提交和提交者， 此外用 -L 选项还可以将标注的输出限制为该文件中的第 69 行到第 82 行。</span><br>git blame -L 69,82 Makefile<br><br><span class="hljs-comment"># 会多一列显示文件名，这样就能知道文件移动</span><br>git blame -C -L 141,153 GITPackUpload.m<br></code></pre></td></tr></table></figure>
<h2 id="搜索">搜索</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查找仓库里的文件，在实践中我们发现没有办法查找历史中的文件</span><br><span class="hljs-comment"># 在 Git 仓库的所有文件中搜索包含字符串 &#x27;whereas&#x27; 的行，并显示这些行的文件名和行号。</span><br>git grep -n <span class="hljs-string">&#x27;whereas&#x27;</span><br><span class="hljs-comment"># 查找哪个提交引入了 whereas</span><br><span class="hljs-comment"># 查找 Git 历史记录中所有包含字符串 &#x27;whereas&#x27; 的提交，并以简洁的单行格式显示每个提交的哈希值和提交信息。</span><br><span class="hljs-comment"># -S &#x27;whereas&#x27;：搜索包含 &#x27;whereas&#x27; 字符串的提交（包括添加、删除或修改该字符串的提交）。</span><br><span class="hljs-comment"># --oneline：以简洁的单行格式显示每个提交。</span><br>git <span class="hljs-built_in">log</span> -S whereas --oneline<br><span class="hljs-comment"># 查找有多少个文件有这个单词</span><br><span class="hljs-comment"># 统计 Git 仓库中所有文件包含字符串 &#x27;whereas&#x27; 的总次数。</span><br><span class="hljs-comment"># --count：仅显示每个文件中匹配行的总数，而不是具体的行内容。</span><br>git grep --count whereas<br><br><span class="hljs-comment"># 从这里开始 git 开始了解程序函数结构了</span><br><br><span class="hljs-comment"># 可以传入 -p 或 --show-function 选项来显示每一个匹配的字符串所在的方法或函数：</span><br><span class="hljs-comment"># 在当前目录及其子目录下所有 .c 文件中搜索包含字符串 &#x27;whereas&#x27; 的行，并显示匹配行的上下文以及文件名和行号。</span><br><span class="hljs-comment"># -p：显示匹配行的上下文（前后几行），有助于理解代码的上下文。</span><br>git grep -p whereas *.c<br><span class="hljs-comment"># 例如，假设我们想查看 zlib.c 文件中 git_deflate_bound 函数的每一次变更， 我们可以执行 git log -L :git_deflate_bound:zlib.c。 Git 会尝试找出这个函数的范围，然后查找历史记录，并且显示从函数创建之后一系列变更对应的补丁。</span><br><span class="hljs-comment"># 跟踪 Git 历史记录中 zlib.c 文件中 git_deflate_bound 函数的所有修改历史。</span><br><span class="hljs-comment"># -L :git_deflate_bound:zlib.c：指定要跟踪的函数名和文件名。Git 会分析该函数在文件中的所有修改，并显示相关的提交信息。</span><br>git <span class="hljs-built_in">log</span> -L :git_deflate_bound:zlib.c<br></code></pre></td></tr></table></figure>
<h2 id="二分查找">二分查找</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 启动</span><br>git bisect start<br><span class="hljs-comment"># 告诉系统当前你所在的提交是有问题的</span><br>git bisect bad<br><span class="hljs-comment"># 告诉 bisect 已知的最后一次正常状态是哪次提交</span><br>git bisect good v1.0<br><br><span class="hljs-comment"># Git 发现在你标记为正常的提交（v1.0）和当前的错误版本之间有大约12次提交，于是 Git 检出中间的那个提交。 现在你可以执行测试，看看在这个提交下问题是不是还是存在。 </span><br><span class="hljs-comment"># 这里的6就是中间提交已被检出的意思</span><br>Bisecting: 6 revisions left to <span class="hljs-built_in">test</span> after this<br>[ecb6e1bc347ccecc5f9350d878ce677feb13d3b2] error handling on repo<br><br><span class="hljs-comment"># 假如这时候系统是没问题的</span><br>git bisect good<br><br>Bisecting: 3 revisions left to <span class="hljs-built_in">test</span> after this<br>[b047b02ea83310a70fd603dc8cd7a6cd13d15c04] secure this thing<br><br><span class="hljs-comment"># 现在你在另一个提交上了，这个提交是刚刚那个测试通过的提交和有问题的提交的中点。 你再一次执行测试，发现这个提交下是有问题的，因此你可以通过 git bisect bad 告诉 Git：</span><br>git bisect bad<br><br><span class="hljs-comment"># 最终输出</span><br><span class="hljs-comment"># 这一步命令似乎没有用</span><br>git bisect good<br>b047b02ea83310a70fd603dc8cd7a6cd13d15c04 is first bad commit<br><br><span class="hljs-comment"># 重置 HEAD</span><br>git bisect reset<br><br><span class="hljs-comment"># 这是一个可以帮助你在几分钟内从数百个提交中找到 bug 的强大工具。 事实上，如果你有一个脚本在项目是正常的情况下返回 0，在不正常的情况下返回非 0，你可以使 git bisect 自动化这些操作。 首先，你设定好项目正常以及不正常所在提交的二分查找范围。 你可以通过 bisect start 命令的参数来设定这两个提交，第一个参数是项目不正常的提交，第二个参数是项目正常的提交：</span><br>git bisect start HEAD v1.0<br>git bisect run test-error.sh<br></code></pre></td></tr></table></figure>
<h1>工作流</h1>
<p>本文一部分也参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/sunyctf/article/details/130587970">《Git之GitFlow工作流 | Gitflow Workflow（万字整理，已是最详）》</a>、<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1646937">《一文弄懂 Gitflow、Github flow、Gitlab flow 的工作流》</a>。</p>
<p>git 的横空出世改变了人们对<strong>分支和合并的想法</strong>。在其他工具里，分支和合并在工具书的最后一章，像要咬人一样。而 git 则把分支和合并放在第三章，因为这些操作非常廉价：</p>
<ul>
<li>Git的分支是非常轻量级的，因为它们本质上只是指向提交对象的指针。这使得创建和删除分支非常快速且占用资源少。</li>
<li>在Git中，分支操作几乎是瞬时的，不需要复制文件或目录。</li>
</ul>
<p>相比之下：</p>
<ul>
<li>CVS的分支和合并操作相对复杂且容易出错，因为它依赖于文件锁和手动合并。</li>
<li>SVN的分支是通过复制整个目录结构实现的，这使得分支操作相对笨重。虽然SVN改进了合并支持（如合并信息记录），但合并过程仍然可能涉及大量手动干预。</li>
<li>Perforce的分支模型较为复杂，通常需要更多的配置和管理。合并操作可能涉及复杂的工作流和权限管理。</li>
</ul>
<blockquote>
<p>Git really changed the way developers think of merging and<br>
branching。git 提倡本地分支，git 提倡分支间合并。For example, in CVS/Subversion books,<br>
branching and merging is first discussed in the later chapters (for<br>
advanced users), while in every Git book, it’s already covered in<br>
chapter 3 (basics).</p>
</blockquote>
<p>常见的工作流都是流水的形式，比喻项目像水流那样，顺畅、自然地向前流动，不会发生冲击、对撞、甚至漩涡，而且都采用”功能驱动式开发”（Feature-driven development，简称FDD）。</p>
<p><img src="lr-branches-2.png" alt="分支工作流"></p>
<p>master 通常落后于其他分支，分支的滞后意味着稳定（<strong>稳定的代价就是落后</strong>）。</p>
<p><img src="remote-branches-1.png" alt="最开始的远端分支和本地分支的commitid是一样的"></p>
<h2 id="gitflow">GitFlow</h2>
<p>互联网企业的 GitFlow 工作流的起源在<a target="_blank" rel="noopener" href="https://nvie.com/posts/a-successful-git-branching-model/">《A successful Git branching model》</a>。我们应该为了多版本同时开发、并存、更新而使用这个模型，如果像web发布一样使用发布代替回滚，则不需要这个模型（这个模式是基于”版本发布”的，目标是一段时间以后产出一个新版本。但是，很多网站项目是”持续发布”，代码一有变动，就部署一次。这时，master分支和develop分支的差别不大，没必要维护两个长期分支。）。</p>
<blockquote>
<p>这个模型诞生于2010年，距今已逾十载，而Git本身诞生的时间也不过稍早一些。在这十年间，git-flow（本文所述的分支模型）在众多软件团队中广受欢迎，甚至被视为某种标准——可惜的是，有些人将其奉为圭臬或万灵药。</p>
<p>这十年里，Git如旋风般席卷全球，而在我所处的圈子里，使用Git开发的软件类型也逐渐偏向网络应用。这类应用通常采用持续交付模式，很少回滚，也无需支持多个版本同时运行。</p>
<p>这与我十年前撰文时所设想的软件类型大相径庭。如果你的团队正在进行软件的持续交付，我建议采用更为简洁的工作流程（如<a target="_blank" rel="noopener" href="https://docs.github.com/en/get-started/using-github/github-flow">GitHub flow</a>），而非勉强将git-flow硬塞进你的团队。</p>
<p>然而，如果你正在开发需要明确版本的软件，或者需要同时支持多个版本，那么git-flow或许仍然是最适合你团队的选择，就像过去十年里它帮助过无数开发者一样。若是如此，请继续阅读下文。</p>
<p>最后，请始终牢记：世上没有包治百病的良方。审视你自身的处境，保持开放的心态，做出自己的判断。</p>
</blockquote>
<p><img src="git-model.png" alt="git-model"></p>
<p>develop 是 feature 分支的起源，release 分支是 develop 到 master 的缓冲。feature 在合并以前都是半成品，branch out 隔离了两条主干。</p>
<p><img src="main-branches.png" alt="main-branches"></p>
<table>
<thead>
<tr>
<th style="text-align:center">分支名称</th>
<th style="text-align:center">分支说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Production</td>
<td style="text-align:center">生产分支，即 Master分支。只能从其他分支合并，不能直接修改</td>
</tr>
<tr>
<td style="text-align:center">Release</td>
<td style="text-align:center">发布分支，<strong>基于 Develop 分支创建，待发布完成后合并到 Develop 和 Production 分支去</strong></td>
</tr>
<tr>
<td style="text-align:center">Develop</td>
<td style="text-align:center">主开发分支，包含所有要发布到下一个 Release 的代码，该分支主要合并其他分支内容</td>
</tr>
<tr>
<td style="text-align:center">Feature</td>
<td style="text-align:center">新功能分支，基于 Develop 分支创建，开发新功能，待开发完毕合并至 Develop 分支</td>
</tr>
<tr>
<td style="text-align:center">Hotfix</td>
<td style="text-align:center">修复分支，基于 Production 分支创建，待修复完成后合并到 Develop 和 Production 分支去，同时在 Master 上打一个tag</td>
</tr>
</tbody>
</table>
<h3 id="分支">分支</h3>
<h4 id="主分支">主分支</h4>
<p><img src="%E4%B8%BB%E5%88%86%E6%94%AF.png" alt="主分支"></p>
<p>The central repo holds two main branches with an infinite lifetime:</p>
<ul>
<li>master-用于生产发布的分支</li>
<li>develop-用于集成构建的分支，这个分支是最繁忙的分支，从 master拉取，<strong>所有其他分支都往她这里 merge back，而且除了 hotfix，全部分支都 branch off 这个分支</strong>。hotfix 不从 develop 拉取是因为 develop 拥有未经验证的 feature。</li>
</ul>
<p>这两个分支最好永远处于<strong>可编译、可运行状态</strong>。develop分支将包含项目的所有历史，而master会是一个缩减版本。</p>
<p>We consider origin/master to be the main branch where the source code of HEAD always reflects a production-ready state.我们认为origin/master主分支中的源代码 HEAD始终反映出可用于生产的状态。</p>
<p>任何人不允许在主要分支上进行代码的直接提交，只接受其他分支的合入。原则上主要分支上的代码必须是合并自经过多轮测试及已经发布一段时间且线上稳定的预发分支。master 分支只存放历史发布(release)版本的源代码。即用于存放对外发布的版本，任何时候在这个分支获取到的<strong>都是稳定的已发布的版本</strong>。各个版本通过 tag 来标记。</p>
<p>We consider origin/develop to be the main branch where the source code of HEAD always reflects a state with the latest delivered development changes for the next release. 我们认为origin/develop这是主分支，其中的源代码 HEAD始终反映出为下一版本提供的最新开发更改的状态。有些人称之为“集成分支”。任何自动夜间构建都是从这里构建的。</p>
<p>开发分支是主开发分支，其上更新的代码始终反映着下一个发布版本需要交付的新功能。当开发分支到达一个稳定的点并准备好发布时，应该从该点拉取一个预发分支并附上发布版本号。也有人称开发分支为集成分支，因为会基于该分支和持续集成工具做自动化的构建。</p>
<p>在有些方法论里，这两个分支是不能被主动修改，只应该被合并的，但有些示例里，有人在 develop 里做新的提交：</p>
<p><img src="gitflow.png" alt="gitflow"></p>
<h4 id="支持分支">支持分支</h4>
<p>Next to the main branches master and develop, our development model uses a variety of supporting branches to aid parallel development between team members, ease tracking of features, prepare for production releases and to assist in quickly fixing live production problems. Unlike the main branches, these branches always have a limited life time, since they will be removed eventually.</p>
<p>除了主分支 master 和 develop 之外，我们的开发模型还使用各种支持分支来帮助团队成员之间的并行开发、简化功能跟踪、为生产发布做准备并帮助快速修复实时生产问题。与主分支不同，这些分支的生命周期始终有限，因为它们最终将被删除。</p>
<ul>
<li>Feature branches</li>
<li>Release branches</li>
<li>Hotfix branches</li>
</ul>
<p>Each of these branches have a specific purpose and are bound to strict <strong>rules as</strong> to which branches may be their originating branch and which branches must be their merge targets. 这些分支中的每一个都有特定的用途，并且必须遵守严格的规则，即哪些分支可以是它们的起源分支，哪些分支必须是它们的合并目标。</p>
<p>我们常见的对 gitflow 的错误使用是没有在 release 和 hotfix 上打标签的习惯，这让这两个分支的功能性减弱了很多。</p>
<p>他们的存在是为了解决特定的问题而<strong>进行的各种开发活动</strong>。与主分支不同，这些分支总是有有限的生命时间，都<strong>可删除</strong>。</p>
<h5 id="特性分支">特性分支</h5>
<p>Feature branches (or sometimes called topic branches) are used to develop new features for the upcoming or a distant future release. When starting development of a feature, the target release in which this feature will be incorporated may well be unknown at that point. The essence of a feature branch is that it exists as long as the feature is in development, but will eventually be merged back into develop (to definitely add the new feature to the upcoming release) or discarded (in case of a disappointing experiment).功能分支（有时称为主题分支）用于为即将发布或遥远的未来版本开发新功能。开始开发某个功能时，该功能将包含在哪个目标版本中可能还不得而知。功能分支的本质是，只要该功能处于开发阶段，它就会存在，但最终会被合并回去 develop （以明确将新功能添加到即将发布的版本中）或丢弃（以防实验令人失望）。</p>
<p>Feature branches typically exist in developer repos only, not in origin.<strong>功能分支通常仅存在于开发人员存储库中，而不存在于origin。</strong></p>
<p>May branch off from:<br>
<code>develop</code><br>
Must merge back into:<br>
<code>develop</code><br>
Branch naming convention:<br>
anything except <code>master</code>, <code>develop</code>, <code>release-*</code>, or <code>hotfix-*</code></p>
<p>开发团队大部分时候做的是从 master 直接拉取 feature，而标准的工作流是从某个特定的 tag 拉取 develop，然后从 develop 拉取 feature。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Creating a feature branch ¶</span><br>$ git checkout -b myfeature develop<br>Switched to a new branch <span class="hljs-string">&quot;myfeature&quot;</span><br><br><span class="hljs-comment"># Incorporating a finished feature on develop </span><br>$ git checkout develop<br><br><span class="hljs-comment"># 原博客这里漏了很关键的一步：第一条命令确保了本地的develop分支拥有最新的代码——这一步必须在将功能代码合并之前做</span><br>$ git pull origin develop<br><br>Switched to branch <span class="hljs-string">&#x27;develop&#x27;</span><br><span class="hljs-comment"># The --no-ff flag causes the merge to always create a new commit object, even if the merge could be performed with a fast-forward. </span><br><span class="hljs-comment"># --no-ff 可以创建一个显式的合并提交</span><br>$ git merge --no-ff myfeature<br>Updating ea1b82a..05e9557<br>(Summary of changes)<br>$ git branch -d myfeature<br>Deleted branch myfeature (was 05e9557).<br>$ git push origin develop<br></code></pre></td></tr></table></figure>
<p>在这里都是让 develop merge feature，而不是反过来，这样 develop 不会污染 feature，很多时候我们的 feature 是受其他 feature 的影响的，所以又有必要经常 merge from develop，这是这个地方被忽略的。</p>
<p>合并完就可以删除 feature 分支了，而不是发布以后。</p>
<h6 id="使用-no-ff-的好处">使用 --no-ff 的好处</h6>
<p>The --no-ff flag causes the merge to always create a new commit object, even if the merge could be performed with a fast-forward. This avoids losing information about the historical existence of a feature branch and groups together all commits that together added the feature. 该–no-ff标志使合并始终创建新的提交对象，即使合并可以通过快进执行。这避免了丢失有关功能分支历史存在的信息，并将所有共同添加该功能的提交分组在一起。比较：</p>
<p><img src="merge-without-ff.png" alt="merge-without-ff"></p>
<p>在后一种情况下，无法从 Git 历史记录中看到哪些提交对象一起实现了某个功能 — 您必须手动读取所有日志消息。在后一种情况下，恢复整个功能（即一组提交）确实是一件令人头疼的事情，而如果 --no-ff使用该标志，则可以轻松完成。</p>
<p>是的，它会创建更多（空）的提交对象，但收益远远大于成本。</p>
<p>结论：<strong>如果单分支开发 merge，尽量快进合并-甚至使用 rebase；如果跨分支合并，在会删除feature的情况下，保留一个 merge commit 是好的</strong>-在回滚的时候尤其如此。</p>
<p>比较痛苦的是多个开发者使用同一个特性分支，这会产生大量的 <strong>merge commit</strong>：<code>Merge branch 'feature/20241218_aaa' into feature/20241218_bbb</code>。</p>
<p>假设有ab两个人往 origin 同一个分支开发：a 先 pull，得到一个 commit，消息是 <code>Merge branch 'origin/feature/aaa' into feature/aaa</code>，然后产生一个 merge commit，然后再 push 到 origin 的时候，另一个人再pull，就会产生另一个 commit，消息也是<code>origin/feature/aaa' into feature/aaa</code>，<strong>这里面的本地分支其实是不一样的，但在 origin 的 git log 里看不出来</strong>。</p>
<h5 id="发布分支">发布分支</h5>
<p>在有的中文翻译里这是<strong>预发分支</strong>。</p>
<p>May branch off from:<br>
<code>develop</code><br>
Must merge back into:<br>
<code>develop</code> and <code>master</code> <strong>可以往两个长期分支合并</strong><br>
Branch naming convention:<br>
<code>release-*</code></p>
<p>发布分支支持准备新的生产版本。它们允许在最后一刻进行细枝末节的完善。此外，它们还允许<strong>修复小错误</strong>并<strong>为版本准备元数据</strong>（版本号、构建日期等）。<strong>通过在发布分支上完成所有这些工作，该develop 分支就可以接收下一个大版本的功能</strong>。</p>
<p>bugfix 在release 上而不是在 feature 上是很多公司会忽略的事情，很多研发人员会直接在 feature 上 fix 而不是在 release 上 fix，这样 release 只是测试用，而合并回 master 的是 feature-这样就让 feature 对 master 的影响更大了。</p>
<p>从 develop 中生成（branch out）出新发布分支的关键时刻是当开发（几乎）反映了新发布所需的状态时。至少所有针对即将构建的发布的功能都必须在此时合并进 develop 。所有针对未来发布的功能可能不会合并 - 它们必须等到生成发布分支之后。</p>
<p>正是在发布分支开始时，即将发布的版本才会被分配一个版本号 — 而不是更早。在此之前，分支develop 反映了“下一个版本”的变化，但在发布分支启动之前，尚不清楚“下一个版本”最终会是 0.3 还是 1.0。该决定是在发布分支开始时做出的，并由项目的版本号提升规则执行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建发布分支</span><br><span class="hljs-comment"># 基于 develop 分支创建并切换到一个新的分支 release-1.2。</span><br>$ git checkout -b release-1.2 develop<br>Switched to a new branch <span class="hljs-string">&quot;release-1.2&quot;</span><br><br><span class="hljs-comment"># release 分支比develop多的第一件事</span><br>$ ./bump-version.sh 1.2<br><span class="hljs-comment"># # release 分支比develop多的第二件事</span><br>$ git commit -a -m <span class="hljs-string">&quot;Bumped version number to 1.2&quot;</span><br>[release-1.2 74d9424] Bumped version number（提升版本号） to 1.2<br>1 files changed, 1 insertions(+), 1 deletions(-)<br><br><span class="hljs-comment"># 完成发布分支</span><br><span class="hljs-comment"># 切换到分支 &#x27;master&#x27; </span><br>$ git checkout master<br><br><span class="hljs-comment"># 记住，因为根据定义master， 上的每个提交都是一个新发布</span><br>$ git merge --no-ff release-1.2<br><span class="hljs-comment"># 必须标记 上的提交，以便将来轻松引用此历史版本</span><br>$ git tag -a 1.2<br><br>$ git checkout develop<br>$ git merge --no-ff release-1.2<br><br><span class="hljs-comment"># 在两个 merge 以后，删除</span><br>$ git branch -d release-1.2<br></code></pre></td></tr></table></figure>
<p>可以说 feature 的分支名带有功能名，而 release 分支带有版本号。</p>
<p>测试在 release 上做，fix 在 release 上做，merge 回 develop-<strong>为什么不merge 回 feature？因为feature 分支在上一步删除了</strong>。</p>
<blockquote>
<p>release分支不是一个放正式发布产品的分支，你可以将它理解为“待发布”分支。</p>
<p>我们用这个分支干所有和发布有关的事情，比如：</p>
<ol>
<li>把这个分支打包给测试人员测试</li>
<li>在这个分支里修复bug</li>
<li>编写发布文档</li>
</ol>
<p>所以，在这个分支里面绝对不会添加新的特性。</p>
<p>当和发布相关的工作都完成后，release分支合并回develop和master分支。</p>
<p>单独搞一个release分支的好处是，<strong>当一个团队在做发布相关的工作时，另一个团队则可以接着开发下一版本的东西</strong>。</p>
</blockquote>
<p>并行开发的精髓就在于并行 feature、release单独做版本，而且 merge back into develop（经常被人忽略）。但是<strong>并行开发的时候，发布是串行的</strong>，每次应该只有一个 release 版本的 develop 发布到 master，<strong>在 release 生成以后，在 release 发布完以前，应该冻结其他 release 的生成</strong>。</p>
<h5 id="热修复分支">热修复分支</h5>
<p>May branch off from:<br>
<code>master</code><br>
Must merge back into:<br>
<code>develop</code> and <code>master</code> <strong>可以往两个长期分支合并</strong><br>
Branch naming convention:<br>
<code>hotfix-*</code></p>
<p>热修复分支与发布分支非常相似，因为它们也是为新生产版本做准备，尽管是计划外的。它们产生于对实时生产版本不良状态立即采取行动的必要性。当必须立即解决生产版本中的关键错误时，可以从标记生产版本的主分支上的<strong>相应标签中</strong>分支出热修复分支-从特定的标签中拉取分支是多版本可运行的管理方法，而现代的 web 开发使用前滚来代替回滚，总是从最新版本拉取hotfix和develop。</p>
<p>本质（essence）是团队成员（在develop分支上）的工作可以继续，而另一个人正在准备快速生产修复。</p>
<p><img src="hotfix-branches.png" alt="hotfix-branches"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout -b hotfix-1.2.1 master<br><span class="hljs-comment"># 增加2个修复操作</span><br><br><span class="hljs-comment"># Don’t forget to bump the version number after branching off!</span><br>$ ./bump-version.sh 1.2.1<br>$ git commit -a -m <span class="hljs-string">&quot;Bumped version number to 1.2.1&quot;</span><br>$ git commit -m <span class="hljs-string">&quot;Fixed severe production problem&quot;</span><br><br>$ git checkout master<br>Switched to branch <span class="hljs-string">&#x27;master&#x27;</span><br>$ git merge --no-ff hotfix-1.2.1<br>Merge made by recursive.<br>(Summary of changes)<br>$ git tag -a 1.2.1<br><br>$ git checkout develop<br><span class="hljs-comment"># 无论如何，不要忘记把修复合并进 develop</span><br>$ git merge --no-ff hotfix-1.2.1<br><br>$ git branch -d hotfix-1.2.1<br></code></pre></td></tr></table></figure>
<p>hotfix 分支也是带有分支名的。</p>
<p>此处规则的一个例外是， 当当前存在发布分支时，修补程序更改需要合并到该发布分支，而不是develop。将错误修复合并到发布分支最终会导致 develop 在发布分支完成时将错误修复也合并到。如果develop立即需要此错误修复并且不能等待发布分支完成，现在您也可以安全地将错误修复合并到develop。</p>
<h3 id="工具推荐">工具推荐</h3>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sunyctf/article/details/130587970">GitFlow 工具推荐 | 配套工具</a>：这里面命令行和 SourceTree 可能启发了别的工具，比如腾讯的 leflow。</p>
<h2 id="githubflow">GitHubFlow</h2>
<p><img src="GitHubFlow.png" alt="GitHubFlow"></p>
<blockquote>
<p>在以前，“fork”是一个贬义词，指的是某个人使开源项目向不同的方向发展，或者创建一个竞争项目，使得原项目的贡献者分裂。 在  GitHub，“fork”指的是你自己的空间中创建的项目副本，这个副本允许你以一种更开放的方式对其进行修改。</p>
</blockquote>
<p>GitHubFlow 只有 master 和其他分支，合并都是通过 PR，不做任何隔离分支-这是大部分公司的最常见的<strong>工作模式</strong>。</p>
<ol>
<li>派生一个项目</li>
<li>从 master 分支创建一个新分支</li>
<li>提交一些修改来改进项目</li>
<li>将这个分支推送到 GitHub 上</li>
<li>创建一个拉取请求</li>
<li>讨论，根据实际情况继续修改</li>
<li>项目的拥有者合并或关闭你的拉取请求</li>
<li>将更新后的 master 分支同步到你的派生中</li>
</ol>
<blockquote>
<p>Github flow 的最大优点就是简单，对于”持续发布”的产品，可以说是最合适的流程。</p>
<p>问题在于它的假设：master分支的更新与产品的发布是一致的。也就是说，master分支的最新代码，默认就是当前的线上代码。</p>
<p>可是，有些时候并非如此，代码合并进入master分支，并不代表它就能立刻发布。比如，苹果商店的APP提交审核以后，等一段时间才能上架。这时，如果还有新的代码提交，master分支就会与刚发布的版本不一致。另一个例子是，有些公司有发布窗口，只有指定时间才能发布，这也会导致线上版本落后于master分支。</p>
<p>上面这种情况，只有master一个主分支就不够用了。通常，你不得不在master分支以外，另外新建一个production分支跟踪线上版本。</p>
</blockquote>
<h3 id="merge-request-vs-pull-request">merge request vs pull request</h3>
<p>from gitlab’s perspective：</p>
<blockquote>
<p>Merge or pull requests are created in a git management application and ask an assigned person to merge two branches. Tools such as GitHub and Bitbucket choose the name pull request since the first manual action would be to pull the feature branch. Tools such as GitLab and Gitorious choose the name merge request since that is the final action that is requested of the assignee. In this article we’ll refer to them as merge requests.</p>
</blockquote>
<p>我们常说的维护者就是 assigned person。pull request 是命名自 first manual action（pull），而 merge request 则命名自  the final action that is requested of the assignee，本质上这都是 ask an assigned person to merge two branches。</p>
<p>但从实战来讲，pr 是从 fork repo merge 到 upstream repo，mr 则是在同一个 repo 里 merge。虽然这并不是这两个操作唯一的使用场景。我们可以在所有场景下使用 merge request，正如下面的例子一样：</p>
<blockquote>
<p>In my point of view, they mean the same activity but from different perspectives:</p>
<p>Think about that, Alice makes some commits on repository A, which was forked from Bob’s repository B.</p>
<p>When Alice wants to “merge” her changes into B, she actually wants Bob to “pull” these changes from A.</p>
<p>Therefore, from Alice’s point of view, it is a “merge request”, while Bob views it as a “pull request”.</p>
</blockquote>
<p>中文的解释：</p>
<blockquote>
<p>很多人可能会问，提交代码通常是commit或者push，拉取代码才是pull，为什么GitHubFlow中提交代码提出的是“Pull<br>
Request”。因为在GitHubFlow中，PR是通知其他人员到你的代码库去拉取代码至本地，然后由他们进行最终的提交，所以用“pull”而非“push”。<br>
前面说过，Pull Request本质是一种对话机制，你可以在提交的时候，@相关人员或团队，引起他们的注意。</p>
</blockquote>
<h2 id="gitlab-flow">Gitlab flow</h2>
<p>Gitlab flow 是 Git flow 与 GitHub flow 的结合。Gitlab flow 的最大原则叫做”上游优先”（upsteam first），即只存在一个主分支master，它是所有其他分支的”上游”。只有上游分支采纳的代码变化，才能应用到其他分支。</p>
<p><img src="gitlab-flow.png" alt="gitlab-flow"></p>
<p>对于”持续发布”的项目，它建议在master分支以外，再建立不同的环境分支。比如，”开发环境”的分支是master，”预发环境”的分支是pre-production，”生产环境”的分支是production。</p>
<p>开发分支是预发分支的”上游”，预发分支又是生产分支的”上游”。代码的变化，必须由”上游”向”下游”发展。比如，生产环境出现了bug，这时就要新建一个功能分支，先把它合并到master，确认没有问题，再cherry-pick到pre-production，这一步也没有问题，才进入production。</p>
<p>只有紧急情况，才允许跳过上游，直接合并到下游分支。</p>
<p>Chromium项目就是一个例子，它明确规定，上游分支依次为：</p>
<ul>
<li>Linus Torvalds的分支</li>
<li>子系统（比如netdev）的分支</li>
<li>设备厂商（比如三星）的分支</li>
</ul>
<h3 id="版本发布">版本发布</h3>
<p><img src="gitlab-flow-deploy.png" alt="gitlab-flow-deploy"></p>
<p>对于”版本发布”的项目，建议的做法是每一个稳定版本，都要从master分支拉出一个分支，比如2-3-stable、2-4-stable等等-在这里，<strong>待发布分支就类似版本 tag</strong>。</p>
<p>以后，只有修补bug，才允许将代码合并到这些分支，并且此时要更新小版本号。</p>
<h1>搭建自己的服务端</h1>
<ol>
<li><a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-GitLab">Git - GitLab</a>。</li>
<li><a target="_blank" rel="noopener" href="https://git-scm.com/book/en/v2/Git-on-the-Server-GitWeb">基于脚本的 GitWeb</a>。</li>
<li><a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-Smart-HTTP">基于 apache 实现 smart HTTP</a>。</li>
<li><a target="_blank" rel="noopener" href="https://git.wiki.kernel.org/index.php/GitHosting">全部的 git hosting</a>。</li>
</ol>
<h1>github</h1>
<h2 id="service-and-hook">service and hook</h2>
<h3 id="service">service</h3>
<p>有许多可以选择的服务，大多数是整合到其他的商业与开源系统中。它们中的大多数是为了整合持续集成服务、BUG 与问题追踪系统、聊天室系统与文档系统。我们将会通过设置一个非常简单的例子来介绍。 如果从 “Add Service” 选择 “email”，会得到一个类似电子邮件服务配置的配置屏幕。</p>
<h3 id="hook">hook</h3>
<p>如果需要做一些更具体的事，或者想要整合一个不在这个列表中的服务或站点，可以转而使用更通用的钩子系统。 GitHub 仓库钩子是非常简单的。 指定一个 URL 然后 GitHub 在任一期望的事件发生时就会发送一个 HTTP 请求到那个 URL 。</p>
<p>这里给的例子都使用 ruby 小框架 Sinatra 来写的。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">require</span> <span class="hljs-string">&#x27;sinatra&#x27;</span><br><span class="hljs-keyword">require</span> <span class="hljs-string">&#x27;json&#x27;</span><br><span class="hljs-keyword">require</span> <span class="hljs-string">&#x27;mail&#x27;</span><br><br>post <span class="hljs-string">&#x27;/payload&#x27;</span> <span class="hljs-keyword">do</span><br>  push = <span class="hljs-variable constant_">JSON</span>.parse(request.body.read) <span class="hljs-comment"># parse the JSON</span><br><br>  <span class="hljs-comment"># gather the data we&#x27;re looking for</span><br>  pusher = push[<span class="hljs-string">&quot;pusher&quot;</span>][<span class="hljs-string">&quot;name&quot;</span>]<br>  branch = push[<span class="hljs-string">&quot;ref&quot;</span>]<br><br>  <span class="hljs-comment"># get a list of all the files touched</span><br>  files = push[<span class="hljs-string">&quot;commits&quot;</span>].map <span class="hljs-keyword">do</span> |<span class="hljs-params">commit</span>|<br>    commit[<span class="hljs-string">&#x27;added&#x27;</span>] + commit[<span class="hljs-string">&#x27;modified&#x27;</span>] + commit[<span class="hljs-string">&#x27;removed&#x27;</span>]<br>  <span class="hljs-keyword">end</span><br>  files = files.flatten.uniq<br><br>  <span class="hljs-comment"># check for our criteria</span><br>  <span class="hljs-keyword">if</span> pusher == <span class="hljs-string">&#x27;schacon&#x27;</span> &amp;&amp;<br>     branch == <span class="hljs-string">&#x27;ref/heads/special-branch&#x27;</span> &amp;&amp;<br>     files.<span class="hljs-keyword">include</span>?(<span class="hljs-string">&#x27;special-file.txt&#x27;</span>)<br><br>    <span class="hljs-title class_">Mail</span>.deliver <span class="hljs-keyword">do</span><br>      from     <span class="hljs-string">&#x27;tchacon@example.com&#x27;</span><br>      to       <span class="hljs-string">&#x27;tchacon@example.com&#x27;</span><br>      subject  <span class="hljs-string">&#x27;Scott Changed the File&#x27;</span><br>      body     <span class="hljs-string">&quot;ALARM&quot;</span><br>    <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>
<h1>子模块</h1>
<p>有种情况我们经常会遇到：某个工作中的项目需要包含并使用另一个项目。 也许是第三方库，或者你独立开发的，用于多个父项目的库。 现在问题来了：<strong>你想要把它们当做两个独立的项目，同时又想在一个项目中使用另一个</strong>。</p>
<p>我们举一个例子。 假设你正在开发一个网站然后创建了 Atom 订阅。 你决定使用一个库，而不是写自己的 Atom 生成代码。 你可能不得不通过 CPAN 安装或 Ruby gem 来包含共享库中的代码，或者将源代码直接拷贝到自己的项目中。</p>
<p>如果将这个库包含进来，那么无论用何种方式都很难定制它，部署则更加困难，因为你必须确保每一个客户端都包含该库。 如果将代码复制到自己的项目中，那么你做的任何自定义修改都会使合并上游的改动变得困难。</p>
<p>Git 通过子模块来解决这个问题。 子模块允许你将一个 Git 仓库作为另一个 Git 仓库的子目录。 <strong>它能让你将另一个仓库克隆到自己的项目中，同时还保持提交的独立</strong>-各提交各的，我不提交你的。</p>
<p><strong>submodule像是源码级别的 lib，对他人项目的使用不是通过库链接，而是通过源码</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git submodule add https://github.com/chaconinc/DbConnector<br></code></pre></td></tr></table></figure>
<p>这会改写<code>.gitmodules</code>文件，内容通常是：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[submodule &quot;DbConnector&quot;]</span> <br>  <span class="hljs-attr">path</span> = DbConnector从根目录开始的相对路径   <br>  <span class="hljs-attr">url</span> = https://github.com/chaconinc/DbConnector<br></code></pre></td></tr></table></figure>
<p>这样产生的项目在一般的 clone 里是没有子模块内容，而空有目录的，需要执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">git submodule init<br>git submodule update<br><br><span class="hljs-comment"># 或者这样</span><br>git <span class="hljs-built_in">clone</span> --recurse-submodules https://github.com/chaconinc/MainProject<br></code></pre></td></tr></table></figure>
<p>然后在子模块目录中运行<code>git fetch</code>和<code>git merge origin/master</code></p>
<h1>底层与上层命令</h1>
<h2 id="四大关键目录">四大关键目录</h2>
<p>从根本上来讲 Git 是一个内容寻址（content-addressable）文件系统，并在此之上提供了一个版本控制系统的用户界面。 马上你就会学到这意味着什么。</p>
<p>早期的 Git（主要是 1.5 之前的版本）的用户界面要比现在复杂的多，因为它更侧重于作为一个文件系统，而不是一个打磨过的版本控制系统。 不时会有一些陈词滥调抱怨早期那个晦涩复杂的 Git 用户界面；不过最近几年来，它已经被改进到不输于任何其他版本控制系统地清晰易用了。</p>
<p>本书主要涵盖了 <strong>checkout、branch、remote 等约 30 个 Git 的子命令</strong>。 然而，由于 Git 最初是一套面向版本控制系统的工具集，而不是一个完整的、用户友好的版本控制系统， 所以它还包含了一部分用于完成底层工作的子命令。 这些命令被设计成能以 UNIX 命令行的风格连接在一起，抑或藉由脚本调用，来完成工作。 这部分命令一般被称作“底层（plumbing）”命令，而那些更友好的命令则被称作“上层（porcelain）”命令。</p>
<p>我们常见的 .git 文件夹内的目录有：</p>
<p>COMMIT_EDITMSG<br>
FETCH_HEAD<br>
HEAD<br>
MERGE_RR<br>
ORIG_HEAD<br>
config<br>
description<br>
hooks<br>
index<br>
info<br>
logs<br>
objects<br>
packed-refs<br>
refs<br>
rr-cache</p>
<p>不重要的目录：</p>
<ul>
<li>escription 文件仅供 GitWeb 程序使用，我们无需关心。</li>
<li>config 文件包含项目特有的配置选项。
<ul>
<li>[core]</li>
<li>[submodule]</li>
<li>[remote “origin”]
<ul>
<li>url = <a href="mailto:git@git.xx.com">git@git.xx.com</a>:groupa/projecta.git</li>
<li>fetch = +refs/heads/<em>:refs/remotes/origin/</em></li>
</ul>
</li>
<li>[branch “feature/migrate-to-spring”]
<ul>
<li>remote = origin</li>
<li>merge = refs/heads/feature/migrate-to-spring</li>
<li>vscode-merge-base = origin/master</li>
</ul>
</li>
<li>[pull]
<ul>
<li>ff = false</li>
</ul>
</li>
</ul>
</li>
<li>info 目录包含一个全局性排除（global exclude）文件， 用以放置那些不希望被记录在 .gitignore 文件中的忽略模式（ignored patterns）。</li>
<li>hooks 目录包含客户端或服务端的钩子脚本（hook scripts）。</li>
</ul>
<p>重要的目录：</p>
<ul>
<li>objects 目录存储所有数据内容；</li>
<li>refs 目录存储指向数据（分支、远程仓库和标签等）的提交对象的<strong>指针</strong>；</li>
<li>HEAD 文件指向目前被检出的分支；</li>
<li>index 文件保存暂存区信息。</li>
</ul>
<p><img src="git%E6%96%87%E4%BB%B6%E5%A4%B9%EF%BC%88.git%EF%BC%89.png" alt=".git"><br>
<a href="git%E6%96%87%E4%BB%B6%E5%A4%B9%EF%BC%88.git%EF%BC%89.xmind">git文件夹（.git）.xmind</a></p>
<h2 id="二进制对象数据库">二进制对象数据库</h2>
<h3 id="内容寻址系统">内容寻址系统</h3>
<p>Git 是一个内容寻址文件系统，听起来很酷。但这是什么意思呢？ 这意味着，Git 的核心部分是一个简单的键值对数据库（key-value data store）。 你可以向 Git 仓库中插入任意类型的内容，它会返回一个唯一的键，通过该键可以在任意时刻再次取回该内容。</p>
<h3 id="写入-读取文件">写入、读取文件</h3>
<p>可以通过底层命令<code>git hash-object</code>来演示上述效果——该命令可将任意数据保存于 .git/objects 目录（即 对象数据库），并返回指向该数据对象的唯一的键。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;test content&#x27;</span> | git hash-object -w --stdin<br><span class="hljs-comment"># 惟一键</span><br>d670460b4b4aece5915caf5c68d12f560a9fe3e4<br></code></pre></td></tr></table></figure>
<p>在这种最简单的形式中，git hash-object 会接受你传给它的东西，而它只会返回可以存储在 Git 仓库中的唯一键。 -w 选项会指示该命令不要只返回键，<strong>还要将该对象写入数据库中</strong>。 最后，<strong>–stdin 选项则指示该命令从标准输入读取内容</strong>（为 echo 的管道命令作准备）；若不指定此选项，则须在命令尾部给出待存储文件的路径。</p>
<p>这时候文件被这样存储起来：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># -type f：这个选项指定查找的类型为文件（file）。这意味着 find 命令只会返回文件，而不会返回目录或其他类型的文件系统对象。</span><br><span class="hljs-comment"># 这里查找了所有文件</span><br>$ find .git/objects -<span class="hljs-built_in">type</span> f<br>.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4<br><br><span class="hljs-comment"># 为 cat-file 指定 -p 选项可指示该命令自动判断内容的类型，并为我们显示大致的内容</span><br>$ git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4<br><span class="hljs-built_in">test</span> content<br></code></pre></td></tr></table></figure>
<h3 id="版本控制">版本控制</h3>
<p>可以对一个文件进行简单的版本控制。</p>
<p>首先，创建一个新文件并将其内容存入数据库：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;version 1&#x27;</span> &gt; test.txt<br>git hash-object -w test.txt<br>83baae61804e65cc73a7201a7252750c76066a30<br></code></pre></td></tr></table></figure>
<p>接着，向文件里写入新内容，并再次将其存入数据库：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;version 2&#x27;</span> &gt; test.txt<br>git hash-object -w test.txt<br>1f7a7a472abf3dd9643fd615f6da379c4acb3e3a<br></code></pre></td></tr></table></figure>
<p>对象数据库记录下了该文件的两个不同版本，当然之前我们存入的第一条内容也还在：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># SHA-1 值的前两个字符作为子目录名称，后 38 个字符则作为子目录内文件的名称</span><br>find .git/objects -<span class="hljs-built_in">type</span> f<br><span class="hljs-comment"># 这里面的 1f 和 83 就是 test.txt 的两个版本</span><br>.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a<br>.git/objects/83/baae61804e65cc73a7201a7252750c76066a30<br><span class="hljs-comment"># d6 是我们写入的第一个文件</span><br>.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4<br></code></pre></td></tr></table></figure>
<p>现在可以在删掉 test.txt 的本地副本，然后用 Git 从对象数据库中取回它的第一个版本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git cat-file -p 83baae61804e65cc73a7201a7252750c76066a30 &gt; test.txt<br><span class="hljs-built_in">cat</span> test.txt<br>version 1<br></code></pre></td></tr></table></figure>
<p>或者第二个版本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git cat-file -p 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a &gt; test.txt<br><span class="hljs-built_in">cat</span> test.txt<br>version 2<br></code></pre></td></tr></table></figure>
<p>版本控制是通过存储多个版本来实现的，没有任何覆盖。</p>
<h2 id="几种对象">几种对象</h2>
<h3 id="blob-数据对象">blob 数据对象</h3>
<p>然而：</p>
<ol>
<li>SHA-1：记住文件的每一个版本所对应的 SHA-1 值并不现实；</li>
<li>名字：另一个问题是，在这个（简单的版本控制）系统中，文件名并没有被保存——我们仅保存了文件的内容。</li>
</ol>
<p>上述类型的对象我们称之为 <strong>数据对象（blob object）</strong>。利用 git cat-file -t 命令，可以让 Git 告诉我们其内部存储的任何对象类型，只要给定该对象的 SHA-1 值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git cat-file -t 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a<br>blob<br></code></pre></td></tr></table></figure>
<h3 id="tree-object-树对象">tree object 树对象</h3>
<p>接下来要探讨的 Git 对象类型是树对象（tree object），它能解决文件名保存的问题，也允许我们将多个文件组织到一起。 Git 以一种类似于 UNIX 文件系统的方式存储内容，但作了些许简化。 <strong>所有内容均以树对象和数据对象的形式存储，其中树对象对应了 UNIX 中的目录项，数据对象则大致上对应了 inodes 或文件内容</strong>。 <strong>一个树对象包含了一条或多条树对象记录（tree entry）</strong>，每条记录含有一个指向数据对象或者子树对象的 SHA-1 指针，以及相应的模式、类型、文件名信息。 例如，某项目当前对应的最新树对象可能是这样的：</p>
<p>所以树对象拥有很多指针（tree entry），指向其他 tree object 或者 blob，这是我们<strong>第一个包含指针的对象</strong>（而且包含多个指针）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git cat-file -p master^&#123;tree&#125;<br>100644 blob a906cb2a4a904a152e80877d4088654daad0c859      README<br>100644 blob 8f94139338f9404f26296befa88755fc2598c289      Rakefile<br>040000 tree 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0      lib<br></code></pre></td></tr></table></figure>
<p>master^{tree} 语法表示 master 分支上最新的提交所指向的树对象。 请注意，lib 子目录（所对应的那条树对象记录）并不是一个数据对象，而是一个指针，其指向的是另一个树对象：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git cat-file -p 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0<br>100644 blob 47c6340d6459e05787f644c2447d2595f5d3a54b      simplegit.rb<br></code></pre></td></tr></table></figure>
<p><img src="data-model-1.png" alt="简化版的 Git 数据模型"></p>
<p>你可以轻松创建自己的树对象。 通常，Git 根据某一时刻暂存区（即 index 区域，下同）所表示的状态创建并记录一个对应的树对象， 如此重复便可依次记录（某个时间段内）一系列的树对象。</p>
<p>因此，为创建一个树对象，首先需要通过暂存一些文件来创建一个暂存区。index 是很多树的源泉，<strong>一个个树对象是 index 区的快照，但是 index 不是 tree object</strong>！</p>
<p>可以通过底层命令 git update-index 为一个单独文件——我们的 test.txt 文件的首个版本——<strong>创建一个暂存区</strong>。 利用该命令，可以把 test.txt 文件的首个版本人为地加入一个<strong>新的暂存区</strong>。 必须为上述命令指定 --add 选项，因为此前该文件并不在暂存区中（我们甚至都还没来得及创建一个暂存区呢）； 同样必需的还有 <strong>–cacheinfo 选项，因为将要添加的文件位于 Git 数据库中，而不是位于当前目录下</strong>。 同时，需要指定文件模式、SHA-1 与文件名：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 把文件放进 index，因为 index 不存在，所以产生了第一棵树</span><br>git update-index --add --cacheinfo 100644 \<br>  83baae61804e65cc73a7201a7252750c76066a30 test.txt<br></code></pre></td></tr></table></figure>
<p>本例中，我们指定的文件模式为 100644，表明这是一个普通文件。 其他选择包括：100755，表示一个可执行文件；120000，表示一个符号链接。 这里的文件模式参考了常见的 UNIX 文件模式，但远没那么灵活——上述三种模式即是 Git 文件（即数据对象）的所有合法模式（当然，还有其他一些模式，但用于目录项和子模块）。而 blob 和 tree 说明了不同的 type。</p>
<p>现在，可以通过 git write-tree 命令将暂存区内容写入一个树对象。 此处无需指定 -w 选项——如果某个树对象此前并不存在的话，当调用此命令时， 它会根据当前暂存区状态自动创建一个新的树对象：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 树对象是从 index 区建立起来的</span><br>$ git write-tree<br>d8329fc1cc938780ffdd9f94e0d364e0ea74f579<br>$ git cat-file -p d8329fc1cc938780ffdd9f94e0d364e0ea74f579<br>100644 blob 83baae61804e65cc73a7201a7252750c76066a30      test.txt<br></code></pre></td></tr></table></figure>
<p>不妨用之前见过的 git cat-file 命令验证一下它确实是一个树对象：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git cat-file -t d8329fc1cc938780ffdd9f94e0d364e0ea74f579<br>tree<br></code></pre></td></tr></table></figure>
<p>接着我们来创建一个新的树对象，它包括 test.txt 文件的第二个版本，以及一个新的文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 假设我们修改了 test.txt，修改的过程在这里被省略；然后我们使用这个命令新建一个 txt</span><br>$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;new file&#x27;</span> &gt; new.txt<br><br><span class="hljs-comment"># 这是在知道文件名和文件 hashcode 的情况下 add index。之所以这样添加是因为我们是通过写入 kv 数据库的方式来 update-index 的，是从内部 update-index</span><br>$ git update-index --add --cacheinfo 100644 \<br>  1f7a7a472abf3dd9643fd615f6da379c4acb3e3a test.txt<br><span class="hljs-comment"># 从外部 update-index，这才是我们常用的方案</span><br>$ git update-index --add new.txt<br></code></pre></td></tr></table></figure>
<p>暂存区现在包含了 test.txt 文件的新版本，和一个新文件：new.txt。 记录下这个目录树（将当前暂存区的状态记录为一个树对象），然后观察它的结构：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git write-tree<br>0155eb4229851634a0f03eb265b69f5a2d56f341<br>$ git cat-file -p 0155eb4229851634a0f03eb265b69f5a2d56f341<br>100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt<br>100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt<br></code></pre></td></tr></table></figure>
<p>我们注意到，新的树对象包含两条文件记录，同时 test.txt 的 SHA-1 值（1f7a7a）是先前值的“第二版”。 只是为了好玩：你可以将第一个树对象加入第二个树对象，使其成为新的树对象的一个子目录。 通过调用 git read-tree 命令，可以把树对象读入暂存区。 本例中，可以通过对该命令指定 --prefix 选项，将一个已有的树对象作为子树读入暂存区：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在索引内，创建一个 bak 目录指向 d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span><br><span class="hljs-comment"># 如果树对象包含文件 file1.txt 和 file2.txt，那么执行这条命令后，索引中会包含 bak/file1.txt 和 bak/file2.txt。</span><br>$ git read-tree --prefix=bak d8329fc1cc938780ffdd9f94e0d364e0ea74f579<br><span class="hljs-comment"># </span><br>$ git write-tree<br>3c4e9cd789d88d8d89c1073707c3585e41b0e614<br>$ git cat-file -p 3c4e9cd789d88d8d89c1073707c3585e41b0e614<br>040000 tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579      bak<br>100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt<br>100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt<br></code></pre></td></tr></table></figure>
<p>如果基于这个新的树对象创建一个工作目录，你会发现工作目录的根目录包含两个文件以及一个名为 bak 的子目录，该子目录包含 test.txt 文件的第一个版本-<strong>我们 write-tree 两次，第一次得到一个 tree，第二次得到第二个 tree，并且引用了第一个tree</strong>。</p>
<p><img src="data-model-2.png" alt="第二棵书对象引用第一棵书对象"></p>
<h3 id="提交对象">提交对象</h3>
<p>如果你做完了以上所有操作，那么现在就有了三个树对象，分别代表我们想要跟踪的不同项目快照。 然而问题依旧：若想重用这些快照，你必须记住所有三个 SHA-1 哈希值。 并且，你也完全不知道是谁保存了这些快照，在什么时刻保存的，以及为什么保存这些快照。 而以上这些，正是提交对象（commit object）能为你保存的基本信息。</p>
<p>可以通过调用 commit-tree 命令创建一个提交对象，为此需要指定一个树对象的 SHA-1 值，以及该提交的父提交对象（如果有的话）。 我们从之前创建的第一个树对象开始：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># d8329f 是我们的第一棵树的 hash</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;first commit&#x27;</span> | git commit-tree d8329f<br>fdf4fc3344e67ab068f836878b6c4951e3b15f3d<br></code></pre></td></tr></table></figure>
<p>由于创建时间和作者数据不同，你现在会得到一个不同的散列值。 请将本章后续内容中的提交和标签的散列值替换为你自己的校验和。 现在可以通过 git cat-file 命令查看这个新提交对象：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 这时候 cat 这个 fdf4fc3 就得到提交对象了</span><br>git cat-file -p fdf4fc3<br>tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579<br>author Scott Chacon &lt;schacon@gmail.com&gt; 1243040974 -0700<br>committer Scott Chacon &lt;schacon@gmail.com&gt; 1243040974 -0700<br><br>first commit<br></code></pre></td></tr></table></figure>
<p>提交对象的格式很简单：它先指定一个顶层树对象，代表当前项目快照； 然后是可能存在的父提交（前面描述的提交对象并不存在任何父提交）； 之后是作者/提交者信息（依据你的 <a target="_blank" rel="noopener" href="http://user.name">user.name</a> 和 user.email 配置来设定，外加一个时间戳）； 留空一行，最后是提交注释。</p>
<p>接着，我们将创建另两个提交对象，它们分别引用各自的上一个提交（作为其父提交对象）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># fdf4fc3 是第一个commit 的 hash，而不是第一个 tree 的 hash</span><br>$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;second commit&#x27;</span> | git commit-tree 0155eb -p fdf4fc3<br>cac0cab538b970a37ea1e769cbbde608743bc96d<br><span class="hljs-comment"># cac0cab 是第二个commit 的 hash，而不是第二个 tree 的 hash</span><br>$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;third commit&#x27;</span>  | git commit-tree 3c4e9c -p cac0cab<br>1a410efbd13591db07496601ebc7a059dd55cfe9<br></code></pre></td></tr></table></figure>
<p>这三个提交对象分别指向之前创建的三个树对象快照中的一个。 现在，如果对最后一个提交的 SHA-1 值运行 git log 命令，会出乎意料的发现，你已有一个货真价实的、可由 git log 查看的 Git 提交历史了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">log</span> --<span class="hljs-built_in">stat</span> 1a410e<br>commit 1a410efbd13591db07496601ebc7a059dd55cfe9<br>Author: Scott Chacon &lt;schacon@gmail.com&gt;<br>Date:   Fri May 22 18:15:24 2009 -0700<br><br>    third commit<br><br> bak/test.txt | 1 +<br> 1 file changed, 1 insertion(+)<br><br>commit cac0cab538b970a37ea1e769cbbde608743bc96d<br>Author: Scott Chacon &lt;schacon@gmail.com&gt;<br>Date:   Fri May 22 18:14:29 2009 -0700<br><br>    second commit<br><br> new.txt  | 1 +<br> test.txt | 2 +-<br> 2 files changed, 2 insertions(+), 1 deletion(-)<br><br>commit fdf4fc3344e67ab068f836878b6c4951e3b15f3d<br>Author: Scott Chacon &lt;schacon@gmail.com&gt;<br>Date:   Fri May 22 18:09:34 2009 -0700<br><br>    first commit<br><br> test.txt | 1 +<br> 1 file changed, 1 insertion(+)<br></code></pre></td></tr></table></figure>
<p>太神奇了：就在刚才，你没有借助任何上层命令，仅凭几个底层操作便完成了一个 Git 提交历史的创建。</p>
<p>这就是每次我们运行<code>git add</code>（1-3）和<code>git commit</code>（4）命令时，Git 所做的工作实质就是:</p>
<ol>
<li><code>git hash-object</code>将被改写的文件保存为<strong>数据对象</strong></li>
<li><code>git update-index</code>更新暂存区</li>
<li><code>git write-tree</code>记录<strong>树对象</strong></li>
<li><code>git commit-tree</code>最后创建一个指明了顶层树对象和父提交的<strong>提交对象</strong></li>
</ol>
<p>这三种主要的 Git 对象——数据对象、树对象、提交对象——最初均以单独文件的形式保存在 .git/objects 目录下。</p>
<p><img src="data-model-3.png" alt="用提交对象的链表来连起树对象"></p>
<p>第一列是 commit 对象，第二列是树对象，第三列 blob。</p>
<p>我们常见的<code>git diff commit1 commit2</code>，实际上就是在<strong>比对两棵树</strong>-git 在进入 commit 的时候，resolve commit 都会得到树。</p>
<h2 id="引用">引用</h2>
<p><strong>引用不是 object</strong>。</p>
<p>如果你对仓库中从一个提交（比如 1a410e）开始往前的历史感兴趣，那么可以运行 git log 1a410e 这样的命令来显示历史，不过你需要记得 1a410e 是你查看历史的起点提交。 如果我们有一个文件来保存 SHA-1 值，而该文件有一个简单的名字， 然后用这个名字指针来替代原始的 SHA-1 值的话会更加简单。</p>
<p>所以 ref 是对 sha-1 起的名字，<strong>用文件指针来装 hash，而 commit 本身就是hash，commit 没有名字</strong>。</p>
<p>若要创建一个新引用来帮助记忆最新提交所在的位置，从技术上讲我们只需简单地做如下操作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 这里是直接用 master 文件来装 hash</span><br><span class="hljs-built_in">echo</span> 1a410efbd13591db07496601ebc7a059dd55cfe9 &gt; .git/refs/heads/master<br></code></pre></td></tr></table></figure>
<p>现在，你就可以在 Git 命令中使用这个刚创建的新引用来代替 SHA-1 值了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span> --pretty=oneline master<br>1a410efbd13591db07496601ebc7a059dd55cfe9 third commit<br>cac0cab538b970a37ea1e769cbbde608743bc96d second commit<br>fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit<br></code></pre></td></tr></table></figure>
<p>我们不提倡直接编辑引用文件。 如果想更新某个引用，Git 提供了一个更加安全的命令 update-ref 来完成此事（这个命令可以创建/更新所有非只读 ref，包括 heads/tags/remotes/stash）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git update-ref refs/heads/master 1a410efbd13591db07496601ebc7a059dd55cfe9<br></code></pre></td></tr></table></figure>
<p>这基本就是 Git <strong>分支的本质：一个指向某一系列提交之首（头指针、head）的指针或引用</strong>。 若想在第二个提交上创建一个分支，可以这么做：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># update 而不是 create，得到一个分支即引用</span><br>git update-ref refs/heads/test cac0ca<br></code></pre></td></tr></table></figure>
<p>这个分支将只包含从第二个提交开始往前追溯的记录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span> --pretty=oneline <span class="hljs-built_in">test</span><br>cac0cab538b970a37ea1e769cbbde608743bc96d second commit<br>fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit<br></code></pre></td></tr></table></figure>
<p><img src="data-model-4.png" alt="带有引用的树"></p>
<p>红色的引用，同样也是分支。</p>
<h3 id="head-引用">HEAD 引用</h3>
<p>HEAD 文件通常是一个符号引用（symbolic reference），指向目前所在的分支。 所谓符号引用，表示它是一个指向其他引用的指针。</p>
<p>然而在某些罕见的情况下，HEAD 文件可能会包含一个 git 对象的 SHA-1 值。 当你在检出一个标签、提交或远程分支，让你的仓库变成“分离 HEAD”状态时，就会出现这种情况。</p>
<p>所以：</p>
<ol>
<li><strong>HEAD 在非 detached 的情况下，是指向ref/heads下的分支的</strong>；</li>
<li><strong>但是在 detached 时可以指向其他任意的ref</strong>。</li>
</ol>
<p>如果查看 HEAD 文件的内容，通常我们看到类似这样的内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># master 是 commit 的引用，HEAD 又是 master 的引用</span><br><span class="hljs-built_in">cat</span> .git/HEAD<br>ref: refs/heads/master<br></code></pre></td></tr></table></figure>
<p>如果执行 git checkout test，Git 会像这样更新 HEAD 文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> .git/HEAD<br>ref: refs/heads/test<br></code></pre></td></tr></table></figure>
<p>当我们执行 git commit 时，该命令会创建一个提交对象，并用 HEAD 文件中那个引用所指向的 SHA-1 值设置其父提交字段（类似上面的 ）。</p>
<p>你也可以手动编辑该文件，然而同样存在一个更安全的命令来完成此事：<code>git symbolic-ref</code>。 可以借助此命令来查看 HEAD 引用对应的值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git symbolic-ref HEAD<br>refs/heads/master<br></code></pre></td></tr></table></figure>
<p>同样可以设置 HEAD 引用的值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git symbolic-ref HEAD refs/heads/test<br><span class="hljs-built_in">cat</span> .git/HEAD<br>ref: refs/heads/test<br></code></pre></td></tr></table></figure>
<h4 id="checkout-的本质">checkout 的本质</h4>
<p>让我们来看看当我们签出提交 <code>b</code>时会发生什么（这里我们展示了两种方法）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout v2.0  <span class="hljs-comment"># 或</span><br>git checkout master^^<br></code></pre></td></tr></table></figure>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs 1c">   HEAD （指向提交&#x27;b&#x27;）<br>    <span class="hljs-string">|</span><br>    v<br>a<span class="hljs-punctuation">-</span><span class="hljs-punctuation">-</span><span class="hljs-punctuation">-</span>b<span class="hljs-punctuation">-</span><span class="hljs-punctuation">-</span><span class="hljs-punctuation">-</span>c<span class="hljs-punctuation">-</span><span class="hljs-punctuation">-</span><span class="hljs-punctuation">-</span>d  分支&#x27;master&#x27;（指向提交&#x27;d&#x27;）<br>    ^<br>    <span class="hljs-string">|</span><br>  tag &#x27;v2.0&#x27; <span class="hljs-punctuation">(</span>指向提交&#x27;b&#x27;<span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure>
<p>请注意，无论我们使用哪条签出（checkout）命令，HEAD现在都直接指向提交b。这就是所谓的分离的<code>HEAD</code>状态。 这意味着，<strong><code>HEAD</code>指向一个特定的提交，而不是指向一个命名的分支</strong>。</p>
<p>如果从 commit b fork 出 e 和 f 提交，我们必须创建一个 ref，才能不被 git gc 清理掉：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建一个新的分支`foo`，指向提交`f`，然后更新`HEAD`，指向分支`foo`。换句话说，这条命令之后，我们将不再处于分离的`HEAD`状态。</span><br>git checkout -b foo<br><span class="hljs-comment"># 创建一个新的分支`foo`，它指向提交`f`，但将`HEAD`分离出来。</span><br>git branch foo<br><span class="hljs-comment"># 创建一个新的标签`foo`，指向提交`f`，让`HEAD`处于分离状态。</span><br>git tag foo<br></code></pre></td></tr></table></figure>
<p>如果我们已经离开了<code>f</code>的提交，那么我们必须首先恢复它的对象名称（通常使用git reflog），然后我们可以创建一个对它的引用。例如，要查看<code>HEAD</code>指向的最后两个提交，我们可以使用以下任一命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reflog -2 HEAD <span class="hljs-comment"># 或</span><br>git <span class="hljs-built_in">log</span> -g -2 HEAD<br></code></pre></td></tr></table></figure>
<p>如果你需要回到之前的某个提交（例如，恢复到一个你已经“离开”的提交），你需要知道那个提交的哈希值。</p>
<ul>
<li>git reflog -2 HEAD会显示HEAD最近的两次移动。这可以帮助你找到之前的提交哈希值，即使你已经切换到其他分支或提交。</li>
<li>git log -g -2 HEAD会显示HEAD最近的两次移动，格式类似于git log的输出。</li>
</ul>
<p>然后<code>git checkout &lt;commit-hash&gt;</code></p>
<h3 id="标签引用">标签引用</h3>
<p>默认情况下，git push 命令并不会传送标签到远程仓库服务器上。 <strong>在创建完标签后你必须显式地推送标签到共享服务器上</strong>。 这个过程就像共享远程分支一样——你可以运行 git push origin <tagname>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 版本名也就是 tag name</span><br>git push origin v1.5<br></code></pre></td></tr></table></figure>
<p>前面我们刚讨论过 Git 的三种主要的对象类型（数据对象、树对象和提交对象 ），然而实际上还有第四种。 标签对象（tag object） 非常类似于一个提交对象——它包含一个标签创建者信息、一个日期、一段注释信息，以及一个指针。</p>
<p>标签对象不在 objects 文件夹里。</p>
<p>主要的区别在于，<strong>标签对象通常指向一个提交对象（拥有自己的元数据），而不是一个树对象（而commit 指向一个 书对象</strong>）。 <strong>它像是一个永不移动的分支引用——永远指向同一个提交对象</strong>（HEAD 会移动），只不过给这个提交对象加上一个更友好的名字罢了。</p>
<h4 id="轻量标签-lightweight">轻量标签（lightweight）</h4>
<p>轻量标签很像一个不会改变（immutable）的分支——它只是某个特定提交的引用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 高级命令</span><br>git tag v1.4-lw<br><br><span class="hljs-comment"># 低级命令</span><br>git update-ref refs/tags/v1.0 cac0cab538b970a37ea1e769cbbde608743bc96d<br></code></pre></td></tr></table></figure>
<p>这就是轻量标签的全部内容——一个固定的引用。</p>
<h4 id="附注标签-annotated">附注标签（annotated）</h4>
<p>而附注标签是存储在 Git 数据库中的一个完整对象， 它们是可以被校验的，其中包含打标签者的名字、电子邮件地址、日期时间， 此外还有一个标签信息，并且可以使用 GNU Privacy Guard （GPG）签名并验证。 <strong>通常会建议创建附注标签</strong>，这样你可以拥有以上所有信息。但是如果你只是想用一个临时的标签， 或者因为某些原因不想要保存这些信息，那么也可以用轻量标签（<strong>默认行为</strong>）。</p>
<p>若要创建一个附注标签，Git 会<strong>创建一个标签对象，并记录一个引用来指向该标签对象</strong>，而不是直接指向提交对象。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 高级命令</span><br>git tag -a v1.4 -m <span class="hljs-string">&quot;my version 1.4&quot;</span><br>git tag -a v1.1 1a410efbd13591db07496601ebc7a059dd55cfe9 -m <span class="hljs-string">&#x27;test tag&#x27;</span><br></code></pre></td></tr></table></figure>
<p>下面是上述过程所建标签对象的 SHA-1 值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> .git/refs/tags/v1.1<br>9585191f37f7b0fb9444f35a9bf50de191beadc2<br></code></pre></td></tr></table></figure>
<p>现在对该 SHA-1 值运行 git cat-file -p 命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 95851 是标签对象的引用</span><br>$ git cat-file -p 9585191f37f7b0fb9444f35a9bf50de191beadc2<br><span class="hljs-comment"># 1a410e 对提交对象的引用</span><br>object 1a410efbd13591db07496601ebc7a059dd55cfe9<br><span class="hljs-comment"># type commit: 标签对象指向的 Git 对象的类型是提交（commit）</span><br><span class="hljs-built_in">type</span> commit<br><span class="hljs-comment"># tag v1.1: 标签的名称-不一定是版本号</span><br>tag v1.1<br><span class="hljs-comment"># 标签的创建者和创建时间。</span><br>tagger Scott Chacon &lt;schacon@gmail.com&gt; Sat May 23 16:48:58 2009 -0700<br><br><span class="hljs-comment"># 标签的注释或描述</span><br><span class="hljs-built_in">test</span> tag<br></code></pre></td></tr></table></figure>
<p>我们注意到，object 条目指向我们打了标签的那个提交对象的 SHA-1 值。 另外要注意的是，标签对象并非必须指向某个提交对象；你可以对任意类型的 Git 对象打标签。 例如，在 Git 源码中，项目维护者将他们的 GPG 公钥添加为一个数据对象，然后对这个对象打了一个标签。 可以克隆一个 Git 版本库，然后通过执行下面的命令来在这个版本库中查看上述公钥：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git cat-file blob junio-gpg-pub<br></code></pre></td></tr></table></figure>
<p>Linux 内核版本库同样有一个不指向提交对象的标签对象——首个被创建的标签对象所指向的是最初被引入版本库的那份内核源码所对应的树对象。</p>
<h3 id="远程引用">远程引用</h3>
<p><strong>remote 不能修改，但是能够被 fetch 更新</strong>。</p>
<p>我们将看到的第三种引用类型是远程引用（remote reference）。 如果你添加了一个远程版本库并对其执行过推送操作，Git 会记录下最近一次推送操作时每一个分支所对应的值，并保存在 refs/remotes 目录下。 例如，你可以添加一个叫做 origin 的远程版本库，然后把 master 分支推送上去：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote add origin git@github.com:schacon/simplegit-progit.git<br>git push origin master<br>Counting objects: 11, <span class="hljs-keyword">done</span>.<br>Compressing objects: 100% (5/5), <span class="hljs-keyword">done</span>.<br>Writing objects: 100% (7/7), 716 bytes, <span class="hljs-keyword">done</span>.<br>Total 7 (delta 2), reused 4 (delta 1)<br>To git@github.com:schacon/simplegit-progit.git<br>  a11bef0..ca82a6d  master -&gt; master<br></code></pre></td></tr></table></figure>
<p>此时，如果查看 refs/remotes/origin/master 文件，可以发现 origin 远程版本库的 master 分支所对应的 SHA-1 值，就是最近一次与服务器通信时本地 master 分支所对应的 SHA-1 值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> .git/refs/remotes/origin/master<br>ca82a6dff817ec66f44342007202690a93763949<br></code></pre></td></tr></table></figure>
<p>远程引用和分支（位于 refs/heads 目录下的引用）之间最主要的区别在于，远程引用是只读的。 虽然可以 git checkout 到某个远程引用，但是 Git 并不会将 HEAD 引用指向该远程引用。因此，<strong>你永远不能通过 commit 命令来更新远程引用</strong>。 Git 将这些远程引用作为记录远程服务器上各分支最后已知位置状态的书签来管理。</p>
<p>remote 底层的配置类似这样（<strong>很像 submodule</strong>）：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs elixir">[remote <span class="hljs-string">&quot;origin&quot;</span>]<br>    url = <span class="hljs-symbol">https:</span>//github.com/schacon/simplegit-progit<br>    fetch = +refs/heads/*<span class="hljs-symbol">:refs/remotes/origin/*</span><br>    push = refs/heads/<span class="hljs-symbol">master:</span>refs/heads/qa/master<br></code></pre></td></tr></table></figure>
<h1>删除 git 文件</h1>
<p>git clean 命令用于删除工作目录中的未跟踪文件（untracked files）。未跟踪文件是指那些不在暂存区中且未被 Git 跟踪的文件。要删除目录下所有未被 Git 跟踪（未添加到暂存区或仓库）的文件，具体步骤如下：</p>
<ul>
<li>首先，查看将要删除的文件列表（建议先执行这一步，以防误删重要文件）：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git clean -n<br></code></pre></td></tr></table></figure>
<p>这会以“dry run”（模拟执行）的方式显示哪些未跟踪的文件将被删除，而不实际删除它们。</p>
<p>如果您还有未跟踪的目录想要删除，可以使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git clean -n -d<br></code></pre></td></tr></table></figure>
<p>这会显示将要删除的未跟踪的文件和目录。</p>
<ul>
<li>确认后，执行删除操作：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git clean -f<br></code></pre></td></tr></table></figure>
<p>这会删除所有未跟踪的文件。</p>
<p>如果还需要删除未跟踪的目录，请使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git clean -f -d<br></code></pre></td></tr></table></figure>
<ul>
<li>如果您想要强制删除包括 .gitignore 中忽略的文件，可以使用：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git clean -f -x<br></code></pre></td></tr></table></figure>
<p>注意：这将删除所有未跟踪的文件，包括被 .gitignore 忽略的文件，请谨慎使用。</p>
<p>提示：</p>
<ul>
<li>在执行<code>git clean</code>命令前，确保您已经备份了重要的未跟踪文件。</li>
<li>使用 -i 选项可以交互式地选择要删除的文件：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git clean -f -i<br></code></pre></td></tr></table></figure>
<ul>
<li>要了解更多关于 git clean 命令的选项，可以查看帮助：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git clean -h<br></code></pre></td></tr></table></figure>
<p>总结：</p>
<p>使用<code>git clean -f [-d]</code>命令可以自动删除当前目录下所有未被 Git 跟踪的文件和目录。在执行删除操作前，建议使用<code>git clean -n [-d]</code> 查看将要删除的文件列表，以防误删重要数据。</p>
<h1>git 支持的协议</h1>
<p>协议有几种：https:// 协议、git:// 协议（比如<code>git://github.com/username/repository.git</code>）或者使用 SSH 传输协议（比如<code>user@server:path/to/repo.git</code>或者<code>ssh://[user@]server/project.git</code>）。</p>
<p>local协议就是在本机的两个文件系统（一个可能是 NFS也可能不是）之间进行传输的协议，并不值得推荐。</p>
<p>从安全来讲：ssh强制鉴权，这要求repo不能被匿名分发；而git协议正相反，无法鉴权，但速度最快。</p>
<h1>如何清理 git 历史</h1>
<ol>
<li>下载 下载BFG Repo-Cleaner工具，如 bfg-1.14.0.jar。</li>
<li>把敏感信息在当前最新版本里都删除。</li>
<li>使用mirror标志克隆一个裸仓库（普通文件将处于不可见）：<code>git clone --mirror git@git.woa.com:aaa/myproject myproject_rmhistory</code>。</li>
<li>生成一个 rule 文件，如 rule.txt：<code>testpass</code>。每一行一个敏感词。</li>
<li><code>java -jar bfg-1.14.0.jar --replace-text rule.txt myproject_rmhistory</code>。</li>
<li><code>cd myproject_rmhistory</code>。</li>
<li><code>git reflog expire --expire=now --all &amp;&amp; git gc --prune=now --aggressive</code>。</li>
<li>关闭对 master 的写保护：<code>git push -f</code>。</li>
</ol>
<h1>idea 上的 git</h1>
<p>git 的命令和输出要看“视图-工具窗口-Git-控制台面板”而不是终端面板。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://magicliang.github.io">magicliang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://magicliang.github.io/2019/12/25/git-%E9%9A%BE%E7%82%B9%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/">https://magicliang.github.io/2019/12/25/git-%E9%9A%BE%E7%82%B9%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/git/">git</a></div><div class="post-share"><div class="social-share" data-image="/2019/12/25/git-%E9%9A%BE%E7%82%B9%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/How-To-Change-Git-Remote-Origin.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">初始化命令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E7%94%A8%E6%88%B7-remote-%E5%92%8C-branch"><span class="toc-number">1.1.</span> <span class="toc-text">配置用户、remote 和 branch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%AD%E7%A9%BA%E4%BA%A7%E7%94%9F%E7%A9%BA%E7%9A%84-git-repo"><span class="toc-number">1.2.</span> <span class="toc-text">凭空产生空的 git repo</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E6%8D%A2remote-repo"><span class="toc-number">1.3.</span> <span class="toc-text">变换remote repo</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%8A%E5%B7%B2%E7%BB%8F%E5%AD%98%E5%9C%A8%E7%9A%84-repo-push-%E4%B8%8A-remote"><span class="toc-number">1.4.</span> <span class="toc-text">把已经存在的 repo push 上 remote</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">areas</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">分支</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">修改提交</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%8E%86%E5%8F%B2"><span class="toc-number">4.1.</span> <span class="toc-text">查看历史</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E7%9A%84%E5%8E%86%E5%8F%B2"><span class="toc-number">4.1.1.</span> <span class="toc-text">普通的历史</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AA%E6%9C%89%E6%9C%AC%E5%9C%B0%E6%89%8D%E8%83%BD%E7%9C%8B%E5%88%B0%E7%9A%84%E5%8E%86%E5%8F%B2"><span class="toc-number">4.1.2.</span> <span class="toc-text">只有本地才能看到的历史</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%8F%8C%E7%82%B9"><span class="toc-number">4.1.2.1.</span> <span class="toc-text">另一种双点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#reset"><span class="toc-number">4.2.</span> <span class="toc-text">reset</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E5%AF%B9%E9%BD%90%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF"><span class="toc-number">4.2.1.</span> <span class="toc-text">强制对齐远程分支</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#checkout"><span class="toc-number">4.3.</span> <span class="toc-text">checkout</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E5%88%86%E6%94%AF"><span class="toc-number">4.3.1.</span> <span class="toc-text">对分支</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%96%87%E4%BB%B6"><span class="toc-number">4.3.2.</span> <span class="toc-text">对文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#revert"><span class="toc-number">4.4.</span> <span class="toc-text">revert</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#amend"><span class="toc-number">4.5.</span> <span class="toc-text">amend</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#restore"><span class="toc-number">4.6.</span> <span class="toc-text">restore</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">主要命令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#merge"><span class="toc-number">5.1.</span> <span class="toc-text">merge</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E5%BF%AB%E8%BF%9B%E5%90%88%E5%B9%B6"><span class="toc-number">5.1.1.</span> <span class="toc-text">非快进合并</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E8%BF%9B%E5%90%88%E5%B9%B6"><span class="toc-number">5.1.2.</span> <span class="toc-text">快进合并</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E5%BF%AB%E8%BF%9B"><span class="toc-number">5.1.3.</span> <span class="toc-text">配置快进</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9%E5%90%88%E5%B9%B6"><span class="toc-number">5.1.4.</span> <span class="toc-text">压缩合并</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rebase"><span class="toc-number">5.2.</span> <span class="toc-text">rebase</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E6%8E%A8%E9%80%81%E4%BC%9A%E6%AF%81%E7%81%AD%E6%8E%A8%E9%80%81%E5%8E%86%E5%8F%B2"><span class="toc-number">5.2.1.</span> <span class="toc-text">强制推送会毁灭推送历史</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A5%E4%B8%81%E5%BC%8F-onto-%E5%9C%A8%E4%B8%89%E4%B8%AA%E5%88%86%E6%94%AF%E4%B8%8A%E5%8F%98%E5%9F%BA"><span class="toc-number">5.2.2.</span> <span class="toc-text">补丁式 onto（在三个分支上变基）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fetch"><span class="toc-number">5.3.</span> <span class="toc-text">fetch</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E5%88%86%E6%94%AF"><span class="toc-number">5.3.1.</span> <span class="toc-text">两个分支</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#remote"><span class="toc-number">5.4.</span> <span class="toc-text">remote</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#commit"><span class="toc-number">5.5.</span> <span class="toc-text">commit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rm"><span class="toc-number">5.6.</span> <span class="toc-text">rm</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">（命令）别名</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">特殊技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A4%E4%BA%92%E5%BC%8F%E6%8F%90%E4%BA%A4"><span class="toc-number">7.1.</span> <span class="toc-text">交互式提交</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%82%A8%E8%97%8F"><span class="toc-number">7.2.</span> <span class="toc-text">储藏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E6%A0%B7%E6%8A%8A%E4%B8%80%E4%BA%9B-commit-%E4%BB%8E%E5%BD%93%E5%89%8D%E5%88%86%E6%94%AF-%E9%80%9A%E5%B8%B8%E6%98%AF-master-%E7%A7%BB%E5%88%B0%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%88%86%E6%94%AF"><span class="toc-number">7.3.</span> <span class="toc-text">怎样把一些 commit 从当前分支（通常是 master）移到另一个分支</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E6%A0%B7%E6%8A%8A%E5%BD%93%E5%89%8D%E5%88%86%E6%94%AF%E7%9A%84%E6%8F%90%E4%BA%A4%E7%9B%B4%E6%8E%A5%E5%A4%8D%E5%88%B6%E5%88%B0%E5%85%B6%E4%BB%96%E5%88%86%E6%94%AF"><span class="toc-number">7.4.</span> <span class="toc-text">怎样把当前分支的提交直接复制到其他分支</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%9F%90%E4%B8%80%E4%B8%AA%E5%88%86%E6%94%AF%E5%8E%8B%E7%BC%A9%E6%9C%AC%E5%88%86%E6%94%AF%E4%B8%8A%E7%9A%84%E4%BF%AE%E6%94%B9"><span class="toc-number">7.5.</span> <span class="toc-text">基于某一个分支压缩本分支上的修改</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E6%A0%B7%E5%BD%BB%E5%A4%B4%E5%BD%BB%E5%B0%BE%E5%9C%B0-ignore-%E4%B8%8D%E9%9C%80%E8%A6%81%E7%9A%84%E6%96%87%E4%BB%B6-%E4%BD%86%E4%BB%8D%E6%8A%8A%E5%AE%83%E4%BF%9D%E7%95%99%E5%9C%A8-wd-%E9%87%8C"><span class="toc-number">7.6.</span> <span class="toc-text">怎样彻头彻尾地 ignore 不需要的文件（但仍把它保留在 WD 里）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E7%BB%8F%E5%85%B8%E7%9A%84%E5%8F%8C%E6%8F%90%E4%BA%A4%E5%86%B2%E7%AA%81"><span class="toc-number">7.7.</span> <span class="toc-text">处理经典的双提交冲突</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%80%E7%96%8F%E6%A3%80%E5%87%BA"><span class="toc-number">7.8.</span> <span class="toc-text">稀疏检出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E7%9A%84%E8%BE%A8%E6%9E%90"><span class="toc-number">7.8.1.</span> <span class="toc-text">关于文件大小的辨析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#shallow-clone-%E6%B5%85%E5%85%8B%E9%9A%86"><span class="toc-number">7.9.</span> <span class="toc-text">Shallow Clone（浅克隆）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#partial-clone"><span class="toc-number">7.10.</span> <span class="toc-text">partial clone</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">文件系统优化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">9.</span> <span class="toc-text">使用git调试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#git-diff-%E7%9A%84%E8%BE%93%E5%87%BA"><span class="toc-number">9.1.</span> <span class="toc-text">git diff 的输出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%A0%87%E6%B3%A8-%E7%B1%BB%E4%BC%BCidea%E9%87%8C%E7%9A%84annotate-%E6%88%96%E8%80%85%E6%88%91%E4%BB%AC%E5%B8%B8%E8%AF%B4%E7%9A%84-blame"><span class="toc-number">9.2.</span> <span class="toc-text">文件标注（类似idea里的annotate，或者我们常说的 blame）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2"><span class="toc-number">9.3.</span> <span class="toc-text">搜索</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">9.4.</span> <span class="toc-text">二分查找</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">10.</span> <span class="toc-text">工作流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#gitflow"><span class="toc-number">10.1.</span> <span class="toc-text">GitFlow</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%94%AF"><span class="toc-number">10.1.1.</span> <span class="toc-text">分支</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E5%88%86%E6%94%AF"><span class="toc-number">10.1.1.1.</span> <span class="toc-text">主分支</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%AF%E6%8C%81%E5%88%86%E6%94%AF"><span class="toc-number">10.1.1.2.</span> <span class="toc-text">支持分支</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E6%80%A7%E5%88%86%E6%94%AF"><span class="toc-number">10.1.1.2.1.</span> <span class="toc-text">特性分支</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-no-ff-%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">10.1.1.2.1.1.</span> <span class="toc-text">使用 --no-ff 的好处</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E5%88%86%E6%94%AF"><span class="toc-number">10.1.1.2.2.</span> <span class="toc-text">发布分支</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%83%AD%E4%BF%AE%E5%A4%8D%E5%88%86%E6%94%AF"><span class="toc-number">10.1.1.2.3.</span> <span class="toc-text">热修复分支</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90"><span class="toc-number">10.1.2.</span> <span class="toc-text">工具推荐</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#githubflow"><span class="toc-number">10.2.</span> <span class="toc-text">GitHubFlow</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#merge-request-vs-pull-request"><span class="toc-number">10.2.1.</span> <span class="toc-text">merge request vs pull request</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gitlab-flow"><span class="toc-number">10.3.</span> <span class="toc-text">Gitlab flow</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83"><span class="toc-number">10.3.1.</span> <span class="toc-text">版本发布</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">11.</span> <span class="toc-text">搭建自己的服务端</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">12.</span> <span class="toc-text">github</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#service-and-hook"><span class="toc-number">12.1.</span> <span class="toc-text">service and hook</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#service"><span class="toc-number">12.1.1.</span> <span class="toc-text">service</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hook"><span class="toc-number">12.1.2.</span> <span class="toc-text">hook</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">13.</span> <span class="toc-text">子模块</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">14.</span> <span class="toc-text">底层与上层命令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E5%A4%A7%E5%85%B3%E9%94%AE%E7%9B%AE%E5%BD%95"><span class="toc-number">14.1.</span> <span class="toc-text">四大关键目录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AF%B9%E8%B1%A1%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">14.2.</span> <span class="toc-text">二进制对象数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AE%B9%E5%AF%BB%E5%9D%80%E7%B3%BB%E7%BB%9F"><span class="toc-number">14.2.1.</span> <span class="toc-text">内容寻址系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E5%85%A5-%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6"><span class="toc-number">14.2.2.</span> <span class="toc-text">写入、读取文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6"><span class="toc-number">14.2.3.</span> <span class="toc-text">版本控制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%A0%E7%A7%8D%E5%AF%B9%E8%B1%A1"><span class="toc-number">14.3.</span> <span class="toc-text">几种对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#blob-%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1"><span class="toc-number">14.3.1.</span> <span class="toc-text">blob 数据对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tree-object-%E6%A0%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">14.3.2.</span> <span class="toc-text">tree object 树对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E5%AF%B9%E8%B1%A1"><span class="toc-number">14.3.3.</span> <span class="toc-text">提交对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-number">14.4.</span> <span class="toc-text">引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#head-%E5%BC%95%E7%94%A8"><span class="toc-number">14.4.1.</span> <span class="toc-text">HEAD 引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#checkout-%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">14.4.1.1.</span> <span class="toc-text">checkout 的本质</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E7%AD%BE%E5%BC%95%E7%94%A8"><span class="toc-number">14.4.2.</span> <span class="toc-text">标签引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E6%A0%87%E7%AD%BE-lightweight"><span class="toc-number">14.4.2.1.</span> <span class="toc-text">轻量标签（lightweight）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%84%E6%B3%A8%E6%A0%87%E7%AD%BE-annotated"><span class="toc-number">14.4.2.2.</span> <span class="toc-text">附注标签（annotated）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E5%BC%95%E7%94%A8"><span class="toc-number">14.4.3.</span> <span class="toc-text">远程引用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">15.</span> <span class="toc-text">删除 git 文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">16.</span> <span class="toc-text">git 支持的协议</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">17.</span> <span class="toc-text">如何清理 git 历史</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">18.</span> <span class="toc-text">idea 上的 git</span></a></li></ol></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2017 - 2025 By magicliang</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional and Simplified Chinese">簡</button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>