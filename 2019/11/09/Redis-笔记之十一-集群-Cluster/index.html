<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Redis 笔记之十一-集群 Cluster | 守株阁</title><meta name="author" content="magicliang"><meta name="copyright" content="magicliang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="背景 在 Redis Cluster 方案诞生以前，在 Redis 集群遇到单机资源和流量瓶颈时，有两种常见分布式解决方案：  客户端方案：需要自己处理分区逻辑、路由、故障转移（有时候 Routing、LB 和 Failover是同一个问题，都需要通过 routing 技术来切换流量的 endpoint）。 代理方案：减轻了客户端的职责和压力，架构上的负担过重。  Redis Cluster 的出">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis 笔记之十一-集群 Cluster">
<meta property="og:url" content="https://magicliang.github.io/2019/11/09/Redis-%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8D%81%E4%B8%80-%E9%9B%86%E7%BE%A4-Cluster/index.html">
<meta property="og:site_name" content="守株阁">
<meta property="og:description" content="背景 在 Redis Cluster 方案诞生以前，在 Redis 集群遇到单机资源和流量瓶颈时，有两种常见分布式解决方案：  客户端方案：需要自己处理分区逻辑、路由、故障转移（有时候 Routing、LB 和 Failover是同一个问题，都需要通过 routing 技术来切换流量的 endpoint）。 代理方案：减轻了客户端的职责和压力，架构上的负担过重。  Redis Cluster 的出">
<meta property="og:locale">
<meta property="og:image" content="https://magicliang.github.io/img/wall-paper-24.jpg">
<meta property="article:published_time" content="2019-11-09T11:13:46.000Z">
<meta property="article:modified_time" content="2026-01-24T07:32:06.754Z">
<meta property="article:author" content="magicliang">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://magicliang.github.io/img/wall-paper-24.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Redis 笔记之十一-集群 Cluster",
  "url": "https://magicliang.github.io/2019/11/09/Redis-%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8D%81%E4%B8%80-%E9%9B%86%E7%BE%A4-Cluster/",
  "image": "https://magicliang.github.io/img/wall-paper-24.jpg",
  "datePublished": "2019-11-09T11:13:46.000Z",
  "dateModified": "2026-01-24T07:32:06.754Z",
  "author": [
    {
      "@type": "Person",
      "name": "magicliang",
      "url": "https://magicliang.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://magicliang.github.io/2019/11/09/Redis-%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8D%81%E4%B8%80-%E9%9B%86%E7%BE%A4-Cluster/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: magicliang","link":"Link: ","source":"Source: 守株阁","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Redis 笔记之十一-集群 Cluster',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"><link rel="alternate" href="/atom.xml" title="守株阁" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      if ($loadingBox.classList.contains('loaded')) return
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()

  if (document.readyState === 'complete') {
    preloader.endLoading()
  } else {
    window.addEventListener('load', preloader.endLoading)
    document.addEventListener('DOMContentLoaded', preloader.endLoading)
    // Add timeout protection: force end after 7 seconds
    setTimeout(preloader.endLoading, 7000)
  }

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/wall-paper-24.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">守株阁</span></a><a class="nav-page-title" href="/"><span class="site-name">Redis 笔记之十一-集群 Cluster</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">Redis 笔记之十一-集群 Cluster</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2019-11-09T11:13:46.000Z" title="Created 2019-11-09 19:13:46">2019-11-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2026-01-24T07:32:06.754Z" title="Updated 2026-01-24 15:32:06">2026-01-24</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">3.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>11mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1>背景</h1>
<p>在 Redis Cluster 方案诞生以前，在 Redis 集群遇到单机资源和流量瓶颈时，有两种常见分布式解决方案：</p>
<ul>
<li>客户端方案：需要自己处理分区逻辑、路由、故障转移（有时候 Routing、LB 和 Failover是同一个问题，都需要通过 routing 技术来切换流量的 endpoint）。</li>
<li>代理方案：减轻了客户端的职责和压力，架构上的负担过重。</li>
</ul>
<p>Redis Cluster 的出现，极大地降低了架构师的负担，解放了生产力。</p>
<h1>数据分布</h1>
<h2 id="数据分布理论">数据分布理论</h2>
<p>|分区方式|特点|代表产品|取舍逻辑|<br>
|:–:|:–:|:–:|<br>
|哈希分区| 离散度好 数据分布业务无关 无法顺序访问| <strong>KV型</strong> Redis Cluster Cassandra Dynamo <strong>Elastic Search</strong>|如果需要平衡地存储大量数据而只有随机访问其中的若干条，则可以使用简单的哈希分区|<br>
|顺序分区|离散度易倾斜 数据分布业务相关 可顺序访问| <strong>表型 Bigtable</strong> HBase Hypertable|如果需要存储大量数据且需要支持区间查找，则也需要使用简单的顺序分区，如果要解决负载均衡的问题可能需要不均匀分片以及分裂和压缩算法的支持|</p>
<p>我们在常规的实践里，随机查找和区间查找的场景同时存在，所以主存储都是按照某个索引顺序存储（MySQL、HBase），再想着怎样使用顺序分区来解决负载均衡（不均衡就会产生倾斜）的问题。而 Dynamo、Cassandra（一个希腊女神的名字）和 Redis用于存储大批量的点状数据为宜。</p>
<p>Redis Cluster 采取<strong>哈希分区规则</strong>，常见的哈希分区规则有</p>
<h3 id="节点取余">节点取余</h3>
<p>根据固定的数量（区间数）而不只是总数取余是简单的。</p>
<p>使用特定的数据，如 Redis 的键或用户 Id，再根据节点数量 N 使用公式：<code>hash(key) % N</code>（经典的双层 hash），用来决定数据映射到哪一个桶里。这种方案存在一个问题，当节点数量变化时，整个映射关系都要重新计算。</p>
<p>如果使用这种哈希方式，一开始就要规划好分区，保证可以支撑<strong>未来一段时间的数据量</strong>，扩容时可以天然采用翻倍扩容。</p>
<p>在实践中，如果使用超量部署的方法，一开始就配好 8 个分片或者16个分片，则可能很长时间都不需要扩容-如果扩容也可以使用新建集群的方法，也不需要考虑数据迁移（然后要依赖于 rehash）的问题。预分区的规划很重要。</p>
<p>如果涉及到数据迁移，则需要考虑：</p>
<ol>
<li>新旧分区的资源申请</li>
<li>新旧分区的目标分布</li>
<li>双写</li>
<li>双读</li>
<li>停写校验</li>
<li>切换读</li>
</ol>
<h3 id="一致性哈希">一致性哈希</h3>
<p>一致性哈希（Distributed Hash Table）的实现思路是为系统中每个节点分配一个 token，范围一般在 0~2<sup>32</sup>，这些 token 构成一个 hash 环。数据读写执行查找时，先 hash，然后顺时针（向大数方向）选最近一个 bucket(第一个&gt;= hash value 的token)。</p>
<p><img src="%E4%B8%80%E8%87%B4%E6%80%A7%E6%95%A3%E5%88%97.jpg" alt="一致性散列.jpg"></p>
<p>一致性散列的好处在于加入和删除节点只影响哈希环中相邻的节点，对其他节点无影响。但一致性哈希分区存在几个问题：</p>
<ul>
<li>加减节点会造成哈希环中部分数据无法命中（取余分区一样存在这个问题），需要手动处理或者忽略这部分数据，因此一致性哈希常用于缓存场景。</li>
<li>当使用少量节点时，节点变化将大范围影响哈希环中数据映射，因此这种方式不适合少量数据节点的分布式方案。</li>
<li>普通的一致性哈希分区在增减节点时需要增加一倍或减去一般节点才能保证数据和负载的均衡。</li>
</ul>
<h3 id="虚拟槽分区">虚拟槽分区</h3>
<p>虚拟槽分区兼顾了取余分区和一致性哈希的优点，使用分散度良好的哈希函数把所有数据映射到一个固定范围的整数集合中，整数定义为槽（slot）。这个数一般远大于节点数，比如 Redis Cluster 的槽范围是 0 -16383。槽是集群内数据管理和迁移的基本单位。采用大范围的槽的目的是为了方便数据拆分和集群扩展，每个节点负责一定数量的槽。</p>
<h2 id="redis-数据分区">Redis 数据分区</h2>
<p>slot = crc16(key) * 16383</p>
<p>注意：</p>
<ul>
<li>crc16 是一种哈希函数</li>
<li>用 * 取余的方法</li>
</ul>
<p>每个节点负责维护一部分槽以及槽锁映射的键值数据。</p>
<p><img src="RedisCluster%E7%9A%84%E6%A7%BD%E4%BD%8D%E6%98%A0%E5%B0%84.jpg" alt="RedisCluster的槽位映射"></p>
<p>Redis 虚拟槽分区的特点：</p>
<ul>
<li>解耦数据和几点之间的关系，简化了节点扩容和收缩难度。如果增加一个节点 6，就需要从节点 1 ~ 5 获得部分 槽 分配到节点 6 上。如果想移除节点 1，需要将节点 1 中的槽移到节点 2 ~ 5 上，然后将没有任何槽的节点 1 从集群中移除即可。由于从一个节点将哈希槽移动到另一个节点并不会停止服务，所以无论添加删除或者改变某个节点的哈希槽的数量都不会造成集群不可用的状态。</li>
<li>节点自身维护槽的映射关系，不需要客户端或者代理服务维护槽分区元数据。</li>
<li>支持节点、槽、键之间的映射查询，用于数据路由、在线伸缩等场景。</li>
</ul>
<h2 id="redis-数据分区限制">Redis 数据分区限制</h2>
<ol>
<li>只允许对映射到同一个 slot 的 key 进行批量操作，如 mget、mset。</li>
<li>只支持对映射到同一个 node 的 key 进行事务操作。</li>
<li>大数据结构（hash/list）必须映射到同一节点（key 在最小的可分割单位）。</li>
<li>不支持多数据空间，只能使用 db0。有了 Redis Cluster，会推动多数据空间消亡。</li>
<li>复制结构只支持一层，从节点只能复制主节点。</li>
</ol>
<h1>搭建集群</h1>
<h2 id="准备节点">准备节点</h2>
<p>Redis Cluster 至少需要 6 个节点。<br>
开启配置<code>redis-enabled yes</code>。</p>
<p>准备配置文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 开启后台运行，在 docker 中不能使用这个属性，否则 redis 会直接退出，具体原因见：https://stackoverflow.com/questions/50790197/why-redis-in-docker-need-set-daemonize-to-no/50790274</span><br><span class="hljs-comment"># 实际上 docker 容器的启动命令都不能使用守护态执行，否则会直接导致 Docker 的 exec（实际上就是 init 的第一个子进程，执行命令的 shell）走到尽头直接退出。</span><br><span class="hljs-comment"># daemonize yes</span><br><span class="hljs-comment"># 指定工作目录，rdb,aof持久化文件将会放在该目录下，不同实例一定要配置不同的工作目录</span><br><span class="hljs-built_in">dir</span> <span class="hljs-string">&quot;/etc/redis-conf/dir&quot;</span><br>logfile <span class="hljs-string">&quot;/etc/redis-conf/log/redis.log&quot;</span><br><br><span class="hljs-comment"># 启用集群模式</span><br>cluster-enabled <span class="hljs-built_in">yes</span><br><span class="hljs-comment"># 生成的集群配置文件名称，集群搭建成功后会自动生成，在工作目录下</span><br>cluster-config-file <span class="hljs-string">&quot;redis-cluster.conf&quot;</span><br><span class="hljs-comment"># 节点宕机发现时间，可以理解为主节点宕机后从节点升级为主节点时间</span><br>cluster-node-timeout 5000<br><span class="hljs-comment"># 开启AOF模式</span><br>appendonly <span class="hljs-built_in">yes</span><br></code></pre></td></tr></table></figure>
<p>要特别注意：</p>
<ul>
<li>dir、log 等目录一定要可写。</li>
<li>cluster-config-file 是会被自动生成的，类似 sentinel 会覆写 sentinel 节点的配置文件。</li>
</ul>
<p><img src="%E9%9B%86%E7%BE%A4%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6.png" alt="集群启动文件.png"></p>
<h2 id="节点握手">节点握手</h2>
<p><strong>注意，配置文件里并没有指明当前任何节点属于什么集群，这些节点可以手动加入任何集群</strong>。</p>
<p>节点握手是指一批运行在集群模式下的节点通过 Gossip 协议彼此通信，达到感知对方的过程。节点握手是集群彼此通信的第一步，由客户端发起命令：<code>cluster meet {ip} {port}</code>。</p>
<p>cluster meet 是一个<strong>异步命令</strong>，执行后立即返回。内部发起与目标节点进行握手通信：</p>
<ol>
<li>节点1创建节点2的节点信息对象，并发送 meet 消息。</li>
<li>节点2接收到 meet 消息后，保存 6379 节点信息并回复 pong 消息。</li>
<li>之后节点 6379 和 6380 彼此定期通过 ping/pong 消息进行正常的节点通信。</li>
</ol>
<p><img src="cluster-meet.png" alt="cluster-meet"></p>
<p>meet、ping、pong 消息是 Gossip 协议通信的载体。它的主要作用是使节点彼此交换状态数据信息。</p>
<p>使用<code>cluster nodes</code>可以获知当前集群的全貌：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">7979ba1902bc0e282e714a67dd74ec089348f5c6</span> <span class="hljs-number">172.22.1.20:6379</span>@<span class="hljs-number">16379</span> master - <span class="hljs-number">0</span> <span class="hljs-number">1573396221415</span> <span class="hljs-number">3</span> connected<br><span class="hljs-attribute">169a1f9a2e43783af421d8d6fd1f12681cc9c1b5</span> <span class="hljs-number">172.22.1.30:6379</span>@<span class="hljs-number">16379</span> master - <span class="hljs-number">0</span> <span class="hljs-number">1573396222427</span> <span class="hljs-number">2</span> connected<br><span class="hljs-attribute">2a7a24e0b3269eaa2bfd787a04a704fa3a04e952</span> <span class="hljs-number">172.22.1.50:6379</span>@<span class="hljs-number">16379</span> master - <span class="hljs-number">0</span> <span class="hljs-number">1573396220409</span> <span class="hljs-number">4</span> connected<br><span class="hljs-attribute">847473ff9b35d4579f829626d97e24d102ce8f4c</span> <span class="hljs-number">172.22.1.40:6379</span>@<span class="hljs-number">16379</span> master - <span class="hljs-number">0</span> <span class="hljs-number">1573396221000</span> <span class="hljs-number">5</span> connected<br><span class="hljs-attribute">985a94be2fc9950bfb5d7e47fab214c42d232a05</span> <span class="hljs-number">172.22.1.60:6379</span>@<span class="hljs-number">16379</span> master - <span class="hljs-number">0</span> <span class="hljs-number">1573396221000</span> <span class="hljs-number">0</span> connected<br><span class="hljs-attribute">3e5bdb0972b892c170960b678185b034e5506d0a</span> <span class="hljs-number">172.22.1.10:6379</span>@<span class="hljs-number">16379</span> myself,master - <span class="hljs-number">0</span> <span class="hljs-number">1573396220000</span> <span class="hljs-number">1</span> connected<br></code></pre></td></tr></table></figure>
<p>其中开头的 40 位 16 进制数是当前集群的节点 id，<strong>在节点生成的时候就唯一初始化好了，每次重启都不会变-不同于 runId，runId 每次重启都会变</strong>。我们只要在集群内的任意节点上执行 <code>cluster meet</code>命令，握手状态就会通过消息在集群内传播，这样其他节点会自动发现新节点并发起握手流程。</p>
<h2 id="分配槽位">分配槽位</h2>
<p>这时候集群只是建立起来，还处于下线状态。直接往任意节点写会出现<code>(error) CLUSTERDOWN Hash slot not served</code>错误。</p>
<p>这时候执行<code>cluster info</code>命令，可以看到</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">cluster_state:fail<br>cluster_slots_assigned:0<br>cluster_slots_ok:0<br>cluster_slots_pfail:0<br>cluster_slots_fail:0<br>cluster_known_nodes:6<br>cluster_size:0<br>cluster_current_epoch:5<br>cluster_my_epoch:1<br>cluster_stats_messages_ping_sent:1947<br>cluster_stats_messages_pong_sent:1979<br>cluster_stats_messages_meet_sent:5<br>cluster_stats_messages_publish_sent:7899<br>cluster_stats_messages_sent:11830<br>cluster_stats_messages_ping_received:1979<br>cluster_stats_messages_pong_received:1952<br>cluster_stats_messages_received:3931<br></code></pre></td></tr></table></figure>
<p><code>cluster_slots_assigned:0</code>意味着当前的集群的槽位没有做过映射，<strong>只有节点被分配了槽位，才能响应和这些槽关联的键命令</strong>。</p>
<p>首先把所有槽位分配给 3 个节点。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 要在 bash 环境下使用，否则 &#123;0..5461&#125; 不会被 redis-cli 的上下文识别</span><br>redis-cli -h 127.0.0.1 -p 6379 cluster addslots &#123;0..5461&#125;<br>redis-cli -h 127.0.0.1 -p 6380 cluster addslots &#123;5462..10922&#125;<br>redis-cli -h 127.0.0.1 -p 6381 cluster addslots &#123;10923..16383&#125;<br></code></pre></td></tr></table></figure>
<p>这个时候再执行<code>cluster info</code>，则会看到：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">cluster_state:ok<br>cluster_slots_assigned:16384<br>cluster_slots_ok:16384<br>cluster_slots_pfail:0<br>cluster_slots_fail:0<br>cluster_known_nodes:6<br>cluster_size:3<br>cluster_current_epoch:5<br>cluster_my_epoch:1<br>cluster_stats_messages_ping_sent:574<br>cluster_stats_messages_pong_sent:456<br>cluster_stats_messages_publish_sent:2190<br>cluster_stats_messages_sent:3220<br>cluster_stats_messages_ping_received:456<br>cluster_stats_messages_pong_received:571<br>cluster_stats_messages_received:1027<br></code></pre></td></tr></table></figure>
<h2 id="制造主从结构">制造主从结构</h2>
<p>这时候把剩下三个节点作为从节点：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 3e5bdb0972b892c170960b678185b034e5506d0a 是要复制的主节点 node id</span><br>redis-cli -h 127.0.0.1 -p 6382 cluster replicate 3e5bdb0972b892c170960b678185b034e5506d0a<br></code></pre></td></tr></table></figure>
<p>这时候集群就已经开始各司其职了。</p>
<p><img src="cluster-nodes.png" alt="cluster-nodes"></p>
<p><img src="%E9%9B%86%E7%BE%A4%E5%AE%8C%E6%95%B4%E7%BB%93%E6%9E%84.png" alt="集群完整结构.png"></p>
<h2 id="简便方案">简便方案</h2>
<p>下面的命令可以一键生成集群，如果 Redis 版本不够高，就必须使用<code>redis-trib.rb</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># --cluster-replicas 1 告诉 Redis 每个主节点应该使用多少个从节点。</span><br>redis-cli --cluster  create --cluster-replicas 1  127.0.0.1:6379 127.0.0.1:6380 127.0.0.1:6381 127.0.0.1:6382 127.0.0.1:6383 127.0.0.1:6384<br></code></pre></td></tr></table></figure>
<p>如果当前节点都位于同一个 host 上，就会报<code>[WARNING] Some slaves are in the same host as their master</code>信息。实际上这些节点都处于一个 docker 集群里，但因为共用了<code>127.0.0.1</code>的地址，触发了反亲和性报错。</p>
<p>广播协议。<br>
共识协议。<br>
发布订阅。<br>
流言协议。</p>
<h1>搭建一个集群管理平台要回答好几个问题</h1>
<ol>
<li>业务归属地<br>
2.事业群、业务线：这里主要供运维参考，方便集群的运维管理。</li>
<li>集群部署位置（几个地域、几个中心）</li>
<li>服务等级</li>
<li>是否涉及现金交易：如果涉及到支付场景，请与SRE/DBA联系。</li>
<li>容量预估：需求容量应该事先评估好，减少后续的扩容次数（扩容过程会不会有数据丢失要看存储方案）。</li>
<li>峰值QPS(次/秒)预估</li>
<li>读写分布</li>
<li>客户端类型：根据实际使用情况进行选择，通常是 Redisson。</li>
<li>集群名：应该能准确简介地描述业务的功能或用途。使用“-”分隔（不要出现超过三次），不要出现环境结尾（环境后缀通常会自动被拼进去），不要出现数字。</li>
<li>集群描述：详细描述具体使用场景</li>
<li>是否持久化：redis集群主要提供的是存储功能。如果仅仅是作为缓存来用，持久化功能可以关闭，关闭了持久化功能的集群可以提供更好的性能。</li>
<li>是否可淘汰</li>
<li>可运维周期（星期几、是否工作日）。</li>
<li>可运维时间（通常是业务低峰期）。</li>
</ol>
<h1>怎样隔离 kv？</h1>
<p>制造名字空间。</p>
<p>一种思路是<code>key</code>等于<code>${表名}.${列名}_${version}</code>。每一个 key 要指定类型为好。</p>
<ul>
<li>category 表名</li>
<li>template 列名</li>
<li>version 是 redis 内部管理的一个数字，如果这个 category 清一次缓存，那么 version 会加1，这样最后的 key 字符串会变成全新的字符串，应用使用新的 key 之后需要重新从数据源加载数据到缓存-这又要引入事件驱动机制。</li>
</ul>
<h1>集群与集群组</h1>
<p>在 Set/单元化架构中，一个 cluster group 包含多个 ldc 里的多个 cluster，每个 cluster 服从每个 unit/region/set 的配置。</p>
<p>在 cluster group 里对 category 进行操作最终会同步到各个 cluster 上。</p>
<h1>集群的辅助服务</h1>
<ul>
<li>Redis-Keeper 集群间数据同步，美团也有自己的 Squirrel-Keeper</li>
<li>Redis-Migrate 扩容/迁移</li>
<li>Redis-Web 管理</li>
<li>Redis-Monitor 监控告警</li>
<li>Redis-Schedule 调度/运营</li>
<li>Redis-HA 集群高可用</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://magicliang.github.io">magicliang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://magicliang.github.io/2019/11/09/Redis-%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8D%81%E4%B8%80-%E9%9B%86%E7%BE%A4-Cluster/">https://magicliang.github.io/2019/11/09/Redis-%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8D%81%E4%B8%80-%E9%9B%86%E7%BE%A4-Cluster/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Redis/">Redis</a></div><div class="post-share"><div class="social-share" data-image="/img/wall-paper-24.jpg" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2019/10/30/Redis-%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8D%81-%E5%93%A8%E5%85%B5-Sentinel/" title="Redis 笔记之十-哨兵 Sentinel"><img class="cover" src="/img/wall-paper-128.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2019-10-30</div><div class="info-item-2">Redis 笔记之十-哨兵 Sentinel</div></div><div class="info-2"><div class="info-item-1">Redis 有若干套高可用实现方案。2.8 开始提供哨兵功能（不要使用更低版本的哨兵，可能有 bug）。 基本概念  主从复制模式的问题 Redis 天然就带有主从复制的功能，但主从复制有若干缺点：  需要手工干预，缺乏自动 FO 机制-分布式高可用问题。 单机的写能力有限-分布式容量问题。 单机的存储能力有限-分布式容量问题。  一个经典的高可用场景 当一个主从集群的 主节点 失效的时候，经典的恢复步骤如下：  主节点失效。 选出新的从节点，slaveof no one。 先更新应用方的连接。 再让其他从节点换主。 再把恢复好的主节点作为新的从节点复制新的主节点。  3 和 4 的步骤可以互换。这种需要手工介入的运行机制不能被当作高可用的。而 sentinel 的作用是把这些经典步骤从手工实现为自动。 Sentinel 的高可用性 Sentinel 方案是在原生的 Master-Slave 集群之外加上一个 Sentinel 集群。 每个 Sentinel 节点会监控其他 Sentinel 节点和所有 Redis 节点。任何一个不可达的节点，它都会将其做下线标识。 如果标识的是...</div></div></div></a><a class="pagination-related" href="/2022/01/13/Redis-%E7%AC%94%E8%AE%B0%E4%B9%8B%EF%BC%9A%E5%86%85%E5%AD%98%E8%B0%83%E4%BC%98/" title="Redis 笔记之：内存调优"><img class="cover" src="/img/wall-paper-23.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-13</div><div class="info-item-2">Redis 笔记之：内存调优</div></div><div class="info-2"><div class="info-item-1">Redis 的 memory info Redis 的内存使用状况可以使用info memory来获取。 需要重点关注的值是 used_memory_rss（用于存储消耗的物理内存），used_memory（用于存储消耗的内存= 物理内存 + 硬盘），以及他们的比值mem_fragmentation_ratio（used_memory_rss/used_memory）。 used_memory_rss或者used_memory很高时，意味着当前的 Redis 实例正在蚕食系统中的内存/硬盘资源。 当这个mem_fragmentation_ratio大于 1 的时候，意味着用于存储消耗的物理内存超过了 Redis 自己掌控的内存值，也就意味着当前有些未能回收的内存泄漏或者碎片。 当这个mem_fragmentation_ratio小于 1 的时候，这意味着有一部分用于存储的内存，实际上是在使用虚拟内存中的 swap 空间，此时 Redis 的性能会非常差。 Redis 的内存轮廓 memory_used = 进程自身消耗的内存 + 存储对象的内存（大头） + buffer 内存 m...</div></div></div></a><a class="pagination-related" href="/2024/11/04/Redis-%E5%BC%80%E5%8F%91%E4%B8%8E%E8%BF%90%E7%BB%B4/" title="Redis 开发与运维"><img class="cover" src="/2024/11/04/Redis-%E5%BC%80%E5%8F%91%E4%B8%8E%E8%BF%90%E7%BB%B4/cover.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-04</div><div class="info-item-2">Redis 开发与运维</div></div><div class="info-2"><div class="info-item-1">Redis 特性 Redis 高性能的原因 Redis 的读写性能达到 10w/s，主要基于以下原因：  数据主要放在内存中。 Redis 使用距离 OS “层次更近”的 C 语言实现。 Redis 使用单线程架构，没有很高的 lock contention。 IO 多路复用技术 Redis 的代码实现得优雅而兼顾性能  Redis 的数据结构 Redis 本身是 Remote Dictionary Server 的简称，其中，老的、常见的数据结构有：  字符串 哈希 列表 set（集合） zset（有序集合）  但后来追加了几种新颖的数据机构，包括：bitmap、hyperloglog，更后来更添加了 GEO 地理信息相关的工具。 基于这些数据结构，我们可以实现一些常见的功能：  键过期，可以用来实现缓存，进而实现分布式锁。 发布订阅功能，进而实现消息系统（TODO）。 Lua 脚本功能，可以实现自定义的 Redis 命令（TODO）。 实现简单的事务功能，能在一定程度上实现事务特性。 提供流水线功能，能够让客户端一次性把一批命令一次性上传到 Redis 里，能够合并 IO 并...</div></div></div></a><a class="pagination-related" href="/2025/07/28/Redis-%E7%9A%84%E7%A5%9E%E5%A5%87%E7%94%A8%E4%BE%8B/" title="Redis 经典用例全解：从数据结构到系统设计"><img class="cover" src="/img/wall-paper-175.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-28</div><div class="info-item-2">Redis 经典用例全解：从数据结构到系统设计</div></div><div class="info-2"><div class="info-item-1">Redis 不只是缓存。它是一把瑞士军刀——凭借五种基础数据结构和若干扩展模块，Redis 能解决从分布式锁到社交网络、从排行榜到消息队列的几乎所有高频系统设计问题。 本文的目标是：建立一套从业务问题到 Redis 数据结构的映射思维。对于每个用例，我们都会回答三个问题：  业务问题是什么？ 需求的本质是什么操作？ 为什么选 Redis？ 相比 MySQL、MQ 等方案，Redis 的优势和代价是什么？ 怎么设计？ 用哪种数据结构，Key 怎么命名，核心命令是什么？  mindmap   root((Redis 用例全景))     基础存储       缓存策略         Cache-Aside         穿透/击穿/雪崩       分布式会话         Session 共享         验证码/短链接       分布式 ID         INCR 自增         日期分段     并发控制       分布式锁         SET NX         Redlock         看门狗续期       计数器与限流        ...</div></div></div></a><a class="pagination-related" href="/2025/07/29/%E7%BC%93%E5%AD%98%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" title="缓存系统设计——从穿透到雪崩的完整攻略"><img class="cover" src="/img/wall-paper-90.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-29</div><div class="info-item-2">缓存系统设计——从穿透到雪崩的完整攻略</div></div><div class="info-2"><div class="info-item-1">缓存是提升系统性能的第一利器，但也是引发故障的第一杀手。缓存穿透、缓存击穿、缓存雪崩——这三大问题几乎是每个后端工程师都会遇到的挑战。本文将系统性地剖析缓存系统的设计原则、经典问题及其解决方案，从单机缓存到分布式缓存，从理论到生产实践。  Part 1: 缓存的基本原理 为什么需要缓存    存储介质 访问延迟 吞吐量 成本     CPU L1 Cache ~1 ns — 极高   CPU L3 Cache ~10 ns — 高   内存（RAM） ~100 ns ~10 GB/s 中   SSD ~100 μs ~500 MB/s 低   HDD ~10 ms ~100 MB/s 极低   网络（同机房） ~500 μs — —   网络（跨机房） ~50 ms — —    内存访问比 SSD 快 1000 倍，比 HDD 快 100,000 倍。缓存的本质就是用更快的存储介质保存热点数据的副本。 缓存的命中率 命中率 = 命中次数 / (命中次数 + 未命中次数)    命中率 效果 说明     &lt; 50% 差 缓存几乎没有意义   50-80% 一般 有一定效果...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">背景</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">数据分布</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%88%86%E5%B8%83%E7%90%86%E8%AE%BA"><span class="toc-number">2.1.</span> <span class="toc-text">数据分布理论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E5%8F%96%E4%BD%99"><span class="toc-number">2.1.1.</span> <span class="toc-text">节点取余</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C"><span class="toc-number">2.1.2.</span> <span class="toc-text">一致性哈希</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%A7%BD%E5%88%86%E5%8C%BA"><span class="toc-number">2.1.3.</span> <span class="toc-text">虚拟槽分区</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis-%E6%95%B0%E6%8D%AE%E5%88%86%E5%8C%BA"><span class="toc-number">2.2.</span> <span class="toc-text">Redis 数据分区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis-%E6%95%B0%E6%8D%AE%E5%88%86%E5%8C%BA%E9%99%90%E5%88%B6"><span class="toc-number">2.3.</span> <span class="toc-text">Redis 数据分区限制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">搭建集群</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%86%E5%A4%87%E8%8A%82%E7%82%B9"><span class="toc-number">3.1.</span> <span class="toc-text">准备节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E6%8F%A1%E6%89%8B"><span class="toc-number">3.2.</span> <span class="toc-text">节点握手</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E6%A7%BD%E4%BD%8D"><span class="toc-number">3.3.</span> <span class="toc-text">分配槽位</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%B6%E9%80%A0%E4%B8%BB%E4%BB%8E%E7%BB%93%E6%9E%84"><span class="toc-number">3.4.</span> <span class="toc-text">制造主从结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BE%BF%E6%96%B9%E6%A1%88"><span class="toc-number">3.5.</span> <span class="toc-text">简便方案</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">搭建一个集群管理平台要回答好几个问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">怎样隔离 kv？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">集群与集群组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">集群的辅助服务</span></a></li></ol></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2017 - 2026 By magicliang</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional and Simplified Chinese">簡</button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><script src="/js/tw_cn.js?v=5.5.2"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="/"></script></div></body></html>