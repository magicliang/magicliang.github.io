<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>数据密集型应用系统设计 - Designing Data Intensive Applications | 守株阁</title><meta name="author" content="magicliang"><meta name="copyright" content="magicliang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="数据密集（Data-Intensive）与计算密集（Compute-Intensive）是当今两大负载类型。前者以大数据为代表，后者以深度学习和 HPC 为主要代表。 谨以本书献给那些追逐梦想的人们。 [另一个电子版本。][1] 前言 数据密集型应用要处理的瓶颈往往是数据的规模、数据的复杂度和数据产生与变化的速率；与之对应的是计算密集型应用，CPU 往往成为其瓶颈。 本书是关于数据处理系统及其相关">
<meta property="og:type" content="article">
<meta property="og:title" content="数据密集型应用系统设计 - Designing Data Intensive Applications">
<meta property="og:url" content="https://magicliang.github.io/2020/10/11/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-Designing-Data-Intensive-Applications/index.html">
<meta property="og:site_name" content="守株阁">
<meta property="og:description" content="数据密集（Data-Intensive）与计算密集（Compute-Intensive）是当今两大负载类型。前者以大数据为代表，后者以深度学习和 HPC 为主要代表。 谨以本书献给那些追逐梦想的人们。 [另一个电子版本。][1] 前言 数据密集型应用要处理的瓶颈往往是数据的规模、数据的复杂度和数据产生与变化的速率；与之对应的是计算密集型应用，CPU 往往成为其瓶颈。 本书是关于数据处理系统及其相关">
<meta property="og:locale">
<meta property="og:image" content="https://magicliang.github.io/2020/10/11/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-Designing-Data-Intensive-Applications/ddia.jpeg">
<meta property="article:published_time" content="2020-10-11T15:09:02.000Z">
<meta property="article:modified_time" content="2025-10-22T08:01:32.321Z">
<meta property="article:author" content="magicliang">
<meta property="article:tag" content="系统架构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://magicliang.github.io/2020/10/11/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-Designing-Data-Intensive-Applications/ddia.jpeg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "数据密集型应用系统设计 - Designing Data Intensive Applications",
  "url": "https://magicliang.github.io/2020/10/11/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-Designing-Data-Intensive-Applications/",
  "image": "https://magicliang.github.io/2020/10/11/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-Designing-Data-Intensive-Applications/ddia.jpeg",
  "datePublished": "2020-10-11T15:09:02.000Z",
  "dateModified": "2025-10-22T08:01:32.321Z",
  "author": [
    {
      "@type": "Person",
      "name": "magicliang",
      "url": "https://magicliang.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://magicliang.github.io/2020/10/11/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-Designing-Data-Intensive-Applications/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: magicliang","link":"Link: ","source":"Source: 守株阁","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据密集型应用系统设计 - Designing Data Intensive Applications',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="守株阁" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/2020/10/11/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-Designing-Data-Intensive-Applications/ddia.jpeg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">守株阁</span></a><a class="nav-page-title" href="/"><span class="site-name">数据密集型应用系统设计 - Designing Data Intensive Applications</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">数据密集型应用系统设计 - Designing Data Intensive Applications</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2020-10-11T15:09:02.000Z" title="Created 2020-10-11 23:09:02">2020-10-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-10-22T08:01:32.321Z" title="Updated 2025-10-22 16:01:32">2025-10-22</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">109.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>339mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>数据密集（Data-Intensive）与计算密集（Compute-Intensive）是当今两大负载类型。前者以大数据为代表，后者以深度学习和 HPC 为主要代表。</p>
<p>谨以本书献给那些追逐梦想的人们。</p>
<p>[另一个电子版本。][1]</p>
<h1>前言</h1>
<p>数据密集型应用要处理的瓶颈往往是数据的规模、数据的复杂度和数据产生与变化的速率；与之对应的是计算密集型应用，CPU 往往成为其瓶颈。</p>
<p>本书是关于数据处理系统及其相关技术的（NoSQL、消息队列、缓存、搜索引擎、批处理和流处理框架）。</p>
<p>每一种技术都基于一定的设计理念，而且只适用于特定的场景。</p>
<p><strong>不要过度优化。</strong></p>
<h1>数据系统基础</h1>
<h1>可靠、可扩展与可维护的应用系统</h1>
<p>现在的典型系统架构已经很明确了，因为业界已经有成功的案例，对这些组件做了很好的抽象，我们只要做好拿来主义就行了。</p>
<h2 id="可靠性-reliability">可靠性（Reliability）</h2>
<p>fault tolerance 和 resilience 是系统的容错的体现。</p>
<h3 id="硬件故障">硬件故障</h3>
<p>对于大型 IDC，即使磁盘的 MTTF 很高，磁盘数量大了以后，每天发生磁盘损坏也是正常的事情。</p>
<p>硬件容错的方案是制造冗余（冗余磁盘、冗余电源）。</p>
<p>软件容错是第二种方式。</p>
<h3 id="软件错误">软件错误</h3>
<p>软件错误可以被认为是 bug。检查 bug 的方法就是不断地做契约检查、测试。</p>
<h3 id="人为失误">人为失误</h3>
<p>运维错误是系统下线的首要原因。</p>
<p>常见的做法有：</p>
<ul>
<li>以最小出错的方式来设计系统。</li>
<li>想办法分离最容易出错的地方、容易引发故障的接口。</li>
<li>充分的测试。</li>
<li>当出现人为错误时、提供快速恢复机制。</li>
<li>设置详细而清晰的监控子系统，包括性能指标和错误率。</li>
<li>推行管理流程并加以培训。</li>
</ul>
<h2 id="可扩展性-scalability">可扩展性（ Scalability）</h2>
<p>如果系统以某种方式增长，我们应对增长的措施有哪些。</p>
<h3 id="描述负载">描述负载</h3>
<h4 id="twitter-的例子">Twitter 的例子</h4>
<p>Twitter 的高扇出（fan-out）的结构：</p>
<p>2011 年时：</p>
<ul>
<li>用户发送 tweet 可以 达到 12k request/sec</li>
<li>用户有 300 k request/sec 的 home timeline 的读请求</li>
</ul>
<p>用户有不同的扇出结构，决定了他们的潜在写放大的系数。</p>
<p>对于 home timeline 的读，有两种方式可以获取所有内容：</p>
<h5 id="lazy-方案">lazy 方案</h5>
<p>这个方案是基础方案，基于 MySQL 的联表查询。</p>
<p>每次每个 follower 读取自己的 home timeline 时，首先 join 自己的 follows 表里的 followee（通过 user_id = follower_id），然后用 followee 去 join user 表（ 通过 followee_id = user_id 这一步其实可以省略），然后用 user 表去 join tweets（通过 user_id = sender_id）。</p>
<p>这种 join 方法可以通过 server side join 来优化，但本质上还是逐步联表。每次做联表查询的时候 join 一次。</p>
<p>如果有必要，这里还可以把 join 的结果缓存起来优化频繁刷新的场景。</p>
<p>这种方法的缺点是，读取大量数据时老老实实地联表查询过多，性能不好。</p>
<h5 id="eager-方案">eager 方案</h5>
<p>这个方案是性能优化方案，基于动态创建的广播队列。</p>
<p>每次每个 followee 发送 tweet 时，会先插入数据到 tweet 表里，然后通过广播的方式把这个 tweet 插入到每个 follower 的一个总的 tweets 列表里。在架构抽象这个列表是一个 mail box，这个列表可以是数据库，也可以是缓存的 list，也可以是 mq 的 topic/consumer。因为 mq 的 topic/consumer 不适合多对多的生产者和消费者的映射关系，<strong>而且动态创建 topic 的成本也很高</strong>。缓存的 list（如 redis 的 list）的创建销毁成本很低，很适合这种场景。</p>
<p>这种方案的优点是比方案 1 性能高两个数量级。联表查询的性能比较差，很容易达到自身的执行瓶颈，不容易scale out；而 broadcast 的 scale out 以后性能比较好，但如果 fan-out 很大的话，broadcast 的时间会非常长，但本质上 broadcast是一种复制方案，复制方案的瓶颈极高。</p>
<p>因此 Twitter 最后的解决方案是先对大多数 followee 的 tweets 采用方案 2，而对于 fanout 特别多的 followee 的 tweets 使用方案 1。为什么？因为动态大规模 eager 写的成本太高了，并不是每个名人的粉丝都想读到这些信息。</p>
<p>用户最终看到的内容，始终是方案 2 和方案 1 延迟合并（merge）的结果。方案1的 lazy 性对于 celebrity 用户的访问是有离散性的，对于方案1还可以使用一个复制副本的方式来提高主动查询（搜索）场景的性能。</p>
<p>这个例子可以应用在非常多的 OLAP 场景内：即对于大数据量的数据汇总查询，我们可以优先采取 eager write 或者 broadcast 的方法在写事务的时候插入汇总数据；<strong>然后对于 fan-out 特别高的数据，在查询的时候 lazy 查询</strong>。</p>
<p>选择方案时，需要考虑的因素主要是写成本比较高，还是读成本比较高：</p>
<ul>
<li>如果全量写的不会被全量读（<strong>明星扇出效应实在太高，却并不是每个 follower 都去读</strong>），而写成本很高的话，不如用 lazy read。</li>
<li>如果读的场景很高，联表查询出现的比例很高，则适合 eager write。</li>
</ul>
<h3 id="描述性能">描述性能</h3>
<p>批处理系统更看重吞吐量，即每秒处理的记录数；而在线系统更看重响应时间，即客户端从发送请求到接收响应之间的时间差（response time = server side latency + communication overhead）。响应时间不是一个固定的数字，而是一个可度量的数字分布。</p>
<p>我们可以用平均值来说明一些问题，但更多的情况下关注分布，我们使用百分位数（percentile），如 p50、p90、p95、p99。亚马逊使用 p999 来定义起内部服务的响应时间标准。</p>
<p>定义 SLA 有助于我们确定我们的标准，我们要为**最慢的响应（tail latencies 长尾效应）**优化到什么地步（百分位越高，越难优化）。</p>
<p>排队延迟往往在百分数响应时间中影响很大。因为服务器并行处理的请求优先，正在处理的少数请求可能阻挡后续的请求。这被称为队头阻塞。做负载测试的时候不要<strong>等待队头阻塞（无意中缩短队列长度）</strong>，要尽可能多地发送请求。</p>
<p>实践中，总是会使用滑动窗口来持续监控性能变化。</p>
<p>在实践之中，最慢的响应，决定了用户的 RT。</p>
<p>针对特定级别负载设计的架构不太可能应付超出预设目标 10 倍的实际负载-引入 APM 监控非常重要。</p>
<p>在<strong>多台机器上分配负载被称为无共享架构</strong>。这种架构易于水平扩展。如果服务负载高度不可预测，则引入自动的弹性扩展是好的，否则手动扩展更能处理意外情况。</p>
<p><strong>超大规模的系统往往针对特定应用而高度定制，很难有一种通用架构</strong>。背后取舍的因素很多，如数据读写量、复杂程度、存储量，响应时间要求。</p>
<p>对特定应用而言，通常我们要做出某些假设（在可用性、一致性上做假设，如单元化场景下的弱一致性假设），有所取舍，才能在我们需要获得进展的方面取得结果-我们应该只优化最频繁的操作，或其他亟需我们优化的操作。</p>
<p>**可扩展架构通常是从通用模块逐步构建而来，背后往往有规律可循。**本书将讨论通用模块和常见模式。</p>
<h2 id="可维护性">可维护性</h2>
<p>软件的成本在于整个生命周期内持续的维护。而遗留系统总有其过期的原因，很难给出通用的优化建议。</p>
<p>可维护性可以被分为三个方面：</p>
<ul>
<li>可运维性：运维/运营/SRE 团队易于保持系统平稳。</li>
<li>简单性：新的工程师能够轻松理解系统。</li>
<li>可演化性：能够轻松对系统改进</li>
</ul>
<h3 id="可运维性">可运维性</h3>
<p>运维团队可能有很多操作，数据系统设计可以提供如下便利：</p>
<ul>
<li>Observability</li>
<li>文档</li>
</ul>
<h3 id="简单性">简单性</h3>
<p>大泥球应用除了功能以外，还提供很多额外意外的复杂性。这种意外的复杂性是可以消除的-而不必减少功能。</p>
<p>消除复杂性最好的手段之一就是抽象。<strong>抽象可以隐藏大量的细节</strong>，而且<strong>可以对外提供干净、易懂的接口。</strong>-接口是很多人的系统里最简洁的部分了，单一职责、接口分离是我们必须强调的。</p>
<h3 id="可演化性">可演化性</h3>
<p>易于修改的系统，易于演化。我们总是处在不断变化的需求中。</p>
<h1>数据模型与查询语言</h1>
<p>语言的边界就是世界的边界。-《逻辑哲学论》</p>
<p>大多数程序都是通过一层一层叠加数据模型的方式来构建的（如网络协议中不同层使用不同的包）。</p>
<p>不同的数据模型支持的操作不一样，有的操作很好，有的操作很不好-数据结构决定算法，数据结构加算法等于程序。精通一种数据模型需要很大功夫。</p>
<h2 id="关系模型与文档模型">关系模型与文档模型</h2>
<h3 id="历史">历史</h3>
<p>Edgar Codd关系型数据库的核心用例最初是商业数据处理，曾经出现过网络模型和层次模型等不同的范式作为竞争对手，但最终关系模型成为最终的赢家。</p>
<p>在关系模型里，relation 最终被当作表，行即元组。</p>
<p>NoSQL 是关系模型的有力竞争者，最初出现在 Twitter tag 里。它用 schemaless 换取了表达能力的提升，sharding 和 replica 换取了 scalability 的提升。</p>
<p>NoSQL 对 OO 的编程语言的适配性更好。</p>
<p>Linkedin profile 的例子告诉我们，education 和 position 对 user 而言是多对一的关系，可以建模为单独的行，也可以建模为嵌套的文档-因此可以使用 json document 来标表示（这可以转化为 json tree），也可以用关系型数据库的 xml/json 类型来表达。但行业、地区等全局的常量数据，则比较适合用单独的表来存放，使用 id 来引用，而严重不适合冗余存放。</p>
<p>不变的业务 fk、物理 fk 适合冗余，而时间/状态则不适合冗余。冗余可以减少联表查询的复杂度，但也会增加 update 的难度。</p>
<p>IBM 的 IMS 是最初的层次模型，可以很好地处理一对多问题，但不能很好地处理多对多问题-这种困境近似于现在文档数据库遇到的困境。</p>
<p>网络模型的代表是 CODASYL。在 CODASYL 里面每层有多个父节点，因此实现了多对多。在这种模型里，外键是指针，指针不是外键。这种模型按照路径遍历非常麻烦，更新也非常麻烦。</p>
<p>而使用了关系型数据库后，查询优化器会根据索引和表间关系，来生成“访问路径”-也就是执行计划。查询优化器是是一个被持续优化的怪兽。</p>
<p>文档数据库是某种意义上的层次模型-父文档保存了子文档。</p>
<p>文档型数据库的优点：性能更好，模型更像是程序自己的数据结构，<strong>适合一对多模型</strong>。</p>
<p>关系型数据库则强在 join、<strong>多对一和多对多的表达上</strong>。但，只要文档数据库可以通过标识符来引用其他文档，则文档数据库的表达能力并没有因而减弱。</p>
<p>如果原始数据有类似树型/层次/文档的复合结构，则比较适合使用文档数据库；否则应该对数据进行分解（规范化），得到关系型数据库的表。</p>
<p>通常，关系型表的数据结构相关的代码是更复杂的。但，如果需要引用嵌套的数据，则嵌套层次越深，文档型模型越不好用。</p>
<p>通常情况下，流式/批处理框架/消息队列里的 event，也适于使用文档数据库。事实上，除了订单系统里的订单/子订单以外，应该大量数据模型都可以放进文档型数据库里。</p>
<p>如果确实需要 join，则文档数据库的弊端就出现了。反范式化很难维护一致性，而且程序的流程会变复杂，流程变差了。</p>
<p>总而言之，关联性越高和数据库选型的关系是：文档型（如 MongoDB；可搜索嵌套 doc 的 ES）→ 关系型 → 图数据库（Neo4j / Neptune / JanusGraph）。</p>
<h3 id="模式灵活性">模式灵活性</h3>
<p>应该说，文档型数据库有模式灵活性，它支持<strong>读时模式</strong>（与之相对地，关系型数据库支持的是<strong>写时模式</strong>）。文档型数据库往往不在写时执行强制模式校验，读时的兼容性必须由读时的应用程序来保证。</p>
<p>关系型数据库因为执行写时校验，所以出现模式变更时，往往需要成本很高的 migrate 操作。</p>
<p>如果外部模式很多，或者模式很易变-最典型的例子，配置型数据，则很适合使用文档型数据库；反之，关系型数据库则要被派上用场。<strong>模式的害处在于，它不易于变动。</strong></p>
<p>写时模式 (Schema-on-Write)：数据的结构（模式/Schema）在数据被写入数据库时就被严格定义和强制执行。</p>
<p>读时模式 (Schema-on-Read)：数据在被写入数据库时没有强制的结构要求。数据可以以任何（通常是文档形式）存入。数据的结构（模式）是在数据被读取时才被解析和应用。</p>
<h4 id="数据局部性与性能">数据局部性与性能</h4>
<p>文档型数据库还有一个缺点，就是对它更新，需要<strong>原地重写</strong>，写的开销很大，可能引起存储问题。</p>
<p>举例：ES 是新版本文档重写。</p>
<h3 id="融合的趋势">融合的趋势</h3>
<p>关系型数据库和文档数据库的融合是大势所趋。当代的 RDBMS 已经可以很好地处理 XML；而一部分的文档型数据库则可以在查询时支持 join（mongo 是在 client 端支持的，这种方案性能不够好，但支持也比不支持强）。</p>
<h2 id="数据查询语言">数据查询语言</h2>
<h3 id="数据库里的查询语言">数据库里的查询语言</h3>
<p>SQL 其实是种声明式查询语言，而 CODASYL 实际上是命令式。</p>
<p>命令式的查询语言，会把查询过程 HOW 写出来（所以我们经常做的客户端查询，都是命令式的查询），告诉计算机，要按照怎样的特定顺序，执行某些操作（第三步可以被扩展，扩展为 map reduce 的不断串联/并联执行）。</p>
<p>而声明式的查询语言，只会把 what 写出来（LINQ 最为明显），指定查询哪些模式，满足哪些条件，需要做怎样的数据处理/聚合。剩下的查询过程，由查询优化器来推导。</p>
<p>声明式的语言都有一个特性，就是无法/也不需要指定执行的流程的细节，这给了编译器/运行时重排执行流程，甚至并行化执行的机会。-<strong>声明式其实是一种高级抽象，能够实现复杂查询流程的数据库，才能提供很漂亮的声明式查询语言，这体现了架构设计的一种取舍。</strong></p>
<p>MongoDB 里面的 AST 式的查询语言，本身只是重新发明了一遍 SQL 罢了。</p>
<h3 id="web-领域的查询语言">web 领域的查询语言</h3>
<p>即使只在 Web 领域，CSS 代表的声明式语言，也比 JavaScript 代表的命令式查询要优雅很多。</p>
<h3 id="mapreduce-查询">MapReduce 查询</h3>
<p>MapReduce 起源于谷歌，MongoDB 和 couchDB 等文档型数据库也部分支持 MapReduce。</p>
<p>map 是函数式编程里的 collect，而 reduce 则是 fold 或者 inject。</p>
<p>MapReduce 不是声明式查询语言，也不是一个完全命令式的查询 API，而是介于两者之间：查询（及处理）的逻辑用代码片段来表示，这些代码片段会被框架来重用（代码片段的设计思路，也被用于 Stream 这项新兴技术中）。通常我们使用 map 来生成逻辑 KV，然后用 reduce 对相同的 Key 的 value 进行聚合处理。</p>
<p>map reduce 我们使用纯函数，因为没有副作用，所以纯函数的顺序和执行为之是非常自由的。</p>
<p>MapReduce 实际上是一种<strong>偏底层的编程模型</strong>，需要执行在计算集群上（否则性能并不好）。<strong>SQL 是极高层的计算模型</strong>，可以通过 MapReduce 来间接实现。当然，这两者之间并不必然有关系。</p>
<h2 id="图计算模型">图计算模型</h2>
<p>多对多模型是不同数据模型之间的重要区别特征。关系型数据库只适合处理简单的多对多关系，复杂的多对多关系需要使用图模型。</p>
<p>图包括顶点和边，常见的图有：</p>
<ul>
<li>社交网络</li>
<li>Web 图</li>
<li>公路或铁路网</li>
</ul>
<p>图的强大之处在于，它不仅可以存储同构数据，它提供了单个数据存储区中保存完全不同类型对象的一致性方式。</p>
<p>有多种不同但相关的方法可以构建和查询图中的数据，常见的图有属性图（property graph）和三元存储模型（triple-store），相关的查询语言有三种：Cypher、SPARQL 和 Datalog。</p>
<p>图计算模型比关系型数据库或者 CODASYL 更加自由，不需要指定 schema，而任何顶点都可以和其他顶点互联。</p>
<h3 id="属性图">属性图</h3>
<p>在属性图中，每个顶点包括：</p>
<ul>
<li>唯一的标识符</li>
<li>出边的集合</li>
<li>入边的集合</li>
<li>属性的集合（键-值对）</li>
</ul>
<p>每个边包括：</p>
<ul>
<li>唯一的标识符</li>
<li>边开始的顶点（尾部的顶点）</li>
<li>边结束的顶点（头部的顶点）</li>
<li>描述两个顶点间关系类型的标签</li>
<li>属性的集合（键-值对）</li>
</ul>
<p>把这两种定义转化为 SQL，可以得到两张表：顶点表和边表。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-comment">-- 顶点表</span><br><span class="hljs-keyword">CREATE TABLE</span> `vertices` (<br>  `id` <span class="hljs-type">bigint</span> <span class="hljs-keyword">NOT NULL</span> AUTO_INCREMENT COMMENT <span class="hljs-string">&#x27;物理主键&#x27;</span>,<br>  `properties` json <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;顶点属性，适应变化&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY KEY</span> (`id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB AUTO_INCREMENT<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8mb4 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8mb4_unicode_ci;<br><br><span class="hljs-comment">-- 边表</span><br><span class="hljs-keyword">CREATE TABLE</span> `edges` (<br>  `id` <span class="hljs-type">bigint</span> <span class="hljs-keyword">NOT NULL</span>,<br>  `tail_vertex` <span class="hljs-type">bigint</span> <span class="hljs-keyword">NOT NULL</span> COMMENT <span class="hljs-string">&#x27;尾顶点&#x27;</span>,<br>  `head_vertex` <span class="hljs-type">bigint</span> <span class="hljs-keyword">NOT NULL</span> COMMENT <span class="hljs-string">&#x27;头顶点&#x27;</span>,<br>  `properties` json <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;属性&#x27;</span>,<br>  `label` <span class="hljs-type">varchar</span>(<span class="hljs-number">45</span>) <span class="hljs-keyword">NOT NULL</span> COMMENT <span class="hljs-string">&#x27;关系类型的标签&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY KEY</span> (`id`),<br>  KEY idx_tail_vertex (`tail_vertex`) <span class="hljs-keyword">USING</span> BTREE,<br>  <span class="hljs-keyword">UNIQUE</span> KEY idx_vertices (`head_vertex`,`tail_vertex`) <span class="hljs-keyword">USING</span> BTREE<br>) ENGINE<span class="hljs-operator">=</span>InnoDB AUTO_INCREMENT<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8mb4 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8mb4_0900_ai_ci;<br></code></pre></td></tr></table></figure>
<p>关于图模型还有一些值得注意的地方：</p>
<ol>
<li>任何顶点都可以连接到其他顶点。没有模式限制哪种事务可以或者不可以关联。</li>
<li>给定某个顶点，可以高效地得到它的所有入边和出边，从而遍历图，即沿着这些顶点链条一直向前或者向后。</li>
<li>通过对不同的类型的关系使用不同的标签，可以在单个图中存储多种不同类型的信息，同时仍然保持整洁的数据类型。-传统的关系模型难以表达不同国家的不同地区结构和颗粒度。</li>
</ol>
<p>图是易于演化的，可以动态地往图里添加功能，图可以很容易适应并扩展。</p>
<p>图是一种前程远大，应用场景广泛的技术。</p>
<h3 id="cypher-查询语言">Cypher 查询语言</h3>
<p>Neo4j 是从黑客帝国里诞生的概念，Cypher 是另一个（和密码学里的 Cypher 恰巧同名），这两个名词都是从人名里诞生的。</p>
<p>我们可以先创建库和数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">CREATE</span> <br>(NAmerican: location, &#123;name: <span class="hljs-string">&#x27;North America&#x27;</span>, type: <span class="hljs-string">&#x27;continent&#x27;</span>&#125;),<br>(USA: location, &#123;name:<span class="hljs-string">&#x27;United States&#x27;</span>, type:<span class="hljs-string">&#x27;country&#x27;</span>&#125;),<br>(Idaho: location, &#123;name:<span class="hljs-string">&#x27;Idaho&#x27;</span>, type:<span class="hljs-string">&#x27;state&#x27;</span>&#125;),<br>(Lucy: person, &#123;name:<span class="hljs-string">&#x27;Lucy&#x27;</span>, type:<span class="hljs-string">&#x27;&#x27;</span>&#125;),<br>(Idaho) <span class="hljs-operator">-</span>[:<span class="hljs-keyword">WITHIN</span>] <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> (USA) <span class="hljs-operator">-</span>[:<span class="hljs-keyword">WITHIN</span>] <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> (NAmerica),<br>(Lucy) <span class="hljs-operator">-</span> [:BORN_IN] <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> (Idaho)<br></code></pre></td></tr></table></figure>
<p>相应的查询语句是这样的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">MATCH</span><br>(person) <span class="hljs-operator">-</span>[:BORN_IN] <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> () <span class="hljs-operator">-</span> [:<span class="hljs-keyword">WITHIN</span><span class="hljs-operator">*</span>o..]<span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> (us: location, &#123;name:<span class="hljs-string">&#x27;United States&#x27;</span>&#125;),<br>(person) <span class="hljs-operator">-</span>[:LIVES_IN] <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> () <span class="hljs-operator">-</span> [:<span class="hljs-keyword">WITHIN</span><span class="hljs-operator">*</span>o..]<span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> (eu: location, &#123;name:<span class="hljs-string">&#x27;Europe&#x27;</span>&#125;),<br><span class="hljs-keyword">RETURN</span> person.name<br></code></pre></td></tr></table></figure>
<p>这里的式子分两层：第一层在右边，表明这是任意一个处于特定地点的地点，而第二层在左边，表明这是和第一层变量相关联的顶点。person 是一个待求值的变量。</p>
<p>遍历有两种基本思路：</p>
<ul>
<li>从每个 person 开始，沿着出边过滤。</li>
<li>从 us 和 eu 这两个顶点开始，沿着入边过滤。</li>
</ul>
<p>使用声明式的查询语句，可以让查询优化器自由地决定执行策略。</p>
<p>同样地，我们可以用关系型数据库来表达图数据库。但通常， SQL 查询要求我们能够制定 join 的次序和数量；对于图查询，join 操作的数量不是预先确定的。这种不能确定 join 顺序和次数的查询，容易诱发 SQL 的反模式。</p>
<p><code>WITHIN*o..</code> 的意思是，沿着 WITHIN 边，遍历 0 次或多次。</p>
<p>在 SQL 1999 中，查询这种可变的遍历路径，可以使用被称为<strong>递归公用表表达式</strong>（即 WITH_RECURSIVE 语法）来表示。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-comment">-- head vertex 的意思是箭头，这个算法就是递归地从右向左找点（每找到一个点都把点添加进点集合里），而箭头本身带有 withhin 标签。</span><br><span class="hljs-comment">-- 这个声明式的算法，可以用类似图算法的方法，命令式地实现</span><br><span class="hljs-keyword">WITH</span> <span class="hljs-keyword">RECURSIVE</span><br>      <span class="hljs-comment">-- in_usa 包含所有的美国境内的位置ID</span><br>        in_usa(vertex_id) <span class="hljs-keyword">AS</span> (<br>        <span class="hljs-keyword">SELECT</span> vertex_id <span class="hljs-keyword">FROM</span> vertices <span class="hljs-keyword">WHERE</span> properties <span class="hljs-operator">-</span><span class="hljs-operator">&gt;&gt;</span> <span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;United States&#x27;</span><br>        <span class="hljs-keyword">UNION</span><br>        <span class="hljs-keyword">SELECT</span> edges.tail_vertex <span class="hljs-keyword">FROM</span> edges<br>          <span class="hljs-keyword">JOIN</span> in_usa <span class="hljs-keyword">ON</span> edges.head_vertex <span class="hljs-operator">=</span> in_usa.vertex_id<br>          <span class="hljs-keyword">WHERE</span> edges.label <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;within&#x27;</span><br>      ),<br>      <span class="hljs-comment">-- in_europe 包含所有的欧洲境内的位置ID</span><br>        in_europe(vertex_id) <span class="hljs-keyword">AS</span> (<br>        <span class="hljs-keyword">SELECT</span> vertex_id <span class="hljs-keyword">FROM</span> vertices <span class="hljs-keyword">WHERE</span> properties <span class="hljs-operator">-</span><span class="hljs-operator">&gt;&gt;</span> <span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Europe&#x27;</span><br>        <span class="hljs-keyword">UNION</span><br>        <span class="hljs-keyword">SELECT</span> edges.tail_vertex <span class="hljs-keyword">FROM</span> edges<br>          <span class="hljs-keyword">JOIN</span> in_europe <span class="hljs-keyword">ON</span> edges.head_vertex <span class="hljs-operator">=</span> in_europe.vertex_id<br>          <span class="hljs-keyword">WHERE</span> edges.label <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;within&#x27;</span> ),<br>      <span class="hljs-comment">-- born_in_usa 包含了所有类型为Person，且出生在美国的顶点</span><br>        born_in_usa(vertex_id) <span class="hljs-keyword">AS</span> (<br>          <span class="hljs-keyword">SELECT</span> edges.tail_vertex <span class="hljs-keyword">FROM</span> edges<br>            <span class="hljs-keyword">JOIN</span> in_usa <span class="hljs-keyword">ON</span> edges.head_vertex <span class="hljs-operator">=</span> in_usa.vertex_id<br>            <span class="hljs-keyword">WHERE</span> edges.label <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;born_in&#x27;</span> ),<br>      <span class="hljs-comment">-- lives_in_europe 包含了所有类型为Person，且居住在欧洲的顶点。</span><br>        lives_in_europe(vertex_id) <span class="hljs-keyword">AS</span> (<br>          <span class="hljs-keyword">SELECT</span> edges.tail_vertex <span class="hljs-keyword">FROM</span> edges<br>            <span class="hljs-keyword">JOIN</span> in_europe <span class="hljs-keyword">ON</span> edges.head_vertex <span class="hljs-operator">=</span> in_europe.vertex_id<br>            <span class="hljs-keyword">WHERE</span> edges.label <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;lives_in&#x27;</span>)<br>      <span class="hljs-keyword">SELECT</span> vertices.properties <span class="hljs-operator">-</span><span class="hljs-operator">&gt;&gt;</span> <span class="hljs-string">&#x27;name&#x27;</span><br>      <span class="hljs-keyword">FROM</span> vertices<br>        <span class="hljs-keyword">JOIN</span> born_in_usa <span class="hljs-keyword">ON</span> vertices.vertex_id <span class="hljs-operator">=</span> born_in_usa.vertex_id<br>        <span class="hljs-keyword">JOIN</span> lives_in_europe <span class="hljs-keyword">ON</span> vertices.vertex_id <span class="hljs-operator">=</span> lives_in_europe.vertex_id;<br></code></pre></td></tr></table></figure>
<p>从这个例子可以看出来，SQL 不如 Cypher，SQL 不具备找到一行记录后自递归的方法。</p>
<h3 id="三元存储与-sparql">三元存储与 SPARQL</h3>
<p>三元存储模型几乎等同于属性图模型，他们只是用不同的名词来描述了相同的思想。</p>
<p>在三元组中，所有信息都以非常简单的三部分形式存储（主语，谓语，客体）。</p>
<ol>
<li>三元组里主体相当于顶点，谓语和宾语相当于 proerpties 中的 key 和 value。</li>
<li>三元组中的主体相当于顶点，谓语是途中的边，客体是头部顶点。</li>
</ol>
<h5 id="语义网">语义网</h5>
<p>Datomic 是一个三元组存储（其实是五元组，带有 2 元版本数据）。语义网（Semantic Network）不是三元组，语义网本身没有靠谱的实现，从未实际出现。</p>
<h4 id="sparql">SPARQL</h4>
<p>SPARQL（音“sparkle”）出现得比 Cypher 早，Cypher 的模式匹配是借用 SPARQL 的。</p>
<h4 id="datalog-出现得更早">Datalog 出现得更早</h4>
<p>Datalog 出现得更早，为 Cypher 和 SPARQL 奠定了基础。它是 Datomic 的查询语言。Datalog 是 Prolog 的一些子集。</p>
<h2 id="小结">小结</h2>
<p>数据的模型发展的脉络，不过是：</p>
<p>树型 -&gt; 文档 -&gt; 关系模型 -&gt; 图</p>
<p>关联越多，越适合使用后面的数据库。<strong>关系模型的平衡性最好，可以模拟其他数据模型</strong>。从这个顺序来讲，<strong>文档模型是关系模型在复杂性上的退化/或者简化</strong>。但<strong>唯有关系模型是强制使用模式的</strong>。</p>
<p>如果需求不断变化，模式可能不断变化，应该尽量选择无模式的数据模型。</p>
<p>每种模型都有自己的查询语言和框架。</p>
<p>这些模型在实现的时候，需要做一些权衡取舍。</p>
<h1>数据存储和检索</h1>
<p>从最基本的层面看，数据库只做两件事情：向它插入数据时，它就保存数据；之后查询时，它应该返回那些数据。</p>
<p>作为应用开发人员，我们大多数情况下不可能从头开始实现一个自己的存储引擎，往往需要从现存的存储引擎中选择一个适合自己的。其他针对事务型工作负载和针对分析型工作负载的存储引擎存在很大的差异。</p>
<p>我们将研究关系型数据库和 NoSQL 数据库，我们将研究两个存储引擎家族，即日志结构的存储引擎和面向页的存储引擎，比如 B-tree（B-tree 是页的组织）。</p>
<h2 id="数据库核心：数据结构">数据库核心：数据结构</h2>
<p>数据存储里通常有三种数据结构：日志、页和索引。</p>
<h3 id="日志">日志</h3>
<p>许多数据库内部都使用日志，日志是一种只支持追加式更新的数据文件。**一个数据库还要处理其他问题：并发控制、回收磁盘空间、错误处理和部分完成写记录等。**但日志始终是一个很有用的机制，被用在很多地方-崩溃恢复、数据复制。</p>
<h3 id="索引">索引</h3>
<p>在日志里面查找结果是不好的，所以引入第二种数据结构-索引。</p>
<p>索引的基本设计思想是，在原始数据上派生额外数据结构，在索引上保留关键数据或者元数据，作为路标，帮助定位想要的数据。</p>
<p>不同的索引支持不同的搜索方式。</p>
<p>索引必然导致写性能下降，因为索引很难使用追加写，<strong>但追加写是性能最高的写入方式</strong>。</p>
<h4 id="哈希索引">哈希索引</h4>
<p>KV 结构随处可见，是构造更多更复杂索引的基础构造块。如，继承/封装 hashmap 是常见的存储方法。</p>
<p>一个特别简单粗暴的例子：Bitcask 的存储格式，使用 CSV 来存储 kv 值，使用 hashmap 来存储 key 和文件系统里的 offset 来充当索引。</p>
<p>我们不能只依赖于一个数据文件，这会导致磁盘空间耗尽-<strong>所以我们对大规模存储应该采取分段的形式。</strong></p>
<p>但使用多段数据，往往意味着数据需要压缩。压缩可以让段变小，因为段被合并后就不会再被修改，所以很适合放进新文件里。这样可以把旧文件段留出来，提供读写支持。</p>
<p>每个段都有自己的内存哈希表。-这里引出了一个范式，一段数据，到底在内存里是怎么被组织的，在硬盘里又是怎么被组织的，可以完全不一样。</p>
<p>这个方法是最简单的方法。但要在实践中行之有效，还要考虑如下问题：</p>
<ol>
<li>文件格式：CSV 不是最佳的文件格式，二进制才是。</li>
<li>删除记录：如果要删除键和值，在日志里追加一个删除日志是简单的做法（墓碑）。墓碑会让记录在被合并时删除键值的实际内容。</li>
<li>崩溃恢复：从头到尾读取日志是一个方法，快照内存里的 hashmap 是另一个方法-这和 RDB/AOF 的设计思想是很像的，快照可以加速崩溃恢复，快照本身就是 compaction 过的值。</li>
<li>部分写入的记录：文件要加上校验和。</li>
<li>并发控制：<strong>只有一个写线程追加写入（类似 log4j 的设计），多个线程并发读</strong>-单线程后台消费是一种解决并发问题的基本思路。</li>
</ol>
<p>为什么要使用追加写，而不是原地更新？这应该是几乎所有的存储使用日志配合数据页的解决方案需要回答的问题。</p>
<ol>
<li>追加的顺序写性能好。</li>
<li>顺序写的并发控制和崩溃恢复会简单得多-只有一个数据文件很难处理脏数据和正确的数据。</li>
<li>有了文件合并，可以减少数据文件本身的碎片程度-所以数据文件本身还是 要紧凑，不能作为写的中间文件。</li>
</ol>
<h5 id="内存里的-hash-表有什么缺点？">内存里的 hash 表有什么缺点？</h5>
<ol>
<li>（因为装填因子的存在）内存利用率不高。</li>
<li>区间查询效率不高。</li>
</ol>
<p>目前只有 Mongodb、MySQL（<code>ENGINE=MEMORY</code>）、PostSQl（<code>CREATE INDEX idx_hash ON table USING HASH (column);</code>）。</p>
<h4 id="sstables-和-lsm-tree">SSTables 和 LSM-Tree</h4>
<p>SSTables 是排序字符串表，以它优化 Bitcask 的例子的话，会产生如下变化：</p>
<ol>
<li>每个的日志段里只能存在一个 key 的最新 v 值，<strong>不按照它们的写入顺序排序，而按照 key 的字典序排序，每个 key 只出现一次（这就像 TreeMap 了）。</strong>-一个 key 的多个值存在多个段里。</li>
<li>段按照特定的时间段（<strong>生成时间</strong>）顺序排序，这也就意味着 compaction 多个段的时候，可以按照时间的顺序读取同一个 key，只保留某个 key 的最新值，丢弃其他段里的其他值。</li>
<li>在内存里保存的索引不需要指向所有的 key value 值，只要能够找到特定的段上的区间起止值，就可以找到特定的段上的最新的 kv，<strong>这样我们可以得到一个稀疏的索引</strong>。</li>
<li>我们的值写入永远都是随机写入的，相关的存储引擎是这样工作的：</li>
<li><strong>写入先写入内存中的平衡数据结构</strong>（通常是某种平衡树，如红黑树），这被叫作内存表（Mem table）。</li>
<li>当内存表的大小达到某个阈值以后，将其生成一个 SSTable 写入磁盘中，然后再生成下一个内存表继续供写入（这应该是一个原子切换）。</li>
<li>如果有读操作，先在内存表里查找，然后按照写顺序查找最新的磁盘段文件、次新的磁盘段文件，以此类推，直到找到目标（或为空）。</li>
<li>后台周期性地执行段合并与压缩过程，<strong>以合并多个段文件并丢弃那些已被覆盖或者删除的值</strong>。</li>
<li>为了防止数据库崩溃，也要准备 WAL。WAL 使用<strong>纯粹的追加写</strong>，而不是排序写（这样的性能最好）。一段日志对应一段 WAL。</li>
</ol>
<p>上述算法实质上是 LevelDB（Riak）和 RocksDB 所使用的，可以嵌入其它程序中提供 KV 存储。这两个引擎都受到 Google 的 BigTable 论文的影响（它引入了 SSTable 和 Mem table 两个术语）。</p>
<p>这种索引结构由 LSM-Tree 命名（这一章可能总体上被称作 LSM-Tree 算法）。Lucene 也使用类似的方案存储 term 和相关的 doc。</p>
<p>**总有很多细节，值得深入优化。**如果有个 Key 找不到，则 LSM-Tree 算法的表现可能很慢。这样可以引入布隆过滤器，近似计算集合的内容。</p>
<p>还有其他的策略可以影响甚至决定 SSTables 压缩和合并时的具体顺序和时机。最常见的方式是大小分级和分层压缩。分层压缩是 LevelDB 和 RocksDB 使用的策略，HBase 使用大小分级，Cassandra 同时支持这两种压缩。</p>
<p>在大小压缩中，较新的和较小的 SSTables 被连续合并到较旧和较大的 SSTables 里。</p>
<p>在分层压缩中，键的范围分裂成多个更小的 SSTables，旧数据被移动到单独的“层级”，这样压缩可以逐步并行并节省磁盘空间。</p>
<p>LSM 的基本思想（保存在后台合并的一系列 SSTable）足够简单有效。<strong>即使数据集远远大于可用内存</strong>，它仍然能够正常工作。<strong>由于磁盘是顺序写入的，LSM-Tree 可以支持非常高的写入吞吐量</strong>。</p>
<p><img src="LSM-Tree-Algorithm.jpg" alt="LSM-Tree-Algorithm.jpg"></p>
<p>要实现上面的结构，要特别考虑各种写操作的并发安全性，高性能还在其次。</p>
<ol>
<li>R-B Tree 就是 MemTable 的一种实现，不是“先 R-B Tree 再变成 MemTable”。</li>
<li>Bloom 过滤器是 SSTable 的附属结构，不是 MemTable 的。</li>
<li>SSTable 不是“类 TreeMap”，它是不可变、排序的磁盘文件，TreeMap 是内存结构。</li>
<li>WAL 和 SSTable 是并行存在的，不是“WAL 变成 SSTable”。<strong>WAL 是崩溃恢复用</strong>，SSTable 是刷盘后用。</li>
</ol>
<h4 id="b-tree">B-tree</h4>
<p>log-structure 日志索引结构正在逐渐受到更多的认可，但目前最广泛使用的索引结构是 B-tree。</p>
<p>从 1970 诞生以来，B-tree <strong>经历了长久的时间的考验</strong>，时至今日，它仍然是几乎所有关系型数据库中的标准索引实现。</p>
<p>B-tree 也按 Key 对键值对排序（证明这个特性极端重要，对于存储而言，区间查找的重要性超乎想象地有用，这也是为什么 hash 类的存储结构使用场景不广泛的原因）。</p>
<p>B-tree 首先把数据库分解成固定大小的块和页（因为操作系统通常使用块作为名称，所以数据库经常使用页），这样更接近底层硬件的设计。页是内部读写的最小单元。</p>
<p>每个页面都有自己的地址。</p>
<p><img src="b-tree.png" alt="b-tree"></p>
<p>B-tree 中一个页所包含的子页引用数量称为分支因子（branching factor）。这种设计使得 B-tree 在 O(logn) 的深度上保持平衡。（如果使用 B+ 树）一个分支因子为 500（通常应该为几百）的 4kb 页（InnoDB默认页大小是16kb）只要 4 层就能够存储 256tb 左右的数据。</p>
<h5 id="如何使-b-tree-更可靠？">如何使 B-tree 更可靠？</h5>
<p>对 B-tree 的底层写操作基本上是使用新数据来代替磁盘上的旧页，（通常）这不会改变该页的磁盘存储位置。这与 LSM-tree 形成鲜明的对比，<strong>后者只是追加写（实际上在 SSTable 内部还是排序更新文件，但总体上是追加写），新旧替换的操作发生在后台线程的 compaction 里。</strong></p>
<p>为了做崩溃恢复，B-tree 当然还是需要引入 WAL（而且 WAL 也会进化，从 binlog 进化到 redo log）。</p>
<p>如果要原地更新数据页，还要考虑并发控制问题，所以需要考虑锁存器（一种轻量级锁）；相比之下，日志结构化的方法先显得更简单了，因为它的实际原地更新是在后台发生的。</p>
<h6 id="如何优化-b-tree？">如何优化 B-tree？</h6>
<ol>
<li>引入 COW，SNAPSHOT Isolation + 锁。</li>
<li>保存 key 的缩略信息，节省页空间，这样树具有更高的分支因子，从而减少层数（这就引入了 B+ 树）。</li>
<li>尽量让相邻的页在磁盘上尽量连续。</li>
<li>在叶子上添加额外的指针，这样寻找兄弟不需要找 parent（这也是 B+树的特性）。</li>
<li>分形树引入了一些 log-structure 来减少磁盘寻道。</li>
</ol>
<h4 id="对比-b-tree-和-lsm-tree">对比 B-tree 和 LSM-tree</h4>
<h5 id="lsm-tree-的优点是什么？">LSM-tree 的优点是什么？</h5>
<p>通常认为，LSM-tree 对写入更快，而 B-tree 对读写更快。当然，真正的性能表现只能选取特定的 workload 进行负载测试才能看出来。</p>
<p>磁盘的总带宽是有限的，SSD 的可擦除写的次数是有限的，所以日志结构的写入可能带来的写放大值得关注，至少 compaction 可能降低初始写入的性能。</p>
<p>因为 compaction 的存在，所以 LSM-tree 的的碎片比 B-tree 要少，所以磁盘上的文件通常要更小。这个结论未必对，因为 LSM-tree 里面是存在重复的键值对的，B-tree 没有这种重复的成本。</p>
<h6 id="lsm-tree-的缺点是什么？">LSM-tree 的缺点是什么？</h6>
<p>compaction 会影响正在进行的读写操作。如果初始写入吞吐量很高，则压缩可能不能真正匹配上它的写入速率。</p>
<p>通常我们不能限制初始写入的速率。</p>
<p>因为多副本的存在，LSM-tree 不具备 B-tree 能够简单地锁住记录而提供事务功能的优点。</p>
<h4 id="其他索引结构">其他索引结构</h4>
<p>索引包括：</p>
<ul>
<li>主键索引</li>
<li>二级索引：值得关注的是 posting-list，或者追加唯一标识使二级索引成为唯一索引的场景。</li>
</ul>
<p>B-tree 和 log-structure 都可以拿来实现二级索引（甚至主键索引）。</p>
<p>索引中存储的要么是值，要么是堆文件的位置信息。堆文件才是真正存储数据的地方。</p>
<p>有了堆文件，只是更新值而不变更键，可以触发原地变更，否则需要牵扯到更多的文件修改和指针值修改。</p>
<p>但从索引到堆文件的额外跳转意味着<strong>太多的性能损失</strong>，所以聚集索引是很重要的。但创造聚集索引的次数是有限的，**聚集索引和非聚集索引之间的折中是覆盖索引。**覆盖索引只通过索引就可以回答某些简单的查询。</p>
<p>如果要同时查询多个列的信息，需要引入多列索引，但普通的多列索引在处理<strong>复杂的二维搜索</strong>的时候可能出现索引跳跃的问题：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> restaurants <span class="hljs-keyword">WHERE</span> latitude <span class="hljs-operator">&gt;</span> <span class="hljs-number">51.4946</span> <span class="hljs-keyword">AND</span> latitude <span class="hljs-operator">&lt;</span> <span class="hljs-number">51.5079</span> <br>                           <span class="hljs-keyword">AND</span> longitude <span class="hljs-operator">&gt;</span> <span class="hljs-number">-0.1162</span> <span class="hljs-keyword">AND</span> longitude <span class="hljs-operator">&lt;</span> <span class="hljs-number">-0.1004</span>;<br></code></pre></td></tr></table></figure>
<p>这种时候可能需要引入专门的空间索引（SPATIAL index），如 R 树（PostgreSQL 支持 R 树查询）。</p>
<p>如果我们使用模糊索引，可以在某个编辑距离内搜索特定的文本。</p>
<p>我们很多数据结构设计起来都是为了<strong>适应磁盘的限制</strong>（注意，这里的磁盘和 SSD 是两样东西），比如 B+tree 的深度和链表结构就是为了适应访问文件块的次数和寻道时间。我们之所以使用磁盘，有至少几个原因：</p>
<ol>
<li>磁盘可以持久化数据。</li>
<li>磁盘的成本比内存低。</li>
<li>磁盘上的文件更加容易使用外部工具运维-因为已经在进程之外了。</li>
</ol>
<p>但如果没有磁盘的限制，我们可以得到极大的性能提升。这种内存提升不是因为磁盘的性能比较差，而是因为避免了用写磁盘的格式对内存数据结构进行编码的开销。因为只要内存足够大，虚拟内存可以使用磁盘的存储引擎充分利用内存。但如果可以自由地使用数据结构，像 Redis 一样的方案可以提供很多样的实现。</p>
<p>有一种类似虚拟内存的页内存管理机制的方案，anti-caching。反缓存把足够冷的记录交换出内存，写入磁盘，再需要时再单独取回。这个方案比页式内存管理好的地方是，颗粒度更低，比操作系统管理内存的方案更有效。</p>
<p>如果将来 NVM 技术得到普及，可能还需要进一步改变存储引擎设计。</p>
<h2 id="事务处理与分析处理">事务处理与分析处理</h2>
<p>事务是在商业数据处理中诞生的，主要指组成一个逻辑单元的一组写操作。广义的事务处理不一定意味着 ACID，只是意味着低延迟的读取和写入。</p>
<p>数据库被广泛用于处理业务交易，也被用于数据分析，这两种模式有显著差异：</p>
<ul>
<li>OLTP 基于键处理，每次查询返回<strong>少量记录</strong>，随机访问，低延迟写入，数据量小。</li>
<li>OLAP 对<strong>大量记录</strong>进行汇总（aggregate），通常要搭配 ETL。</li>
</ul>
<p>这两种模式都需要交互式响应。<br>
SQL 非常灵活，被证明能够同时胜任 OLTP 和 OLAP。但从上世纪 90 年代初期开始了一种趋势，大企业放弃使用 OLTP 系统用于分析目的，而在单独的数据库上运行分析。这个单独的数据库被称为数据仓库。</p>
<h3 id="数据仓库">数据仓库</h3>
<p>企业可能有几十种不同的交易处理系统（Transaction Process System）。这些系统每一个都足够复杂，也每一个都非常重要，数据库管理员往往不愿意让业务分析人员在 OLTP 数据库上直接运行临时分析查询，这些查询代价很高，<strong>可能损害并发执行事务的性能</strong>-反之，隔离、专属数据库可以反过来保护并发事务的性能。</p>
<p>数据仓库里包含公司所有 OLTP 系统的只读副本，通过 ETL 流程导入数据。</p>
<p>几乎所有的大型企业都有数据仓库，但是在小型企业中却几乎闻所未闻。</p>
<p>单独的数据仓库，可以针对分析访问模式进行优化。值得注意的是，本章前半部分讨论的索引算法适合 OLTP，但不擅长应对分析查询。</p>
<h3 id="oltp-数据库和数据仓库之间的差异">OLTP 数据库和数据仓库之间的差异</h3>
<p>有许多图形化的数据分析工具，它们可以生成 SQL 查询、可视化结果并支持分析师探索数据，例如通过诸如向下钻去、切片和切丁等操作。</p>
<p>数仓和 OLTP 系统的相似之处是：他们都有 SQL 接口。这也可以看出 SQL 作为声明式语言，抽象表达能力之强。</p>
<p>目前市面上有商业数据仓库系统通过商业许可销售系统，也有一些开源的 SQL on hadoop 的解决方案，正在逐渐流行。</p>
<h3 id="星型与雪花型分析模式">星型与雪花型分析模式</h3>
<p>不像事务处理领域广泛使用的不同数据模型，数据仓库在分析型业务上相当公式化地使用星型模型，也成为维度建模（dimensional modeling）。</p>
<p>模式的中心是一张事实表，事实被捕获为单独的事件成为事实表中的每一行；<strong>因为事实表在中央而维度表在四周，这个模式被称为星型模式</strong>。</p>
<p>每一行里都有很多属性，和引用其他维度表的外键；这些维度表通常代表事件的对象（who）、什么（what）、地点（where）、时间（when）、方法（how）以及原因（why）。</p>
<p>星型模式有个变体，<strong>其中维度被进一步细分为子空间——维度表之间还可以再进一步用外键互相引用，而不是冗余</strong>，这种更加规范化的形态叫做<strong>雪花模型</strong>；对于分析人员而言，雪花模型比星型模型更复杂，星型 → 雪花（边更多了？）。</p>
<p>在典型的数据仓库中，表通常非常宽：事实表常见 30–50 列，特殊宽表场景可超 100 列甚至数百列；维度表也可能非常宽，因为它们常把多级描述属性反范式地拼成一张大表以加速查询。</p>
<h2 id="列式存储">列式存储</h2>
<p>如果事实表中有数亿乃至万亿行、PB 大小的数据，则高效地存储和查询这些数据将成为一个具有挑战性的问题；维度表则通常小很多，因此本节主要关注事实表的存储。</p>
<p>虽然<strong>事实表可能超过 100 列</strong>（特殊宽表场景），但典型的数据仓库查询往往一次只访问其中的 4 或 5 列。</p>
<p>在面向行的存储引擎中，若无法利用覆盖索引，引擎仍需把包含目标列的整页加载进内存——页内其余列也随之进入，解析后再过滤，造成带宽与缓存的浪费。</p>
<p>面向列的存储想法很简单：不再把一行中的所有值存在一起，而是把每列的所有值存在一起。</p>
<p>列式布局依赖一组列文件，每个文件按相同行顺序保存该列数据；这种按列切分的密集数组为后续压缩、编码及稀疏表示提供了对齐基础。</p>
<h3 id="列压缩">列压缩</h3>
<p>除了仅从磁盘中加载查询所需的列之外，还可以通过压缩数据进一步降低对磁盘吞吐量的要求。列的值序列有很多重复的话，是压缩的好兆头。在数据仓库中特别有效的一种技术是位图编码（bitmap encoding）。</p>
<p>一列如果有 n 种值，则可以有 n 种位图，每个位图上的一位，代表一行在上面是不是有值。这样重复的字面量存储空间被减少到一个比特。而且可以使用游程编码，对于 WHERE product_sk IN (30, 68, 69) 这样的查询，可以找到对应值 30, 68, 69 的位图，对它们执行按位 OR 操作，得到的结果位图就标记了所有满足条件的行。</p>
<p>这个设计思想可以总结为：拿可枚举值作为位图数量（横向数据有限），事实数量（纵向数据无限）作为比特。</p>
<p>有一个常见的误解：Cassandra 和 HBase 都源于 BigTable，但它们使用列族，将行主键与列族的列存储在一起，并且不使用列压缩（因为他们不能简单实用位图来节省空间）。<strong>所以 BigTable 模型仍然面向行</strong>，可以被称作表格型 KV。</p>
<h3 id="内存带宽和矢量化处理">内存带宽和矢量化处理</h3>
<p>面向列的存储有利于 CPU 利用内存带宽，而且快速矢量化处理。</p>
<h3 id="列存储中的排序">列存储中的排序</h3>
<p>在列存储中，行的存储顺序不重要，最简单的方法是按照插入顺序保存，这样插入一个新行只是追加到每个列文件。</p>
<p>但单独排序某一列没有意义，如果这样的话无法知道列中的某一项具体属于哪一行。如果我们知道某列中的第 k 项一定属于同一行，基于这种约定我们可以重建一行。</p>
<p>相反，即使数据是按列存储的，它也需要一次排序整行。</p>
<p>只要涉及到排序，我们就要考虑排序键。第一个排序键往往是最重要的，我们通常选择的排序键是日期之类的列，这类列 selectivity 最高。这样我们进行范围查找的时候，解空间可以一下子收敛到很小的范围，加快查找的结果。</p>
<p>一个列存储表会有一个主要的排序键（可能是复合的）。但确实可以为不同的查询模式创建不同的实体化视图（Materialized Views），每个视图可以有自己的排序键，这类似于为行存创建多个二级索引。</p>
<p>排序的另一个优点是，他可以帮助进一步压缩列。有大量重复值的列压缩率最好。第一列的压缩率最好，第二第三列的排序键的情况会更复杂。因为它们的值域里面相邻的重复值，可能因为归属于不同的第一键而被切割得七零八落-这就是局部簇聚性的局限了。</p>
<p><strong>排序优先级进一步下降的列基本上会呈现接近随机的顺序，因此通常无法压缩。</strong></p>
<h4 id="几种不同的排序">几种不同的排序</h4>
<p>面向列的存储具有多个排序顺序，这有些类似在面向行的存储汇总具有多个二级索引。但面向行的存储，行的数据只在一处，二级索引里保存的是指向行的指针；对于列存储，通常没有任何指向别处数据的指针，只有包含值的列。<strong>拥有多个维度的存储，对保持查询业务的高可用有一定帮助。</strong></p>
<h3 id="列存储的写操作">列存储的写操作</h3>
<p>B-tree 使用原地更新的方式，必然会带来数据页的裂。而列式存储每插入一行就要更新所有列，代价更大，所以选择 LSM-tree 有其必然性。</p>
<p>通常列式存储在内存中使用的数据结构是面向行还是面向列的，无关紧要（这就是为什么可以使用一个 RB-tree 的原因）。</p>
<h3 id="聚合：数据立方体和实体化视图">聚合：数据立方体和实体化视图</h3>
<p>未必每个数据仓库都基于列存储（<strong>但数据仓库的事实表如果有几百列，又会倾向于使用列存储</strong>）。</p>
<p>我们通常需要使用聚合方法处理原始数据的很多列，每次都重新处理非常浪费时间。所以这诞生了两类解决方案：</p>
<ul>
<li>实体化视图：将之前的查询结果缓存在磁盘上。我们常说的数据血缘表即是这种表。</li>
<li>虚拟视图：我们常说的 view，编写查询的快捷方式，隐藏了真实的细节，差异化地管控查询的细节- SQL on hadoop 就是为分布式文件系统设计的虚拟视图。</li>
</ul>
<p>实体化视图的写入成本很高，但查询效果很好。所以<strong>数据仓库喜欢用实体化视图而 RDBMS 喜欢使用虚拟视图</strong>。</p>
<p>实体化视图的一种常见情况被称为数据立方体。</p>
<p>一个二维的数据立方体是这样的：每个事实只包含两个维度表的外键，每个维度是二维矩阵的一个方向，而二维矩阵格子是事实的完整属性。这样，我们可以沿着任意维度应用聚合操作，得到减少一个维度的总和。</p>
<p><img src="data-cube.png" alt="data-cube.png"></p>
<p>注意，这个立方体里有一列专门的聚合列，产生了单一维度的聚合格子（这一列不能存储复合值，它必须从属于这一维度），这个聚合列才是加速的关键。</p>
<p>一般来说，事实表的维度不止五个。我们很难想象五维超立方体是什么样子的。我们可以简单想象一下：</p>
<ul>
<li>数据存放在特定的格子里</li>
<li>格子上存储了它拥有的所有维度的外键</li>
<li>格子的内容就是维度1-维度2-维度3-…-维度 x 限定的事实属性</li>
</ul>
<p>数据立方体针对某些查询会非常快，因为她已经被预先计算出来了。但它不能解决非特定维度聚合的问题，所以数据仓库还是必须存储原始数据。</p>
<h2 id="小结">小结</h2>
<p>OLTP 面向用户，OLAP 面向业务分析师。</p>
<p>OLTP 方面，有两个流派的存储引擎：</p>
<ul>
<li>日志结构流派，它追加更新，后台合并数据页。</li>
<li>原地更新流派（B-tree 不是一种流派），它原地更新数据页。</li>
</ul>
<h1>数据编码与演化</h1>
<h2 id="数据编码格式">数据编码格式</h2>
<p>编码模式要处理模式变化，才能兼容新旧系统和新旧数据。</p>
<p>向后兼容：<strong>新代码理解老数据</strong>。<br>
向前兼容：<strong>老代码理解新数据</strong>。我们常说的新平台可以直接读老数据（比如 Java 平台和字节码的兼容性、windows和老 API 的兼容性），就是指的这个。现在向过去兼容往往是必须的，很常见；而现在向未来兼容只是基于一种假设，不常见。</p>
<p>程序通常使用（至少）两种不同的数据表示形式：</p>
<ol>
<li>在内存中，保存在专门的数据结构中，使用指针优化 cpu 进行高效访问和操作的优化-<strong>使用指针</strong>。</li>
<li>在传输和存储时，将其编码为某种<strong>自包含的字节序列</strong>，由于<strong>指针对其他进程</strong>没有意义，所以这个字节序列看起来与内存中使用的数据结构大不一样。</li>
</ol>
<p>从 1 到 2 被称为编码，从 2 到 1 被称为解码。</p>
<p>许多编程语言都内置支持将内存中的对象编码为字节序列。但它有种种缺点：</p>
<ul>
<li>不利于异构系统集成</li>
<li>容易导致安全问题</li>
<li>不利于版本管理（进而处理向前兼容和向后兼容）</li>
<li>效率不高</li>
</ul>
<p>因此我们产生了一些流行的格式，Json、XML 与二进制变体。这些格式处理数字、模式、二进制数据都有一些小小的问题。</p>
<p>明文是前后兼容性最好的格式，也是最不紧凑的格式。所以越是大数据量的场合，越要发明一些新颖的格式来解决容量问题。</p>
<h3 id="三个例子">三个例子</h3>
<p>Thrift、Protobuf、Avro 是三种数据编码格式，也是3种IDL定义语言，可以通过工具生成不同语言的代码。</p>
<ul>
<li>Protobuf (Protocol Buffers)：主要专注于数据序列化。虽然它也支持定义服务（用于 gRPC），但其核心和最初的设计目标是高效的数据编码。</li>
<li>Thrift：由 Facebook（现 Meta）开发，不仅支持数据序列化，还内置了对RPC 服务的定义和实现支持。它是一个更完整的跨语言服务开发框架的一部分。</li>
<li>Avro：由 Apache 开发，同样支持数据序列化。它的一个显著特点是其 Schema（模式）与数据一起存储（在数据文件中）或在通信时交换，这使得它在处理模式演化（Schema Evolution）方面非常强大和灵活。Avro 也常用于 Hadoop 生态系统中。</li>
</ul>
<h2 id="数据流格式">数据流格式</h2>
<p>**进程内通信是共享内存的通信；进程间通信是基于字节序列的数据编码通信。**我们编写程序时进行函数间调用，就是进程内通信；我们编写 API 进行服务间通信，就是进程间通信。</p>
<h3 id="基于数据库的数据流">基于数据库的数据流</h3>
<p>基于数据库的数据流要注意模式演化和兼容性问题。</p>
<h3 id="基于服务的数据流：rest-和-prc">基于服务的数据流：REST 和 PRC</h3>
<p>服务器公开的 API 被称为服务，API 通常包括一组标准的协议和数据格式。Web 浏览器、服务器和网站作者都同意这些标准，所以可以使用任何浏览器访问任何网页。</p>
<p>Web 浏览器不是唯一的客户端，移动设备或者桌面计算机上的应用程序也可以向服务器发出网络请求。</p>
<p>此外，服务器本身也可以成为另一项服务的客户端。这种方法可以用于将大型应用程序按照功能区域分解为较小的服务，服务之间通过请求传递数据。这种构建应用程序的方式被称为 SOA 或者微服务架构。</p>
<p>SOA/微服务体系结构的一个关键设计目标是，<strong>通过使服务可独立部署和演化，让程序更易于更改和维护</strong>。</p>
<ol>
<li>RPC：关注动作或行为。客户端调用远程服务器上的一个“函数”或“过程”，就像调用本地函数一样。例如：getUserInfo(123) 或 CalculateTax(order)。接口设计围绕可执行的操作。</li>
<li>REST：关注资源。服务器管理各种资源（如用户、订单、产品），客户端通过标准的 HTTP 方法（GET, POST, PUT, DELETE）对这些资源的 URI 进行操作。例如：GET /users/123 (获取用户), POST /orders (创建订单)。接口设计围绕资源及其状态。</li>
</ol>
<h4 id="网络服务">网络服务</h4>
<p>当 HTTP 被用作与服务通信的底层协议时，它被称作 Web 服务。</p>
<p>REST 不是一种协议，而是一种基于 HTTP 原则的设计理念。它强调：</p>
<ul>
<li>简单的数据格式</li>
<li>使用 URL 来标识资源</li>
<li>并且使用 HTTP 功能进行缓存控制、身份验证和内容类型协商</li>
</ul>
<p>REST 在微服务架构非常受欢迎。</p>
<p>相比之下，SOAP 是基于 XML 的协议，虽然它最常用于 HTTP，但其设计目的是独立于 HTTP，并避免使用大多数 HTTP 的功能。SOAP 相关的复杂框架通常是 Web Service Framework，被称为<code>WS-*</code>。因此它的 API 通常使用 WSDL 来生成代码，使用本地类和方法调用来访问远程服务。</p>
<p>SOAP 过于复杂，对于没有 SOAP 供应商支持的编程语言的用户来说，试图与 SOAP 服务集成非常困难。</p>
<h4 id="远程过程调用-rpc-的问题">远程过程调用（RPC）的问题</h4>
<p>EJB、RMI、DCOM 和 CORBA，各有其局限性。</p>
<p>**RPC 思想试图使向远程网络服务发出请求看起来与在同一进程中调用编程语言中的函数或方法相同（这种抽象被称作位置透明）。**这种方法有根本的缺陷（我们无法克服这些分布式计算与生俱来的缺陷），网络请求与本地函数调用非常不同：</p>
<ul>
<li>本地函数调用是可预测的，并且成功或失败仅取决于控制的参数。而网络请求不可预测，因此必须有所准备，重试所有的请求。</li>
<li>本地函数调用要么返回一个结果，要么抛出一个异常，或者永远不会返回（因为无限循环或进程崩溃）。网络请求返回时可能没有结果。</li>
<li>如果重试失败的网络请求，可能会发生请求实际上已完成，只是响应丢失的情况，这又要求我们建立重复数据消除（幂等性）机制。</li>
<li>调用本地函数的时间大致相同，而网络请求的耗时则不同。</li>
<li>调用本地函数有时候只要传输指针就行（有时候传递数据，或者说，<strong>针对复杂数据量传递指针，简单数据传递数据</strong>），而远程请求则必须全部传递数据。</li>
<li>客户端和服务端可能用不同编程语言来实现，所以 RPC 框架必须处理数据类型转换的问题。</li>
</ul>
<h4 id="rpc-的发展方向">RPC 的发展方向</h4>
<p>RPC 的性能会更好，但 RESTful API 还有其他一些显著的优点：它有利于实验和调试，支持所有的主流编程语言和平台，并且有一个庞大的工具生态系统。</p>
<h4 id="rpc-的数据编码和演化">RPC 的数据编码和演化</h4>
<p>如果 RPC 经常要用于跨组织边界的通信，维护服务的兼容性会变得更加困难。服务的提供者无法控制其客户，也不能强制他们升级。</p>
<p>管理 API 版本的方法有：</p>
<ul>
<li>在 URL 或 HTTP Accept 头中使用版本号</li>
<li>使用 API 密钥来标识特定客户端的服务</li>
<li>使用单独的管理接口来更新 API 版本的选项</li>
</ul>
<h3 id="基于消息传递的数据流">基于消息传递的数据流</h3>
<p>消息是介于 RPC 和数据库之间的异步消息传递系统。客户端的请求通过低延迟传递到另一个进程中。</p>
<p>与 RPC 相比，消息传递有几个优点：</p>
<ul>
<li>消息代理可以充当缓冲区</li>
<li>它可以自动将消息重新发送到崩溃的进程，从而防止消息丢失</li>
<li>它避免了发送方需要知道接收方的IP 地址和端口号</li>
<li>它支持将一条消息发送给多个接收方</li>
<li>它在逻辑上将发送方与接收方分离</li>
</ul>
<p>与 RPC 的差异在于，消息传递通信通常是单向的。</p>
<h4 id="消息代理">消息代理</h4>
<p>有一类的消息队列，有请求队列，也有回复队列。</p>
<h4 id="分布式-actor-框架">分布式 Actor 框架</h4>
<pre><code class="hljs mermaid">graph LR
    A[Actor A] --&gt;|发送异步消息| B[Actor B]
    B --&gt;|发送异步消息| C[Actor C]
    C --&gt;|回复消息| A
    B --&gt;|发送异步消息| B[Actor B]

    style A fill:#c8e6c9,stroke:#388e3c
    style B fill:#ffecb3,stroke:#ffa000
    style C fill:#bbdefb,stroke:#1976d2

    note1[每个 Actor：&lt;br&gt;- 有私有状态&lt;br&gt;- 通过邮箱接收消息&lt;br&gt;- 单线程处理，无锁&lt;br&gt;- 可创建新 Actor]
    note2[消息：&lt;br&gt;- 异步、不可靠&lt;br&gt;- 无共享内存&lt;br&gt;- 通过地址（引用）寻址]</code></pre>
<p>Actor 模型是一种被用于<strong>单个进程内并发</strong>的编程模型，其核心思想是通过<strong>状态隔离与事件驱动来避免锁竞争</strong>：**。逻辑被封装在 Actor 中，而不是直接操作线程或共享内存处理线程。</p>
<p>每个 Actor 通常代表一个客户端或实体，拥有<strong>私有它可能有某些本地状态</strong>（不与其他 Actor 共享），并且它通过发送和接收异步消息与其他 Actor 通信。由于状态完全隔离，且每个 Actor 一次只处理一条消息，对内部状态的修改天然串行化，<strong>因此无需使用锁，从根本上消除了竞态条件和线程安全问题</strong>。</p>
<p>不保证消息传送：在某些错误情况下（如节点崩溃、网络中断），<strong>消息可能</strong>不保证消息传送：在某些错误情况下，消息将丢失。**，除非框架或应用层额外实现持久化与重试机制。</p>
<p>Actor <strong>的执行由调度器独立管理</strong>，而不是像普通函数调用那样直接在调用者线程中运行，因此多个 Actor 可被高效复用少量线程，并由于每个 actor 一次只处理一条消息，因此不需要担心线程，每个 Actor 都可以由框架自动独立调度。</p>
<p>虽然与 Goroutine 表面相似，但二者模型不同：<strong>Goroutine 基于 CSP（通信顺序进程），通过 channel 共享通信；Actor 则强调封装与消息传递</strong>。</p>
<p>在分布式 Actor 框架中，这一模型被扩展到多节点：无论通信是否跨机器，都使用<strong>统一的消息传递机制和透明序列化</strong>，使分布式编程如同本地并发一样自然虽然很相似，但 Goroutine 不同于 Actor，它是 CSP 模型。Actor 和线程也不一样，<strong>Actor 的执行是被调度器独立管理的，而不是像普通函数调用那样直接在调用者的执行流中运行。</strong>。</p>
<p>在分布式 Actor 框架中，这个编程模型被用来跨越多个节点来扩展应用程序。不管通讯是不是跨界点，使用相同的消息传递机制，使用透明的编码。</p>
<p>分布式 Actor 框架实质上是将消息代理、容错调度与和 Actor 编程模型深度集成，提供位置透明性、弹性伸缩和故障隔离（如监督树）。</p>
<p>得益于其隔离性和无共享状态的设计，集成到单个框架中。</p>
<p>Actor 模型能可以很好地支持滚动更新：<strong>新版本 Actor 可逐步替换旧版本，而不会因状态共享导致不一致或停机</strong>。</p>
<h2 id="小结">小结</h2>
<table>
<thead>
<tr>
<th>维度</th>
<th>Message Broker (Kafka/RabbitMQ…)</th>
<th>Distributed Actor Framework (Akka/Orleans/Erlang OTP)</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>核心抽象</strong></td>
<td>Topic/Queue → 字节流</td>
<td>Actor → 状态 + 行为 + 邮箱</td>
</tr>
<tr>
<td><strong>数据模型</strong></td>
<td>无：消息 = 任意字节 + 元数据</td>
<td>强：每个 Actor 有私有状态，消息触发方法</td>
</tr>
<tr>
<td><strong>消息语义</strong></td>
<td>At-least-once / at-most-once 由 Broker 提供</td>
<td>同上，但<strong>框架层</strong>重试 + 监督策略</td>
</tr>
<tr>
<td><strong>位置透明</strong></td>
<td>手动：生产者要显式知道 topic 名与分区</td>
<td>自动：ActorRef 就是地址，本地/远程对业务代码一样</td>
</tr>
<tr>
<td><strong>并发单位</strong></td>
<td>外部线程/RPC 调用</td>
<td>内部 mailbox → <strong>单线程模型</strong>无锁</td>
</tr>
<tr>
<td><strong>故障恢复</strong></td>
<td>重投队列 / 死信队列</td>
<td>监督树：崩溃→重启→状态快照/热迁移</td>
</tr>
<tr>
<td><strong>升级兼容</strong></td>
<td>只要字节兼容即可</td>
<td>必须保证<strong>Actor 状态序列化</strong>前后向兼容</td>
</tr>
<tr>
<td><strong>部署形态</strong></td>
<td>独立中间件集群</td>
<td>应用进程<strong>内嵌</strong>运行时，Broker 能力被集成到框架</td>
</tr>
</tbody>
</table>
<h1>分布式数据系统</h1>
<p>主要出于以下目的，我们需要在多台机器上分布数据：</p>
<ul>
<li>扩展性</li>
<li>容错与高可用性</li>
<li>延迟考虑</li>
</ul>
<h2 id="系统扩展能力">系统扩展能力</h2>
<p><strong>我们让系统的成本增加一倍，处理数据的能力不一定增加一倍。</strong></p>
<p>我们经常拿来垂直扩展的系统，由单个操作系统管理更多 CPU、内存和磁盘，通过高速内部总线使任一 CPU 都能访问全部内存或磁盘，这种架构称为共享内存架构（shared memory architecture）。</p>
<p>由于所有部件受同一内核管辖，<strong>任一 CPU、内存或主板故障即可导致整系统宕机</strong>，因此共享内存架构只能提供有限的容错能力。</p>
<p>另一种方案是共享磁盘架构（shared disk architecture）：多台服务器各自拥有独立 CPU 与内存，通过高速网络把数据存放在<strong>可被所有节点并发访问的共享磁盘阵列上</strong>（如 Oracle RAC、DB2 PureScale）。</p>
<h3 id="无共享架构">无共享架构</h3>
<p>采用这种架构（shared nothing）时，运行数据库软件的机器或者虚拟机称为节点。每个节点使用本地的 CPU、内存和磁盘，只通过网络通信。</p>
<p>采用 shared-nothing 时，运行数据库软件的机器或虚拟机称为节点；每个节点仅使用本地的 CPU、内存和磁盘，<strong>节点间没有任何硬件级共享</strong>。</p>
<p>本部分重点放在无共享体系，并非因为它必然最优，而是因为它要求开发者显式面对分布式复杂性——例如如何把数据分布在多节点、如何权衡副本一致性、如何进行分区容错——数据库无法魔术般屏蔽所有这些细节。</p>
<p>我们常见的“无状态服务+单实例数据库”模式<strong>在逻辑上更接近共享磁盘模型</strong>，但应用服务器并未直接共享块设备；而单元化架构<strong>在数据切片与故障隔离意义上更接近无共享模型</strong>，同时增加了业务层面的流量隔离与多活能力。</p>
<p>NAS 和SAN 属于共享磁盘方法。</p>
<h3 id="复制与分区">复制与分区</h3>
<p>将数据分布在多个节点上有两种常见方式：复制和分区。</p>
<p>在了解以上概念之后，我们会讨论分布式环境中错综复杂的权衡之道，很可能我们在设计系统时不得不面对这些艰难选择**（没有做过艰难选择，不能算是解决过很难的问题）**。</p>
<h1>数据复制</h1>
<p>数据复制是指在多台机器上通过互联网络保存相同数据的副本。</p>
<p>它有几个好处：</p>
<ul>
<li>使数据更接近用户，<strong>降低延迟</strong>-CDN</li>
<li>提高冗余</li>
<li>读扩展（冗余提供了超量部署，读扩展也降低了延迟，负载和）</li>
</ul>
<p>如果复制的数据一成不变，那么复制就非常容易：只需将数据复制到每个节点，一次即可搞定。然而所有的技术挑战都在于处理那些持续更改的数据。</p>
<p>目前流行的复制数据变化的方法有：</p>
<ul>
<li>主从复制</li>
<li>多主节点复制</li>
<li>无节点复制</li>
</ul>
<p>复制技术中存在许多需要权衡的因素，例如选择同步复制还是异步复制，以及如何处理失败的副本。</p>
<p>数据库复制是个很古老的话题，因为网络的基本约束条件，自始至终没有发生过本质的变化（计算机发展的早期就已经摸清楚了这些基本问题，而且推导出了问题的基本解法）。</p>
<p>实践中大多数开发人员仍然假定数据库只运行在单节点上，分布式数据库成为主流也是最近发生的事情（<strong>长久以来 MySQL 始终是个非分布式数据库，所以才有各种中间件方案</strong>）。</p>
<p><strong>许多应用开发人员在处理分布式系统时经验不足，对“最终一致性”等概念存在误解。因此，在“复制滞后问题”中，我们会详细讨论最终一致性，包括读自己的写和单调读。</strong></p>
<p>复制滞后是导致最终一致性等弱一致性模型的原因之一。</p>
<h2 id="主节点和从节点">主节点和从节点</h2>
<p>每个保存数据库完整数据集的节点称为副本。当有了多副本，不可避免地会引入一个问题：如何确保所有副本之间的数据是一致的？</p>
<ol>
<li>指定某一个副本为主副本（或称为主节点）。当客户写数据库时，必须将写请求首先发送给主副本，主副本首先将新数据写入本地存储。</li>
<li>其他副本则全部称为从副本（或称为从节点）。主副本负责通过日志或者数据流把数据同步到从副本。</li>
<li>用户可以从所有副本读数据。主副本 RW，从副本 RO。</li>
</ol>
<h3 id="同步复制与异步复制">同步复制与异步复制</h3>
<p>RDBMS 通常拥有多种同异步模式，而很多别的系统的复制模式是固定的。</p>
<p><img src="%E5%90%8C%E6%AD%A5%E5%A4%8D%E5%88%B6%E4%B8%8E%E5%BC%82%E6%AD%A5%E5%A4%8D%E5%88%B6.png" alt="同步复制与异步复制.png"></p>
<p>上图的第一个节点显示了同步复制的工作流程，第二个节点显示了异步复制的工作流程。</p>
<p>同步的优点是，如果用户收到看  OK，则所有从节点 OK 了。同步复制的缺点是，如果有从节点阻塞，所有写入都会被阻塞（主从延迟是很常见的情形，所以同步复制产生的写阻塞会很频繁）。</p>
<p>实践中，如果数据库启用了同步复制，通常意味着其中某一个从节点是同步的，而其他节点则是异步模式。万一同步的从节点变得不可用或性能下降，则将另一个异步的从节点提升为同步模式。这样可以保证至少有两个节点（即主节点和一个同步从节点）拥有最新的数据副本。这种配置有时被称为半同步。</p>
<p>主从复制还可以配置为全异步模式，这样配置性能最高，但可能丢失所有尚未复制到从节点的写请求-这是后面要谈到的“复制滞后问题”的体现。</p>
<p>异步模式看起来不靠谱，但还是被广泛使用，特别是从节点数量巨大或者分布于广域地理环境。</p>
<p>复制涉及的问题非常复杂，多副本一致性和共识问题后续再讨论。链式复制（Chain Replication）能够兼容高吞吐和高可用的场景，已经应用在微软的 Azure 存储中。</p>
<h3 id="配置新的从节点">配置新的从节点</h3>
<p>新增从节点不能使用直接停机拷贝的方式，除非我们的主节点停写，直至拷贝完成。但停写的时间不能太长，否则高可用不能被保证。所以常见的做法是：</p>
<ol>
<li>生成一个<strong>一致性快照</strong>，MySQL 使用 innobackupex。</li>
<li>将一致性快照应用（Apply）到从节点上。</li>
<li>从节点请求快照点之后发生的数据更改日志。这种日志的快照点位有特别的叫法，PostgreSQL 将其称为“log sequence number”，MySQL 将其称为“binlog coordinates”。</li>
<li>获得日志后，从节点来应用这些快照点之后的所有数据变更。</li>
</ol>
<p>所谓的数据追平。我们要了解日志和快照的分割点在哪里。</p>
<h3 id="处理节点失效">处理节点失效</h3>
<h4 id="从节点失效：追赶式恢复">从节点失效：追赶式恢复</h4>
<p>如果发生网络闪断，只要从节点明确知道故障之前处理的最后一笔事务，然后连接到主节点，请求从那笔事务之后中断期间所有的数据变更。</p>
<h4 id="主节点失效：节点切换">主节点失效：节点切换</h4>
<p><strong>节点切换，极度危险！</strong></p>
<p>处理主节点故障的情况则比较棘手：选择某个从节点将其提升至主节点；客户端也需要更新，这样之后的写请求会发送给新的主节点，然后其他从节点要接受新的主节点的变更数据，这一过程称之为切换。</p>
<p>故障切换可以手动执行，也可以自动进行。自动切换的步骤通常如下：</p>
<ol>
<li>确认主节点失效。一般基于<strong>超时的心跳机制</strong>。</li>
<li>选举新节点。一般基于共识算法选举新节点，需要选出和失效的主节点数据差异最小的从节点。</li>
<li>重新配置系统使新主节点生效。</li>
</ol>
<p>在上述切换过程中还充满了各种各样的变数：</p>
<ol>
<li>如果使用了异步的复制，新的主节点未必收到了原主节点的所有数据（任何一种共识算法都解决不了这个问题）。如果这时候新的节点收到了新的冲突的写请求，这时候可能产生脏数据。常见的解决方案（高可用）方法是：<strong>新的主节点丢弃未完成复制的请求，但这可能会违背数据更新持久化的承诺。-另一种强一致性的做法是，在新主和老主确认校验一致之前，禁止新节点的写。这种禁止对可用性伤害很高，如果校验长时间无法完成，集群会瘫痪掉。</strong></li>
<li>如果在数据库之外有其他系统依赖于数据库的内容并在一起协同使用，丢弃数据的方案就特别危险。<strong>所以强一致性的数据（余额、序列号等交易因子业务）不能使用丢弃后写的数据方案。</strong></li>
<li>在某些情况下，可能出现两个从节点都认为自己是新主节点，这种情况被称为脑裂。这非常危险，两个主节点都可能接受写请求，并且没有很好地解决冲突的方法（没有办法自动处理，可能需要引入手工处理）。作为一种安全应急方案，有些系统会采取措施来强制关闭其中一个节点。</li>
<li>如何设置合适的超时时间来检测主节点失效呢？主节点失效后，<strong>超时时间设置得越长也意味着总体恢复时间就越长</strong>。但如果超时时间设置得<strong>太短，可能导致很多不必要的切换</strong>，遇到网络流量暴增可能会让系统频繁切换而崩溃。-<strong>超时时间太长或者太短都是陷阱，至少应该让超时时间长于一个应用接口超时时延的 margin。</strong></li>
</ol>
<h3 id="复制日志的实现">复制日志的实现</h3>
<h4 id="基于语句的复制">基于语句的复制</h4>
<p>这是最基础的方案。</p>
<p>最简单的情况，主节点记录所执行的每个写请求（操作语句）并将该操作作为日志发送给从节点。</p>
<p>区块链的方案是：交易脚本+状态机，≠ SQL 语句回放。</p>
<p>但这种方案有诸多限制：</p>
<ul>
<li>限制语句必须是确定性的语句。</li>
<li>语句本身不能依赖于本地现有数据（自增列），或者会限制所有语句的执行顺序。这实际上仍然会限制事务的并发执行-只有序列化执行能够无措执行。</li>
<li>有副作用的语句。</li>
</ul>
<p><strong>我们自己做 C/S 类型的数据同步，也可能采取基于语句的复制的方案，如果我们不能解决上面的问题，我们可能会遇到很大的问题。这就看出 Log-Structure 这种设计模式的重要了。</strong></p>
<h4 id="基于预写日志的复制">基于预写日志的复制</h4>
<p>所有对数据库写入的字节序列都被记入日志，这种日志就是 WAL。WAL 的缺点就是它描述的数据结果非常底层，某些磁盘块里的某些字节发生了改变，会让复制方案和存储引擎紧密耦合。</p>
<h4 id="基于行的逻辑日志复制">基于行的逻辑日志复制</h4>
<p>另一种方法是复制和存储引擎采用不同的日志格式，这样复制与存储逻辑剥离。这种复制日志称为逻辑日志。</p>
<p>MySQL 的 binlog 是这样工作的：针对一个事务，产生涉及多行的多条日志记录，并在后面跟着一条记录，指出该事务已提交。</p>
<p>因为 binlog 是逻辑日志，所以它不与存储引擎绑定，是 Server 层日志。 binlog 特别适合用来<strong>跨版本复制是它的一个优点</strong>，但不适合特种的存储引擎的问题恢复。</p>
<h4 id="基于触发器的控制">基于触发器的控制</h4>
<p>这里的触发器可用内置触发器，也可写应用代码。基于应用层的程序比较灵活，<strong>也开销更高，而且也更加容易出错</strong>。</p>
<h2 id="复制滞后问题-replication-lag">复制滞后问题（replication lag）</h2>
<p>我们可以粗略地认为，分布式系统的一致性问题就是复制滞后问题。</p>
<p>主从复制要求所有的写请求都经过主节点。为了保证主从复制的写吞吐量，所以往往会开启异步复制。只要开启异步复制，都可能产生各种复制滞后，这也就意味着我们必然面对现实中的最终一致性。</p>
<p>故障和网络时延会导致一致性被破坏，而且比较需要在意的是，破坏了很多操作的因果关系，让我们的流程出错。</p>
<ul>
<li>引入主从异步复制 → 冒「写后读」风险</li>
<li>引入多副本读负载均衡 → 冒「单调读」风险</li>
<li>引入分片写 → 冒「前缀一致读」风险</li>
</ul>
<table>
<thead>
<tr>
<th>一致性级别</th>
<th>实时</th>
<th>全局顺序</th>
<th>因果顺序</th>
<th>人话一句</th>
<th>实现要诀</th>
</tr>
</thead>
<tbody>
<tr>
<td>最终一致性</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>停写足够久，大家终一致</td>
<td>异步复制+后台合并</td>
</tr>
<tr>
<td>单调读</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>自己不会&quot;时光倒流&quot;</td>
<td>副本粘性/读令牌</td>
</tr>
<tr>
<td>读己所写</td>
<td>×</td>
<td>×</td>
<td>√</td>
<td>自己写立刻能读到</td>
<td>会话粘主/缓存最新LSN</td>
</tr>
<tr>
<td>因果一致</td>
<td>×</td>
<td>×</td>
<td>√</td>
<td>有因果的操作顺序不乱</td>
<td>向量时钟/版本向量</td>
</tr>
<tr>
<td>实时因果</td>
<td>√</td>
<td>×</td>
<td>√</td>
<td>因果+物理时钟也保序</td>
<td>向量时钟+物理时间</td>
</tr>
<tr>
<td>顺序一致</td>
<td>×</td>
<td>√</td>
<td>√</td>
<td>大家看到顺序一样</td>
<td>单写入链+顺序广播</td>
</tr>
<tr>
<td>线性一致</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>像单机一样实时+原子</td>
<td>主副本同步+全局时钟</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>一致性级别</th>
<th>实时</th>
<th>全局顺序</th>
<th>因果顺序</th>
<th>现实产品/协议</th>
<th>一句人话</th>
<th>一眼识别技巧</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>线性一致性</strong><br>(Linearizability)</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td><strong>Raft</strong><br><strong>ZooKeeper</strong><br><strong>etcd</strong></td>
<td>写完<strong>立刻</strong>被所有人看见，像单机</td>
<td>只要读写都走<strong>Leader</strong>且<strong>同步刷盘</strong>，就是线性</td>
</tr>
<tr>
<td><strong>顺序一致性</strong><br>(Sequential)</td>
<td>❌</td>
<td>✅</td>
<td>✅</td>
<td><strong>ZooKeeper</strong><br><strong>Raft</strong><br><em>（允许 follower 读旧值时降级）</em></td>
<td>大家看到的顺序一样，但<strong>不一定马上</strong></td>
<td>follower 读可能滞后，但<strong>不会乱序</strong></td>
</tr>
<tr>
<td><strong>因果一致性</strong><br>(Causal)</td>
<td>❌</td>
<td>❌</td>
<td>✅</td>
<td><strong>COPS</strong><br><strong>MongoDB因果令牌</strong><br><strong>Redis CL. TRACKING</strong></td>
<td><strong>有因果</strong>的操作才保序，<strong>并发</strong>的随便</td>
<td>看到“<strong>因果令牌</strong>”“<strong>向量时钟</strong>”就是因果</td>
</tr>
<tr>
<td><strong>会话一致性</strong><br>(Session)</td>
<td>❌</td>
<td>❌</td>
<td>✅(<em>本会话</em>)</td>
<td><strong>大多数云数据库</strong><br><strong>MongoDB session</strong></td>
<td>自己<strong>会话内</strong>写→立即可读，别人管不着</td>
<td>带<strong>sticky connection</strong>或<strong>session token</strong></td>
</tr>
<tr>
<td><strong>单调读/写</strong><br>(Monotonic)</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
<td><strong>Cassandra</strong><br><strong>DynamoDB</strong><br><strong>读令牌</strong></td>
<td>自己<strong>视图只进不退</strong>，不会<strong>时光倒流</strong></td>
<td>给客户端发<strong>读令牌</strong>或<strong>副本粘性</strong></td>
</tr>
<tr>
<td><strong>弱/最终</strong><br>(Eventual)</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
<td><strong>DNS</strong><br><strong>普通主从</strong><br><strong>S3</strong></td>
<td>停写足够久，<strong>终会一样</strong></td>
<td>没有令牌、没有Leader、随便读</td>
</tr>
</tbody>
</table>
<ul>
<li>ZooKeeper &amp; Raft 到底在哪一格？
<ul>
<li>默认写：线性一致（Leader 同步写）。</li>
<li>默认读：顺序一致（Follower 可返回旧值，但不会乱序）。</li>
<li>强制线性读：调用 sync() 再读 → 升级成线性一致读- ZooKeeper 的做法。</li>
</ul>
</li>
</ul>
<p>“读己所写”只保证同一客户端能立即读到自己刚才的写入；它既不自动包含“单调读”，更不包含“前缀一致”——这三者是正交保证，必须分别实现。</p>
<p>ZooKeeper 和 Raft 把写操作做成“单主 + 多数派落盘”，相当于在写返回的瞬间就把一条全局记录点固化下来；后续任何读只要去这条记录点查，就能给出“实时 + 全局顺序”的答案，因此官方文档直接说：<br>
写是线性一致（Linearizable Writes）<br>
读默认顺序一致，可升级到线性</p>
<ul>
<li>做了“读己所写”不一定就能单调读——如果第二次读落到更旧副本，仍会出现“时光倒流”。</li>
<li>做了“读己所写”更不等于前缀一致——它只关心单客户端+单条写入，不保证跨分片因果序列的全局顺序。</li>
</ul>
<p>要想同时拿到三种保证，必须显式叠加对应机制，而不是“买一送二”。</p>
<table>
<thead>
<tr>
<th>保证点</th>
<th>读己所写</th>
<th>单调读</th>
<th>前缀一致</th>
</tr>
</thead>
<tbody>
<tr>
<td>目标</td>
<td>自己写→自己立刻可读</td>
<td>自己后续读≥前一次读</td>
<td>跨分片因果写顺序不乱</td>
</tr>
<tr>
<td>是否隐含其他保证</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr>
<td>实现举例</td>
<td>写后1s内强制读主；或客户端缓存最新LSN</td>
<td>副本粘性；或读令牌</td>
<td>因果令牌+分片级等待</td>
</tr>
</tbody>
</table>
<h3 id="读自己的写-read-your-writes">读自己的写（read-your-writes）</h3>
<p>许多应用让用户提交一些数据，接下来查看他们自己提交的内容。</p>
<p>许多应用让用户提交数据后立即查看自己刚写的内容。由于（主从）异步复制的存在，用户可能在副本上查不到最新写入，因此需要 read-after-write consistency。</p>
<p>保证思路：</p>
<ul>
<li>若用户访问的数据可能被该用户自己修改，则直接路由到主节点读取；否则可读从节点。这要求业务规则能区分“用户自己的数据”与“他人数据”。</li>
</ul>
<blockquote>
<p>注：单元化/Set<br>
化架构一般基于共识协议（Raft/Paxos）选主，切换后新主仍能保证线性一致；只有“异步复制+客户端切到旧从”场景才会破坏写后读一致性。</p>
</blockquote>
<ul>
<li>当大部分数据可被大部分用户修改时，上述方案失效；若所有读都回落到主节点，又失去读扩展性。可采用弱时间假设：更新后 N 秒（如 1 min）内读主，其余时间读从——只需保证副本滞后 &lt; N，无需全球毫秒级时钟，但要监控慢节点。</li>
<li>客户端可记住最近一次更新的时间戳（逻辑 LSN Log Sequence Number 或物理时钟），读请求携带该戳；服务端若发现副本未达此戳，可转发给其他副本或等待，直至返回<strong>≥该戳</strong>的数据。此模式又称“写事件驱动读带时间戳”。</li>
<li>若副本跨数据中心，需把读请求先路由到主节点所在数据中心（可能距离远），再按上述逻辑处理。</li>
</ul>
<h3 id="单调读-monotonic-read">单调读（monotonic-read）</h3>
<p>定义：同一用户**不会看到“新→旧→新”**的回滚现象。<br>
强度关系：强一致性 → 单调读 → 最终一致性（弱一致性为最宽松统称）。<br>
保证方法：让用户在同一分片/同一副本上连续读取——随机负载均衡+纯主从复制无法提供此保证-我们的 kafka 有序就是一个解释单调的问题。</p>
<blockquote>
<p>单元化/Set 化方案若发生异步主从切换，且客户端被路由到错误的滞后副本，也会破坏单调读。所以多副本有时候会破坏单调读，有时候不会。</p>
</blockquote>
<h3 id="前缀一致读-consistent-prefix-reads">前缀一致读（consistent prefix reads）</h3>
<p>定义：对于一系列按因果顺序写入的记录，读取时必须看到相同的写入顺序，不得出现“先写后见、后写先见”的乱序现象。<br>
这是分片数据库特有的问题：<strong>并发跨分片写入时，即使写入端按因果顺序发出，读取端也可能因分片复制进度不同而看到乱序</strong>（类比 Kafka 多分区无法保证全局有序）。</p>
<p>这是分片数据库在多分片写时特有的一个问题。一般情况下，即使以相同的顺序写入数据库，读取也无法保证保证总是看到一致的序列-这和 Kafka 多分区无法保证全局有序是一样的。实现前缀一致读的最简单的方法是破坏分区写这个先决条件，保证有因果关系的写入都交给一个分区来完成。</p>
<p><strong>所以全局有序性 ⇔ producer’s consistent prefix read + consumer’s monotonic read。<br>
一旦主从切换导致副本滞后，单调读失效，前缀一致也可能被打破</strong></p>
<h3 id="复制滞后的解决方案">复制滞后的解决方案</h3>
<p>使用最终一致性系统时，最好先思考这样的问题：（系统最大的风险是）如果复制延迟增加到几分钟甚至几小时，那么应用层的行为会是什么样子？</p>
<p>如果需要强一致性设计，需要考虑写后读的一致性（写后读也不是很简单的，这里的写后读专指能读到写的写后读）；如果系统设计时假定是同步复制，但最终它事实上成为了异步复制，就可能会导致灾难性后果。</p>
<p>如果需要做特别的设计，需要在应用层上做，应用层也可以提供更灵活、强力的保障措施；而代价则是，应用层中处理这些代码非常复杂、且容易出错。</p>
<p>如果应用程序开发人员不必担心这么多底层的复制问题，而是假定数据库在做“正确的事情”，情况就变得简单。而这也是事务存在的原因，事务是数据库提供更强保证的一种方式。</p>
<p>在单节点上支持事务已经非常成熟，然而在转向分布式数据库（即支持复制和分区）的过程中，有许多系统却选择放弃支持事务，并生成事务在性能与可用性方便代价过高，然后断言在可扩展的分布式系统中最终的一致性是无法避免的终极选择。关于这样的表述，首先它有一定的道理，但情况远不是它所声称的那么简单。-<strong>我们应该跳出一个又一个有过取舍的实现，形成一个一般的、成熟的观点。</strong></p>
<h2 id="多主节点复制">多主节点复制</h2>
<p>主从复制的方法比较常见。</p>
<p>主从复制存在一个明显的缺点：系统只有一个主节点，而所有写入都必须经由主节点。只要发生单点故障，主从复制就会影响所有的写入操作。</p>
<p>对主从复制模型进行自然的扩展，则可以配置多个主节点，<strong>每个主节点都可以接受写操作，跨数据中心的主可能是别的节点的从</strong>，后面复制的流程类似：处理写的每个主节点都必须将该数据更改转发到所有其他节点，这就是多主节点复制。</p>
<p>多主复制的好处是：（从吞吐量维度）<strong>提高写的可用性</strong>。</p>
<p>多主复制首要动机是就近低延迟写（<strong>写到本地的主节点</strong>） + 数据中心容错。</p>
<p>对于我们要谈到的三种复制：</p>
<ol>
<li>主越少，写入越容易，故障容错性越弱，冲突也越少。</li>
<li>主越多，写入越多样，故障容错性越强，冲突也越多。</li>
<li>容错带来冲突，可能同时写入相同的数据带来冲突。</li>
</ol>
<h3 id="适用场景">适用场景</h3>
<p>通常不推荐在同一个数据中心内用多主。因为写冲突、运维复杂度大于收益，除非有强烈的分区容忍或滚动升级需求。</p>
<h4 id="多数据中心">多数据中心</h4>
<p>为了容忍整个数据中心级别的故障或者更接近用户，可以把数据库的副本横跨多个数据中心。</p>
<p><img src="%E5%A4%9A%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83%E6%96%B9%E6%A1%88.png" alt="多数据中心方案-可以看到是主写到主，而不是a主写b从"></p>
<p>在多数据中心环境下，部署单主节点的主从复制方案与多主复制方案之间存在如下差异：</p>
<ul>
<li>性能：多数据中心的方案使得终端用户体验到的性能更好。如果在多数据中心下还是单主多从，则其他数据中心的用户体验是差的。</li>
<li>容忍数据中心失效：每个数据中心的副本一开始就是活的，不需要经过主从提升的操作-这要求异地的数据中心一开始就是多活的。</li>
<li>容忍网络问题：多数据中心如果采用异步复制方案，可以更好地容忍网络闪断。因为多数据中心天然就有远传输距离，采用异步复制也是名正言顺的。异步 = <strong>冲突窗口变大，需接受潜在写冲突与短暂不一致</strong>。</li>
</ul>
<p>多主复制可能存在一个潜在的问题，<strong>就是不同的数据中心可能同时修改相同的数据</strong>，因而必须解决潜在的写冲突。</p>
<p>由于多主复制在许多数据库中还只是新增的高级功能，所以可能存在配置方面的细小缺陷；去与其他数据库功能交互时会出现意想不到的副作用。</p>
<h4 id="离线客户端操作">离线客户端操作</h4>
<p>另一种多主复制比较适合的场景是，应用在与网络断开后还需要继续工作。</p>
<p>在这种情况下，每个设备都有一个充当主节点的本地数据库（用来接受写请求），然后在所有设备之间采用<strong>异步方式同步</strong>这些多主节点上的副本。</p>
<p>从架构层面来看，上述设置基本上等同于数据中心之间的多主复制，只不过是个极端情况，即一个设备就是数据中心。这就好像当前的架构在 C/S 和 P2P 架构之间的区别被模糊化了。</p>
<p>印象笔记之类的服务就是采取这种方案。</p>
<h4 id="协作编辑">协作编辑</h4>
<p>EtherPad 或者谷歌文档通常允许多人同时编辑文本文档或电子表格。</p>
<p>我们通常不会将协作编辑完全等价于数据库复制问题，但两者确实有很多相似之处。当一个用户编辑文档时，所做的更改会立即应用到本地副本（Web<br>
浏览器或客户端应用程序），然后异步复制到服务器以及编辑同一文档的其他用户。</p>
<p>为了防止编辑冲突，可以将文档锁定（类似事务的序列化）或者实现无锁 merge。</p>
<p>为了加快协作编辑的效率，可编辑的粒度需要非常小。例如，单个按键甚至是全程无锁。</p>
<h3 id="处理写冲突">处理写冲突</h3>
<p>上文的例子经常提到的多主副本写入有几个前提：</p>
<ol>
<li><strong>本地存储是一个主副本</strong>。</li>
<li><strong>修改会被延迟-异步同步到远端</strong>。</li>
</ol>
<p>多主复制意味着多头写入，这也意味着同时写入一行时，只要复制到远端就会产生冲突。</p>
<p>近端优先合并可让作者立即看到自己的光标变化，提升体感，但不保证单调读，仍需 OT/CRDT 或版本向量（<strong>捕捉因果关系</strong>）保证最终一致。</p>
<p>协作编辑是单文档多副本，乱序发生在操作层面而非分片层面，应说成“违反单一操作序列”或“违反全序操作流”。</p>
<h4 id="同步与异步冲突检测">同步与异步冲突检测</h4>
<p>之所以会产生异步写冲突，是因为多个主节点写入时无法相互阻塞**（没有先后因果关系产生了并发）**。所以为了减少这样的冲突，逼不得已的时候可能需要使用同步复制。而使用同步复制，还不如回退回单主从复制的方案。</p>
<h4 id="避免冲突">避免冲突</h4>
<p>现实中处理写冲突的方案多少有些瑕疵，所以避免冲突反而成为大家普遍推荐的首选方案。避免写冲突的方式可能有：</p>
<ul>
<li>对特定记录的每次写入只在一个主节点上（对 update 和 insert 实行分片错开-奇偶发号器就是这样的方案），这相当于用分片的形式将多主复制退化为单主复制</li>
<li>实现 id 的跳跃（对 insert 实行交错的主键自增-步长都是2，但是起点是0和1）。</li>
</ul>
<h4 id="收敛于一致状态">收敛于一致状态</h4>
<p>主从复制模型的数据更新符合顺序性原则，如果同一个字段有多个更新，则最后一个写操作讲决定该字段的最终值。</p>
<p>分布式数据库必须以一种收敛趋同的方式来解决冲突。实现收敛的冲突解决有以下可能的方式：</p>
<ul>
<li>给每个<strong>写入分配唯一的 id</strong>，最大的写入 id 作为胜利者，丢弃其他写入。<strong>如果基于时间戳，这种技术被称为最后写入者胜利</strong>。虽然这种方法很流行，但是很容易造成数据丢失。</li>
<li>为每个副本（replica）分配一个唯一的 id（所以说副本之间也有主从关系），并制定规则，如序列号高的副本写入始终优先于序号低的副本-后面会讲到任期制度。这样也会造成数据丢失。</li>
<li>以某种方式定义 merge 算法，自动 merge</li>
<li>利用预定义好的格式来记录和保留冲突的所有信息，<strong>然后依靠应用层的逻辑</strong>，事后解决冲突（可能会提示用户）。这就是印象笔记等解决方案的相关做法。</li>
</ul>
<h4 id="自定义冲突解决逻辑">自定义冲突解决逻辑</h4>
<p>大多数多主节点复制模型都有工具来让用户编写应用代码来解决冲突。可以在写入时执行或在读取时执行这些代码逻辑。</p>
<ul>
<li>在写入时执行。只要数据库系统在复制变更日志时检查</li>
<li>在读取时执行。当检测到冲突时，所有冲突写入值都会暂时保存下来。下一次读取数据时，会将数据的多个版本读返回给应用层。</li>
</ul>
<p>git 两种策略都采用了，在向远端 push 遇到冲突时，会要求近端 merge 远端，<strong>将多个版本列出来</strong>，然后强迫用户手工处理。</p>
<h4 id="什么是冲突">什么是冲突</h4>
<p>冲突的定义很复杂，我们最好简单地把同一条记录的冲突的相关修改当作冲突。</p>
<p>目前诞生了很多自动解决冲突的算法，但这些算法目前还处于早期阶段，未来它们可能被整合到更多的数据系统中。</p>
<ol>
<li>CRDT：Conflict-free Replicated DataTypes。map、ordered list、计数器之类的方案是可由多个用户同时编辑的数据结构。</li>
<li>Mergeable persistent data：跟踪变更历史，类似于 Git version control，使用三向合并 three-way merge function。</li>
<li>操作转换：Operational transformation。</li>
</ol>
<h3 id="拓扑结构">拓扑结构</h3>
<p>我们常见的拓扑结构有如下几种：</p>
<p><img src="%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84.png" alt="拓扑结构.png"></p>
<p>最常见的拓扑结构是全部-至-全部，Eureka 之类的解决方案就是使用这种拓扑结构，支持简单的多主写入，无惧数据丢失-只要写入能够频繁重试，数据能够最终收敛到正确值。</p>
<p>默认的情况下 <strong>MySQL 只支持环形拓扑结构</strong>。这种拓扑结构需要放置复制中的写请求出现无限循环，通常的解决方案是在复制日志中内置一种标记，能够记录已经处理过这个写请求的节点。GTID 是一类这种解决方案。</p>
<p>全部-至-全部的拓扑结构的问题是，可能出现一些日志先发出，后到达的情况，出现不满足前缀一致性读的错乱。比如，update 的日志必须出现在 insert 之后。为了使得日志消息正确有序，可以使用一种称为版本向量的技术。</p>
<h2 id="无主节点复制-leaderless">无主节点复制（leaderless）</h2>
<p>到目前为止本章所讨论的复制方法，都是“有主方法”：客户端先向某个主节点发送请求，由主节点决定写操作的顺序，<strong>从节点按照相同的顺序来应用</strong>主节点所发送的写日志。</p>
<p>一些数据存储系统则采用不同的设计思路：选择放弃主节点，允许任何副本直接接受客户端的写请求。</p>
<p>在 RDBMS 出现以前，数据复制系统就是无主节点的。</p>
<p>Dynamo-style 的系统是现在无主复制的主要实现。DynamoDB 只是 Amazon 的内部实现对外封装，Cassandra 在全球使用量上更配得上“主流”。</p>
<p>在一些无领导者的实现中，客户端直接将写入发送到到几个副本中，而另一些情况下，一个协调者（coordinator）节点代表客户端进行写入。但与主库数据库不同，协调者不执行特定的写入顺序-这和 MySQL 单主的全同步复制有显著区别。我们将会看到，这种设计上的差异对数据库的使用方式有着深远的影响。</p>
<h3 id="gossip-不是无主复制-只是无主物">Gossip 不是无主复制，只是无主物</h3>
<p>Gossip 只是一种去中心化的“消息感染”机制，本身不规定存储模型；它既可以用在<strong>无主（Dynamo、Cassandra）里，也可以用在有主（etcd、Consul）里——关键看谁发消息、消息里带什么</strong>：</p>
<ul>
<li>无主场景<br>
Cassandra/Dynamo：<strong>每个节点都是对等 replica</strong>，gossip 用来<strong>交换副本差异哈希</strong>（Merkle tree）和<strong>心跳存活</strong>，最终<strong>各节点自行合并/修复</strong> → 这时 gossip 确实服务于<strong>无主复制</strong>。</li>
<li>有主场景<br>
etcd/Consul：<strong>Leader 产生日志条目</strong>，follower 只负责<strong>转发与确认</strong>；gossip 被用来做<strong>成员变更广播和失效探测，不决定副本写入路径</strong> → 属于<strong>有主架构里的辅助 gossip</strong>。<br>
因此：<br>
<strong>gossip ≠ 无主复制</strong>，它只是**“流行病式”通信原语**；到底**“有无主”要看写路径是否由单一 leader 定序**。</li>
</ul>
<h3 id="节点失效时写数据库">节点失效时写数据库</h3>
<p>以一个三副本数据库，其中一个副本当前不可用。在基于主节点复制模型下，如果要继续处理写操作，则需要执行切换操作。</p>
<p>对无节点配置，则不存在这样的切换操作。用户只要写入二个副本，即可认为写入成功。</p>
<p>如果失效的节点重新上线，客户端开始读取它，则可能会将陈旧（过时）值视为响应。</p>
<p>为了解决这个问题，当一个客户端从数据库中读取数据时，它不仅仅发送它的请求到一个副本：<strong>读请求也被并行地发送到多个节点</strong>-这是我们在单主和多主都遇不到的多读问题，这也是后面出现 r 值的原因。客户可能会从不同的节点获得不同的响应。即来自一个节点的最新值和来自另一个节点的陈旧值。<strong>版本号用于确定哪个值更新</strong>（参阅“检测并发写入”）。</p>
<h4 id="读修复和反熵">读修复和反熵</h4>
<p><strong>复制方案应确保最终将所有数据复制到每个副本。​ 在Dynamo风格的数据存储</strong>中经常使用两种机制：</p>
<h5 id="读修复-read-repair">读修复（Read repair）</h5>
<p>当客户端并行读取多个节点时，它可以检测到任何陈旧的响应。<strong>客户端发现某个副本具有陈旧值，并将新值写回副本</strong>（所以 ZooKeeper 的 sync()后读不是读修复，而是读时一致性保证）。这种方法适用于频繁阅读的值。</p>
<p>这个做法和 Cache-Aside Pattern 和 WeakHashMap 的惰性机制很像，但可能损害持久性（duration）。</p>
<p>读修复必须依赖“能比较新旧”的版本机制；没有版本就无从知晓哪个值更“新”，也不敢盲目回写。</p>
<h5 id="反熵-anti-entropy-process">反熵（Anti-entropy process）</h5>
<p>此外，一些数据存储具有后台进程，<strong>该进程不断查找副本之间的数据差异，并将任何缺少的数据从一个副本复制到另一个副本</strong>。与基于领导者的复制中的复制日志不同，此反熵过程不会以任何特定的顺序复制写入，并且在复制数据之前可能会有显著的延迟。<strong>我们能不能通过反熵过程来修复数据不一致，不取决于我们能不能找到全局有序的预写日志，它使用Merkle 树/哈希对比把乱序缺失数据补齐</strong>。</p>
<p>并不是所有的系统都实现了这两个；例如，Voldemort目前没有反熵过程。请注意，<strong>如果没有反熵过程，某些副本中很少读取的值可能会丢失，从而降低了持久性，因为只有在应用程序读取值时才执行读修复</strong>。</p>
<h4 id="读写的法定人数">读写的法定人数</h4>
<p>要保证读取一定能够读到最新值，就要求写副本足够多，并行读副本也足够多。把道理推广到一般情况，如果有 n 个副本，每个写入必须由w节点确认才能被认为是成功的，并且我们必须至少为每个读取查询r个节点（r 专指并行读）。只要 w + r &gt; n，读取的节点中一定会包含最新值。</p>
<p>设 old = n - w，只要 r &gt; old 则 r 一定包含最新值，<strong>因为 old 不够多</strong>，因此 w + r &gt; n。满足这些r、w值的读写称为法定票数读和法定票数写。你可以认为，r和w是有效读写所需的最低票数。r 和 w 往往要相互配合。</p>
<p>在 Dynamo 风格的数据库中，参数n，w和r通常是可配置的。</p>
<ol>
<li>一个常见的选择：使n为奇数（通常为3或5）并设置 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>=</mo><mi>r</mi><mo>=</mo><mtext>（</mtext><mi>n</mi><mo>+</mo><mn>1</mn><mtext>）</mtext><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">w = r =（n + 1）/ 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord cjk_fallback">（</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord cjk_fallback">）</span><span class="mord">/</span><span class="mord">2</span></span></span></span>（向上取整）。</li>
<li>另一个选择：设置<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>=</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">w = n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">r = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。写入很少且读取次数较多的工作负载可能会受益。这使得读取速度更快，但具有只有一个失败节点导致所有数据库写入失败的缺点（因为只要少一个节点，w 就注定失败）。</li>
</ol>
<blockquote>
<p>“读法定人数 r”和“写法定人数 w”<strong>本来就是两个独立参数，日常口语里我们说“quorum”往往只指写侧</strong>（多数派 w&gt;n/2），而<br>
<strong>Dynamo 风格的无主系统才把 r 也显式拉出来，形成 r+w&gt;n 的双参组合</strong>。</p>
</blockquote>
<p>仲裁条件<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>+</mo><mi>r</mi><mo>&gt;</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">w + r&gt; n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>允许系统容忍不可用的节点，如下所示：</p>
<ul>
<li>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>&lt;</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">w &lt; n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>，如果节点不可用，我们仍然可以处理写入。</li>
<li>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>&lt;</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">r &lt; n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>，如果节点不可用，我们仍然可以处理读取。</li>
<li>对于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>3</mn><mtext>，</mtext><mi>w</mi><mo>=</mo><mn>2</mn><mtext>，</mtext><mi>r</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n = 3，w = 2，r = 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>，我们可以容忍一个不可用的节点。</li>
<li>对于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>5</mn><mtext>，</mtext><mi>w</mi><mo>=</mo><mn>3</mn><mtext>，</mtext><mi>r</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">n = 5，w = 3，r = 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>，我们可以容忍两个不可用的节点。</li>
<li>通常，读取和写入操作始终并行发送到所有n个副本。参数w和r决定我们等待多少个节点，即在我们认为读或写成功之前，有多少个节点需要报告成功。我们能够容忍的节点数 &lt; min(w, r)。</li>
</ul>
<h3 id="quorum-一致性的局限性">Quorum 一致性的局限性</h3>
<p>通常，<strong>r和w被选为多数（超过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">n / 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">2</span></span></span></span> ）节点，因为这确保了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>+</mo><mi>r</mi><mo>&gt;</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">w + r &gt; n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>，同时仍然容忍多达<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">n/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">2</span></span></span></span>个节点故障</strong>。但是，法定人数不一定必须是大多数，<strong>只是读写使用的节点交集至少需要包括一个节点</strong>。其他法定人数的配置是可能的，这使得分布式算法的设计有一定的灵活性。</p>
<p>但是，即使在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>+</mo><mi>r</mi><mo>&gt;</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">w + r&gt; n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>的情况下，也可能存在返回陈旧值的边界条件。这取决于实现，但可能的情况包括：</p>
<ul>
<li>如果使用松散的法定人数（见“松散法定人数与带提示的接力”），w个写入和r个读取落在完全不同的节点上，因此r节点和w之间不再保证有重叠节点。实现层需通过提示移交或读修复保证最终交集，否则松散 quorum 会被视为无效配置。</li>
<li>如果两个写入同时发生，不清楚哪一个先发生。在这种情况下，唯一安全的解决方案是合并并发写入。如果根据时间戳（最后写入胜利）挑选出胜者，则由于时钟偏差，写入可能会丢失。我们将返回“检测并发写入”中的此主题。</li>
<li>如果写操作与读操作同时发生，写操作可能仅反映在某些副本上。在这种情况下，不确定读取是返回旧值还是新值。</li>
<li>如果写操作在某些副本上成功，而在其他节点上失败（例如，因为某些节点上的磁盘已满），在小于w个副本上写入成功。所以整体判定写入失败，但整体写入失败并没有在写入成功的副本上回滚。这意味着写失败未回滚的脏值会在读修复前短暂可见。</li>
<li>如果携带新值的节点失败，需要读取其他带有旧值的副本。并且其数据从带有旧值的副本中恢复，则存储新值的副本数可能会低于w，从而打破法定人数条件。</li>
<li>即使一切工作正常，有时也会不幸地出现关于时序（timing）的边缘情况。</li>
</ul>
<p>因此，尽管法定人数似乎保证读取返回最新的写入值，但在实践中并不那么简单。**Dynamo 风格的数据库通常针对可以忍受最终一致性的用例进行优化。允许通过参数w和r来调整读取陈旧值的概率，但把它们当成绝对的保证是不明智的。**无主写带来更复杂的冲突检测与合并负担。</p>
<p>注意，这里使用的 quorum 和后面共识算法会再次提到的 quorum 是不一样的，此处的 rwn 算法是适应无主复制的，并不一定和后面要讲到的防脑裂多数票算法一样。它们都恰好使用了 quorum 和 rwn，但共识算法的 quorum 依赖于多数共识（防止小分区产生的脑裂），所以 w 的数量是需要强制过半的。</p>
<h4 id="监控旧值">监控旧值</h4>
<p>从运维的角度来看，监控数据库是否返回最新的结果是很重要的。即使应用可以容忍陈旧的读取，您也需要了解复制的健康状况。如果显著落后，应该提醒您，以便您可以调查原因（例如，网络中的问题或超载节点）。</p>
<p>对于基于领导者的复制，数据库通常会公开复制滞后的度量标准，您可以将其提供给监视系统。这是可能的，因为写入按照相同的顺序应用于领导者和追随者，并且每个节点在复制日志中具有一个位置。通过从领导者的当前位置中减去随从者的当前位置，您可以测量复制滞后量。**比对位点的位置是监控这类日志的基础方案。**binlog offset 只要可以衡量量化，就可以做监控。</p>
<p>然而，在无领导者复制的系统中，<strong>没有固定的写入顺序</strong>，这使得监控变得更加困难。而且，如果数据库只使用读修复（没有反熵过程），那么对于一个值可能会有多大的限制是没有限制的 - 如果一个值很少被读取，那么由一个陈旧副本返回的值可能是古老的。</p>
<p>现在的新研究可以基于 n，w 和 r 来预测读到旧值的百分比。</p>
<h4 id="宽松法定票数-quorum-与数据回传">宽松法定票数（quorum）与数据回传</h4>
<p>松散法定票数（sloppy quorum）意味着，网络中断时，写入和读取仍然需要 w 和 r 个成功的响应，但包含了那些不在先前指定的 n 个节点。比方说，如果你把自己锁在房子外面，你可能会敲开邻居的门，问你是否可以暂时停留在沙发上。</p>
<p>一旦网络中断得到解决，代表另一个节点临时接受的一个节点的任何写入都被发送到适当的“本地”节点。这就是所谓的数据回传（暗示移交 hinted handoff）。一旦你再次找到你的房子的钥匙，你的邻居礼貌地要求你离开沙发回家。</p>
<h4 id="运维多个数据中心">运维多个数据中心</h4>
<p>无主复制还适用于多数据中心操作，因为它旨在容忍冲突的并发写入，网络中断和延迟尖峰。- 多主复制也可以容忍这些东西。</p>
<p>Cassandra 和 Voldemort 在正常的无主模型中实现了他们的多数据中心支持：副本的数量n包括所有数据中心的节点；Riak 将客户端和数据库节点之间的所有通信保持在一个数据中心本地，因此n描述了一个数据中心内的副本数量。</p>
<p>所有的跨数据中心写入都用类似多主复制的方案，采取异步写入方案。</p>
<h3 id="检测并发写">检测并发写</h3>
<p>Dynamo 风格的数据库允许多个客户端同时写入相同的主键，这意味着即使使用严格的法定人数也会发生冲突。这种情况与多领导者复制相似，但在 Dynamo 样式的数据库中，在读修复或数据回传期间也可能会产生冲突。总体而言，比多主复制更差。</p>
<p>无主节点复制的致命缺点是：请求在不同节点上可能呈现不同的顺序。</p>
<p>如果每个节点只要接收到来自客户端的写入请求就简单地覆盖了某个键的值，那么节点就会永久地不一致。所以我们需要引入一些解决冲突的技巧，来让系统的副本值收敛、统一。</p>
<h4 id="最后写入者胜-丢弃并发写入">最后写入者胜（丢弃并发写入）</h4>
<p>实现最终融合的一种方法是声明每个副本只需要存储最“最近”的值，并允许“更旧”的值被覆盖和抛弃。然后，只要我们有一种明确的方式来确定哪个写是“最近的”，并且每个写入最终都被复制到每个副本，那么复制最终会收敛到相同的值。</p>
<p>关键的设计在于，如何定义“最新的”。事实上，说“发生”是没有意义的：我们说写入是并发（concurrent）的，所以它们的顺序是不确定的。</p>
<p>即使写入没有自然的排序，我们也可以强制任意排序。例如，可以为每个写入附加一个时间戳，挑选最“最近”的最大时间戳，并丢弃具有较早时间戳的任何写入。这种冲突解决算法被称为最后写入胜利（LWW, last write wins），是 Cassandra 唯一支持的冲突解决方法，也是 Riak 中的一个可选特征。</p>
<p>LWW实现了最终收敛的目标，但以持久性为代价：如果同一个Key有多个并发写入，即使它们都被报告为客户端成功（因为它们被写入 w 个副本），但只有一个写入将存活，而其他写入将被静默丢弃。此外，LWW甚至可能会删除不是并发的写入。</p>
<p>有一些情况，如缓存，其中丢失的写入可能是可以接受的。<strong>如果丢失数据不可接受，LWW不是解决冲突的一个好选择。</strong></p>
<p>与LWW一起使用数据库的<strong>唯一安全方法是确保一个键只写入一次，然后视为不可变，从而避免对同一个主键进行并发更新</strong>（final 化也是一种高明的办法）。例如，Cassandra推荐使用的方法是使用UUID作为键，从而为每个写操作提供一个唯一的键。</p>
<h4 id="happens-before-关系和并发">Happens-before 关系和并发</h4>
<p><strong>如果 A 在 B 之前发生或者 B 在 A 之前发生，他们之间的关系可以归为 Happens-before；否则它们可以被归为并发</strong>。如果一个操作发生在另一个操作之前，则后面的操作应该覆盖较早的操作，但是如果这些操作是并发的，则存在需要解决的冲突。</p>
<p>另一种标准：如果两个操作都意识不到对方的存在，就称这两个操作并发；否则他们就不是并发的。</p>
<p>操作的三种关系：</p>
<ol>
<li>A前B后。</li>
<li>B前A后。</li>
<li>AB 并发。</li>
</ol>
<h4 id="确定并发关系">确定并发关系</h4>
<p>一个基于版本号的算法的工作原理如下：</p>
<ul>
<li>服务器为每个键保留一个版本号，每次写入键时都增加版本号，并将新版本号与写入的值一起存储。</li>
<li>当客户端读取键时，服务器将返回所有未覆盖的值以及最新的版本号。客户端在写入前必须读取。</li>
<li>客户端写入键时，必须包含之前读取的版本号（类似令牌的机制），并且必须将之前读取的所有值合并在一起。 <strong>来自写入请求的响应可以像读取一样，返回所有当前值</strong>，这使得我们可以像购物车示例那样连接多个写入。</li>
<li>当服务器接收到具有特定版本号的写入时，它可以<strong>覆盖该版本号或更低版本的所有值</strong>（因为它知道它们已经被合并到新的值中），但是<strong>它必须保持更高版本号的所有值（因为这些值与传入的写入属于并发）</strong>。</li>
</ul>
<p>这种算法的 merge 是发生在客户端上的。</p>
<p><img src="fig5-13.png" alt="图5-13 捕获两个客户端之间的因果关系，同时编辑购物车"><br>
<img src="fig5-14.png" alt="图5-14 图5-13中的因果依赖关系图"></p>
<p>这个算法体现了：</p>
<ol>
<li>购物车不会简单让新值覆盖旧值，如果版本号不match，触发merge。</li>
<li>因果关系可能部分来自于并发的另一个操作，但是因为不是总是得到并发操作的全貌，所以每次只能获取部分信息。所以：<strong>对中间值的更新会覆盖老值，但是会合并更高值</strong>。</li>
</ol>
<h4 id="合并同时写入的值">合并同时写入的值</h4>
<p>这种算法可以确保没有数据被无声地丢弃，但不幸的是，客户端需要做一些额外的工作：如果多个操作并发发生，<strong>则客户端必须通过合并并发写入的值来继承旧值</strong>。 Riak称这些并发值为兄弟（siblings）。</p>
<p>然而，简单地 union 无法保证被删除的数据真的被删除。所以我们需要在数据结构里提供墓碑标志位，以保证数据在真正合并时被删除-<strong>真正的删除算法需要仔细设计</strong>！</p>
<p>具体地说，如果我们在一个购物车里面删除了一个商品，要给它一个特殊的标记，这样合并的时候另一个购物车即使也有这个商品，也会因为<strong>遇到墓碑把它从合并结果里删除</strong>。CRDT数据结构的一个使用场景就在这里了。</p>
<h4 id="版本向量">版本向量</h4>
<p>如何解决多副本的并发写入问题？</p>
<p>使用简单的版本号只适合单副本（实际上是单主）的架构模式。<strong>我们需要为每个副本和每个主键均定义一个版本号</strong>。每个副本在处理写入时增加自己的版本号，并且跟踪从其他副本中看到的版本号。这个信息指出了要覆盖哪些值，以及保留哪些并发值。</p>
<p><strong>所有副本的版本号集合称为版本向量（version vector）。</strong></p>
<p>版本向量有时也被称为矢量时钟，即使它们不完全相同。<strong>在比较副本的状态时，应当采用版本向量</strong>。</p>
<p>我们之前已经看到了一个例子：</p>
<ol>
<li>S 返回 version 给 C，C在下一个请求的时候重放 version，S根据请求version和当前副本最高 version 决定行为。</li>
<li>版本向量与此类事，S 返回的不是当前的最新版本，而是版本变化的序列，请求重放给 S 的也是向量。</li>
</ol>
<h2 id="小结">小结</h2>
<p>复制很难，有很多微妙的问题。</p>
<p>如果可以，最好使用单主从复制；否则需要承受脆弱的一致性问题-单元化、sequence id 的双主生成问题。</p>
<p>我们需要仔细考虑三种一致性：</p>
<ul>
<li>写后读：只读主。读主或 sync() 后再读</li>
<li>单调读：只读一个副本。用粘性连接或读令牌保证每次都回到同一副本。</li>
<li>前缀一致读：把有因果关系的写都发到同一分片。</li>
</ul>
<h1>数据分区</h1>
<p>分区(partition)，在MongoDB，Elasticsearch和Solr Cloud中被称为分片(shard)，在HBase中称之为区域(Region)，Bigtable中则是 表块（tablet），Cassandra和Riak中是虚节点（vnode)， Couchbase中叫做虚桶(vBucket)。但是分区(partition) 是约定俗成的叫法。</p>
<p>通常情况下，每条数据（每条记录，每行或每个文档）属于且仅属于一个分区。实际上，每个分区都是自己的小型数据库，尽管数据库可能支持同时进行多个分区的操作。</p>
<p>分区主要是为了可扩展性。不同的分区可以放在不共享集群中的不同节点上（参阅第二部分关于无共享架构的定义）。因此，大数据集可以分布在多个磁盘上，并且查询负载可以分布在多个处理器上。（<strong>所以分区会派生一个问题，请求路由</strong>）。</p>
<p>对于在单个分区上运行的查询，每个节点可以独立执行对自己的查询，因此可以通过添加更多的节点来扩大查询吞吐量。<strong>分区和复制都是一种实现读扩展的方式。然而分区会让复杂查询变得更复杂。</strong></p>
<h2 id="分区与复制">分区与复制</h2>
<p>分区通常与复制结合使用，使得每个分区的副本存储在多个节点上。 这意味着，即使每条记录属于一个分区，它仍然可以存储在多个不同的节点上以获得容错能力。</p>
<p>一个节点可能存储多个分区。  每个分区领导者(主)被分配给一个节点，追随者(从)被分配给其他节点。 每个节点可能是某些分区的领导者，同时是其他分区的追随者。 大多数情况下，分区方案的选择与复制方案的选择是独立的。</p>
<p><img src="%E5%88%86%E5%8C%BA%E4%B8%8E%E5%A4%8D%E5%88%B6%E7%BB%84%E5%90%88%E4%BD%BF%E7%94%A8.png" alt="分区与复制组合使用.png"></p>
<h2 id="键-值数据的分区">键-值数据的分区</h2>
<p>分区目标是将数据和查询负载均匀分布在各个节点上。如果每个节点公平分享数据和负载，那么理论上10个节点应该能够处理10倍的数据量和10倍的单个节点的读写吞吐量（暂时忽略复制）。</p>
<p>**如果分区是不公平的，一些分区比其他分区有更多的数据或查询，我们称之为偏斜（skew）。**数据偏斜的存在使分区效率下降很多。在极端的情况下，所有的负载可能压在一个分区上，其余9个节点空闲的，瓶颈落在这一个繁忙的节点上。<strong>不均衡导致的高负载的分区被称为热点（hot spot）</strong>。</p>
<p>避免热点最简单的方法是将记录随机分配给节点-给分区键加上一些随机值。这将在所有节点上平均分配数据，但是它有一个很大的缺点：当你试图读取一个特定的值时，你无法知道它在哪个节点上，所以你必须并行地查询所有的节点。</p>
<p>键的范围不一定均匀分布，因为数据也很可能不均匀分布**（skew 是天然存在的）**。</p>
<h3 id="根据键的范围分区">根据键的范围分区</h3>
<p>一种分区的方法是为每个分区指定一块连续的键范围（从最小值到最大值），如纸百科全书的卷。如果知道范围之间的边界，则可以轻松确定哪个分区包含某个值。如果您还知道分区所在的节点，那么可以直接向相应的节点发出请求（对于百科全书而言，就像从书架上选取正确的书籍）。</p>
<p><strong>键的范围不一定均匀分布，因为数据也很可能不均匀分布。为了均匀分配数据，分区边界需要依据数据调整。</strong></p>
<p>分区边界可以由管理员手动选择，也可以由数据库自动选择。 Bigtable使用了这种分区策略，以及其开源等价物HBase，RethinkDB和2.4版本之前的 MongoDB。</p>
<h3 id="根据键的散列分区">根据键的散列分区</h3>
<p>由于偏斜和热点的风险，许多分布式数据存储使用散列函数来确定给定键的分区。</p>
<p>一个好的散列函数可以将将偏斜的数据均匀分布。出于分区的目的，散列函数不需要多么强壮的加密算法。许多编程语言都有内置的简单哈希函数（它们用于哈希表），但是它们可能不适合分区：例如，在Java的Object.hashCode()和Ruby的Object#hash，同一个键可能在不同的进程中有不同的哈希值。<strong>这证明散列算法必须是 common-lang 的一部分。</strong></p>
<p>一旦你有一个合适的键散列函数，你可以为每个分区分配一个散列范围（而不是键的范围），每个通过哈希散列落在分区范围内的键将被存储在该分区中。</p>
<p><img src="%E9%94%AE%E8%8C%83%E5%9B%B4.png" alt="键范围.png"></p>
<p>这个图有两个值得注意的东西：</p>
<ol>
<li>hashcode 的结果的高位可以做分桶键（短 URL 服务有这样的例子）。</li>
<li>键范围是桶范围。</li>
</ol>
<p>这种技术擅长在分区之间分配键。分区边界可以是均匀间隔的，也可以是伪随机选择的（<strong>在这种情况下，该技术有时也被称为一致性哈希（consistent hashing）</strong>）。</p>
<p>不幸的是，通过使用键散列进行分区，我们失去了键范围分区的一个很好的属性：高效执行范围查询的能力。曾经相邻的密钥现在分散在所有分区中，所以它们之间的顺序就丢失了。在MongoDB中，如果您使用了基于散列的分区模式，则任何范围查询都必须发送到所有分区。Riak ，Couchbase 或 Voldemort 不支持主键上的范围查询。<strong>目前的分布式数据库的成果无法很好地解决散列分区导致的范围查询失效的问题，有的实现索性直接放弃。</strong></p>
<p>但，有一种“组合分区键 + 区间查找键”的思路可以兼顾部分场景下的多种查找的问题（制造数据局部性的思想又发挥作用了）：<br>
Cassandra采取了折衷的策略。 Cassandra中的表可以使用由多个列组成的复合主键来声明。键中只有第一列会作为散列的依据，而其他列则被用作Casssandra的SSTables中排序数据的连接索引。尽管查询无法在复合主键的第一列中按范围扫表，但如果第一列已经指定了固定值，则可以对该键的其他列执行有效的范围扫描。</p>
<p>​ 组合索引方法为一对多关系提供了一个优雅的数据模型。例如，在社交媒体网站上，一个用户可能会发布很多更新。<strong>如果更新的主键被选择为(user_id, update_timestamp)，那么您可以有效地检索特定用户在某个时间间隔内按时间戳排序的所有更新。不同的用户可以存储在不同的分区上，对于每个用户，更新按时间戳顺序存储在单个分区上</strong>。</p>
<h3 id="负载倾斜与消除热点">负载倾斜与消除热点</h3>
<p>如前所述，哈希分区可以帮助减少热点。但是，它不能完全避免它们：在极端情况下，所有的读写操作都是针对同一个键的，所有的请求都会被路由到同一个分区。</p>
<p>这种场景也许并不常见，但并非闻所未闻：例如，在社交媒体网站上，一个拥有数百万追随者的名人用户在做某事时可能会引发一场风暴。这个事件可能导致大量写入同一个键（键可能是名人的用户ID，或者人们正在评论的动作的ID）。哈希策略不起作用，因为两个相同ID的哈希值仍然是相同的。</p>
<p>如今，大多数数据系统无法自动补偿这种高度偏斜的负载，因此应用程序有责任减少偏斜。例如，如果一个主键被认为是非常火爆的，一个简单的方法是在主键的开始或结尾添加一个随机数。只要一个两位数的十进制随机数就可以将主键分散为100种不同的主键,从而存储在不同的分区中。</p>
<p>然而，将主键进行分割之后，任何读取都必须要做额外的工作，因为他们必须从所有100个主键分布中读取数据并将其合并。此技术还需要额外的记录：只需要对少量热点附加随机数;对于写入吞吐量低的绝大多数主键来是不必要的开销。因此，您还需要一些方法来跟踪哪些键需要被分割。</p>
<p>也许在将来，数据系统将能够自动检测和补偿偏斜的工作负载；但现在，您需要自己来权衡。</p>
<p>这证明 hot key 的写入解决方案是破坏 hot key 的均衡性，引入散列分布。但散列分布的结果一定是全区间搜索（散列是一把双刃剑），其实得不偿失。另一个思路可能需要应用层削峰。</p>
<h2 id="分区与二级索引">分区与二级索引</h2>
<p>到目前为止，我们讨论的分区方案依赖于键值数据模型。<strong>现实中二级索引有其存在的必要性</strong>：需要加速特定值的查询。但一般的键值数据库都放弃了对二级索引的支持（Redis 就不支持二级索引），这就是搜索引擎等全文搜索服务存在的原因。</p>
<h3 id="按文档的二级索引-document-partitioned">按文档的二级索引（document partitioned）</h3>
<p><img src="%E6%96%87%E6%A1%A3%E5%88%86%E5%8C%BA%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95.png" alt="文档分区二级索引"></p>
<p>在这种索引方法中，每个分区是完全独立的：每个分区维护自己的二级索引，仅覆盖该分区中的文档。它不关心存储在其他分区的数据。无论何时您需要写入数据库（添加，删除或更新文档），只需处理包含您正在编写的文档ID的分区即可。出于这个原因，<strong>文档分区索引也被称为本地索引（local index）（而不是将在下一节中描述的全局索引（global index））</strong>。</p>
<p>但是，从文档分区索引中读取需要注意：除非您对文档ID做了特别的处理，否则没有理由将所有具有特定颜色或特定品牌的汽车放在同一个分区中因此，如果要搜索红色汽车，则需要将查询发送到所有分区，并合并所有返回的结果。</p>
<p>这种查询分区数据库的方法有时被称为分散/聚集（scatter/gather），并且可能会使二级索引上的读取查询相当昂贵。即使并行查询分区，分散/聚集也容易导致尾部延迟放大（参阅“实践中的百分位点”）。然而，它被广泛使用：MongoDB，Riak，Cassandra，Elasticsearch，SolrCloud 和 VoltDB 都使用文档分区二级索引。大多数数据库供应商建议您构建一个能从单个分区提供二级索引查询的分区方案，但这并不总是可行，尤其是当在单个查询中使用多个二级索引时（例如同时需要按颜色和制造商查询）。</p>
<ol>
<li>Scatter：把同一条查询同时广播到所有涉及的分区（shard）。</li>
<li>Gather：等每个分区把本地结果返回后，在协调节点做一次合并（去重、排序、limit、聚合等），再返回给客户端。</li>
</ol>
<p>分散的本地索引会带来如下问题：</p>
<ol>
<li>并行查找</li>
<li>并发写失败</li>
</ol>
<p><strong>按文档的二级索引是本地索引，它跟着文档的主键走，写简单（无跨分片事务），读复杂（有并行查找的问题）。类似 ER-sharding</strong>。</p>
<h3 id="按关键词的二级索引-term-partitioned">按关键词的二级索引（term partitioned）</h3>
<p>我们可以构建一个覆盖所有分区数据的全局索引，而不是给每个分区创建自己的次级索引（本地索引）。但是，我们不能只把这个索引存储在一个节点上，因为它可能会成为瓶颈，违背了分区的目的。全局索引也必须进行分区，但可以采用与主键不同的分区方式。</p>
<p>关键词(Term) 来源于来自全文搜索索引（一种特殊的次级索引），指文档中出现的所有单词。</p>
<p>关键词分区的全局索引优于文档分区索引的地方点是它可以使读取更有效率：不需要分散/收集所有分区，客户端只需要向包含关键词的分区发出请求。全局索引的缺点在于写入速度较慢且较为复杂，因为写入单个文档现在可能会影响索引的多个分区（文档中的每个关键词可能位于不同的分区或者不同的节点上） 。</p>
<p>理想情况下，索引总是最新的，写入数据库的每个文档都会立即反映在索引中。但是，在关键词分区索引中，这需要跨分区的分布式事务，并不是所有数据库都支持（请参阅第7章和第9章）。</p>
<p>在实践中，<strong>对全局二级索引的更新通常是异步的</strong>（也就是说，如果在写入之后不久读取索引，刚才所做的更改可能尚未反映在索引中）。例如，Amazon DynamoDB声称在正常情况下，其全局次级索引会在不到一秒的时间内更新，但在基础架构出现故障的情况下可能会有延迟。</p>
<p>全局关键词分区索引的其他用途包括Riak的搜索功能和Oracle数据仓库，它允许您在本地和全局索引之间进行选择。</p>
<p><strong>词条索引是个全局索引，索引跟着自己的分区算法走，读取简单，但写入复杂。</strong></p>
<p><strong>全局索引的核心问题是：到底是不是跟着主维度走？跟着主维度走，则自己的维度无法兼顾，读复杂；不跟着主维度走，则文档插入时的写复杂。</strong></p>
<p>ES 的索引是被异步更新的，它是文档索引，还是词条索引？</p>
<h2 id="分区再平衡">分区再平衡</h2>
<p>将负载从集群中的一个节点向另一个节点移动的过程称为再平衡（reblancing）。</p>
<p>无论使用哪种分区方案，再平衡通常都要满足一些最低要求：</p>
<ul>
<li>再平衡之后，负载（数据存储，读取和写入请求）应该在集群中的节点之间公平地共享。</li>
<li>再平衡发生时，数据库应该继续接受读取和写入。</li>
<li>节点之间只移动必须的数据，以便快速再平衡，并减少网络和磁盘I/O负载。</li>
</ul>
<h3 id="平衡策略">平衡策略</h3>
<h4 id="反面教材：hash-mod-n">反面教材：hash mod N</h4>
<p>模<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>方法的问题是，如果节点数量N发生变化，大多数密钥将需要从一个节点移动到另一个节点。<strong>我们需要一种只移动必需数据的方法。</strong></p>
<h4 id="固定数量的分区">固定数量的分区</h4>
<p>幸运的是，有一个相当简单的解决方案：创建比节点更多的分区，并为每个节点分配多个分区（<strong>这是 Redis 的集群方案，减少再平衡的成本，这可以被称作固定桶/方案方案</strong>）。</p>
<p>现在，如果一个节点被添加到集群中，新节点可以从当前每个节点中窃取一些分区，直到分区再次公平分配。</p>
<p>只有分区在节点之间的移动。分区的数量不会改变，键所指定的分区也不会改变。唯一改变的是分区所在的节点。这种变更并不是即时的 — 在网络上传输大量的数据需要一些时间 — 所以在传输过程中，原有分区仍然会接受读写操作。</p>
<p><img src="%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E4%B8%8E%E8%BF%81%E7%A7%BB.png" alt="固定分区与迁移.png"></p>
<p>ES 恰好是这种动态平衡方式（所以一开始的时候的分片尽可能多是有好处的，改变 ES 的分片数量的再平衡又是另一个问题了）。</p>
<p>在这种配置中，分区的数量通常在数据库第一次建立时确定，之后不会改变。虽然原则上可以分割和合并分区（请参阅下一节），但固定数量的分区在操作上更简单，因此许多固定分区数据库选择不实施分区分割。因此，一开始配置的分区数就是您可以拥有的最大节点数量，所以您需要选择足够多的分区以适应未来的增长。但是，每个分区也有管理开销，所以选择太大的数字会适得其反。</p>
<p>如果数据集的总大小难以预估（例如，如果它开始很小，但随着时间的推移可能会变得更大），选择正确的分区数是困难的。由于每个分区包含了总数据量固定比率的数据，因此每个分区的大小与集群中的数据总量成比例增长。如果分区非常大，再平衡和从节点故障恢复变得昂贵。但是，如果分区太小，则会产生太多的开销。当分区大小“恰到好处”的时候才能获得很好的性能，如果分区数量固定，但数据量变动很大，则难以达到最佳性能。<strong>这证明做大规模数据存储分区设计的时候，事先计算是很重要的-每天产生多少数据，要产生多少天。</strong></p>
<h4 id="动态分区">动态分区</h4>
<p>对于使用键范围分区的数据库，具有固定边界的固定数量的分区将非常不便：如果出现边界错误，则可能会导致一个分区中的所有数据或者其他分区中的所有数据为空。手动重新配置分区边界将非常繁琐。</p>
<p>出于这个原因，按键的范围进行分区的数据库（如HBase和RethinkDB）会动态创建分区。当分区增长到超过配置的大小时（在HBase上，默认值是10GB），会被分成两个分区，每个分区约占一半的数据。与之相反，如果大量数据被删除并且分区缩小到某个阈值以下，则可以将其与相邻分区合并。此过程与B树顶层发生的过程类似（参阅“B树”）。</p>
<p><strong>每个分区分配给一个节点，每个节点可以处理多个分区，就像固定数量的分区一样。大型分区拆分后，可以将其中的一半转移到另一个节点，以平衡负载</strong>。在HBase中，分区文件的传输通过HDFS（底层分布式文件系统）来实现。</p>
<p>动态分区的一个优点是分区数量适应总数据量。如果只有少量的数据，少量的分区就足够了，所以开销很小;如果有大量的数据，每个分区的大小被限制在一个可配置的最大值。<strong>动态分区可以借助阈值实现分区的固定大小和分区的恰当数量，进而总是得到固定开销。</strong></p>
<h4 id="按节点比例分区">按节点比例分区</h4>
<p>通过动态分区，分区的数量与数据集的大小成正比，因为拆分和合并过程将每个分区的大小保持在固定的最小值和最大值之间。另一方面，对于固定数量的分区，每个分区的大小与数据集的大小成正比。在这两种情况下，分区的数量都与节点的数量无关。</p>
<p>Cassandra 和 Ketama 使用的第三种方法是使分区数与节点数成正比——换句话说，每个节点具有固定数量的分区。在这种情况下，每个分区的大小与数据集大小成比例地增长，而节点数量保持不变，但是当增加节点数时，分区将再次变小。由于较大的数据量通常需要较大数量的节点进行存储，因此这种方法也使每个分区的大小较为稳定。</p>
<p>当一个新节点加入集群时，它随机选择固定数量的现有分区进行拆分，然后占有这些拆分分区中每个分区的一半，同时将每个分区的另一半留在原地。随机化可能会产生不公平的分割，但是平均在更大数量的分区上时（在Cassandra中，默认情况下，每个节点有256个分区），新节点最终从现有节点获得公平的负载份额。 Cassandra 3.0引入了另一种再分配的算法来避免不公平的分割。</p>
<p>随机选择分区边界要求使用基于散列的分区（可以从散列函数产生的数字范围中挑选边界）。实际上，这种方法最符合一致性哈希的原始定义（参阅“一致性哈希”）。最新的哈希函数可以在较低元数据开销的情况下达到类似的效果。但是实践中原始一致性哈希的效果并不好，数据库在弃用这种方案。</p>
<h4 id="运维：手动还是自动平衡">运维：手动还是自动平衡</h4>
<p>在全自动重新平衡（系统自动决定何时将分区从一个节点移动到另一个节点，无须人工干预）和完全手动（分区指派给节点由管理员明确配置，仅在管理员明确重新配置时才会更改）之间有一个权衡。</p>
<p>在全自动重新平衡（系统自动决定何时将分区从一个节点移动到另一个节点，无须人工干预）和完全手动（分区指派给节点由管理员明确配置，仅在管理员明确重新配置时才会更改）之间有一个权衡。例如，Couchbase，Riak和Voldemort会自动生成建议的分区分配，但需要管理员提交才能生效。</p>
<p>全自动重新平衡可以很方便，因为正常维护的操作工作较少。但是，这可能是不可预测的。再平衡是一个昂贵的操作，因为它需要重新路由请求并将大量数据从一个节点移动到另一个节点。如果没有做好，这个过程可能会使网络或节点负载过重，降低其他请求的性能。</p>
<p>这种自动化与自动故障检测相结合可能十分危险。例如，假设一个节点过载，并且对请求的响应暂时很慢。其他节点得出结论：过载的节点已经死亡，并自动重新平衡集群，使负载离开它。这会对已经超负荷的节点，其他节点和网络造成额外的负载，从而使情况变得更糟，并可能导致级联失败。</p>
<p>出于这个原因，再平衡的过程中有人参与是一件好事。这比完全自动的过程慢，但可以帮助防止运维意外。</p>
<p>最佳再平衡机制 = 自动故障检测 + 手工决策。</p>
<h2 id="请求路由">请求路由</h2>
<p>数据如果出现再平衡，读写这些数据的时候需要恰到好处地找到数据<strong>所在的节点，进而找到分片</strong>。</p>
<p>这个问题可以概括为 服务发现(service discovery) ，它不仅限于数据库。任何可通过网络访问的软件都有这个问题，特别是如果它的目标是高可用性（在多台机器上运行冗余配置）。</p>
<p>概括来说，这个问题有几种不同的方案:</p>
<ul>
<li>Sefl-As-Router 法：允许客户联系任何节点（例如，通过循环策略的负载均衡（Round-Robin Load Balancer））。如果该节点恰巧拥有请求的分区，则它可以直接处理该请求;否则，它将请求转发到适当的节点，接收回复并传递给客户端。</li>
<li>Dedicated-Proxy 法：首先将所有来自客户端的请求发送到路由层，它决定了应该处理请求的节点，并相应地转发。此路由层本身不处理任何请求；它仅负责分区的负载均衡。</li>
<li>Sefl-As-Client 法：要求客户端知道分区和节点的分配。在这种情况下，客户端可以直接连接到适当的节点，而不需要任何中介。</li>
</ul>
<p><img src="request-routing.png" alt="request-routing.png"></p>
<p>这是一个具有挑战性的问题，因为重要的是所有参与者都同意 - 否则请求将被发送到错误的节点，而不是正确处理。 在分布式系统中有达成共识的协议，但很难正确地实现。</p>
<p><strong>许多分布式数据系统都依赖于一个独立的协调服务。</strong></p>
<h3 id="执行并行查询">执行并行查询</h3>
<p>如何执行并行查询也是一个“请求路由”的子命题。</p>
<p>然而，通常用于分析的大规模并行处理（MPP, Massively parallel processing） 关系型数据库产品在其支持的查询类型方面要复杂得多。一个典型的数据仓库查询包含多个连接，过滤，分组和聚合操作。 MPP查询优化器将这个复杂的查询分解成许多执行阶段和分区，其中许多可以在数据库集群的不同节点上并行执行。涉及扫描大规模数据集的查询特别受益于这种并行执行。</p>
<h2 id="小结">小结</h2>
<p>分区有不同方法。</p>
<p>二级索引因此也有不同方法。</p>
<p>请求分区也有不同的方法。</p>
<h1>事务</h1>
<p>我们的写入操作可能存在非常多的问题，完善的容错机制非常复杂，<strong>事务是简化这些问题的首选机制</strong>。但事务并不是天然存在的，它是被人为创造出来，<strong>简化应用层的编程模型</strong>。</p>
<p>当然，事务并不必然存在于所有存储系统中，Redis 之类的方案就不天然支持事务（pipeline 就不是事务，mset/lua 脚本是）。</p>
<h2 id="深入理解事务">深入理解事务</h2>
<p>最早的事务来自于 IBM 1975 年的 System R。</p>
<p>大部分的情况下：NoSQL 提供 shard 和 replication，RDBMS 提供 relation 和 transaction，这两者是相互对立的。</p>
<p>NoSQL 很多时候为了某些方面的性能-主要是灵活性或者可扩展性，会牺牲事务。</p>
<h3 id="acid-的含义">ACID 的含义</h3>
<p>不同的系统的 ACID 实现其实是不一样的。<strong>这个词汇被创造出来是为了描述数据库的容错机制</strong>。而BASE也很含糊，本质上是“非 ACID”。</p>
<h4 id="原子性-atomicity">原子性（Atomicity）</h4>
<p>多线程编程里的原子性指的是，如果一个线程执行一个原子操作，这意味着另一个线程无法看到该操作的一半结果。系统只能处于操作之前或操作之后的状态，而不是介于两者之间的状态。<strong>这对应的是 ACID 的隔离性</strong>。</p>
<p>ACID原子性的定义特征是：能够在错误时中止事务，丢弃该事务进行的所有写入变更的能力。 或许<strong>可中止性（abortability）</strong> 是更好的术语，但本书将继续使用原子性，因为这是惯用词。这需要用到 undo log。</p>
<h4 id="一致性-consistency">一致性（Consistency）</h4>
<p>一致性在不同场景下有不同的含义：</p>
<ul>
<li>我们讨论了副本一致性，以及异步复制系统中的最终一致性问题。**副本一致性指的是多个副本的数据相同。**这要求我们实现读己之写一致性、单调读一致性、前缀读一致性。</li>
<li>一致性散列（Consistency Hash）)是某些系统用于重新分区的一种分区方法。这里的一致性指的是系统重新达到平衡。</li>
<li>在CAP定理中，一致性一词用于表示可线性化（Linearizability）-<strong>和副本一致性最容易混淆。</strong></li>
<li>在ACID的上下文中，一致性是指数据库在应用程序的特定概念中处于“良好状态”。</li>
</ul>
<p>ACID一致性的概念是，对数据的一组特定陈述必须始终成立。即不变量（invariants）、状态有效（valid）。</p>
<p>原子性，隔离性和持久性是数据库的属性，<strong>而一致性（在ACID意义上）是应用程序的属性</strong>。应用可能依赖数据库的原子性和隔离属性来实现一致性，但这并不仅取决于数据库。因此，字母C不属于ACID，<strong>也就与各种 WAL 无关</strong>。</p>
<h4 id="隔离性-isolation">隔离性（Isolation）</h4>
<p>ACID意义上的隔离性意味着，同时执行的事务是相互隔离的：它们不能相互交叉。传统的数据库教科书将隔离性形式化为可序列化（Serializability），这意味着每个事务可以假装它是唯一在整个数据库上运行的事务。数据库确保当事务已经提交时，结果与它们按顺序运行（一个接一个）是一样的，尽管实际上它们可能是并发运行的。<strong>所以可序列化本来是唯一的隔离级别。</strong></p>
<table>
<thead>
<tr>
<th>大类</th>
<th>代表算法/级别</th>
<th>核心手段</th>
<th>典型数据库</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>锁驱动</strong></td>
<td>2PL、S2PL、SS2PL</td>
<td>加锁持续到事务结束（或提交点）</td>
<td>MySQL InnoDB（RR=SS2PL）</td>
</tr>
<tr>
<td><strong>锁+区间</strong></td>
<td>谓词锁、Next-Key Lock</td>
<td>给“范围”加锁，防幻读</td>
<td>同上</td>
</tr>
<tr>
<td><strong>多版本</strong></td>
<td>快照隔离 SI</td>
<td>每个事务看<strong>启动时快照</strong>；写时<strong>First-committer-wins</strong></td>
<td>PostgreSQL默认、Oracle</td>
</tr>
<tr>
<td><strong>多版本+验证</strong></td>
<td>Serializable SI (SSI)</td>
<td>在 SI 基础上<strong>跟踪读写依赖图</strong>，发现环即回滚</td>
<td>PostgreSQL 9.1+、CockroachDB</td>
</tr>
<tr>
<td><strong>乐观并发</strong></td>
<td>OCC / MVCC-OCC</td>
<td><strong>读写不设锁</strong>，提交时<strong>验证是否冲突</strong>；冲突则重试</td>
<td>Hekaton、TiDB乐观事务</td>
</tr>
<tr>
<td><strong>时间戳排序</strong></td>
<td>TSO / MVTO</td>
<td>给事务<strong>全局时间戳</strong>，按戳定序，写时检查<strong>是否已过期</strong></td>
<td>Spanner、Percolator</td>
</tr>
<tr>
<td><strong>单线程</strong></td>
<td>Serial Execution</td>
<td>把所有事务<strong>放到一个线程</strong>里顺序执行</td>
<td>VoltDB、DuckDB本地模式</td>
</tr>
<tr>
<td><strong>混排</strong></td>
<td>H-Store、Calvin</td>
<td>先<strong>全局定序</strong>，再<strong>分区多线程执行</strong>，保证等价串行</td>
<td>FaunaDB、Calvin</td>
</tr>
</tbody>
</table>
<h4 id="持久性-durability">持久性（Durability）</h4>
<p>持久性是一个承诺，即一旦事务成功完成，即使发生硬件故障或数据库崩溃，写入的任何数据也不会丢失。</p>
<p>如“可靠性”一节所述，完美的持久性是不存在的：</p>
<ol>
<li>一般的 RDBMS 因为日志写缓冲的关系，可能丢失一些事物操作。</li>
<li>硬盘还是会毁灭，除非引入足够多的副本。</li>
</ol>
<h3 id="单对象和多对象事务操作">单对象和多对象事务操作</h3>
<p>隔离性可以避免这个问题：通过确保用户2 要么同时看到新邮件和增长后的计数器，要么都看不到。反正不会看到执行到一半的中间结果。</p>
<p>存储引擎最起码的设计目标是保证对但对象的写入是有原子性和隔离性的。</p>
<p>CAS以及其他单一对象操作被称为“轻量级事务”，甚至出于营销目的被称为“ACID”，但是这个术语是误导性的。事务通常被理解为，将多个对象上的多个操作合并为一个执行单元的机制。</p>
<h4 id="多对象事务的必要性">多对象事务的必要性</h4>
<p>应用仍然在没有事务的情况下实现。然而，没有原子性，错误处理就要复杂得多-没有原子性，无法精确丢弃错误数据；缺乏隔离性，就会导致并发问题-对共享资源进行并发写，不隔离则有逻辑判断错误。</p>
<h2 id="弱隔离级别">弱隔离级别</h2>
<p>并发错误难以检测。</p>
<p>可序列化（serializable）的隔离等级意味着数据库保证事务的效果与连续运行（即一次一个，没有任何并发）是一样的。</p>
<p>只要弱于可序列化的隔离级别，都会有些微妙的错误发生。</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>已解决（不会出现）</th>
<th>仍可能遇到（含视角版）</th>
<th>典型现象举例（含读偏斜）</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Read Uncommitted (RU)</strong></td>
<td>脏写（Dirty Write）</td>
<td>脏读（Dirty Read）、不可重复读（含读偏斜）、幻读、写偏斜</td>
<td>事务 A 未提交时，事务 B 读到 A 刚改但尚未提交的数据。</td>
</tr>
<tr>
<td><strong>Read Committed (RC)</strong></td>
<td>脏写、脏读</td>
<td>不可重复读（含读偏斜）、幻读、写偏斜</td>
<td>事务 A 先读账户 X，再读账户 Y；中间事务 B 提交 X→X’；A 第二次读到 X’ + 旧 Y，出现读偏斜（不同快照）。</td>
</tr>
<tr>
<td><strong>Repeatable Read (RR)</strong></td>
<td>脏写、脏读、不可重复读（含读偏斜）</td>
<td>幻读、写偏斜</td>
<td>事务 A 按条件 <code>WHERE amt&gt;100</code> 统计，事务 B 插入新行并提交 → A 再次统计行数变多（幻读）。</td>
</tr>
<tr>
<td><strong>Serializable (S)</strong></td>
<td>脏写、脏读、不可重复读（含读偏斜）、幻读、写偏斜</td>
<td>无（任意并发调度等价于某种串行顺序）</td>
<td>理论上不再有任何异常；代价是性能最低、锁或串行执行最严格。</td>
</tr>
</tbody>
</table>
<h3 id="读已提交">读已提交</h3>
<p>最基本的事务隔离级别是读已提交（Read Committed），它提供了两个保证：</p>
<ul>
<li>从数据库读时，只能看到已提交的数据（没有脏读（dirty reads））。</li>
<li>写入数据库时，只会覆盖已经写入的数据（没有脏写（dirty writes））。</li>
</ul>
<h4 id="防止脏读">防止脏读</h4>
<p>设想一个事务已经将一些数据写入数据库，但事务还没有提交或中止。另一个事务可以看到未提交的数据吗？如果是的话，那就叫做脏读（dirty reads）。</p>
<p>依照脏读做决策，可能读到未被持久化的数据。<strong>脏（不管是读或者写）等于只写内存而未提交</strong>。</p>
<h4 id="防止脏写">防止脏写</h4>
<p>但是，如果先前的写入是尚未提交事务的一部分，又会发生什么情况，后面的写入会覆盖一个尚未提交的值？这被称作脏写（dirty write）- <strong>第一个写是脏写，覆盖被称为更新丢失。</strong></p>
<h4 id="实现读已提交">实现读已提交</h4>
<p>防止脏读可以用读锁，但会带来性能问题。所以从 RC 开始，引入快照读的思想：</p>
<p>对于写入的每个对象，数据库都会记住旧的已提交值，和由当前持有写入锁的事务设置的新值。 当事务正在进行时，任何其他读取对象的事务都会拿到旧值。 只有当新值提交后，事务才会切换到读取新值。</p>
<h3 id="快照隔离和可重复读">快照隔离和可重复读</h3>
<p>不能正确隔离，产生不可重复读的例子：</p>
<p>爱丽丝在银行有1000美元的储蓄，分为两个账户，每个500美元。现在一笔事务从她的一个账户中转移了100美元到另一个账户。<strong>如果她在事务处理的同时查看其账户余额列表，不幸地在转账事务完成前看到收款账户余额（余额为500美元）</strong>-因为另一个 update 语句还未执行完，隔离性问题在分布式事务更复杂，而在转账完成后看到另一个转出账户（已经转出100美元，余额400美元）。对爱丽丝来说，现在她的账户似乎只有900美元——看起来100美元已经消失了。</p>
<p>这种异常被称为不可重复读（nonrepeatable read）或读倾斜（read skew-错误地读到了中间状态）。不幸的是，术语偏差（skew） 这个词是滥用的：<strong>以前使用它是因为热点的不平衡工作量，而这里偏差意味着时间异常</strong>。</p>
<p>快照隔离（snapshot isolation）是这个问题最常见的解决方案。想法是，每个事务都从数据库的一致快照（consistent snapshot） 中读取——也就是说，事务可以看到事务开始时在数据库中提交的所有数据。即使这些数据随后被另一个事务更改，每个事务也只能看到该特定时间点的旧数据。<strong>所有的快照都是一致性快照，因为它们是事务 ACID 的结果。</strong></p>
<p>快照隔离对长时间运行的只读查询（如备份和分析）非常有用。<strong>所以读越多越适合 MVCC；写越多 MVCC 越可能出问题。</strong></p>
<h4 id="实现快照隔离">实现快照隔离</h4>
<p>从性能的角度来看，快照隔离的一个关键原则是：<strong>读不阻塞写，写不阻塞读</strong>。这允许数据库在处理一致性快照上的长时间查询时，可以正常地同时处理写入操作。且两者间没有任何锁定争用。这也是 MVCC 的原则。</p>
<p>数据库必须可能保留一个对象的几个不同的提交版本，因为各种正在进行的事务可能需要看到数据库在不同的时间点的状态。因为它并排维护着多个版本的对象，所以这种技术被称为多版本并发控制（MVCC, multi-version concurrentcy control）。MVCC 的出现，在允许并发的基础上实现了隔离。</p>
<p>如果一个数据库只需要提供读已提交的隔离级别，而不提供快照隔离，那么保留一个对象的两个版本就足够了：提交的版本和被覆盖但尚未提交的版本。支持快照隔离的存储引擎通常也使用MVCC来实现读已提交隔离级别。一种典型的方法是<strong>读已提交为每个查询使用单独的快照，而快照隔离对整个事务使用相同的快照。</strong></p>
<p>表中的每一行都有一个 created_by 字段，其中包含将该行插入到表中的的事务ID。此外，每行都有一个 deleted_by 字段，最初是空的。如果某个事务删除了一行，那么该行实际上并未从数据库中删除，而是通过将 deleted_by 字段设置为请求删除的事务的ID来标记为删除。在稍后的时间，当确定没有事务可以再访问已删除的数据时，数据库中的垃圾收集过程会将所有带有删除标记的行移除，并释放其空间。</p>
<p>UPDATE 操作在内部翻译为 DELETE 和 INSERT-先更新老行的 deleted_by，然后再用事务来更新新行的 created_by。</p>
<p>UPDATE 到来时，MySQL 先把原行的 deleted_by 标为当前事务 ID，再插入新行 whose created_by 等于同一事务 ID；同一事务后续只认这条最新版本，其他事务则依据自己启动时生成的 ReadView 判断：若新行 created_by 落在 ReadView 的“已提交”区间且 deleted_by 不可见，则对其可见，否则跳过。后台 purge 线程定期扫描，把 deleted_by 小于最早活跃 ReadView 最小事务号的旧版本物理删除，释放空间。</p>
<h4 id="一致性快照的可见性规则">一致性快照的可见性规则</h4>
<p>当一个事务从数据库中读取时，事务ID用于决定它可以看见哪些对象，看不见哪些对象。通过仔细定义可见性规则，数据库可以向应用程序呈现一致的数据库快照。工作如下：</p>
<ol>
<li>在每次事务开始时，数据库列出当时所有其他（尚未提交或中止）的事务清单，即使之后提交了，这些事务的写入也都会被忽略。</li>
<li>被中止事务所执行的任何写入都将被忽略。</li>
<li>由具有较晚事务ID（即，在当前事务开始之后开始的）的事务所做的任何写入都被忽略，而不管这些事务是否已经提交。</li>
<li>所有其他写入，对应用都是可见的-<strong>不可见在本事务创建第一个ReadView-（对MySQL 而言，是第一个 select 语句）那一瞬间仍未完成的操作，其他都可见</strong>。</li>
</ol>
<p>一行被 update 几次就有几个版本，算是用 cow 来实现并发的一个实例。</p>
<h4 id="索引和快照隔离">索引和快照隔离</h4>
<p>索引如何在多版本数据库中工作？一种选择是使索引简单地指向对象的所有版本，并且需要索引查询来过滤掉当前事务不可见的任何对象版本。当垃圾收集删除任何事务不再可见的旧对象版本时，相应的索引条目也可以被删除。</p>
<p>另一种方法是是重构整棵新的 B-tree。</p>
<h4 id="可重复读与命名混淆">可重复读与命名混淆</h4>
<p>现在没有明确的可重复读的定义。但是可重复读解决了 Read Skew，没有解决 Write Skew。</p>
<table>
<thead>
<tr>
<th style="text-align:left">维度</th>
<th style="text-align:left">不可重复读 (Non-Repeatable Read)/读倾斜(Read Skew)</th>
<th style="text-align:left">幻读 (Phantom Read)</th>
<th style="text-align:left">写偏斜 (Write Skew)</th>
<th style="text-align:left">数据偏斜 (Data Skew)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>所属层面</strong></td>
<td style="text-align:left">事务隔离级别—并发异常现象</td>
<td style="text-align:left">事务隔离级别—并发异常现象</td>
<td style="text-align:left">事务隔离级别—并发异常现象</td>
<td style="text-align:left">工程/分布式系统—负载分布问题</td>
</tr>
<tr>
<td style="text-align:left"><strong>核心问题</strong></td>
<td style="text-align:left"><strong>同一行数据</strong>，被其他事务<strong>修改或删除</strong>，导致本事务前后两次读取结果不同。</td>
<td style="text-align:left"><strong>同一范围查询</strong>，被其他事务<strong>插入或删除</strong>，导致本事务前后两次查询到的<strong>行数</strong>不同。</td>
<td style="text-align:left">两个事务读取相同数据，然后各自基于此去修改<strong>不同的数据</strong>，最终共同破坏了业务上的全局约束。本质上写倾斜是写事务之间的互相干扰。</td>
<td style="text-align:left">分区键或数据访问模式不均，导致负载（数据量/QPS）集中在少数节点。</td>
</tr>
<tr>
<td style="text-align:left"><strong>一个比喻</strong></td>
<td style="text-align:left">你在数钱包里的钱，数到一半，有人从你刚数过的钱里抽走一张，你再数一遍发现钱少了。</td>
<td style="text-align:left">你在统计房间里有多少人，数完一遍后，又有人走进或走出了房间，你再数一遍发现人数变了。</td>
<td style="text-align:left">两位护士都看到“至少还有一人值班”，于是各自都放心下班了，结果导致无人值班。</td>
<td style="text-align:left">一个超市开了 10 个收银台，但 90% 的顾客都挤在同一个收银台结账，其他 9 个很空闲。</td>
</tr>
<tr>
<td style="text-align:left"><strong>MySQL 表现与隔离级别</strong></td>
<td style="text-align:left">在 <code>READ COMMITTED</code> (RC) 级别会出现。<br>MySQL 的 <code>REPEATABLE READ</code> (RR) 通过 <strong>MVCC 快照</strong>已解决。</td>
<td style="text-align:left">标准 RR 级别会出现。<br>MySQL 的 RR 级别通过 <strong>MVCC 快照</strong>解决了“快照读”的幻读；但“当前读” (<code>FOR UPDATE</code>) 仍需 <strong>Next-Key Lock</strong> 来防止。</td>
<td style="text-align:left">即使在 MySQL 的 RR 级别下也可能出现，因为它只锁定了读取的范围，无法预知其他事务基于此信息的逻辑冲突。</td>
<td style="text-align:left">与事务隔离级别无关。</td>
</tr>
<tr>
<td style="text-align:left"><strong>解决手段</strong></td>
<td style="text-align:left">提升隔离级别到 <code>REPEATABLE READ</code> 或更高。</td>
<td style="text-align:left">1. <strong>Next-Key Lock</strong> (Gap Lock + Record Lock) 解决当前读的幻读。<br>2. 提升到 <code>SERIALIZABLE</code> 级别。</td>
<td style="text-align:left">1. 提升到 <code>SERIALIZABLE</code>。<br>2. 使用 <code>SELECT ... FOR UPDATE</code> 显式锁定依赖的数据。<br>3. 使用“实体化冲突”等应用层手段。</td>
<td style="text-align:left">重新设计分区键、热点数据加缓存、读写分离、动态分片等。</td>
</tr>
<tr>
<td style="text-align:left"><strong>是否破坏业务语义</strong></td>
<td style="text-align:left"><strong>是</strong>，破坏了事务执行期间的数据一致性。</td>
<td style="text-align:left"><strong>是</strong>，破坏了事务执行期间的数据一致性。</td>
<td style="text-align:left"><strong>是</strong>，破坏了业务层面的逻辑约束，后果可能更严重。</td>
<td style="text-align:left"><strong>否</strong>，不破坏业务语义，仅是性能、可用性和扩展性问题。</td>
</tr>
<tr>
<td style="text-align:left"><strong>官方术语</strong></td>
<td style="text-align:left">是 (ANSI SQL 标准)</td>
<td style="text-align:left">是 (ANSI SQL 标准)</td>
<td style="text-align:left">是 (学术界/DDIA 常用)</td>
<td style="text-align:left">否 (工程/运维领域常用语)</td>
</tr>
</tbody>
</table>
<h3 id="防止更新丢失">防止更新丢失</h3>
<p>如果应用从数据库中读取一些值，修改它并写回修改的值（读取-修改-写入 read modify write 过程），则可能会发生丢失更新（lost update）的问题。</p>
<h4 id="原子写">原子写</h4>
<p>如果你的代码可以用这些操作来表达，那这通常是最好的解决方案。</p>
<h4 id="显式锁定">显式锁定</h4>
<p>如果数据库的内置原子操作没有提供必要的功能，防止丢失更新的另一个选择是让应用程序显式地锁定将要更新的对象。</p>
<p>要加锁就要在全部的地方加锁。</p>
<h3 id="写倾斜与幻读">写倾斜与幻读</h3>
<h4 id="定义写倾斜">定义写倾斜</h4>
<p>可以将写倾斜视为丢失更新问题的一般化。如果两个事务读取相同的<strong>一批对象</strong>，然后更新其中一些对象（<strong>不同的事务可能更新不同的对象</strong>），则可能发生写入写倾斜。在多个事务更新同一个对象的特殊情况下，就会发生脏写或丢失更新（取决于时机）。</p>
<blockquote>
<p>两个并发事务各自读取同一范围，各自根据读到的数据做写入，单独看都满足约束，但合并后违反全局业务规则。 Write Skew<br>
是幻读的一种特殊形式，在 RR 下仍然存在，因为 InnoDB 的间隙锁只保护已存在记录，不保护未来插入或未命中条件的行。</p>
</blockquote>
<p>所以已知的并发写问题有：</p>
<ol>
<li>脏写：写入提交前就被覆盖。</li>
<li>更新丢失：覆盖提交前写入。</li>
<li>写倾斜：并发读批量而交叉写，导致读失效。</li>
</ol>
<p>写倾斜绝不可能被 RR 解决（而读倾斜已经被RR解决了），解法有：</p>
<ol>
<li>真正使用可序列化隔离级别。</li>
<li>对事务依赖的所有行<strong>和间隙</strong>进行显示加锁（下面讲的实体化冲突）。</li>
</ol>
<h4 id="更多写倾斜的例子">更多写倾斜的例子</h4>
<p>会议系统的可预订时间是多行记录，如果没有锁定全部时间，则可能在插入时产生写倾斜。</p>
<h4 id="为何产生写倾斜">为何产生写倾斜</h4>
<p>读后写依赖的读未被锁定，所以写可能出现逻辑错误。</p>
<p>不是所有时候都有可以锁定的行-后面会讲怎么解决。</p>
<p>一个事务中的写入改变另一个事务的搜索查询的结果，被称为幻读。幻读不同于写倾斜，但幻读可能导致写倾斜。RR 可以解决只读时的幻读（这里这本书的描述指的是我们常见的不可不重复读）问题。</p>
<h4 id="实体化冲突">实体化冲突</h4>
<p>我们可以引入一些不存储写入信息，但可以供锁定的行，即“锁表”。如会议室的例子，我们可以制造锁表，每 15 分钟是锁表里的一行。<strong>这种方法被称为实体化冲突（materializing conflicts），因为它将幻读变为数据库中一组具体行上的锁冲突</strong>。</p>
<p>这就是上面说的解法 2，大多数时候，解法 1 比 2 好，因为解法 2 影响了应用的模型设计。</p>
<p>基本思路：槽之间有插入的唯一索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- =============================================================================</span><br><span class="hljs-comment">-- Filename: materializing_conflicts_booking_system.sql</span><br><span class="hljs-comment">-- Description:</span><br><span class="hljs-comment">--   An example of a booking system using the &quot;Materializing Conflicts&quot; pattern</span><br><span class="hljs-comment">--   as described in &quot;Designing Data-Intensive Applications&quot; (DDIA).</span><br><span class="hljs-comment">--</span><br><span class="hljs-comment">--   Instead of locking a time range, we &quot;materialize&quot; time slots into</span><br><span class="hljs-comment">--   concrete rows and use a UNIQUE constraint to automatically prevent</span><br><span class="hljs-comment">--   double-booking.</span><br><span class="hljs-comment">--</span><br><span class="hljs-comment">-- Database: PostgreSQL (with notes for MySQL)</span><br><span class="hljs-comment">-- =============================================================================</span><br><br><br><span class="hljs-comment">-- =============================================================================</span><br><span class="hljs-comment">-- SECTION 1: SCHEMA DEFINITION (DDL)</span><br><span class="hljs-comment">-- =============================================================================</span><br><br><span class="hljs-comment">-- To make the script re-runnable, we drop existing tables first.</span><br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> booking_slots;<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> bookings;<br><br><span class="hljs-comment">--</span><br><span class="hljs-comment">-- Table `bookings`: Stores the main information for each booking.</span><br><span class="hljs-comment">--</span><br><span class="hljs-keyword">CREATE TABLE</span> bookings (<br>    <span class="hljs-comment">-- For MySQL, use: `booking_id BIGINT PRIMARY KEY AUTO_INCREMENT`</span><br>    booking_id SERIAL <span class="hljs-keyword">PRIMARY KEY</span>,<br>    user_id <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT NULL</span>,<br>    room_id <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT NULL</span>,<br>    full_start_time <span class="hljs-type">TIMESTAMP</span> <span class="hljs-keyword">NOT NULL</span>,<br>    full_end_time <span class="hljs-type">TIMESTAMP</span> <span class="hljs-keyword">NOT NULL</span>,<br>    status <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;PENDING&#x27;</span>, <span class="hljs-comment">-- PENDING, CONFIRMED, CANCELLED</span><br>    created_at <span class="hljs-type">TIMESTAMP</span> <span class="hljs-keyword">WITH</span> <span class="hljs-type">TIME</span> ZONE <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span><br>);<br><br>COMMENT <span class="hljs-keyword">ON</span> <span class="hljs-keyword">TABLE</span> bookings <span class="hljs-keyword">IS</span> <span class="hljs-string">&#x27;Stores high-level information about each booking.&#x27;</span>;<br><br><span class="hljs-comment">--</span><br><span class="hljs-comment">-- Table `booking_slots`: The core of the &quot;Materializing Conflicts&quot; pattern.</span><br><span class="hljs-comment">-- Each row represents a specific room being occupied for a specific time slot.</span><br><span class="hljs-comment">-- We use a 30-minute slot duration in this example.</span><br><span class="hljs-comment">--</span><br><span class="hljs-keyword">CREATE TABLE</span> booking_slots (<br>    room_id <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT NULL</span>,<br>    <span class="hljs-comment">-- The start time of the discrete time slot (e.g., 09:00:00, 09:30:00)</span><br>    slot_time <span class="hljs-type">TIMESTAMP</span> <span class="hljs-keyword">NOT NULL</span>,<br>    <span class="hljs-comment">-- Foreign key to link back to the main booking record</span><br>    booking_id <span class="hljs-type">BIGINT</span> <span class="hljs-keyword">NOT NULL</span> <span class="hljs-keyword">REFERENCES</span> bookings(booking_id) <span class="hljs-keyword">ON</span> <span class="hljs-keyword">DELETE</span> CASCADE,<br><br>    <span class="hljs-comment">-- THE MAGIC: This primary key &quot;materializes&quot; the conflict.</span><br>    <span class="hljs-comment">-- It makes it impossible for two bookings to claim the same slot for the same room.</span><br>    <span class="hljs-comment">-- Any attempt to insert a duplicate (room_id, slot_time) pair will fail.</span><br>    <span class="hljs-keyword">PRIMARY KEY</span> (room_id, slot_time)<br>);<br><br>COMMENT <span class="hljs-keyword">ON</span> <span class="hljs-keyword">TABLE</span> booking_slots <span class="hljs-keyword">IS</span> <span class="hljs-string">&#x27;Materializes time slots to prevent conflicts via UNIQUE constraint.&#x27;</span>;<br>COMMENT <span class="hljs-keyword">ON</span> <span class="hljs-keyword">COLUMN</span> booking_slots.slot_time <span class="hljs-keyword">IS</span> <span class="hljs-string">&#x27;Start time of the 30-minute slot, e.g., 2024-05-21 09:00:00&#x27;</span>;<br><br><span class="hljs-comment">-- Add an index for looking up slots by booking_id, useful for cancellations.</span><br><span class="hljs-keyword">CREATE</span> INDEX idx_booking_slots_booking_id <span class="hljs-keyword">ON</span> booking_slots(booking_id);<br><br><br><span class="hljs-comment">-- =============================================================================</span><br><span class="hljs-comment">-- SECTION 2: TRANSACTION EXAMPLES (DML)</span><br><span class="hljs-comment">-- =============================================================================</span><br><br><span class="hljs-comment">-- -----------------------------------------------------------------------------</span><br><span class="hljs-comment">-- EXAMPLE 1: A SUCCESSFUL BOOKING</span><br><span class="hljs-comment">--</span><br><span class="hljs-comment">-- Scenario: User A wants to book Room 123 from 09:15 to 10:15.</span><br><span class="hljs-comment">--</span><br><span class="hljs-comment">-- Application Logic:</span><br><span class="hljs-comment">-- 1. The application calculates that this request covers three 30-minute slots:</span><br><span class="hljs-comment">--    - 09:00:00</span><br><span class="hljs-comment">--    - 09:30:00</span><br><span class="hljs-comment">--    - 10:00:00</span><br><span class="hljs-comment">-- 2. It then executes the following transaction.</span><br><span class="hljs-comment">-- -----------------------------------------------------------------------------</span><br><br>DO $$ <span class="hljs-comment">-- This is a PostgreSQL block to declare a variable.</span><br><span class="hljs-keyword">DECLARE</span><br>    new_booking_id <span class="hljs-type">BIGINT</span>;<br><span class="hljs-keyword">BEGIN</span><br>    RAISE NOTICE <span class="hljs-string">&#x27;--- Starting Successful Booking for User A (09:15 - 10:15) ---&#x27;</span>;<br><br>    <span class="hljs-comment">-- The entire process is wrapped in a single transaction for atomicity.</span><br>    <span class="hljs-comment">-- START TRANSACTION; -- (Implicit in DO block, but shown for clarity)</span><br><br>    <span class="hljs-comment">-- Step 1: Create a main booking record in a &#x27;PENDING&#x27; state.</span><br>    <span class="hljs-comment">-- The `RETURNING` clause is a PostgreSQL feature to get the new ID.</span><br>    <span class="hljs-comment">-- For MySQL, you would run the INSERT, then `SELECT LAST_INSERT_ID();`</span><br>    <span class="hljs-keyword">INSERT INTO</span> bookings (user_id, room_id, full_start_time, full_end_time, status)<br>    <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">101</span>, <span class="hljs-number">123</span>, <span class="hljs-string">&#x27;2024-05-21 09:15:00&#x27;</span>, <span class="hljs-string">&#x27;2024-05-21 10:15:00&#x27;</span>, <span class="hljs-string">&#x27;PENDING&#x27;</span>)<br>    RETURNING booking_id <span class="hljs-keyword">INTO</span> new_booking_id;<br><br>    RAISE NOTICE <span class="hljs-string">&#x27;Created pending booking with ID: %&#x27;</span>, new_booking_id;<br><br>    <span class="hljs-comment">-- Step 2: Attempt to &quot;claim&quot; all required time slots by inserting them.</span><br>    <span class="hljs-comment">-- If any of these slots are already taken, the INSERT will fail,</span><br>    <span class="hljs-comment">-- violating the primary key constraint, and the entire transaction will be rolled back.</span><br>    RAISE NOTICE <span class="hljs-string">&#x27;Attempting to claim slots...&#x27;</span>;<br>    <span class="hljs-keyword">INSERT INTO</span> booking_slots (room_id, slot_time, booking_id) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">123</span>, <span class="hljs-string">&#x27;2024-05-21 09:00:00&#x27;</span>, new_booking_id);<br>    <span class="hljs-keyword">INSERT INTO</span> booking_slots (room_id, slot_time, booking_id) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">123</span>, <span class="hljs-string">&#x27;2024-05-21 09:30:00&#x27;</span>, new_booking_id);<br>    <span class="hljs-keyword">INSERT INTO</span> booking_slots (room_id, slot_time, booking_id) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">123</span>, <span class="hljs-string">&#x27;2024-05-21 10:00:00&#x27;</span>, new_booking_id);<br>    RAISE NOTICE <span class="hljs-string">&#x27;Successfully claimed all 3 slots.&#x27;</span>;<br><br>    <span class="hljs-comment">-- Step 3: If all slots were claimed successfully, update the main booking to &#x27;CONFIRMED&#x27;.</span><br>    <span class="hljs-keyword">UPDATE</span> bookings<br>    <span class="hljs-keyword">SET</span> status <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;CONFIRMED&#x27;</span><br>    <span class="hljs-keyword">WHERE</span> booking_id <span class="hljs-operator">=</span> new_booking_id;<br>    RAISE NOTICE <span class="hljs-string">&#x27;Booking ID % is now CONFIRMED.&#x27;</span>;<br><br>    <span class="hljs-comment">-- COMMIT; -- (Implicit at the end of a successful DO block)</span><br><span class="hljs-keyword">END</span> $$;<br><br><br><span class="hljs-comment">-- -----------------------------------------------------------------------------</span><br><span class="hljs-comment">-- EXAMPLE 2: A CONFLICTING BOOKING ATTEMPT</span><br><span class="hljs-comment">--</span><br><span class="hljs-comment">-- Scenario: User B tries to book the same Room 123 from 10:00 to 11:00.</span><br><span class="hljs-comment">--</span><br><span class="hljs-comment">-- Application Logic:</span><br><span class="hljs-comment">-- 1. The application calculates this request covers two slots:</span><br><span class="hljs-comment">--    - 10:00:00</span><br><span class="hljs-comment">--    - 10:30:00</span><br><span class="hljs-comment">-- 2. The slot &#x27;10:00:00&#x27; is already taken by User A&#x27;s booking.</span><br><span class="hljs-comment">-- 3. The transaction will fail.</span><br><span class="hljs-comment">-- -----------------------------------------------------------------------------</span><br><br>DO $$<br><span class="hljs-keyword">DECLARE</span><br>    new_booking_id <span class="hljs-type">BIGINT</span>;<br><span class="hljs-keyword">BEGIN</span><br>    RAISE NOTICE <span class="hljs-string">&#x27;--- Starting Conflicting Booking for User B (10:00 - 11:00) ---&#x27;</span>;<br><br>    <span class="hljs-comment">-- START TRANSACTION;</span><br><br>    <span class="hljs-keyword">INSERT INTO</span> bookings (user_id, room_id, full_start_time, full_end_time, status)<br>    <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">202</span>, <span class="hljs-number">123</span>, <span class="hljs-string">&#x27;2024-05-21 10:00:00&#x27;</span>, <span class="hljs-string">&#x27;2024-05-21 11:00:00&#x27;</span>, <span class="hljs-string">&#x27;PENDING&#x27;</span>)<br>    RETURNING booking_id <span class="hljs-keyword">INTO</span> new_booking_id;<br><br>    RAISE NOTICE <span class="hljs-string">&#x27;Created pending booking with ID: %&#x27;</span>, new_booking_id;<br><br>    <span class="hljs-comment">-- Attempt to claim the slots. The second INSERT will fail.</span><br>    RAISE NOTICE <span class="hljs-string">&#x27;Attempting to claim slots...&#x27;</span>;<br>    <span class="hljs-keyword">INSERT INTO</span> booking_slots (room_id, slot_time, booking_id) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">123</span>, <span class="hljs-string">&#x27;2024-05-21 10:30:00&#x27;</span>, new_booking_id);<br>    RAISE NOTICE <span class="hljs-string">&#x27;Successfully claimed slot 10:30.&#x27;</span>;<br><br>    <span class="hljs-comment">-- THIS NEXT LINE WILL CAUSE THE ERROR</span><br>    RAISE NOTICE <span class="hljs-string">&#x27;Attempting to claim conflicting slot 10:00...&#x27;</span>;<br>    <span class="hljs-keyword">INSERT INTO</span> booking_slots (room_id, slot_time, booking_id) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">123</span>, <span class="hljs-string">&#x27;2024-05-21 10:00:00&#x27;</span>, new_booking_id);<br><br>    <span class="hljs-comment">-- The code below will NOT be reached.</span><br>    <span class="hljs-keyword">UPDATE</span> bookings <span class="hljs-keyword">SET</span> status <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;CONFIRMED&#x27;</span> <span class="hljs-keyword">WHERE</span> booking_id <span class="hljs-operator">=</span> new_booking_id;<br><br>    <span class="hljs-comment">-- COMMIT;</span><br><br>EXCEPTION<br>    <span class="hljs-comment">-- The application code would catch this specific database error.</span><br>    <span class="hljs-keyword">WHEN</span> unique_violation <span class="hljs-keyword">THEN</span><br>        RAISE NOTICE <span class="hljs-string">&#x27;ERROR: Booking failed due to a time slot conflict (unique_violation).&#x27;</span>;<br>        RAISE NOTICE <span class="hljs-string">&#x27;The transaction will be automatically rolled back.&#x27;</span>;<br>        <span class="hljs-comment">-- The application would then inform User B that the time is unavailable.</span><br>        <span class="hljs-comment">-- ROLLBACK; (Implicit on error in a transaction)</span><br><span class="hljs-keyword">END</span> $$;<br><br><br><span class="hljs-comment">-- =============================================================================</span><br><span class="hljs-comment">-- SECTION 3: VERIFICATION</span><br><span class="hljs-comment">-- =============================================================================</span><br><br><span class="hljs-comment">-- Let&#x27;s check the final state of the database.</span><br><br>RAISE NOTICE <span class="hljs-string">&#x27;--- Final State Verification ---&#x27;</span>;<br><br><span class="hljs-comment">-- We should see only one CONFIRMED booking from User A.</span><br><span class="hljs-comment">-- The pending booking for User B should not exist because the transaction was rolled back.</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> bookings;<br><br><span class="hljs-comment">-- We should see the three slots claimed by User A&#x27;s booking.</span><br><span class="hljs-keyword">SELECT</span><br>    room_id,<br>    to_char(slot_time, <span class="hljs-string">&#x27;YYYY-MM-DD HH24:MI:SS&#x27;</span>) <span class="hljs-keyword">as</span> slot_time,<br>    booking_id<br><span class="hljs-keyword">FROM</span> booking_slots<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> room_id, slot_time;<br></code></pre></td></tr></table></figure>
<p>至此我们有了2种思路：</p>
<ol>
<li>谓词锁-索引区间锁-临键锁：<strong>自动通过 where 条件锁定范围，存储引擎支持空行锁定</strong>。</li>
<li>把范围细化成原子slot：<strong>每个事务必须全插入这些原子 slot，否则事务就全体回滚</strong>。</li>
</ol>
<h3 id="可串行化">可串行化</h3>
<p>弱隔离级别的问题，只有使用可串行化来解决。</p>
<h4 id="实际串行执行">实际串行执行</h4>
<p>数据库设计人员只是在2007年左右才确信，单线程循环执行事务是可行的。多线程并发在过去的30年中被认为是获得良好性能的关键所在。</p>
<h4 id="在存储过程中封装事务">在存储过程中封装事务</h4>
<p>如果数据库事务需要等待来自用户的输入，则数据库需要支持潜在的大量并发事务，其中大部分是空闲的。大多数数据库不能高效完成这项工作，因此几乎所有的OLTP应用程序都避免在事务中等待交互式的用户输入，以此来保持事务的简短。-但同一个事务里面多次写入是可以的。</p>
<p>出于这个原因，具有单线程串行事务处理的系统不允许交互式的多语句事务。取而代之，应用程序必须提前将整个事务代码作为存储过程提交给数据库。</p>
<p>但存储过程太烂了，语法不标准和丑陋、难以调试。</p>
<h4 id="分区">分区</h4>
<p>事务在单核上执行，并发度不高。</p>
<p>在多核上执行需要配合多数据分区-类似区块链的分片方案。跨分区的存储过程需要跨分区的锁定。</p>
<h4 id="两阶段加锁">两阶段加锁</h4>
<p>大约30年来，<strong>在数据库中只有一种广泛使用的串行化算法</strong>：两阶段锁定（2PL，two-phase locking），- 实际上其他隔离级别出现 update 或者Select for share/update时，都会触发两阶段加锁。</p>
<p>2PL 和 2PC 是不同的东西。</p>
<h5 id="实现两阶段锁">实现两阶段锁</h5>
<p>读要求锁保护自己，写要求锁保护自己，读写要互斥，要注意锁要升级。</p>
<p>“两阶段”这个名字的来源：第一阶段（当事务正在执行时）获取锁，第二阶段（在事务结束时）释放所有的锁。</p>
<p>MVCC 要求读互不干扰，而 2PL 要求读写互斥、写写互斥。</p>
<h5 id="两阶段锁的性能不好">两阶段锁的性能不好</h5>
<p>即使你保证所有的事务都很短，如果有多个事务想要访问同一个对象，那么可能会形成一个队列。</p>
<h5 id="谓词锁-predicate-lock">谓词锁（predicate lock）</h5>
<p>它类似于前面描述的共享/排它锁，但不属于特定的对象（例如，表中的一行），它属于所有符合某些搜索条件的对象-<strong>锁住查询条件的锁</strong>，类似MySQL的 Next-Key Lock (临键锁) = Record Lock (行锁) + Gap Lock (间隙锁)。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-comment">-- 我们要想办法把这段查询结果实体化成锁，比如“保单挂起”。</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> bookings<br><span class="hljs-keyword">WHERE</span> room_id <span class="hljs-operator">=</span> <span class="hljs-number">123</span> <br>    <span class="hljs-keyword">AND</span> end_time <span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;2018-01-01 12:00&#x27;</span><br>    <span class="hljs-keyword">AND</span> start_time <span class="hljs-operator">&lt;</span> <span class="hljs-string">&#x27;2018-01-01 13:00&#x27;</span>;<br>    <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>; <span class="hljs-comment">-- 这一行原书没有</span><br></code></pre></td></tr></table></figure>
<p>谓词锁限制访问，如下所示：</p>
<ul>
<li>如果事务A想要读取匹配某些条件的对象，就像在这个 SELECT 查询中那样，它必须获取查询条件上的共享谓词锁（shared-mode predicate lock）。如果另一个事务B持有任何满足这一查询条件对象的排它锁，那么A必须等到B释放它的锁之后才允许进行查询。</li>
<li>如果事务A想要插入，更新或删除任何对象，<strong>则必须首先检查旧值或新值是否与任何现有的谓词锁匹配</strong>。如果事务B持有匹配的谓词锁，那么A必须等到B已经提交或中止后才能继续。</li>
</ul>
<p>谓词锁的出现让我们能够锁定还未出现的数据-防止幻读。</p>
<h5 id="索引范围锁">索引范围锁</h5>
<p>不幸的是谓词锁性能不佳：如果活跃事务持有很多锁，检查匹配的锁会非常耗时。因此，大多数使用2PL的数据库实际上实现了索引范围锁（也称为间隙锁（next-key locking）），这是一个简化的近似版谓词锁。</p>
<p>下面的方案是假设没有room_id+时间的唯一联合索引，<strong>只有一列索引，只能通过粗化索引（coarsed index）来提供锁定</strong>：</p>
<p>通过使谓词匹配到一个更大的集合来简化谓词锁是安全的。例如，如果你有在中午和下午1点之间预订123号房间的谓词锁，<strong>则锁定123号房间的所有时间段</strong>，或者**锁定12:00<code>~</code>13:00时间段的所有房间（不只是123号房间）**是一个安全的近似，因为任何满足原始谓词的写入也一定会满足这种更松散的近似。</p>
<p>在房间预订数据库中，您可能会在room_id列上有一个索引，并且/或者在start_time 和 end_time上有索引（否则前面的查询在大型数据库上的速度会非常慢）：</p>
<ul>
<li>假设您的索引位于room_id上，并且数据库使用此索引查找123号房间的现有预订。现在数据库可以简单地将共享锁附加到这个索引项上，指示事务已搜索123号房间用于预订。</li>
<li>或者，如果数据库使用基于时间的索引来查找现有预订，那么它可以将共享锁附加到该索引中的一系列值，指示事务已经将12:00<code>~</code>13:00时间段标记为用于预定。</li>
</ul>
<h6 id="加锁示例">加锁示例</h6>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 事务A</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> bookings <br><span class="hljs-keyword">WHERE</span> room_id <span class="hljs-operator">=</span> <span class="hljs-number">123</span> <br>  <span class="hljs-keyword">AND</span> start_time <span class="hljs-operator">&lt;</span> <span class="hljs-string">&#x27;10:00&#x27;</span> <br>  <span class="hljs-keyword">AND</span> end_time <span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;09:00&#x27;</span> <br><span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;<br></code></pre></td></tr></table></figure>
<p>因为这是 FOR UPDATE 查询，数据库必须保证在事务A结束前，查询结果（即“空集”）不会改变。为了做到这一点，它必须阻止任何可能改变这个结果的 INSERT 操作。<br>
因此，InnoDB 在它扫描过的“间隙”上放置了一个间隙锁。这个锁覆盖了所有可能插入一条与 (9:00, 10:00) 冲突记录的潜在位置。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp">索引 (room_id=<span class="hljs-number">123</span>, start_time):<br>&lt;----------------------------------------------------------------------&gt;<br>          ^         ^         ^         ^         ^<br>        <span class="hljs-number">8</span>:<span class="hljs-number">00</span>      <span class="hljs-number">9</span>:<span class="hljs-number">00</span>      <span class="hljs-number">10</span>:<span class="hljs-number">00</span>     <span class="hljs-number">11</span>:<span class="hljs-number">00</span>     <span class="hljs-number">12</span>:<span class="hljs-number">00</span><br>                  |=========🔒 Gap Lock <span class="hljs-keyword">by</span> Txn A 🔒=========|<br></code></pre></td></tr></table></figure>
<p>为什么是这样设计条件？<code>start_time &lt; '10:00' AND end_time &gt; '09:00'</code>。</p>
<p>因为在区间左边的不重叠条件就是<code>end_time &lt; '09:00'</code>，而右边的不重叠条件是<code>start_time &gt; '10:00'</code>。</p>
<p><strong>这里的索引区间锁的用意是不要持有多把锁，而是只索引一个值（如 room id）。</strong></p>
<p>如果没有可以挂载间隙锁的索引，数据库可以退化到使用整个表上的共享锁。这对性能不利，因为它会阻止所有其他事务写入表格，但这是一个安全的回退位置。</p>
<h2 id="序列化快照隔离-ssi">序列化快照隔离（SSI）</h2>
<p>一方面，我们实现了性能不好（2PL）或者扩展性不好（串行执行）的可序列化隔离级别。另一方面，我们有性能良好的弱隔离级别，但容易出现各种竞争条件（丢失更新，写入偏差，幻读等）。序列化的隔离级别和高性能是从根本上相互矛盾的吗？</p>
<p>也许不是：一个称为可序列化快照隔离（SSI, serializable snapshot isolation） 的算法是非常有前途的。它提供了完整的可序列化隔离级别，但与快照隔离相比只有只有很小的性能损失。 SSI是相当新的：它在2008年首次被描述，并且是 Michael Cahill 的博士论文的主题。</p>
<p>纯悲观锁性能不佳。<strong>纯乐观锁在系统满负载的时候一样性能不佳</strong>。</p>
<p>序列化快照隔离是一种乐观（optimistic） 的并发控制技术。在这种情况下，乐观意味着，如果存在潜在的危险也不阻止事务，而是继续执行事务，希望一切都会好起来。当一个事务想要提交时，数据库检查是否有什么不好的事情发生（即隔离是否被违反）；如果是的话，事务将被中止，并且必须重试。只有可序列化的事务才被允许提交。</p>
<p>它有两种实现方法：</p>
<ol>
<li>如果读提交在后，检测对旧MVCC对象版本的读取（读之前存在未提交的写入），如果发生冲突，中止事务。</li>
<li>如果写提交在后，检测影响先前读取的写入（读之后发生写入），如果发生冲突，写事务退出。</li>
</ol>
<pre><code class="hljs mermaid">sequenceDiagram
    participant ClientA
    participant ClientB
    participant Database

    title SSI Workflow

    ClientA-&gt;&gt;Database: BEGIN T1
    ClientA-&gt;&gt;Database: SELECT on_call count
    activate Database
    Database--&gt;&gt;ClientA: 2
    Note right of Database: T1 reads on_call predicate
    deactivate Database

    ClientB-&gt;&gt;Database: BEGIN T2
    ClientB-&gt;&gt;Database: SELECT on_call count
    activate Database
    Database--&gt;&gt;ClientB: 2
    Note right of Database: T2 reads on_call predicate
    deactivate Database

    ClientA-&gt;&gt;Database: UPDATE Alice to not on_call
    activate Database
    Note right of Database: T1&#x27;s write affects T2&#x27;s read. Create dependency: T1 -&gt; T2
    Database--&gt;&gt;ClientA: OK
    deactivate Database

    ClientA-&gt;&gt;Database: COMMIT T1
    activate Database
    Note right of Database: No cycle found. T1 commits successfully.
    Database--&gt;&gt;ClientA: OK
    deactivate Database

    ClientB-&gt;&gt;Database: UPDATE Bob to not on_call
    activate Database
    Note right of Database: T2&#x27;s write affects T1&#x27;s read. Create dependency: T2 -&gt; T1
    Database--&gt;&gt;ClientB: OK
    deactivate Database

    ClientB-&gt;&gt;Database: COMMIT T2
    activate Database
    Note right of Database: Cycle detected (T1-&gt;T2-&gt;T1). Abort T2.
    Database--&gt;&gt;ClientB: ABORT
    deactivate Database</code></pre>
<pre><code class="hljs mermaid">sequenceDiagram
    participant Reporting as T1_Reporting
    participant Clerk as T2_Clerk
    participant PricingBot as T3_PricingBot
    participant Database

    title SSI - Complex Cycle with 3 Transactions (Inventory Example)

    %% 1. T1 (报表) 开始，读取一个数据范围 (谓词)
    T1_Reporting-&gt;&gt;Database: BEGIN T1
    T1_Reporting-&gt;&gt;Database: SELECT SUM(price * stock) FROM items WHERE category=&#x27;Electronics&#x27;
    activate Database
    Database--&gt;&gt;T1_Reporting: 15000
    Note right of Database: T1 reads the &#x27;Electronics&#x27; category predicate.
    deactivate Database

    %% 2. T2 (店员) 开始，并进行一次写入，该写入会影响 T1 的读取范围
    T2_Clerk-&gt;&gt;Database: BEGIN T2
    T2_Clerk-&gt;&gt;Database: UPDATE items SET category=&#x27;Electronics&#x27; WHERE name=&#x27;Smart Speaker&#x27;
    activate Database
    Note right of Database: T2&#x27;s write affects T1&#x27;s read predicate. Dependency created: T1 -&gt; T2
    Database--&gt;&gt;T2_Clerk: OK
    deactivate Database

    %% 3. T3 (机器人) 开始，并写入一个 T2 刚刚修改过的数据行
    T3_PricingBot-&gt;&gt;Database: BEGIN T3
    T3_PricingBot-&gt;&gt;Database: UPDATE items SET price=price*1.1 WHERE name=&#x27;Smart Speaker&#x27;
    activate Database
    Note right of Database: T3 writes to a row T2 also wrote to (ww-conflict). Dependency created: T2 -&gt; T3
    Database--&gt;&gt;T3_PricingBot: OK
    deactivate Database

    %% 4. T1 (报表) 准备写入其计算结果
    T1_Reporting-&gt;&gt;Database: INSERT INTO daily_reports (category, total_value) VALUES (&#x27;Electronics&#x27;, 15000)
    activate Database
    Note right of Database: T1&#x27;s write is based on its initial read.
    Database--&gt;&gt;T1_Reporting: OK
    deactivate Database

    %% 5. 关键时刻：T3 尝试提交，形成了致命的依赖环
    T3_PricingBot-&gt;&gt;Database: COMMIT T3
    activate Database
    Note right of Database: T3&#x27;s price update also affects T1&#x27;s initial SUM calculation. This creates the final link: T3 -&gt; T1.
    Note right of Database: The system now sees a full cycle: T1 -&gt; T2 -&gt; T3 -&gt; T1.
    Note right of Database: To break the cycle and ensure serializability, T3 must be aborted.
    Database--&gt;&gt;T3_PricingBot: ABORT (Serialization Failure)
    deactivate Database

    %% 6. T1 和 T2 现在可以安全提交 (假设它们也尝试提交)
    T1_Reporting-&gt;&gt;Database: COMMIT T1
    activate Database
    Database--&gt;&gt;T1_Reporting: COMMIT OK
    deactivate Database

    T2_Clerk-&gt;&gt;Database: COMMIT T2
    activate Database
    Database--&gt;&gt;T2_Clerk: COMMIT OK
    deactivate Database</code></pre>
<h2 id="小结">小结</h2>
<p>事务是一个过程抽象，使应用程序可以忽略复杂并发问题，忽略故障处理，简化应用层处理逻辑为中止或重试。</p>
<p>事务是简化复杂访问模式的好方法。</p>
<h1>分布式系统的挑战</h1>
<p>要构建可靠的系统，要依赖于对故障的理解。</p>
<p>本章对分布式系统中可能出现的问题进行彻底的悲观和沮丧的总结-问题是不可克服的。</p>
<p>目前已知的错误，现实中一定会发生：</p>
<ol>
<li>节点失效。</li>
<li>复制滞后。</li>
<li>事务隔离出错。</li>
</ol>
<h2 id="故障与部分失效">故障与部分失效</h2>
<p>单机程序的确定性比较好，行为可预测。</p>
<p><strong>我们通常宁可计算机全部崩溃，也不返回一个错误结果</strong>。</p>
<p>在分布式系统中，尽管系统的其他部分工作正常，但系统的某些部分可能会以某种不可预知的方式被破坏。这被称为部分失效（partial failure）。难点在于部分失效是不确定性的（nonderterministic）：如果你试图做任何涉及多个节点和网络的事情，它有时可能会工作，有时会出现不可预知的失败。正如我们将要看到的，你甚至不知道是否成功了，因为消息通过网络传播的时间也是不确定的！</p>
<p>这种不确定性和部分失效的可能性，使得分布式系统难以工作。</p>
<h3 id="云计算和超算">云计算和超算</h3>
<p>超级计算机更像是一个单节点计算机而不是分布式系统：<strong>通过让部分失败升级为完全失败来处理部分失败</strong>——如果系统的任何部分发生故障，只是让所有的东西都崩溃（就像单台机器上的内核崩溃 kernel panic 一样）。</p>
<p>在分布式系统中，怀疑、悲观和偏执狂才能生存。</p>
<p>但是有些系统会讲究“柔性失败”，允许某些非核心失败降级。</p>
<h2 id="不可靠的网络">不可靠的网络</h2>
<p>我们无法区分：</p>
<ol>
<li>请求丢失</li>
<li>远程节点崩溃</li>
<li>响应丢失的任何一种情况</li>
</ol>
<p>所以我们并不知道远端节点是否处理过这个请求-所以 exactly 总是 at least 而不是 at most 加上幂等构成的。</p>
<h3 id="真实世界的网络故障">真实世界的网络故障</h3>
<p>partition 在这里意味着网络分区：网络的一部分由于网络故障而被切断（而继续工作）。</p>
<h3 id="检测故障">检测故障</h3>
<p>许多系统需要自动检测故障节点。例如：</p>
<ul>
<li>负载平衡器需要停止向已死亡的节点转发请求（即从移出轮询列表（out of rotation））。</li>
<li>在单主复制功能的分布式数据库中，如果主库失效，则需要将从库之一升级为新主库（参阅“处理节点宕机”）。</li>
</ul>
<p>不幸的是，<strong>网络的不确定性使得很难判断一个节点是否工作</strong>（后面还会反复强调这一点）。</p>
<p>如果出了什么问题，你可能会在堆栈的某个层次上得到一个错误响应，但总的来说，你必须假设你根本就没有得到任何回应。您可以重试几次（TCP重试是透明的，但是您也可以在应用程序级别重试），等待超时过期，并且如果在超时时间内没有收到响应，则最终声明节点已经死亡。-<strong>所以心跳检测超时是检测故障的首选方案。</strong></p>
<h3 id="超时与无穷的延迟">超时与无穷的延迟</h3>
<p>如何设置超时时间是个两难的问题：</p>
<ol>
<li>太短的超时时间可能会误杀系统，进而：</li>
<li>导致系统容量错误地缩小，将其负载转移到其他节点可能会导致级联失效（cascading failure）。</li>
<li>造成了双节点写-可能破坏前缀一致读一致性。</li>
<li>太长的超时时间会让系统可用性降低，用户会等待更多的时间。</li>
</ol>
<p>设想一个虚构的系统，其网络可以保证数据包的最大延迟——每个数据包要么在一段时间内传送，要么丢失，但是传递永远不会比<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span>更长。此外，假设你可以保证一个非故障节点总是在一段时间内处理一个请求<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>。在这种情况下，您可以保证每个成功的请求在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>d</mi><mo>+</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">2d + r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>时间内都能收到响应，如果您在此时间内没有收到响应，则知道网络或远程节点不工作。如果这是成立的，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>d</mi><mo>+</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">2d + r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span> 会是一个合理的超时设置。</p>
<h3 id="网络拥塞和排队">网络拥塞和排队</h3>
<p>一些对延迟敏感的应用程序（如视频会议和IP语音（VoIP））使用UDP而不是TCP。这是在可靠性和和延迟可变性之间的折衷：由于UDP不执行流量控制并且不重传丢失的分组，所以避免了可变网络延迟的一些原因（尽管它仍然易受切换队列和调度延迟的影响）。</p>
<p>在延迟数据毫无价值的情况下，UDP是一个不错的选择。例如，在VoIP电话呼叫中，可能没有足够的时间重新发送丢失的数据包，并在扬声器上播放数据。在这种情况下，重发数据包没有意义——应用程序必须使用静音填充丢失数据包的时隙（导致声音短暂中断），然后在数据流中继续。<strong>重试发生在人类层</strong>。 （“你能再说一遍吗？声音刚刚断了一会儿。“）</p>
<h3 id="同步网络-vs-异步网络">同步网络 vs 异步网络</h3>
<p>我们不可能在异步网络里预测延迟（实际上任何网络都不可以）。</p>
<h2 id="不可靠的时钟">不可靠的时钟</h2>
<h3 id="单调钟与时钟">单调钟与时钟</h3>
<p>System.currentTimeMillis() 是墙上时钟，如果操作系统的时间回拨，这个时钟会出错。</p>
<p>System.nanoTime()都是单调时钟。这个名字来源于他们保证总是前进的事实（而时钟可以及时跳回）。</p>
<p><strong>在分布式系统中，使用单调钟测量经过时间（elapsed time）（比如超时）通常很好。</strong></p>
<h3 id="依赖同步时钟">依赖同步时钟</h3>
<p>如果有极强的硬件，可以保证时间差不太多。</p>
<h4 id="时间戳与事件顺序">时间戳与事件顺序</h4>
<p>跨节点的事件排序是不可依赖时钟的，不共用一个时间的事件不可依赖时间戳排序。</p>
<p>只有共用一个时钟，才能正确依赖 LWW。否则，就会丢失因果跟踪关系，进而丢失关键更新。</p>
<p>如果不基于晶振，而基于递增计数器，就可以制造逻辑时钟。</p>
<ul>
<li>逻辑时钟是一个抽象概念。</li>
<li>Lamport 时钟是逻辑时钟的一种简单实现。</li>
<li>向量时钟是逻辑时钟的一种更强大、更完善的实现，它解决了 Lamport 时钟的局限性。</li>
<li>版本向量是向量时钟在数据复制和冲突解决场景下的一个别名或应用。</li>
</ul>
<h5 id="逻辑时钟-logical-clock">逻辑时钟 (Logical Clock)</h5>
<p>这是一个顶层概念。它不是一个具体的算法，而是一种思想：在分布式系统中，我们不关心物理世界的真实时间（Wall Clock Time），因为网络延迟、时钟不同步等问题会让物理时间不可靠。我们只关心事件之间的因果关系（Causality）。</p>
<p>逻辑时钟的目标就是为系统中的每个事件分配一个“时间戳”，这个时间戳遵循一个核心原则：</p>
<blockquote>
<p>时钟一致性原则 (Clock Consistency Condition): 如果事件 A 是事件 B 的原因 (记为<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A→B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>)，那么事件 A 的时间戳必须小于事件 B 的时间戳 (记为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mi>C</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">C(A) &lt; C(B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span></span>)。</p>
</blockquote>
<pre><code class="hljs mermaid">graph TD
    subgraph &quot;逻辑时钟：概念与实现 (Logical Clocks: Concept &amp; Implementations)&quot;
        %% 顶层抽象概念
        LC[(Logical Clock&lt;br/&gt;抽象概念&lt;br/&gt;目标：通过因果关系排序事件)]

        %% 简单实现
        LaC[&quot;Lamport Clock&lt;br/&gt;(简单实现)&lt;br/&gt;&lt;b&gt;数据:&lt;/b&gt; 单个整数&lt;br/&gt;&lt;b&gt;局限:&lt;/b&gt; 无法区分并发&quot;]

        %% 高级实现 (将 Vector Clock 和 Version Vector 放在一起)
        subgraph &quot;高级实现：同一算法，不同名称&quot;
            VC[&quot;Vector Clock&lt;br/&gt;(向量时钟)&lt;br/&gt;&lt;b&gt;理论/算法名称&lt;/b&gt;&quot;]
            VV[&quot;Version Vector&lt;br/&gt;(版本向量)&lt;br/&gt;&lt;b&gt;应用/工业界名称&lt;/b&gt;&lt;br/&gt;(用于数据库版本控制)&quot;]
            VC &lt;--&gt; |&quot;是同一个东西&quot;| VV
        end
        
        AdvancedImpl[&quot;(高级实现)&lt;br/&gt;&lt;b&gt;数据:&lt;/b&gt; 向量/数组&lt;br/&gt;&lt;b&gt;能力:&lt;/b&gt; 可准确识别并发&quot;]

        %% 定义关系
        LC -- &quot;由...实现&quot; --&gt; LaC
        LC -- &quot;由...实现&quot; --&gt; AdvancedImpl
        LaC -.-&gt; |&quot;演进为&lt;br/&gt;(解决其局限性)&quot;| AdvancedImpl
        AdvancedImpl -- &quot;包含&quot; --&gt; VC &amp; VV
        
    end

    %% 样式
    style LC fill:#e3f2fd,stroke:#333,stroke-width:2px
    style LaC fill:#fff9c4,stroke:#333,stroke-width:1px
    style AdvancedImpl fill:#dcedc8,stroke:#333,stroke-width:2px,stroke-dasharray: 5 5
    style VC fill:#c8e6c9,stroke:#333,stroke-width:1px
    style VV fill:#c8e6c9,stroke:#333,stroke-width:1px</code></pre>
<h5 id="lamport-时钟-lamport-clock">Lamport 时钟 (Lamport Clock)</h5>
<p>这是由计算机科学家 Leslie Lamport 提出的第一种、也是最简单的逻辑时钟实现。</p>
<ul>
<li>数据结构: 每个进程（或节点）维护一个单一的整数计数器。</li>
<li>工作方式:
<ul>
<li>进程在每次执行内部事件时，将自己的计数器加 1。</li>
<li>进程发送消息时，会附上自己当前的计数器值。</li>
<li>进程接收到消息时，会将自己的计数器更新为 max(本地计数器, 接收到的计数器) + 1。</li>
</ul>
</li>
<li>优点: 非常简单、轻量。</li>
<li>核心局限: 它只能保证单向的因果关系推导。
<ul>
<li>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A→B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>，那么我们一定能得出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mi>C</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">C(A) &lt; C(B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span></span>。<br>
-但是，如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mi>C</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">C(A) &lt; C(B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span></span>，我们<strong>不能</strong>断定<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \rightarrow B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>。这两个事件有可能是并发的（Concurrent）。</li>
</ul>
</li>
</ul>
<p>例子: 进程 P1 的事件 A 时间戳为 10，进程 P2 的事件 B 时间戳为 11。我们仅凭此无法判断是 P1 影响了 P2，还是它们恰好独立发生。</p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant P1
    participant P2
    participant P3

    P1-&gt;&gt;P1: 事件 A (本地)
    note right of P1: 时钟更新: C=1

    P1-&gt;&gt;P2: 发送消息 m1
    note right of P1: 发送前: C=1+1=2&lt;br/&gt;消息附带 C=2
    
    P3-&gt;&gt;P3: 事件 E (本地)
    note right of P3: 时钟更新: C=1

    P2-&gt;&gt;P2: 接收 m1, 触发事件 B
    note left of P2: 本地C=0, 消息C=2&lt;br/&gt;更新: max(0, 2) + 1 = 3

    P2-&gt;&gt;P2: 事件 C (本地)
    note left of P2: 时钟更新: C=3+1=4

    P1-&gt;&gt;P1: 事件 D (本地)
    note right of P1: 时钟更新: C=2+1=3

    P2-&gt;&gt;P3: 发送消息 m2
    note left of P2: 发送前: C=4+1=5&lt;br/&gt;消息附带 C=5

    P3-&gt;&gt;P3: 接收 m2, 触发事件 F
    note right of P3: 本地C=1, 消息C=5&lt;br/&gt;更新: max(1, 5) + 1 = 6</code></pre>
<h5 id="向量时钟-vector-clock-版本向量-version-vector">向量时钟 (Vector Clock) / 版本向量 (Version Vector)</h5>
<p>为了解决 Lamport 时钟无法区分并发的局限性，向量时钟被提了出来。</p>
<ul>
<li>数据结构: 每个进程维护一个整数向量（或数组），向量的长度等于系统中总的进程数。例如，在有3个进程的系统中，P1 的向量时钟可能是<code>[3, 1, 4]</code>。
<ul>
<li><code>VC(i)[i]</code> 是进程 i 本地的事件计数。</li>
<li><code>VC(i)[j]</code> (当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo mathvariant="normal">≠</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i≠j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>) 表示进程<code>i</code>所知道的进程<code>j</code>已经发生的事件数。</li>
</ul>
</li>
<li>工作方式:
<ul>
<li>进程<code>i</code>在每次执行内部事件时，只将自己分量<code>VC(i)[i]</code>加 1。</li>
<li>进程<code>i</code>发送消息时，会附上自己完整的向量时钟。</li>
<li>进程<code>j</code>收到来自<code>i</code>的消息时，首先对两个向量的每一个元素取<code>max</code>值进行合并，然后将自己的分量<code>VC(j)[j]</code>加 1。</li>
</ul>
</li>
<li>优点: 它能完美地捕捉因果关系。
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A→B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 当且仅当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mi>C</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mi>V</mi><mi>C</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">VC(A) &lt; VC(B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span></span>。<br>
-（这里的 &lt; 对向量有特殊定义：A 的每个分量都小于等于 B 的对应分量，并且至少有一个分量严格小于）。</li>
</ul>
</li>
<li>并发判断: 如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mi>C</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">VC(A)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mclose">)</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mi>C</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">VC(B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span></span> 无法比较大小（即 A 中有比 B 大的分量，B 中也有比 A 大的分量），那么事件 A 和 B 就是并发的。</li>
</ul>
<p>版本向量 (Version Vector): 这其实就是向量时钟。当向量时钟被用于分布式数据库或存储系统，用来追踪数据对象的不同副本的“版本”时，人们更喜欢称它为“版本向量”。它的作用是检测和解决更新冲突。例如，Amazon DynamoDB 就使用了这个技术。</p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant P1
    participant P2
    participant P3

    P1-&gt;&gt;P1: 事件 A (本地)
    note right of P1: P1 更新: VC=[1,0,0]

    P1-&gt;&gt;P2: 发送消息 m1
    note right of P1: 发送前 P1 更新: [2,0,0]&lt;br/&gt;消息附带 VC=[2,0,0]

    P3-&gt;&gt;P3: 事件 E (本地)
    note right of P3: P3 更新: VC=[0,0,1]

    P2-&gt;&gt;P2: 接收 m1, 触发事件 B
    note left of P2: 合并: max([0,0,0],[2,0,0])=[2,0,0]&lt;br/&gt;P2 更新: [2,1,0]

    P2-&gt;&gt;P2: 事件 C (本地)
    note left of P2: P2 更新: [2,2,0]

    P1-&gt;&gt;P1: 事件 D (本地)
    note right of P1: P1 更新: [3,0,0]

    P2-&gt;&gt;P3: 发送消息 m2
    note left of P2: 发送前 P2 更新: [2,3,0]&lt;br/&gt;消息附带 VC=[2,3,0]

    P3-&gt;&gt;P3: 接收 m2, 触发事件 F
    note right of P3: 合并: max([0,0,1],[2,3,0])=[2,3,1]&lt;br/&gt;P3 更新: [2,3,2]</code></pre>
<h3 id="时钟读数存在置信区间">时钟读数存在置信区间</h3>
<p>一个有趣的例外是 Spanner 中的 Google TrueTime API，它明确地报告了本地时钟的置信区间。当你询问当前时间时，你会得到两个值：[最早，最晚]，这是最早可能的时间戳和最晚可能的时间戳。在不确定性估计的基础上，时钟知道当前的实际时间落在该区间内。间隔的宽度取决于自从本地石英钟最后与更精确的时钟源同步以来已经过了多长时间。</p>
<h3 id="全局快照的同步时钟">全局快照的同步时钟</h3>
<p>快照隔离最常见的实现需要单调递增的事务ID。如果写入比快照晚（即，写入具有比快照更大的事务ID），则该写入对于快照事务是不可见的。在单节点数据库上，一个简单的计数器就足以生成事务ID。</p>
<p>但是当数据库分布在许多机器上，也许可能在多个数据中心中时，由于需要协调，（跨所有分区）全局单调递增的事务ID可能很难生成。事务ID必须反映因果关系：如果事务B读取由事务A写入的值，则B必须具有比A更大的事务ID，否则快照就无法保持一致。在有大量的小规模、高频率的事务情景下，在分布式系统中创建事务ID成为一个站不住脚的瓶颈。</p>
<p>Spanner以这种方式实现跨数据中心的快照隔离【59，60】。它使用TrueTime API报告的时钟置信区间，并基于以下观察结果：如果您有两个置信区间，每个置信区间包含最早和最近可能的时间戳（ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mo stretchy="false">[</mo><mi>A</mi><mrow><mi>e</mi><mi>a</mi><mi>r</mi><mi>l</mi><mi>i</mi><mi>e</mi><mi>s</mi><mi>t</mi></mrow><mo separator="true">,</mo><mi>A</mi><mrow><mi>l</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>s</mi><mi>t</mi></mrow><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">A = [A{earliest}, A{latest}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">A</span><span class="mord"><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">A</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span></span><span class="mclose">]</span></span></span></span>， $B=[B{earliest}, B{latest}] <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>），这两个区间不重叠（即：</mtext></mrow><annotation encoding="application/x-tex">），这两个区间不重叠（即：</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">）</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">这</span><span class="mord cjk_fallback">两</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">区</span><span class="mord cjk_fallback">间</span><span class="mord cjk_fallback">不</span><span class="mord cjk_fallback">重</span><span class="mord cjk_fallback">叠</span><span class="mord cjk_fallback">（</span><span class="mord cjk_fallback">即</span><span class="mord cjk_fallback">：</span></span></span></span>A{earliest} &lt; A{latest} &lt; B{earliest} &lt; B{latest}$），那么B肯定发生在A之后——这是毫无疑问的。<strong>只有当区间重叠时，我们才不确定A和B发生的顺序</strong>。</p>
<p>为了确保事务时间戳反映因果关系，在提交读写事务之前，Spanner在提交读写事务时，会故意等待置信区间长度的时间（只在提交（commit）那一刻做一次 commit-wait truetime api 得到的 latest time）。通过这样，它可以确保任何可能读取数据的事务处于足够晚的时间，因此它们的置信区间不会重叠。为了保持尽可能短的等待时间，Spanner需要保持尽可能小的时钟不确定性，为此，Google在每个数据中心都部署了一个GPS接收器或原子钟，允许时钟在大约7毫秒内同步。</p>
<p>这个方案可能是唯一在工业界能够落地的方案。</p>
<h3 id="暂停进程">暂停进程</h3>
<p>主节点如何维护自己的任期？使用租约机制：</p>
<p>一种选择是领导者从其他节点获得一个租约（lease），类似一个带超时的锁。<strong>任一时刻只有一个节点可以持有租约</strong>——因此，当一个节点获得一个租约时，它知道它在某段时间内自己是领导者，直到租约到期。为了保持领导地位，节点必须在周期性地在租约过期前续期。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>    request=getIncomingRequest();<br>    <span class="hljs-comment">// 确保租约还剩下至少10秒，在事务开始之前续租，或者开一个独立的线程续租，注意这个检查租约的时间顺序</span><br>    <span class="hljs-keyword">if</span> (lease.expiryTimeMillis-System.currentTimeMillis()&lt; <span class="hljs-number">10000</span>)&#123;<br>        lease = lease.renew();<br>    &#125;<br>    <span class="hljs-keyword">if</span>(lease.isValid())&#123;<br>        process(request);<br>    &#125;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>想象一下，线程在lease.isValid()行周围停止15秒，然后才终止。在这种情况下，在请求被处理的时候，租约可能已经过期，而另一个节点已经接管了领导。然而，没有什么可以告诉这个线程已经暂停了这么长时间了，所以这段代码不会注意到租约已经到期了，直到循环的下一个迭代 ——到那个时候它可能已经做了一些不安全的处理请求。</p>
<p>有很多种原因造成进程停顿：</p>
<ul>
<li>GC 的 stw</li>
<li>操作系统自身暂停进程</li>
<li>虚拟化</li>
<li>上下文切换</li>
</ul>
<p>在单台机器上编写代码时，可以通过共享内存通信；而分布式场景下通信时，必须通过通信来共享内存。</p>
<p>在嵌入式系统中，实时是指系统经过精心设计和测试，以满足所有情况下的特定时间保证。这个含义与Web上实时术语的模糊使用相反，它描述了服务器将数据推送到客户端以及流处理，而没有严格的响应时间限制。</p>
<h4 id="调整垃圾回收的方法-非常重要">调整垃圾回收的方法（非常重要!）</h4>
<ol>
<li>一个新兴的想法是将 GC 暂停视为<strong>一个节点的短暂计划内的临时离线</strong>，并让其他节点处理来自客户端的请求，同时一个节点正在收集其垃圾。如果运行时可以警告应用程序一个节点很快需要GC暂停，那么应用程序可以停止向该节点发送新的请求（可以在服务端自己摘除，也可以靠客户端的滑动窗口熔断），等待它完成处理未完成的请求，然后在没有请求正在进行时执行GC。<strong>这个技巧隐藏了来自客户端的GC暂停</strong>，并降低了响应时间的高百分比。一些对延迟敏感的金融交易系统使用这种方法-这要求我们能够：1、预测 gc，2、在 gc 到来之前在 LB 切换流量，停止新的流量，3、gc 过后重新打开 LB。</li>
<li>这个想法的一个变种是只用垃圾收集器来处理短命对象（这些对象要快速收集），并定期在积累大量长寿对象（因此需要完整GC）之前重新启动进程。一次可以重新启动一个节点，在计划重新启动之前，流量可以从节点移开，就像滚动升级一样。- 这要求我们能够严格预测、控制 ygc 的频率和时长（<strong>这需要不断调整 ygc 的参数，改变 young 区范围大小和垃圾收集算法</strong>，让 young 区足够小，甚至有意识地让对象进入 old 区来避免过长时间的 ygc，这时候不如直接上  g1/zgc，让它自己在回收循环里面自我调优-因为这就是在手工做同样的事情），并且能够定期重启服务。</li>
<li>使用对象池，明确区分不易回收的对象，尽量减少没必要的、重复的 ygc 对象，这可以和方法 2 搭配使用。</li>
<li>主动 gc：在 jdk7 使用 system.gc，其它jdk版本使用 jmap -histo:live。</li>
</ol>
<h2 id="知识-真相与谎言">知识、真相与谎言</h2>
<h3 id="真理由多数所定义">真理由多数所定义</h3>
<p><strong>节点不一定能相信自己对于情况的判断</strong>。分布式系统不能完全依赖单个节点，因为节点可能随时失效，可能会使系统卡死，无法恢复。相反，许多分布式算法都依赖于法定人数，即在节点之间进行投票：决策需要来自多个节点的最小投票数，<strong>以减少对于某个特定节点的依赖</strong>。</p>
<p>最常见的法定人数是超过一半的绝对多数（尽管其他类型的法定人数也是可能的）。多数法定人数允许系统继续工作，如果单个节点发生故障（三个节点可以容忍单节点故障；五个节点可以容忍双节点故障）。系统仍然是安全的，因为在这个制度中只能有一个多数——<strong>不能同时存在两个相互冲突的多数决定-RAFT 的根基就在这里</strong>。</p>
<h4 id="fencing-令牌">fencing 令牌</h4>
<blockquote>
<p>本书中提到的 fencing 机制，核心目的确实是防止“旧主”（或失效节点）在主切换后继续操作共享资源，从而破坏一致性；而“term”（任期）是实现 fencing 的一种常见手段，但 fencing 的形式不限于 term。</p>
</blockquote>
<p>这里的租约是客户端租约（还有服务端租约），完善的租约是带有版本化检查机制的服务端发给客户的数据和版本，而服务端拥有版本检查机制。</p>
<ol>
<li>我们假设每次锁定服务器授予锁或租约时，它还会返回一个防护令牌（fencing token），这个数字在每次授予锁定时都会增加。</li>
<li>我们可以要求客户端每次向存储服务（注释：而不是发出令牌的服务，这里的两个服务分别是 zk 和 storage service，这种分离让这个令牌具有广泛的使用场景）发送写入请求时，都必须包含当前的屏蔽令牌。</li>
<li>服务器要原子化地同时具有处理资源和令牌的功能，能够比对当前的令牌是不是最高级的。</li>
</ol>
<p>如果将ZooKeeper用作锁定服务，则可将事务标识zxid或节点版本cversion用作屏蔽令牌。由于它们保证单调递增，因此它们具有所需的属性。</p>
<p>c，可能仍然可以解决此限制（例如，在文件存储服务的情况下，可以将防护令牌包含在文件名中-另一个方法，把令牌写进资源的一个属性中，如表的 version）。</p>
<p>注释：</p>
<ol>
<li>如果没有办法实现 fencing 盾牌，可以学习 Spanner 进行等待。</li>
<li>要注意 fencing token 和我们常见的分布式锁里的 value 的区别。前者是锁服务发出来的钥匙，只有持有锁的人才有的高版本的钥匙，用锁不靠客户端的自觉，要每次都带钥匙。而我们对分布式锁写 value 本质上是给出了一个客户端自己的 value，跟客户约定，最终解锁（而不是每次用锁），需要使用自己带的钥匙解锁。锁提供服务需要自身提供接受解锁钥匙和产出 fencing token 的功能。</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">特性 / 概念</th>
<th style="text-align:left">Fencing Token (防护令牌)</th>
<th style="text-align:left">Raft Term (任期号)</th>
<th style="text-align:left">向量时钟 (Version Vector)</th>
<th style="text-align:left">租约 (Lease)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>核心目的</strong></td>
<td style="text-align:left"><strong>防止过期的节点污染数据 (STONITH)</strong>。确保只有最新的授权者才能修改资源。</td>
<td style="text-align:left">保证领导权唯一性与操作顺序性。</td>
<td style="text-align:left">检测并发更新，追踪数据因果关系。</td>
<td style="text-align:left">保证在一段时间内的独占权限。<br><strong>服务端持有</strong>可优化读性能 (Lease Read)；<br><strong>客户端持有</strong>可保证互斥访问安全。</td>
</tr>
<tr>
<td style="text-align:left"><strong>值类型</strong></td>
<td style="text-align:left"><strong>逻辑时钟</strong> (单调递增的数字)</td>
<td style="text-align:left"><strong>逻辑时钟</strong> (单调递增的数字)</td>
<td style="text-align:left"><strong>逻辑时钟</strong> (一组逻辑时钟的向量)</td>
<td style="text-align:left"><strong>物理时钟</strong> (依赖时间戳和有效期)</td>
</tr>
<tr>
<td style="text-align:left"><strong>工作原理</strong></td>
<td style="text-align:left">协调者为每个授权分配一个递增的令牌。资源方在每次写操作时验证令牌，拒绝旧令牌。</td>
<td style="text-align:left">节点只接受并跟随 <code>term</code> 更高的领导者，拒绝旧 <code>term</code> 的请求。</td>
<td style="text-align:left">每个节点维护一个向量，记录对其他节点事件的认知。通过向量比较判断因果关系。</td>
<td style="text-align:left">授权方授予一个带<strong>明确过期时间</strong>的许可。<br><strong>服务端持有 (Leader Lease):</strong> Leader 从 Follower 处获得租约，确信自身唯一性。<br><strong>客户端持有 (Lock Lease):</strong> 客户端从锁服务处获得租约，用于安全访问共享资源。</td>
</tr>
<tr>
<td style="text-align:left"><strong>解决的主要问题</strong></td>
<td style="text-align:left"><strong>进程暂停</strong>、网络延迟等导致的**“僵尸节点”<strong>或</strong>“过时请求”**问题。</td>
<td style="text-align:left"><strong>领导者选举的安全性</strong>和<strong>日志一致性</strong> (在共识算法中)。</td>
<td style="text-align:left"><strong>数据冲突检测</strong> (在多主或最终一致性系统中)。</td>
<td style="text-align:left"><strong>防止脑裂</strong> (Split-Brain)，特别是因网络分区导致的。</td>
</tr>
<tr>
<td style="text-align:left"><strong>实现方式</strong></td>
<td style="text-align:left"><strong>主动 Fencing</strong>：资源节点主动拒绝旧令牌的请求。这是最直接的隔离手段。</td>
<td style="text-align:left"><strong>被动 Fencing</strong>：旧领导者在通信后发现更高 <code>term</code> 时被迫退位。<strong>它本身就是一种 Fencing Token 的实现</strong>。</td>
<td style="text-align:left">不直接提供 Fencing，但检测出的冲突可触发上层处理。</td>
<td style="text-align:left"><strong>主动 Fencing</strong>：旧持有者检查自身租约，发现过期后<strong>主动</strong>放弃权限。</td>
</tr>
<tr>
<td style="text-align:left"><strong>典型应用场景</strong></td>
<td style="text-align:left">Google GFS/Chubby, HDFS 高可用, 各种需要外部协调者的分布式锁服务。</td>
<td style="text-align:left">Raft, Paxos (共识算法), Etcd, ZooKeeper。</td>
<td style="text-align:left">DynamoDB, Riak (多主复制数据库), 离线数据同步。</td>
<td style="text-align:left"><strong>服务端持有:</strong> Etcd (Lease Read), HDFS NameNode 高可用。<br><strong>客户端持有:</strong> Google Chubby (客户端从锁服务获取租约)。</td>
</tr>
<tr>
<td style="text-align:left"><strong>优点</strong></td>
<td style="text-align:left">机制简单、极其可靠，是数据安全的最后一道防线。</td>
<td style="text-align:left">机制简单、可靠，是 Raft 安全性的基石。</td>
<td style="text-align:left">能精确判断因果关系 (Happened-Before) 和并发。</td>
<td style="text-align:left">安全性高；可用于优化读性能 (Lease Read)。</td>
</tr>
<tr>
<td style="text-align:left"><strong>缺点/依赖</strong></td>
<td style="text-align:left">需要一个高可用的协调者来分发和存储最新的令牌。</td>
<td style="text-align:left">依赖节点间通信来发现过时。</td>
<td style="text-align:left">向量大小随节点数增长；不负责解决冲突。</td>
<td style="text-align:left">依赖大致同步的物理时钟；时钟漂移是主要风险。</td>
</tr>
</tbody>
</table>
<p>这里还要好好区分什么是客户端租约什么是服务端租约，本上下文提到的是客户端租约。</p>
<ul>
<li>服务端租约：
<ul>
<li>目标：
<ul>
<li>保证 Leader 的稳定性：Leader 持有租约期间，可以确信自己是唯一的 Leader，不会有其他节点来篡权。</li>
<li>优化读性能（Lease Read）：这是最重要的应用。既然 Leader 确信自己在租约期内是唯一的，那么当它收到一个读请求时，就不需要再向 Follower 发起一次 Quorum 确认，可以直接返回自己本地的数据。这大大降低了读请求的延迟。</li>
</ul>
</li>
</ul>
</li>
<li>客户端租约：
<ul>
<li>目标：
<ul>
<li>保证互斥访问的安全性：确保在任何时候，只有一个客户端进程能够修改某个共享资源（比如一个文件，或者数据库中的一行）。这里的核心是防止因进程暂停（如 GC）而醒来的“僵尸客户端”破坏数据。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>我们的服务端租约通常是某个服务器去向分布式锁服务获取锁成为主节点，这种服务器得到的租约对锁服务而言是一种客户端租约，但是成为主节点的服务器和其他服务器之间相比，拥有的就是服务端租约了。锁服务可以给这个租约附带上一个 fencing token/version。</p>
<h3 id="拜占庭故障">拜占庭故障</h3>
<p>拜占庭容错系统的协议的实现异常复杂。</p>
<p>但是，我们通常不使用拜占庭容错协议，而只是让服务器决定什么是客户端行为（在 C/S架构中），而不是允许的。在没有这种中心授权的对等网络中，拜占庭容错更为重要-所以简单粗暴的设计是中心化服务。</p>
<p>大多数拜占庭式容错算法要求超过三分之二的节点能够正常工作（即，如果有四个节点，最多只能有一个故障）。</p>
<h3 id="系统模型与现实">系统模型与现实</h3>
<ul>
<li>同步模型</li>
</ul>
<p>同步模型（synchronous model）假设网络延迟，进程暂停和和时钟误差都是有界限的。这并不意味着完全同步的时钟或零网络延迟；这只意味着你知道网络延迟，暂停和时钟漂移将永远不会超过某个固定的上限【88】。同步模型并不是大多数实际系统的现实模型，因为（如本章所讨论的）无限延迟和暂停确实会发生。</p>
<ul>
<li>部分同步模型</li>
</ul>
<p>部分同步（partial synchronous）意味着一个系统在大多数情况下像一个同步系统一样运行，但有时候会超出网络延迟，进程暂停和时钟漂移的界限【88】。这是很多系统的现实模型：大多数情况下，网络和进程表现良好，否则我们永远无法完成任何事情，但是我们必须承认，在任何时刻假设都存在偶然被破坏的事实。发生这种情况时，网络延迟，暂停和时钟错误可能会变得相当大。</p>
<ul>
<li>异步模型</li>
</ul>
<p>在这个模型中，一个算法不允许对时机做任何假设——事实上它甚至没有时钟（所以它不能使用超时）。一些算法被设计为可用于异步模型，但非常受限。</p>
<p>同步模型不切实际，部分同步模型是常见的。</p>
<p>进一步来说，除了时间问题，我们还要考虑节点失效。三种最常见的节点系统模型是：</p>
<ul>
<li>崩溃-停止故障</li>
</ul>
<p>在崩溃停止（crash-stop）模型中，算法可能会假设一个节点只能以一种方式失效，即通过崩溃。这意味着节点可能在任意时刻突然停止响应，此后该节点永远消失——它永远不会回来。</p>
<ul>
<li>崩溃-恢复故障</li>
</ul>
<p>我们假设节点可能会在任何时候崩溃，但也许会在未知的时间之后再次开始响应。在崩溃-恢复（crash-recovery）模型中，假设节点具有稳定的存储（即，非易失性磁盘存储）且会在崩溃中保留，而内存中的状态会丢失。</p>
<ul>
<li>拜占庭（任意）故障</li>
</ul>
<p>节点可以做（绝对意义上的）任何事情，包括试图戏弄和欺骗其他节点，如上一节所述。</p>
<p>对于真实系统的建模，具有崩溃-恢复故障（crash-recovery）的部分同步模型（partial synchronous）通常是最有用的模型-常见的就是性价比最高的。</p>
<h4 id="算法的正确性">算法的正确性</h4>
<p>如果我们正在为一个锁生成屏蔽令牌（参阅“屏蔽令牌”），我们可能要求算法具有以下属性：</p>
<ul>
<li>唯一性</li>
</ul>
<p>没有两个屏蔽令牌请求返回相同的值。</p>
<ul>
<li>单调序列</li>
</ul>
<p>如果请求 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 返回了令牌 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">t_x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，并且请求<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>返回了令牌<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>y</mi></msub></mrow><annotation encoding="application/x-tex">t_y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>，并且 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 开始之前已经完成，那么<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>x</mi></msub><mo>&lt;</mo><msub><mi>t</mi><mi>y</mi></msub></mrow><annotation encoding="application/x-tex">t_x &lt; t_y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>。</p>
<ul>
<li>可用性</li>
</ul>
<p>请求防护令牌并且不会崩溃的节点，最终会收到响应。</p>
<h4 id="safety-和-liveness">safety 和 liveness</h4>
<p>唯一性和单调序列是 safety。</p>
<p>最终一致性是一个 liveness。</p>
<p>大多数分布式系统一定要保证 safety，尽量确保 liveness。</p>
<p>若协议宣称自己“correct”或“fault-tolerant”，99% 的论文都会把规格拆成：</p>
<p>safety = “坏事永远不会发生”<br>
liveness = “好事最终会发生”</p>
<p>因为这是最简洁、最易于形式化验证的框架（TLA+/PlusCal、Ivy、Coq 都直接支持）。</p>
<h4 id="将系统模型映射到现实世界">将系统模型映射到现实世界</h4>
<p>这并不是说理论上抽象的系统模型是毫无价值的，恰恰相反。它们对于将实际系统的复杂性降低到一个我们可以推理的可处理的错误是非常有帮助的，以便我们能够理解这个问题，并试图系统地解决这个问题。我们可以证明算法是正确的，通过显示它们的属性总是保持在某个系统模型中。</p>
<p>证明算法正确并不意味着它在真实系统上的实现必然总是正确的。但这迈出了很好的第一步，因为理论分析可以发现算法中的问题，这种问题可能会在现实系统中长期潜伏，直到你的假设（例如，时间）因为不寻常的情况被打破。理论分析与经验测试同样重要。</p>
<h2 id="本章小结">本章小结</h2>
<p><strong>这类部分失效可能发生的事实是分布式系统的决定性特征</strong>。每当软件试图做任何涉及其他节点的事情时，偶尔就有可能会失败，或者随机变慢，或者根本没有响应（最终超时）。在分布式系统中，我们试图在软件中建立部分失效的容错机制，这样整个系统即使在某些组成部分被破坏的情况下，也可以继续运行。</p>
<p>为了容忍错误，第一步是<strong>检测它们</strong>，但即使这样也很难。大多数系统没有检测节点是否发生故障的准确机制，所以大多数分布式算法依靠超时来确定远程节点是否仍然可用。</p>
<p>如果你习惯于在理想化的数学完美（同一个操作总能确定地返回相同的结果）的单机环境中编写软件，那么转向分布式系统的凌乱的物理现实可能会有些令人震惊。相反，如果能够在单台计算机上解决一个问题，那么分布式系统工程师通常会认为这个问题是平凡的，现在单个计算机确实可以做很多事情。如果你可以避免打开潘多拉的盒子，把东西放在一台机器上，那么通常是值得的。</p>
<p>有可能给网络提供硬实时的响应保证和有限的延迟，但是这样做非常昂贵，且导致硬件资源的利用率降低。大多数非安全关键系统会选择便宜而不可靠，而不是昂贵和可靠。</p>
<h1>一致性与共识</h1>
<p>这一章探讨的问题和<strong>第五章的复制问题</strong>有极大的关系，复制既是达成共识的手段，也是达成共识所需要解决的问题的本身。本章要考虑在<strong>第八章的网络问题</strong>（特别是不可靠网络延迟）的基础上，如何构建共识算法，进而达到一致。</p>
<p><strong>处理故障的最简单方法是简单地让整个服务失效</strong>，并向用户显示错误消息，<strong>否则要考虑容错</strong>。</p>
<p>构建容错系统的最好方法，是找到一些带有实用保证的通用抽象，实现一次，然后让应用依赖这些保证。</p>
<p>事务是一种这样的抽象，共识算法是另一种这样的抽象，两者是正交的。分布式系统最重要的抽象之一就是共识（consensus）：<strong>是让所有的节点对某件事（某个 proposal）达成一致，且不可撤销</strong>。</p>
<p>我们要面对不可抗拒的谎言，寻求真相，有两大类的路径：</p>
<ul>
<li>我们尝试用单一节点来实现线性化：
<ul>
<li>我们首先要制造多节点的主节点。</li>
<li>而选主就就要涉及求锁/租约/主被动Fencing机制。</li>
<li>当我们得到主节点以后，我们使用 term 和租约来维护逻辑/物理的独占/领导性，用fencing机制来保证错误的主在全局失效。</li>
<li>然后我们基于主节点的单一日志实现事件的线性化，在通过全序院子广播来维护全部系统的版本一致性。</li>
</ul>
</li>
<li>如果我们无法得到单一主节点，我们就可能要面临多主复制一样的问题：
<ul>
<li>必然出现版本冲突和并发，我们就要检测版本冲突。
<ul>
<li>检测和处理版本冲突的核心手段是事件排序。</li>
<li>我们标准的事件排序是逻辑时钟，低级的逻辑时钟是 lamport clock，而高级的逻辑时钟是版本向量/向量时钟。</li>
</ul>
</li>
<li>我们通常只在 Dynamo Style 的数据库里才会遇到这种需要事件排序的场景，所以我们并不了解向量时钟。</li>
</ul>
</li>
</ul>
<blockquote>
<p>在分布式系统中，所有事件在‘先行发生’（Happened-Before）关系下，构成一个偏序集 (Partially Ordered Set)。因为并发事件的存在，导致我们无法对所有事件进行排序。而向量时钟正是用来精确描述这个偏序关系的一种工具。</p>
</blockquote>
<p>只有一个偏序集。</p>
<blockquote>
<p>相比之下，像 Raft 这样的共识算法，其核心目标就是将这个偏序集中的事件，通过一个中心化的 Leader 强制安排成一个全序 (Total Order)，也就是我们看到的复制日志。这个过程消除了并发，从而避免了冲突。</p>
</blockquote>
<blockquote>
<p>线性化（或全序广播）是为系统唯一的、全局的偏序集，寻找并确定一个合法的全序排列的过程。</p>
</blockquote>
<blockquote>
<p>在分布式系统中，所有事件在‘先行发生’（Happened-Before）关系下，共同构成一个全局的偏序集 (a single, global Partially Ordered Set)。并发事件的存在，是这个集合之所以是‘偏序’而非‘全序’的根本原因。向量时钟是一种数据结构，它能够为每个事件打上‘坐标’，从而精确地判断任意两个事件在该偏序集中的关系：是因果，还是并发。”</p>
</blockquote>
<blockquote>
<p>相比之下，像 Raft 这样的共识算法，其核心目标就是为这个全局偏序集找到一个确定的、对所有节点都一致的全序排列 (a single, consistent Total Order)。这个过程通过中心化的 Leader 来完成：Leader 接收到并发的事件后，负责对它们进行排序（即从多个合法的全序中选择一个），并将这个唯一的顺序记录在复制日志中。通过这种方式，系统将‘并发’的可能性从根本上消除了，从而避免了数据冲突。</p>
</blockquote>
<h2 id="一致性保证">一致性保证</h2>
<p>大多数可复制的数据库提供的是最终一致性，最终一致性意味着所有的数据的值最终会收敛（convergence）到相同的值。但分布式多副本的场景下，如何维护副本状态，是一个很复杂的问题。</p>
<p>一个抽象提供的一致性<strong>越强</strong>，它的上层要处理的问题<strong>越少</strong>；抽象提供的一致性<strong>越弱</strong>，则它的上层要处理的问题<strong>越多</strong>。这就是上层系统处理最终一致性时要预防各种出错的原因。</p>
<h2 id="可线性化">可线性化</h2>
<p><strong>可线性化的准确定义非常复杂</strong>，但<strong>它表现得好像只有一个副本</strong>，<strong>所有操作都是原子</strong>的（<strong>没有中间状态，读到的状态不可撤销</strong>）-另一种类似的等价定义是所有客户端可以看到相同的数据视图。</p>
<p>单一副本是一种假象。</p>
<p>我们在缓存和数据库之间如果实现了某种共识算法，也能够提供可线性化的视图。</p>
<p><img src="fig9-1.png" alt="这个系统是非线性一致的，导致了球迷的困惑"></p>
<p>延迟导致了间隙时间窗口，允许读中间状态，就会得到多个副本的非线性系统-不是单一副本的线性系统。</p>
<h3 id="如何达到可线性化">如何达到可线性化</h3>
<p>将分布式数据的<strong>主键定义为寄存器</strong>，可线性化系统的工作方式是：如果某一个客户端读到的寄存器值发生了跳变，所有的客户端读到的值都只能是该最新值。</p>
<p>把主键/行/记录/文档当做寄存器，则我们对寄存器经常使用的工作内存/主存抽象可以被用在这里。</p>
<p><img src="fig9-2.png" alt="如果读取请求与写入请求并发，则可能会返回旧值或新值"></p>
<p>任何与写操作并行发生的读操作得到的值都可能是新旧值。</p>
<p>如果一个寄存器在读写并发时可以返回旧值或者新值，它是常规寄存器。</p>
<table>
<thead>
<tr>
<th>DDIA 术语</th>
<th>别称/一致性等级</th>
<th>核心语义（无公式）</th>
<th>客户端并发读写时可能出现的现象</th>
<th>典型实现/场景</th>
<th>与 CPU 寄存器关系</th>
</tr>
</thead>
<tbody>
<tr>
<td>常规寄存器 (Ordinary Register)</td>
<td>顺序一致以外最弱</td>
<td>只保证&quot;写后读能读到某次写的结果&quot;，不保证&quot;读到的值是哪个写产生的&quot;</td>
<td>并发读可能返回任意旧值；并发写可能互相覆盖；无并发检测</td>
<td>理论教学用；实际系统很少暴露这么弱的一致性</td>
<td>❌ 完全无关，是分布式理论里的共享变量抽象</td>
</tr>
<tr>
<td>原子寄存器 (Atomic Register)</td>
<td>原子一致性 (Atomicity)</td>
<td>所有读写操作看起来<strong>在某个瞬间原子完成</strong>，不会看到&quot;写一半&quot;或新旧值拼半</td>
<td>不会出现<strong>读撕裂</strong>（partial read）或<strong>写撕裂</strong>；但<strong>不保证全局线性顺序</strong></td>
<td>单副本变量 + 互斥锁；RAFT 日志条目；ZooKeeper 数据节点</td>
<td>❌ 同上，理论抽象</td>
</tr>
<tr>
<td>线性化寄存器 (Linearizable Register)</td>
<td>线性一致性 (Linearizability)</td>
<td>在原子基础上，<strong>所有操作都按全局真实时间线排成一条链</strong>；后发起的读必须看到后完成的写</td>
<td>最强一致性：外部可观察顺序 = 真实时间顺序</td>
<td>单主同步复制；Spanner 的 Paxos 状态机；ZooKeeper sync() 后读</td>
<td>❌ 仍是理论抽象，不是硬件</td>
</tr>
</tbody>
</table>
<p><img src="fig9-3.png" alt="任何一个读取返回新值后，所有后续读取（在相同或其他客户端上）也必须返回新值"></p>
<p>举例：客户端 a 在全局时钟 1 读到 v2，则 b 在全局时钟 2（这里的时钟指的是客户端的请求在服务器端发生的时间-<strong>某一种jing’que</strong>，不分读写，2 在 1 之后）读到的值至少是 v2（<strong>不管此时 V2 的写是不是写完了</strong>-所以其实可线性化的严格程度还在写 ack 之前），否则发生了倒退，不满足可线性化。</p>
<p><img src="fig9-4.png" alt="可视化读取和写入看起来已经生效的时间点。 B的最后读取不是线性一致性的"></p>
<p>这个例子背后还有一个设定：单纯支持 RW 的可线性化系统是存在的，还有一种更完备的支持可信性 CAS 的系统，要求的能力比单纯支持 RW 的可线性化系统更强。</p>
<blockquote>
<p>客户B的最后一次读取（阴影条柱中）<strong>不是线性一致性的</strong>。 该操作与C的cas写操作并发（它将 x 从 2 更新为 4<br>
）。在没有其他请求的情况下，B的读取返回 2 是可以的。然而，在B的读取开始之前，客户端A已经读取了新的值 4<br>
，因此不允许B读取比A更旧的值。</p>
</blockquote>
<p>DDIA 使用直觉定义来绕开详细的排序计算：<br>
当一个C读到了latest值，所有节点自动被传染（实际上不存在这样的同步机制），不允许读到非latest值。</p>
<blockquote>
<p>这就是<strong>线性一致性背后的直觉</strong>。 正式的定义【6】更准确地描述了它。<br>
<strong>通过记录所有请求和响应的时序</strong>，并<strong>检查它们是否可以排列成有效的顺序</strong>，测试一个系统的行为是否线性一致性是可能的（尽管在计算上是昂贵的）【11】。</p>
</blockquote>
<h4 id="可线性化不是可序列化">可线性化不是可序列化</h4>
<p>可线性化是寄存器读到最新值的保证。<br>
可序列化是事务的并发执行结果和非并发执行结果完全相同的保证。</p>
<p>一个数据库可以提供可串行性和线性一致性，这种组合被称为严格的可串行性或强的单副本强可串行性（strong-1SR）【4,13】。基于两阶段锁定的可串行化实现（参见“[两阶段锁定（2PL）][2]”一节）或实际串行执行（参见第“[实际串行执行][3]”）通常是线性一致性的。</p>
<h3 id="依赖线性一致性的场景">依赖线性一致性的场景</h3>
<p>线性一致性在什么情况下有用？</p>
<p>下面讲了三种我们实际上<strong>需要 linearizability</strong>，但是我们很难意识到的场景。</p>
<h4 id="锁定和领导选举">锁定和领导选举</h4>
<p>所有的<strong>锁操作都强依赖于可线性化</strong>（而不是反过来），否则会出现问题（Redis 的主从复制方案不满足线性化，所以在自动主从切换的时候会出问题）。</p>
<ol>
<li>一个使用主从复制的系统，需要确保领导真的只有一个，而不是几个（脑裂）。</li>
<li>一种选择领导者的方法是使用锁：每个节点在启动时尝试获取锁，成功者成为领导者。</li>
<li>这个锁是如何实现的，它必须是线性一致的：所有节点必须就哪个节点拥有锁达成一致，否则就没用了。</li>
</ol>
<p>ZooKeeper 的线性一致性读是 sync() 后读；etcd 的读是法定票数读。</p>
<p>实践的例子：</p>
<ol>
<li>Apache Curator 提供了分布式锁、Leader 选举、共享计数器、分布式队列等实现。</li>
<li>Oracle Real Application Cluster 会把分布式锁放在事务的关键执行路径上。</li>
</ol>
<h4 id="约束和唯一性保证">约束和唯一性保证</h4>
<p>如何保证一个值全局唯一，<strong>即全局的唯一值插入或者满足全局的业务主键唯一</strong>？这个问题和上一个问题是等价的。</p>
<p>主键唯一性要求可线性化保证，外键或者其他属性约束则不要求一定线性化。</p>
<h4 id="跨信道的时序依赖">跨信道的时序依赖</h4>
<p>结论：把本地时钟戳或到达顺序当成全局顺序，在分布式环境下必然错序，出现竞态、重复处理、丢失补偿。</p>
<p><strong>如果端到端存在两个通信信道，如消息队列和数据库</strong>，则读消息队列 读到的数据可能和数据库里读到的数据库不一致。这时候也是需要让读这两个信道的客户端读到线性一致性的数据的。但本章提供的解决方案，只有异构共识算法可能解决这个问题。</p>
<p>现实之中通常使用<strong>版本加读修复</strong>的方式来部分解决这个问题。</p>
<h3 id="实现可线性化系统">实现可线性化系统</h3>
<p>几个思路：</p>
<ol>
<li>一个副本：不容错。</li>
<li>多个副本：注意复制机制，要用共识来控制复制流程。</li>
</ol>
<p>我们已知的复制机制：</p>
<ul>
<li>简单的主从复制：只从<strong>主节点或者全同步的从节点</strong>读，不考虑快照隔离则满足线性一致性。所以半同步复制的 MySQL 集群大部分时候是满足可线性化的。</li>
<li>共识算法：ZooKeeper 和 etcd 可以实现可线性化。</li>
<li>多主复制：不可以，因为写冲突。</li>
<li>无主复制：LWW 必定不是线性化的，因为网络不可靠可能导致乱序写。达不到因果一致性就更谈不上可线性化。</li>
</ul>
<h4 id="可线性化和-quorum">可线性化和 quorum</h4>
<p>本书讲了一个复杂的例子，从节点每次读之前都执行读修复，且主节点写之前先做 volatile 式的读。这个例子不可取，所以无主复制就是不可线性化的，即使满足<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>+</mo><mi>w</mi><mo>&gt;</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">r + w &gt; n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>。</p>
<table>
<thead>
<tr>
<th style="text-align:left">特性</th>
<th style="text-align:left">读写 Quorum (Dynamo-style)</th>
<th style="text-align:left">多数派 Quorum (Consensus-style)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>主要目标</strong></td>
<td style="text-align:left">数据新鲜度 (Freshness)</td>
<td style="text-align:left">全局共识 (Agreement), 单一真相</td>
</tr>
<tr>
<td style="text-align:left"><strong>系统模型</strong></td>
<td style="text-align:left">AP (高可用), Leaderless/Multi-Leader</td>
<td style="text-align:left">CP (强一致性), Single-Leader</td>
</tr>
<tr>
<td style="text-align:left"><strong>数学原理</strong></td>
<td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mo>+</mo><mi>R</mi><mo>&gt;</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">W+R&gt;N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> (保证读写集有交集)</td>
<td style="text-align:left">Quorum = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌊</mo><mi>N</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌋</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\lfloor N/2 \rfloor + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">⌋</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> (保证任意两个Quorum有交集)</td>
</tr>
<tr>
<td style="text-align:left"><strong>灵活性</strong></td>
<td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span> 可调，用于平衡读写性能</td>
<td style="text-align:left">固定为多数派，不可调整</td>
</tr>
<tr>
<td style="text-align:left"><strong>保证强度</strong></td>
<td style="text-align:left">最终一致性</td>
<td style="text-align:left">线性一致性 (强一致性)</td>
</tr>
<tr>
<td style="text-align:left"><strong>解决的问题</strong></td>
<td style="text-align:left">读到陈旧数据</td>
<td style="text-align:left">脑裂、数据不一致、操作乱序</td>
</tr>
<tr>
<td style="text-align:left"><strong>是否解决写冲突</strong></td>
<td style="text-align:left">不解决，需要额外机制</td>
<td style="text-align:left">通过排序来预防，所有写操作都通过Leader排队</td>
</tr>
</tbody>
</table>
<h3 id="可线性化的代价">可线性化的代价</h3>
<p>多数据中心的数据库之间的复制默认是多主异步复制。</p>
<p>如果我们要让数据中心满足可线性化，我们就要引入主从复制，但是不可抗拒网络中断。</p>
<p>所以可线性化对多数据中心而言是有代价的方案：共识算法+主从切换时牺牲可用性才可以做到。</p>
<p>所以 ZooKeeper 不适合放在跨 DC 的场景下使用，因为 DC 之间的网络中断对它的基于单主/选主的工作模式影响很大。</p>
<h4 id="cap-理论">CAP 理论</h4>
<p>CAP 没有准确的定论，A 的定义都存在争议，C <strong>专指可线性化</strong>，P 目前<strong>只能指节点网络中断但仍能单独工作，不考虑延迟、节点失败等其他折中</strong>。CAP 其实是鼓励大家探索无共享系统（不要共享硬件，做到 shared-nothing）。</p>
<p>只要内存、磁盘、电源、主板等硬件资源被多台机器共享，就可能出现“集体失联但数据仍在”的假象，从而绕过网络分区去破坏一致性；<br>
CAP 想讨论的纯粹是“网络消息不可靠”带来的权衡，所以必须把这类共享硬件漏洞排除在外 → 只能假设 shared-nothing。</p>
<h4 id="线性一致性和网络延迟">线性一致性和网络延迟</h4>
<p>虽然线性一致是一个很有用的保证，但实际上，线性一致的系统惊人的少。例如，<strong>现代多核CPU上的内存甚至都不是线性一致的</strong>，除非使用内存屏障或者 fenc 指令。这种不一致性是由 cache 和主存之间的异步刷新决定的，这种异步刷新至关重要。</p>
<p>由此反推，非常多的数据库不支持线性化算法<strong>主要是为了性能，而不是为了容错</strong>。</p>
<h2 id="顺序保证">顺序保证</h2>
<p>排序、可线性化和共识之间存在着某些深刻的联系。</p>
<h3 id="顺序与因果关系">顺序与因果关系</h3>
<p>顺序决定了因果关系，有些事件必须发生在某些事情之前（happens-before），这叫作因果一致性。<strong>快照隔离满足因果一致性</strong>，因为我们一旦能看到快照，就能看到快照的前序事件。</p>
<h4 id="因果关系并非全序-这一章是本书至关重要的点">因果关系并非全序（这一章是本书至关重要的点）</h4>
<h5 id="全序就是允许单一时间线排序">全序就是允许单一时间线排序</h5>
<p>全序（total order）支持任何两个元素之间进行比较，即全部的事件可以在一个时间线上简单线性排序-<strong>一个数轴上的自然数满足全序关系</strong>。</p>
<p>{a, b} 和{b, c}不满足全序关系，<strong>数学集合只能是偏序（partially order）</strong>。</p>
<h5 id="并发事件要使用单独时间线排序-偏序-因此也不满足可线性化">并发事件要使用单独时间线排序-偏序，因此也不满足可线性化</h5>
<p><strong>可线性化事件满足全序（但满足全序不等于可线性化事件）</strong>。一定存在一个时间线，让所有事件都并发执行。</p>
<p>并发时间线上的并发事件不可比较，但同一根并发的时间线上的事件可以被比较-想象 git 的分支模型，同一branch 上的事件都满足因果关系，但 git 的事件本身不是可线性化的。</p>
<h5 id="可线性化包含因果一致性-但强于因果一致性">可线性化包含因果一致性，但强于因果一致性</h5>
<p>非可线性化的因果一致性（Causal Consistency）是三种一致性模型里面最弱的，<strong>算是在网络延迟中可以被接受的，可以容错的最强一致性模型</strong>。很多时候看起来需要可线性化的场景，<strong>真正需要的是因果一致性</strong>，正如我们上面看到的 git 的选择就是因果一致性。</p>
<h5 id="捕获因果依赖关系">捕获因果依赖关系</h5>
<p>我们需要一些手段来描述节点知道的“知识”：哪些事件发生在哪些事件之前。<strong>建立因果关系最简单的方法是使用在写操作时对读的数据标定版本-序列号，百试百灵。</strong></p>
<h3 id="序列号排序">序列号排序</h3>
<p>序列号是一种逻辑时钟，区块的 pre-transaction 是另一种（但链表结构不可简单排序）。</p>
<p>我们需要一个真正的自增算法，让发生在前的事件拥有更小的序列号。</p>
<p>binlog 就使用单调递增的序号（LSN）来标记操作。我们可以使用<strong>单一的 seq在 MySQL 的 log 里看到严格递增</strong>的时间顺序，但是我们无法在分布式seq里依赖趋势递增的序列号达到目的。</p>
<h4 id="非因果序列发生器">非因果序列发生器</h4>
<p>如果没有单一的序列号生成的主节点，可以产生各自独立的序列号：</p>
<ul>
<li>不同的机器产生奇偶序列号</li>
<li>使用墙上时钟-会发生 LWW</li>
<li>预先分配序列号的区间范围：一个节点产生1-1000；另一个节点产生1001-2000。</li>
</ul>
<p>这些序列号无法正确<strong>捕获跨节点操作的顺序</strong>，只能捕获本节点操作的偏序。</p>
<h4 id="lamport-时间戳">Lamport 时间戳</h4>
<p>这个方案可以<strong>捕捉因果一致性（Causal Consistency）</strong>，不能捕获更强的一致性。</p>
<ol>
<li>每个服务器节点为每个主键维护（已处理的请求数，节点 id）。</li>
<li>每个写操作<strong>携带自己已知的版本</strong>，如果该版本大于当前服务器节点的版本，则使用此版本加 1 作为数据的最新版本，否则使用服务器自己使用的版本加 1 作为数据的最新版本。</li>
<li>返回最新版本给客户端，以备下次写请求携带。</li>
<li>比对版本时先比对版本，版本越高时间戳越大；其次比对节点 id，节点 id 越高时间戳越大。</li>
</ol>
<p>Lamport 时间戳虽然能够告诉我们全序，但我们无法区分两个事件是并发的，还是有因果关系的。</p>
<p><img src="fig9-8.png" alt="拥有因果一致性的全序-Lamport时间戳可以保证全序与因果关系一致"></p>
<p>DDIA的原话是：</p>
<blockquote>
<p>版本向量和 Lamport 时间戳目的不同：版本向量用以区分两个操作是并发还是因果依赖，而 Lamport 时间戳主要用于确保全序关系。即使<br>
Lamport 时间戳与因果序一致，但根据其全序关系却无法区分两个操作属于并发关系，还是因果依赖关系。</p>
</blockquote>
<p>但是Kimi的观点是：</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>Lamport 时钟 (Lamport Clock)</th>
<th>Lamport 时间戳 (Lamport Timestamp)</th>
</tr>
</thead>
<tbody>
<tr>
<td>本质</td>
<td>算法/机制：单整数计数器 + 两条更新规则</td>
<td>数据/值：计数器当前读数 <code>(counter, nodeId)</code> 对</td>
</tr>
<tr>
<td>作用</td>
<td>生成并维护逻辑时钟，为事件定序</td>
<td>为某一具体事件打标签，供比较先后</td>
</tr>
<tr>
<td>数据结构</td>
<td>一个整数 <code>counter</code></td>
<td>一个元组 <code>(counter, nodeId)</code></td>
</tr>
<tr>
<td>是否算法</td>
<td>✅ 是算法（含发送/接收规则）</td>
<td>❌ 不是算法，只是算法输出的值</td>
</tr>
<tr>
<td>是否含节点ID</td>
<td>❌ 计数器本身仅整数；通常额外携带节点ID</td>
<td>✅ 元组内显含节点ID，用于打破全局同值</td>
</tr>
<tr>
<td>功能范围</td>
<td>产生时间戳 + 更新自己 + 推进他人</td>
<td>只负责“被比较”：提供全序关系</td>
</tr>
<tr>
<td>能否检测并发</td>
<td>❌ 不能，只能给出全序</td>
<td>❌ 同左（单整数无法区分并发）</td>
</tr>
<tr>
<td>空间开销</td>
<td>O(1) 整数</td>
<td>O(1) 两个整数</td>
</tr>
<tr>
<td>常见称呼</td>
<td>LC、Lamport Clock、Lamport Logic Clock</td>
<td>Lamport timestamp、LC value</td>
</tr>
<tr>
<td>关系</td>
<td>时钟是“发动机”，时间戳是“产出物”——二者常混用指同一机制</td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="时间戳排序依然不够">时间戳排序依然不够</h4>
<p>在这里举了一个注册用户的例子。</p>
<p>我们可以通过 lamport 时间戳收集全序时间戳。这意味着，我们要知道用户名是不是冲突，我们要让所有创建用户请求汇集到一起（<strong>让请求汇集到一点，很容易丧失容错性</strong>），才能知道操作之间的全序关系。</p>
<p>为了确保结果是全局唯一的，需要在收集所有确定的信息的基础上做全局排序，这样的全局排序才有意义。</p>
<p>而且这种全局排序在确定以后，要让需要确定的人了解，所以我们会看到全序关系广播。</p>
<h3 id="全序关系广播-total-order-broadcast">全序关系广播（total order broadcast）</h3>
<p>主从复制的经典流程是：选取一个主节点，它维护日志的事件写入顺序，并严格按照这个顺序广播给其他从节点。如果主从复制能够<strong>解决单一主节点的吞吐量和节点失效时的限制</strong>，它就是全序关系广播或者原子广播。</p>
<p>原子广播要保证：所有消息<strong>严格按照顺序</strong>（不允许中途插入数据扰乱顺序），<strong>一条不漏地到达所有节点</strong>（即使网络有问题也要引入大重试）。</p>
<h4 id="使用全序关系广播">使用全序关系广播</h4>
<p><strong>数据库使用全序关系广播，可以实现状态机复制（state machine replication）</strong>。</p>
<p>有了全序关系广播，必然带来日志，写日志的编号可以产生序列号或者 fencing token-这就要求写请求耦合在写日志流程里。</p>
<h4 id="使用全序广播实现线性一致性存储">使用全序广播实现线性一致性存储</h4>
<p>全序广播的定义要求可靠+全序，对同步/异步无限制。但在本书中，认为它基于异步模型，但异步崩溃-中止模型下全序广播等价共识→FLP 不可能；工程上必须引入时钟、重试或部分同步才能活。</p>
<p>ZAB 本身就是异步 pipeline 复制（leader 先写本地就 ack，follower 异步追），并非同步模型。</p>
<p>我们回忆一下，什么是可线性化：可线性化是类似在一个节点里读写，在一个读节点读到最新值以后，其他节点都只能读到最新值。甚至可以认为，写返回后，必然读到最新值是可线性化的一种形式。</p>
<p><strong>全序关系广播等价于共识</strong>。线性化读写寄存器如果解决 atomic cas 问题，则等价于共识问题。</p>
<p>可以通过将全序广播当成仅追加日志的方式来实现这种线性一致的CAS操作：</p>
<ol>
<li>在日志中追加一条消息，试探性地指明你要声明的用户名。</li>
<li>读日志，广播它们，<strong>等待回复</strong>。</li>
<li>检查是否有任何消息声称目标用户名的所有权。如果这些消息中的第一条就是你自己的消息，那么你就成功了：你可以提交声称的用户名（也许是通过向日志追加另一条消息）并向客户端确认。如果所需用户名的第一条消息来自其他用户（<strong>理论上如果在其他系统发生了状态冲突，必然发生一个冲突，所以这里实际上比对的不是第一条，而是唯一一条，类似 2PC 的 participant 投票中止</strong>），则中止操作。</li>
</ol>
<p>**全序广播可以实现顺序一致性（因为不同的节点同步完成的时间不一样），它可以实现写的线性化，不能实现读的线性化。**全序广播本身只保证日志全序；要线性化读写需在读路径也加一次同步点。</p>
<p>这里提供了顺序一致性/时间线一致性，强于因果一致性，弱于线性一致性。</p>
<p>顺序一致性也存在一个时间线，每个客户端始终始终可以满足单调读（即不回退）和前缀一致读（即所有客户端都读到 1、2、3，而不是有的客户端只读到 1、3），但不能满足读到新版本的时间线顺序完全一致（即有的客户端 1 读到 2 时，还有客户端 2 会读到 1，但最终客户端 2 会读到 2）。</p>
<h4 id="使用线性一致性存储实现全序广播">使用线性一致性存储实现全序广播</h4>
<p>这一步和上一步正好反过来。</p>
<p>最简单的方法是假设你有一个线性一致的寄存器来存储一个整数，并且有一个原子自增并返回操作。或者原子CAS操作也可以完成这项工作。</p>
<p>该算法很简单：</p>
<ol>
<li>每个要通过全序广播发送的消息首先对线性一致寄存器执行自增并返回操作。</li>
<li>然后将从寄存器获得的值作为序列号附加到消息中。</li>
<li>然后你可以将消息发送到所有节点（重新发送任何丢失的消息），而收件人将按序列号回复消息。</li>
</ol>
<p>这个算法的难点，就是如何正确地实现分布式场景下的原子 CAS。</p>
<p>全序广播（多轮共识，每一轮消息都是一轮共识） ⇔ 线性化寄存器 + (CAS 或 increment-and-get) ⇔ 共识问题<br>
三者互相可构造，因而落在同一难度层级——这是分布式系统里最深刻的可互换结论。</p>
<h2 id="分布式事务与共识">分布式事务与共识</h2>
<p>需要解决共识问题的问题：</p>
<ol>
<li>领导选举</li>
<li>原子提交（atomic commitment 也就是我们经常要解决的分布式事务问题，问题是跨节点/分区的原子性问题）</li>
</ol>
<p><strong>FLP 不可能定律，假定我们不能使用超时检测机制或者时钟</strong>。如果我们可以使用超时，我们可以达到稳定共识。</p>
<h3 id="原子提交与二阶段提交-2pc">原子提交与二阶段提交（2PC）</h3>
<p>2pc 也是一种共识算法-虽然不优秀，经常用来实现原子提交问题。</p>
<h4 id="从单节点到分布式原子提交">从单节点到分布式原子提交</h4>
<p>原子提交可以防止系统状态被破坏，对于多对象事务修改二级索引（特别是基于词条的索引而不是基于文档的索引）特别重要。</p>
<p><strong>事务提交必须是不可撤销的</strong> —— 事务提交之后，你不能改变主意，并追溯性地中止事务。这个规则的原因是，一旦数据被提交，<strong>其结果就对其他事务可见</strong>，因此其他客户端可能会开始依赖这些数据。</p>
<p>提交事务的结果有可能通过事后执行另一个补偿事务来取消，但从数据库的角度来看，这是一个单独的事务，因此任何关于<strong>跨事务正确性的保证都是应用自己的问题</strong>。</p>
<h4 id="两阶段提交">两阶段提交</h4>
<p><img src="2pc.png" alt="2pc.png"></p>
<p>正常情况下，2PC事务以应用在多个数据库节点上读写数据开始。</p>
<p>我们称这些数据库节点为参与者（participants/cohort）。当（经过一系列的预先的本地 write data，类似 MySQL 的更新内存页）应用准备提交时，协调者开始阶段 1 ：</p>
<p>它发送一个准备（prepare）请求到每个节点，询问它们是否能够提交。</p>
<p>然后协调者会跟踪参与者的响应：</p>
<ol>
<li>如果所有参与者都回答“是”，表示它们已经准备好提交，那么协调者在阶段 2 发出提交（commit）请求，然后提交真正发生。</li>
<li>如果任意一个参与者回复了“否”，则协调者在阶段2 中向所有节点发送中止（abort）请求。</li>
</ol>
<h4 id="系统的承诺">系统的承诺</h4>
<ol>
<li>所有的本地事务依赖于一个全局的 txid，会把这个 txid 附在本地事务上。</li>
<li>所有的本地事务答应 commit 后，锁定资源，而且不会放弃事务（<strong>不可撤销</strong>，放弃撤销权）。</li>
<li>协调者做出决定后，要<strong>把决定写入 wal 中</strong>。这个时刻被称作提交点（commit point）。</li>
<li>一旦协调者的决定落盘，提交或放弃请求会发送给所有参与者。如果这个请求失败或超时，协调者必须永远保持重试，直到成功为止。没有回头路：如果已经做出决定，不管需要多少次重试它都必须被执行。如果参与者在此期间崩溃，事务将在其恢复后提交——由于参与者投了赞成，因此恢复后它不能拒绝提交。<strong>尽最大努力通知，不可撤销。</strong></li>
</ol>
<p>单节点原子提交将这两个事件合二为一：写入事务日志即提交。redo log 的 prepare 写 binlog 和 commit，<strong>这个最后一个 commit 等于两个不可撤销的操作合在一起。</strong></p>
<h4 id="协调者故障">协调者故障</h4>
<p>在第一阶段参与者故障会造成系统故障，在第二阶段协调者故障会造成系统阻塞-参与者不能自行决定。所以要尽快恢复协调者，依靠日志尽快让系统从阻塞中恢复。</p>
<h4 id="三阶段提交">三阶段提交</h4>
<p>作为2PC的替代方案，已经提出了一种称为三阶段提交（3PC）的算法。然而，3PC假定网络延迟有界，节点响应时间有限；在大多数具有无限网络延迟和进程暂停的实际系统中，它并不能保证原子性。</p>
<p>通常，非阻塞原子提交需要一个完美的故障检测器（perfect failure detector）。</p>
<h3 id="实践中的分布式事务">实践中的分布式事务</h3>
<p>分布式事务性能不好，因为：</p>
<ol>
<li>写文件系统。</li>
<li>网络往返。</li>
<li>可能存在的阻塞点，而超时本身是不可靠的。</li>
</ol>
<h4 id="恰好一次的消息处理">恰好一次的消息处理</h4>
<p>exactly-once 有两种方法：</p>
<ol>
<li>at-least-once + 幂等</li>
<li>分布式事务在异构系统（mq + db）中实现副作用回滚</li>
</ol>
<h4 id="xa事务">XA事务</h4>
<p>X/Open XA（扩展架构（eXtended Architecture）的缩写）是<strong>跨异构技术实现两阶段提交</strong>的标准。</p>
<p>XA不是一个网络协议——它只是一个用来与事务协调者连接的C API。其他语言也有这种API的绑定；例如在Java EE应用的世界中，XA事务是使用Java事务API（JTA, Java Transaction API）实现的，而许多使用Java数据库连接（JDBC, Java Database Connectivity）的数据库驱动，以及许多使用Java消息服务（JMS）API的消息代理都支持Java事务API（JTA）。</p>
<h4 id="停顿时持有锁">停顿时持有锁</h4>
<p>在全局提交以前，本地事务不会释放锁。如果要避免永久加锁，可能需要手工处理。</p>
<h4 id="从协调者故障中恢复">从协调者故障中恢复</h4>
<p>孤立（orphaned）的存疑事务确实会出现。</p>
<p>唯一的出路是让管理员手动决定提交还是回滚事务。管理员必须检查每个存疑事务的参与者，确定是否有任何参与者已经提交或中止，然后将相同的结果应用于其他参与者。解决这个问题潜在地需要大量的人力，并且可能发生在严重的生产中断期间（不然为什么协调者处于这种糟糕的状态），并很可能要在巨大精神压力和时间压力下完成。</p>
<p>许多XA的实现都有一个叫做启发式决策（heuristic decistions）的紧急逃生舱口：允许参与者单方面决定放弃或提交一个存疑事务，而无需协调者做出最终决定。要清楚的是，这里启发式是可能破坏原子性（probably breaking atomicity）的委婉说法，因为它违背了两阶段提交的系统承诺-<strong>不单独决定，自行放弃事务</strong>。</p>
<h4 id="分布式事务的限制">分布式事务的限制</h4>
<ol>
<li>协调者是系统的单点。</li>
<li>协调者不是无状态的。</li>
<li>xa 要兼容死锁的状态协议。</li>
<li>分布式事务有扩大失效（amplifying failures）的趋势，这又与我们构建容错系统的目标背道而驰。</li>
</ol>
<h3 id="容错共识">容错共识</h3>
<p>一个或多个节点可以提议（propose）某些值，而共识算法决定（decides）采用其中的某个值。</p>
<p>共识里的节点是指进程。</p>
<ol>
<li>一致同意（Uniform agreement）：没有两个节点的决定不同。</li>
<li>诚实性（Integrity）：没有节点决定两次，也不能反悔。比如 Raft 里的每个 candidate 做了投票以后，就要乖乖地做 follower。</li>
<li>有效性（Validity）：如果一个节点决定了值 v ，则 v 由某个节点所提议。</li>
<li>终止（Termination）：由所有未崩溃的节点来最终决定值。</li>
</ol>
<p>其中 1、2、3 是 safety，4 是容错共识所必须有的 liveness。</p>
<p>如果你不关心容错，那么满足前三个属性很容易：你可以将一个节点硬编码为“独裁者”，并让该节点做出所有的决定。终止属性正式形成了容错的思想。它实质上说的是，一个共识算法不能简单地永远闲坐着等死 —— 换句话说，它必须取得进展。</p>
<p>共识的系统模型假设，当一个节点“崩溃”时，它会突然消失而且永远不会回来。<strong>在这个系统模型中，任何需要等待节点恢复的算法都不能满足终止属性。特别是，2PC不符合终止属性的要求。</strong></p>
<p>当然如果所有的节点都崩溃了，没有一个在运行，那么所有算法都不可能决定任何事情。算法可以容忍的失效数量是有限的：事实上可以证明，任何共识算法都需要至少占总体多数（majority）的节点正确工作，以确保终止属性。</p>
<p>克服拜占庭故障，稳健地达成共识是可能的，<strong>只要少于三分之一的节点存在拜占庭故障（pow 算法不受此限制）</strong>。</p>
<h4 id="共识算法与全序广播">共识算法与全序广播</h4>
<p>VSR、Paxos、Raft 和 Zab。</p>
<p>本书最重要的结论之一：这些算法的本质不是“先提议，再决定”，而是“<strong>先决定（决定的就是它在全局日志中的位置，随后按此位置广播），然后做全序关系广播</strong>”。</p>
<p>具体地，一个广播有多条消息，每条消息是按照相同的顺序发送到所有节点，有且只有一次。如果仔细想想，<strong>这其实相当于进行了多轮的共识过程</strong>：在每一轮，节点提出他们接下来想要的发送的消息，然后决定下一个消息的发送顺序（message 和 order 的顺序每轮变一次）。</p>
<p><strong>全序广播相当于持续的多轮共识</strong>（<strong>每一轮共识对应于一条消息</strong>）：</p>
<ol>
<li>由于协商一致性：所有节点决定以相同的顺序发送相同的消息。</li>
<li>由于诚实性：消息不能重复（或出现反悔）。</li>
<li>由于合法性：消息不会被破坏，也不是凭空捏造的（所以不能防拜占庭错误）。</li>
<li>由于可中止性：消息不会丢失，liveness 一定会发生。</li>
</ol>
<p>ViewStampReplication，Raft 和 Zab 直接实现了全序广播，因为这样做比重复一次一值（one value a time）的共识更高效。在 Paxos 的情况下，这种优化被称为Multi-Paxos。</p>
<h4 id="主从复制与共识">主从复制与共识</h4>
<p>单纯的主从复制即“独裁类型的”，不可容错的共识算法，只使用了基本的全序广播。要制造 termination，就要求“总是能选出主节点”。</p>
<p>奇怪的循环：要有一个主节点，我们首先要有一个主节点帮助选举。</p>
<h4 id="epoch-和-quorum">Epoch 和 Quorum</h4>
<p>目前这些共识协议都定义了一个形式化的主节点，然后定义了一个<strong>时代编号</strong>（epoch number），对应于 Paxos 中的 ballot number，VSP 中的 view number，Raft 中的 term number，并且<strong>在每个世代里，主节点是唯一的。</strong> term 是一个全局的 version，和 Lamport 时钟里的版本号类似，但又不太一样。出现 term 的算法，要假定算法要么有全局生成 term 的能力，要么有全局维护 term 递增的机制。</p>
<p>如果主节点失效，节点就开始投票选主节点，选举会赋予一个单调递增的 epoch 号。</p>
<p>如果存在两个互相冲突的主节点，则拥有高 epoch 的主节点会获胜。</p>
<p>主节点成立后，会进行两轮投票：</p>
<ol>
<li>首先投票谁是主节点-epoch投票能产生初始的主节点。</li>
<li>对主节点的提议进行投票-主节点使用 proposal 让其他集群得到自己的主节点。</li>
</ol>
<p>这两轮投票来自于 quorum，quorum 之间要重叠（至少有一个节点既选出了这个主节点，也同意了主节点的提议），<strong>这样可以保证目前已知的 epoch 是最高的</strong>，而且 quorum 的数量要满足多数。</p>
<h4 id="共识的局限性">共识的局限性</h4>
<p>共识可以提供全序关系广播，以容错的方式实现线性化的原子操作。从另一个角度来讲共识可看成‘能终止的、基于 quorum 投票’的 2PC 变种，但终止性而非投票比例才是本质差异。2pc 自己就带着一个对 proposal 投票的机制，但 2pc 要求全票通过，共识算法只要求 quorum 投票通过。</p>
<p>本书最重要的结论：<strong>主流工程共识算法（Raft/Zab/VSR） 的典型路径 = 先选主 + 再由主做总序广播</strong>，但选主并非共识定义的一部分。</p>
<p>共识的单轮决定可用来实现原子 CAS；若再配合读同步，则整个寄存器满足线性化。</p>
<p>广播链路可以是异步 pipeline（Leader 本地追加即 ack），也可同步等待 quorum 落盘；ballot/term 等<strong>逻辑编号</strong>与同步策略无关。</p>
<p>Basic Paxos 未定义成员变更；Raft 等现代算法支持 joint-consensus 在线扩缩容，但实现复杂度较高，早期 ES 版本选择离线重启方式。</p>
<p>动态选举若缺乏随机退避或预投票，可能出现短暂活锁；成熟算法通过随机超时等手段最终必收敛。</p>
<h3 id="成员与协调服务">成员与协调服务</h3>
<p>ZooKeeper 与 etcd 都针对保存少量的、可以载入内存的数据而设计。</p>
<p>ZooKeeper 可以提供如下特性：</p>
<ol>
<li>线性一致性的原子操作（唯一需要共识算法的功能）</li>
<li>操作的全序排序</li>
<li>失效检测</li>
<li>变更通知</li>
</ol>
<p>服务发现领域可以实现线性一致性，但不需要，因为它的性能负担大到不切实际的地步。</p>
<p>成员服务是“真理掌握在大多数人身上”的一个好例子，所以成员服务也可以使用 ZooKeeper。</p>
<h2 id="附带-paxos-的一个简单流程">附带 Paxos 的一个简单流程</h2>
<pre><code class="hljs mermaid">sequenceDiagram
    participant Client
    participant Proposer
    participant Acceptor1 as Acceptor A
    participant Acceptor2 as Acceptor B
    participant Acceptor3 as Acceptor C

    Note over Client,Proposer: Phase 1: Prepare / Promise

    Client-&gt;&gt;Proposer: 提议值 V (e.g. &quot;Leader=X&quot;)
    Proposer-&gt;&gt;Proposer: 选择提案编号 N (唯一递增)
    Proposer-&gt;&gt;Acceptor1: Prepare(N)
    Proposer-&gt;&gt;Acceptor2: Prepare(N)
    Proposer-&gt;&gt;Acceptor3: Prepare(N)

    Acceptor1--&gt;&gt;Proposer: Promise(N, 最高已接受编号 n_a, 值 v_a)
    Acceptor2--&gt;&gt;Proposer: Promise(N, n_b, v_b)
    Acceptor3--&gt;&gt;Proposer: Promise(N, n_c, v_c)

    Note over Proposer: 若收到多数派 Promise，&lt;br&gt;则选择值：&lt;br&gt; - 若有已接受值，选编号最大者&lt;br&gt; - 否则用客户端提议值 V

    Note over Client,Proposer: Phase 2: Accept / Accepted

    Proposer-&gt;&gt;Acceptor1: Accept(N, chosen_value)
    Proposer-&gt;&gt;Acceptor2: Accept(N, chosen_value)
    Proposer-&gt;&gt;Acceptor3: Accept(N, chosen_value)

    Acceptor1--&gt;&gt;Proposer: Accepted(N)
    Acceptor2--&gt;&gt;Proposer: Accepted(N)
    Acceptor3--&gt;&gt;Proposer: Accepted(N)

    Note over Proposer: 收到多数派 Accepted →&lt;br&gt;值 chosen_value 已达成共识！

    Proposer-&gt;&gt;Client: 值已提交：chosen_value

    Note right of Acceptor1: Acceptor 规则：&lt;br&gt;1. 只 Promise ≥ 已见最大编号&lt;br&gt;2. 只 Accept ≥ 已 Promise 编号&lt;br&gt;3. 一旦 Accept，必须记录 (N, value)</code></pre>
<ol>
<li>系统初始启动，无任何历史提案；客户端请求设置初始值 V_initial（如 “Leader=A”），首个 Proposer（如 Proposer A）为此分配槽位 slot=1，生成不应假设已选定单一主 Proposer，标准 Paxos 允许多个 Proposer 并发竞争，依靠提案编号解决冲突。</li>
<li>Proposer 选择一个全局唯一且递增的提案编号 N1=100，向多数派 Acceptor（如 3/5） 发送 Prepare(1, 100)，仅含槽位与编号，用于探测历史并锁定提案资格；此时 Learner（作为独立预设角色）尚未被激活，因共识尚未形成，无值可学N) 请求，不是发给所有。</li>
<li>所有被请求的 Acceptor 检查 slot=1 无历史记录，均回复 Promise(1, 100, null)；Proposer A 收到多数空响应，确认无历史负担，采用客户端值，发送 Accept(1, 100, “Leader=A”)；Acceptor 收到后验证无更高编号承诺，接受并持久化 (slot=1, 100, “Leader=A”) —— 此时单个 Acceptor 可选择通知 Learner，但共识未完成，Learner 不做最终确认。</li>
<li>当多数派 Acceptor（≥3 个）均接受 (slot=1, 100, “Leader=A”)，slot=1 的值正式达成共识；此时，Acceptor 可主动广播 Accepted 消息给预配置的 Learner，或由 Learner 主动轮询多数派 Acceptor 获取并交叉验证值 —— Learner 确认一致后，记录该值为“已学习”，对外提供读服务；Learner 始终不参与投票或提案，仅被动或主动“学习”已稳定共识的结果。</li>
<li>客户端后续请求更新为 V_new（如 “Leader=B”），新 Proposer（如 Proposer B）分配新槽位 slot=2，生成更高编号 N2=200，发送 Prepare(2, 200)；Acceptor 检查 slot=2 无历史，回复 Promise(2, 200, null)；Proposer B 发送 Accept(2, 200, “Leader=B”)；Acceptor 接受并记录；当多数派接受后，再次触发 Learner 学习机制 —— 无论通过推送或拉取，Learner 获取 slot=2 的共识值，追加到本地序列。</li>
<li>Learner 按槽位顺序（slot1→slot2→…）维护值序列，重建系统状态演进（如 “Leader=A” → “Leader=B”）；多个 Learner 可独立存在，各自从多数派 Acceptor 学习相同序列，无需彼此通信；系统通过追加新槽位实现状态安全演进，旧槽位值不可修改，Learner 仅读取已共识的稳定值，不干预提案或接受过程，确保职责分离与系统可扩展性。</li>
</ol>
<pre><code class="hljs mermaid">sequenceDiagram
    participant Client
    participant Proposer
    participant Acceptor1 as Acceptor A
    participant Acceptor2 as Acceptor B
    participant Acceptor3 as Acceptor C
    participant Learner

    Note over Client,Proposer: Slot 1: 初始共识

    Client-&gt;&gt;Proposer: 请求设置值 V1=&quot;Leader=A&quot;
    Proposer-&gt;&gt;Proposer: 分配 slot=1, 选编号 N1=100
    Proposer-&gt;&gt;Acceptor1: Prepare(1, 100)
    Proposer-&gt;&gt;Acceptor2: Prepare(1, 100)
    Proposer-&gt;&gt;Acceptor3: Prepare(1, 100)

    Acceptor1--&gt;&gt;Proposer: Promise(1, 100, null)
    Acceptor2--&gt;&gt;Proposer: Promise(1, 100, null)
    Acceptor3--&gt;&gt;Proposer: Promise(1, 100, null)

    Proposer-&gt;&gt;Acceptor1: Accept(1, 100, &quot;Leader=A&quot;)
    Proposer-&gt;&gt;Acceptor2: Accept(1, 100, &quot;Leader=A&quot;)
    Proposer-&gt;&gt;Acceptor3: Accept(1, 100, &quot;Leader=A&quot;)

    Acceptor1-&gt;&gt;Learner: Accepted(1, 100, &quot;Leader=A&quot;) (可选通知)
    Acceptor2-&gt;&gt;Learner: Accepted(1, 100, &quot;Leader=A&quot;)
    Acceptor3-&gt;&gt;Learner: Accepted(1, 100, &quot;Leader=A&quot;)

    Learner-&gt;&gt;Learner:收到 Prepare(N) 后，若 N 大于它已响应过的所有 Prepare 编号，则回复 Promise，包含它已接受的最大编号提案值（若有），并承诺不再接受编号小于 N 的提案；否则忽略或拒绝该 Prepare。
4. Proposer 收集到多数派 → 学习 slot1=&quot;Leader=A&quot;
    Learner-&gt;&gt;Client: 返回当前值 &quot;Leader=A&quot;

    Note over Client,Proposer: Slot 2: 更新共识

    Client-&gt;&gt;Proposer: 请求设置值 V2=&quot;Leader=B&quot;
    Proposer-&gt;&gt;Proposer: 分配 slot=2, 选编号 N2=200
    Proposer-&gt;&gt;Acceptor1: Prepare(2, 200)
    Proposer-&gt;&gt;Acceptor2: Prepare(2, 200)
    Proposer-&gt;&gt;Acceptor3: Prepare(2, 200)

    Acceptor1--&gt;&gt;Proposer: Promise(2, 200, null)
    Acceptor2--&gt;&gt;Proposer: Promise(2, 200, null)
    Acceptor3--&gt;&gt;Proposer: Promise(2, 200, null)

    Proposer-&gt;&gt;Acceptor1: Accept(2, 200, &quot;Leader=B&quot;)
    Proposer-&gt;&gt;Acceptor2: Accept(2, 200, &quot;Leader=B&quot;)
    Proposer-&gt;&gt;Acceptor3: Accept(2, 200, &quot;Leader=B&quot;)

    Acceptor1-&gt;&gt;Learner: Accepted(2, 200, &quot;Leader=B&quot;)
    Acceptor2-&gt;&gt;Learner: Accepted(2, 200, &quot;Leader=B&quot;)
    Acceptor3-&gt;&gt;Learner: Accepted(2, 200, &quot;Leader=B&quot;)

    Learner-&gt;&gt;Learner: 收集多数派 → 学习 slot2=&quot;Leader=B&quot;
    Learner-&gt;&gt;Client: 返回当前值 &quot;Leader=B&quot; (按最新槽位)</code></pre>
<ul>
<li>Lamport timestamp 和 Paxos 虽然解决的问题不同，但在分布式系统中处理顺序的方式存在深层相似性：
<ul>
<li>都用于在分布式系统中建立事件或操作的顺序，且都不依赖物理时钟，而是使用本地生成、可比较的标识符（逻辑时间戳或提案编号）来定义顺序。</li>
<li>都依赖消息传递来传播顺序信息：Lamport timestamp 通过在消息中携带时间戳更新接收方时钟，Paxos 通过在 Prepare/Accept 消息中携带提案编号协调 Acceptor 行为。</li>
<li>都采用“更大值胜出”的冲突解决策略：Lamport 用更大的时间戳表示逻辑上的“更晚”，Paxos 用更大的提案编号抢占旧提案，确保系统收敛。</li>
<li>都承认全局一致顺序的高代价，并在设计上做出权衡：Lamport 仅保证因果事件的偏序以提升可扩展性，Paxos 虽能实现全序但通信开销大，适用于对一致性要求极高的场景而非高吞吐日志复制。</li>
<li>在 DDIA 的框架下，两者共同体现了分布式系统的核心思想：在缺乏全局时钟和共享状态的环境中，通过递增标识符和消息传递，在局部协作中构建可靠的顺序语义。</li>
</ul>
</li>
</ul>
<h2 id="raft-的简单流程">Raft 的简单流程</h2>
<pre><code class="hljs mermaid">sequenceDiagram
    participant Client
    participant Proposer
    participant Acceptor1 as Acceptor A
    participant Acceptor2 as Acceptor B
    participant Acceptor3 as Acceptor C
    participant Learner

    Note over Client,Proposer: Slot 1: 初始共识

    Client-&gt;&gt;Proposer: 请求设置值 V1=&quot;Leader=A&quot;
    Proposer-&gt;&gt;Proposer: 分配 slot=1, 选编号 N1=100
    Proposer-&gt;&gt;Acceptor1: Prepare(1, 100)
    Proposer-&gt;&gt;Acceptor2: Prepare(1, 100)
    Proposer-&gt;&gt;Acceptor3: Prepare(1, 100)

    Acceptor1--&gt;&gt;Proposer: Promise(1, 100, null)
    Acceptor2--&gt;&gt;Proposer: Promise(1, 100, null)
    Acceptor3--&gt;&gt;Proposer: Promise(1, 100, null)

    Proposer-&gt;&gt;Acceptor1: Accept(1, 100, &quot;Leader=A&quot;)
    Proposer-&gt;&gt;Acceptor2: Accept(1, 100, &quot;Leader=A&quot;)
    Proposer-&gt;&gt;Acceptor3: Accept(1, 100, &quot;Leader=A&quot;)

    Acceptor1-&gt;&gt;Learner: Accepted(1, 100, &quot;Leader=A&quot;) (可选通知)
    Acceptor2-&gt;&gt;Learner: Accepted(1, 100, &quot;Leader=A&quot;)
    Acceptor3-&gt;&gt;Learner: Accepted(1, 100, &quot;Leader=A&quot;)

    Learner-&gt;&gt;Learner: 收集多数派 → 学习 slot1=&quot;Leader=A&quot;
    Learner-&gt;&gt;Client: 返回当前值 &quot;Leader=A&quot;

    Note over Client,Proposer: Slot 2: 更新共识

    Client-&gt;&gt;Proposer: 请求设置值 V2=&quot;Leader=B&quot;
    Proposer-&gt;&gt;Proposer: 分配 slot=2, 选编号 N2=200
    Proposer-&gt;&gt;Acceptor1: Prepare(2, 200)
    Proposer-&gt;&gt;Acceptor2: Prepare(2, 200)
    Proposer-&gt;&gt;Acceptor3: Prepare(2, 200)

    Acceptor1--&gt;&gt;Proposer: Promise(2, 200, null)
    Acceptor2--&gt;&gt;Proposer: Promise(2, 200, null)
    Acceptor3--&gt;&gt;Proposer: Promise(2, 200, null)

    Proposer-&gt;&gt;Acceptor1: Accept(2, 200, &quot;Leader=B&quot;)
    Proposer-&gt;&gt;Acceptor2: Accept(2, 200, &quot;Leader=B&quot;)
    Proposer-&gt;&gt;Acceptor3: Accept(2, 200, &quot;Leader=B&quot;)

    Acceptor1-&gt;&gt;Learner: Accepted(2, 200, &quot;Leader=B&quot;)
    Acceptor2-&gt;&gt;Learner: Accepted(2, 200, &quot;Leader=B&quot;)
    Acceptor3-&gt;&gt;Learner: Accepted(2, 200, &quot;Leader=B&quot;)

    Learner-&gt;&gt;Learner: 收集多数派 → 学习 slot2=&quot;Leader=B&quot;
    Learner-&gt;&gt;Client: 返回当前值 &quot;Leader=B&quot; (按最新槽位)</code></pre>
<ol>
<li>系统初始启动，所有节点均为 Follower，无 Leader，无已提交日志；当 Follower 在选举超时（如 150–300ms）内未收到来自 Leader 的心跳，它自增当前任期号 Term=1，转为 Candidate，向其他节点发送 RequestVote(Term=1, lastLogIndex=0, lastLogTerm=0) 请求投票，同时为自己投一票。</li>
<li>收到 RequestVote 的节点（仍为 Follower 或 Candidate）检查：若请求 Term ≥ 自己当前 Term，且请求方日志不比自己旧（Raft 日志完整性规则），则授予投票并重置选举超时；当 Candidate 收到包括自己在内的多数派选票（如 3/5），即当选 Leader，立即向所有节点广播空 AppendEntries(Term=1, prevLogIndex=0, entries=[]) 心跳，宣告领导权，阻止新选举。</li>
<li>客户端向 Leader 发起写请求（如 “SET Leader=A”），Leader 将该操作作为新日志条目追加到本地日志（log[1] = {Term:1, Command:“SET Leader=A”}），然后并行向所有 Follower 发送 AppendEntries(Term=1, prevLogIndex=0, entries=[log[1]])；Follower 收到后，若本地日志与 prevLogIndex/prevLogTerm 匹配，则追加条目并回复成功，否则拒绝。</li>
<li>Leader 收到多数派 Follower 对 log[1] 的成功响应后，将该日志条目标记为“已提交”，应用到本地状态机（执行 “SET Leader=A”），并向客户端返回成功；随后在下一次 AppendEntries 或心跳中，携带已提交索引（commitIndex=1），通知 Follower 也提交并应用该条目，确保所有节点状态最终一致。</li>
<li>若后续需更新值（如 “SET Leader=B”），客户端仍只与 Leader 交互；Leader 追加新条目（log[2] = {Term:1, Command:“SET Leader=B”}），复制到多数派，提交后应用；若期间发生 Leader 崩溃，剩余节点超时后发起新选举（Term=2），新 Leader 必须包含所有已提交日志（通过 RequestVote 中的日志比对机制保证），当选后继续复制未同步条目，系统在新任期下恢复服务，状态演进连续不丢失Promise 后，若任一 Acceptor 返回了已接受的值，则必须选择其中编号最大的值作为提案值 V；否则可使用客户端提议的值。然后向多数派 Acceptor 发送 Accept(N, V) 请求。</li>
<li>Acceptor 收到 Accept(N, V) 时，若未对编号大于 N 的提案做出过 Promise，则接受该提案并记录。Learner 通过监听 Acceptor 的 Accepted 消息或主动查询得知最终选定值，无需 Acceptor 主动广播同步。</li>
</ol>
<h1>数据派生系统</h1>
<p>在这最后一部分，我们要讨论将不同的数据系统（拥有不同的数据模型，针对不同的访问模式优化过）整合至一致的应用程序体系结构中。</p>
<p>存储与处理数据的系统从高层次分成两大类：</p>
<ol>
<li>记录系统：记录真实数据，拥有数据的权威版本。</li>
<li>派生数据系统：从一个系统获取数据，以某种方式转换或处理。</li>
</ol>
<p>派生数据包括：缓存里的数据、非规范数据、索引、实体化视图。<strong>派生数据是复制冗余，对于提高读性能很重要</strong>。</p>
<p>查询语言、存储引擎都不区分这两种系统，这种系统的区别在于，<strong>我们如何在应用程序中使用它们</strong>。</p>
<h1>批处理系统</h1>
<ol>
<li>在线服务：客户请求驱动，产生一个响应，主要衡量指标是响应时间和可用性。</li>
<li>批处理系统（离线系统）：大数据输入，处理任务单独启动。客户不等待处理完成。批处理定期执行。主要衡量指标是吞吐量。</li>
<li>流处理系统（近实时系统）：像批处理，处理输入而不是响应请求，流处理在事件发生后就开始处理，所以延迟更低。</li>
</ol>
<p>MapReduce 是我们要探讨的第一个例子，它并不比数仓的并行处理系统更优秀，但是实现了在商用硬件上可扩展的架构突破，仍然有研究的价值。</p>
<h2 id="使用-unix-工具进行批处理">使用 UNIX 工具进行批处理</h2>
<p>我们一开始先用一个 UNIX 工具链用管道命令串起来，其次我们用了一个 Ruby 程序来处理数据。这引出一个基本问题：</p>
<ol>
<li>在数据集大于工作内存时，排序方法的优点是高校使用磁盘，<strong>归并排序在磁盘上拥有良好的顺序访问模式</strong>，<strong>所以我们在内存里把可排序的段排好序写入磁盘再归并就可以了</strong>。</li>
</ol>
<h3 id="unix-的哲学">Unix 的哲学</h3>
<ol>
<li>让每个程序都做好一件事。要做一件新的工作，写一个新程序，而不是通过添加“功能”让老程序复杂化。</li>
<li>期待每个程序的输出成为另一个程序的输入。不要将无关信息混入输出。避免使用严格的列数据或二进制输入格式。不要坚持交互式输入。</li>
<li>设计和构建软件，甚至是操作系统，要尽早尝试，最好在几周内完成。不要犹豫，扔掉笨拙的部分，重建它们。</li>
<li>优先使用工具来减轻编程任务，即使必须曲线救国编写工具，且在用完后很可能要扔掉大部分。</li>
</ol>
<h4 id="统一接口">统一接口</h4>
<p>程序使用统一接口，则总能让一个程序的输出成为另一个程序的输入。</p>
<p>Unix 里，这个<strong>统一的输入输出接口</strong>就是文件（<strong>文件描述符</strong>）。</p>
<h4 id="逻辑与布线分离">逻辑与布线分离</h4>
<p>stdin 和 stdout 本身是可以切换实现的。本书讲的布线的意思似乎是我们可以切换这两个标准流的实际实现，而应用程序无感知。</p>
<p>Kimi 的解读：<br>
把「业务逻辑」与「数据/控制流向的拓扑结构」解耦，让代码功能<strong>不再硬编码在固定的调用链或部署拓扑里</strong>，从而可以随时重布线（重分区、重均衡、扩缩容）而不触动逻辑层。</p>
<h4 id="透明与测试">透明与测试</h4>
<p>“不可变 + 可见 + 可重放”的透明流水线，让实验成本趋近于零；<br>
Unix 命令行是这一哲学的原型，Hadoop 只是把它从单机扩展到千台节点。</p>
<h2 id="mapreduce-与分布式文件系统">MapReduce 与分布式文件系统</h2>
<p>MapReduce有点像Unix工具，但分布在数千台机器上。像Unix工具一样，它相当简单粗暴，但令人惊异地管用。一个MapReduce作业可以和一个Unix进程相类比：它接受一个或多个输入，并产生一个或多个输出-解决了单一的 stdin 和 stdout 的局限问题。</p>
<p>和大多数Unix工具一样，运行MapReduce作业通常不会修改输入，除了生成输出外没有任何副作用。</p>
<p>MapReduce 通常使用一个 HDFS 式的文件系统。Unix 工具：stdin → 程序 → stdout。MapReduce：HDFS 输入路径 → Mapper/Reducer → HDFS 输出路径。</p>
<p><strong>HDFS 让存算发生在同一个节点里，节省了带宽开销；但是对象存储通常存算分离。</strong></p>
<h3 id="mapreduce-作业执行">MapReduce 作业执行</h3>
<ol>
<li>读取一组输入文件，并将其分解成记录（records）。</li>
<li>调用Mapper函数，从每条输入记录中提取一对键值。</li>
<li>按键排序所有的键值对。</li>
<li>调用Reducer函数遍历排序后的键值对。</li>
</ol>
<p>这四个步骤可以作为一个MapReduce作业执行。步骤2（Map）和4（Reduce）是你编写自定义数据处理代码的地方，也就是实现 Mapper 和 Reducer。</p>
<h4 id="分布式执行mapreduce">分布式执行MapReduce</h4>
<p>MapReduce与Unix命令管道的主要区别在于，MapReduce可以在多台机器上并行执行计算，而无需编写代码来显式处理并行问题。</p>
<p>在分布式计算中可以使用标准的Unix工具作为Mapper和Reducer，但更常见的是，它们被实现为传统编程语言的函数。</p>
<p>作业的输入通常是HDFS中的一个目录，输入目录中的每个文件或文件块都被认为是一个单独的分区，可以单独处理map任务。MapReduce调度器（图中未显示）试图在其中一台存储输入文件副本的机器上运行每个Mapper，只要该机器有足够的备用RAM和CPU资源来运行Mapper任务。</p>
<p><img src="fig10-1.png" alt="具有三个Mapper和三个Reducer的MapReduce任务"></p>
<p>在大多数情况下，应该在Mapper任务中运行的应用代码在将要运行它的机器上还不存在，所以MapReduce框架首先将代码（例如Java程序中的JAR文件）复制到适当的机器。然后启动Map任务并开始读取输入文件，一次将一条记录传入Mapper回调函数。Mapper的输出由键值对组成。</p>
<p>计算的Reduce端也被分区。虽然Map任务的数量由输入文件块的数量决定，但Reducer的任务的数量是由作业作者配置的（它可以不同于Map任务的数量）。为了确保具有相同键的所有键值对最终落在相同的Reducer处，框架使用键的散列值来确定哪个Reduce任务应该接收到特定的键值对）。</p>
<p>键值对必须进行排序，但数据集可能太大，无法在单台机器上使用常规排序算法进行排序。相反，分类是分阶段进行的。首先每个Map任务都按照Reducer对输出进行分区。每个分区都被写入Mapper程序的本地磁盘，使用的技术与我们在“SSTables与LSM树”中讨论的类似。</p>
<p>只要当Mapper读取完输入文件，并写完排序后的输出文件，MapReduce调度器就会通知Reducer可以从该Mapper开始获取输出文件。Reducer连接到每个Mapper，并下载自己相应分区的有序键值对文件。按Reducer分区，排序，从Mapper向Reducer复制分区数据，这一整个过程被称为混洗（shuffle）【26】（一个容易混淆的术语 —— 不像洗牌，在MapReduce中的混洗没有随机性）。</p>
<p>Reducer调用时会收到一个键，和一个迭代器作为参数，迭代器会顺序地扫过所有具有该键的记录（因为在某些情况可能无法完全放入内存中）。Reducer可以使用任意逻辑来处理这些记录，并且可以生成任意数量的输出记录。这些输出记录会写入分布式文件系统上的文件中（通常是在跑Reducer的机器本地磁盘上留一份，并在其他机器上留几份副本）。</p>
<h4 id="mapreduce工作流">MapReduce工作流</h4>
<p>将MapReduce作业链接成为工作流（workflow）中是极为常见的，例如，一个作业的输出成为下一个作业的输入。 Hadoop Map-Reduce框架对工作流没有特殊支持，所以这个链是通过目录名隐式实现的：第一个作业必须将其输出配置为HDFS中的指定目录，第二个作业必须将其输入配置为从同一个目录。从MapReduce框架的角度来看，这是是两个独立的作业。</p>
<p>因此，被链接的MapReduce作业并没有那么像Unix命令管道（它直接将一个进程的输出作为另一个进程的输入，仅用一个很小的内存缓冲区）。它更像是一系列命令，其中每个命令的输出写入临时文件，下一个命令从临时文件中读取。这种设计有利也有弊，我们将在“实体化中间状态”中讨论。</p>
<p>只有当作业成功完成后，批处理作业的输出才会被视为有效的（MapReduce会丢弃失败作业的部分输出）。因此，工作流中的一项作业只有在先前的作业 —— 即生产其输入的作业 —— 成功完成后才能开始。为了处理这些作业之间的依赖，有很多针对Hadoop的工作流调度器被开发出来，包括Oozie，Azkaban，Luigi，Airflow和Pinball。</p>
<h3 id="reduce端连接与分组">Reduce端连接与分组</h3>
<p>分布式数据处理的难点在于 join。</p>
<p>因为 MapReduce 不支持索引，而我们如果需要跨表关联-如例子里的事实表和维度表的关联，则我们需要进行全表扫描。在例子里，如果我们要join，必然要遍历文件。与其遍历查询数据库，不如把数据库的记录副本记录到 NameNode 上。</p>
<p><img src="fig10-3.png" alt="在用户ID上进行的Reduce端连接。如果输入数据集分区为多个文件，则每个分区都会被多个Mapper并行处理"></p>
<p>当MapReduce框架通过键对Mapper输出进行分区，然后对键值对进行排序时，效果是具有相同ID的所有活动事件和用户记录在Reducer输入中彼此相邻。 Map-Reduce作业甚至可以也让这些记录排序，使Reducer总能先看到来自用户数据库的记录，紧接着是按时间戳顺序排序的活动事件 —— 这种技术被称为二次排序（secondary sort）。</p>
<p>然后Reducer可以容易地执行实际的连接逻辑：每个用户ID都会被调用一次Reducer函数，且因为二次排序，第一个值应该是来自用户数据库的出生日期记录。 Reducer将出生日期存储在局部变量中，然后使用相同的用户ID遍历活动事件，输出已观看网址和观看者年龄的结果对。随后的Map-Reduce作业可以计算每个URL的查看者年龄分布，并按年龄段进行聚集。</p>
<p>由于Reducer一次处理一个特定用户ID的所有记录，因此一次只需要将一条用户记录保存在内存中，而不需要通过网络发出任何请求。这个算法被称为排序合并连接（sort-merge join），因为Mapper的输出是按键排序的，然后Reducer将来自连接两侧的有序记录列表合并在一起。</p>
<ul>
<li>二次排序 = 让同一把键（用户 ID）里的记录再按“出生日期记录 &gt; 活动事件”排好队；</li>
<li>排序合并连接 = Reducer 只要顺序扫一遍这条队，就能把用户表和活动表拼在一起，内存只用一行。</li>
</ul>
<h4 id="将相关数据放在一起">将相关数据放在一起</h4>
<p>在排序合并连接中，Mapper和排序过程确保了所有对特定用户ID执行连接操作的必须数据都被放在同一个地方：单次调用Reducer的地方。预先排好了所有需要的数据，Reducer可以是相当简单的单线程代码，能够以高吞吐量和与低内存开销扫过这些记录。</p>
<p>这种架构可以看做，Mapper将“消息”发送给Reducer。当一个Mapper发出一个键值对时，这个键的作用就像值应该传递到的目标地址。即使键只是一个任意的字符串（不是像IP地址和端口号那样的实际的网络地址），它表现的就像一个地址：所有具有相同键的键值对将被传递到相同的目标（一次Reduce的调用）。</p>
<p>使用MapReduce编程模型，能将计算的物理网络通信层面（从正确的机器获取数据）从应用逻辑中剥离出来（获取数据后执行处理）。这种分离与数据库的典型用法形成了鲜明对比，从数据库中获取数据的请求经常出现在应用代码内部。由于MapReduce能够处理所有的网络通信，因此它也避免了应用代码去担心部分故障，例如另一个节点的崩溃：MapReduce在不影响应用逻辑的情况下能透明地重试失败的任务。</p>
<h4 id="分组">分组</h4>
<p>mapper 可以在生成kv的时候带上分组关键字，这样相关数据会发到一个特定 reducer 上。</p>
<p>在没有背压的时候，内存缓冲区/blockingqueue 可以实现背压。</p>
<h4 id="处理数据倾斜">处理数据倾斜</h4>
<p>要先找出热键，然后想办法用并发或者其他方法单独处理热键。</p>
<h3 id="mapper-端-join-操作">Mapper 端 join 操作</h3>
<ul>
<li>Reduce 端 Join 不用对数据有任何假设，啥都能连，却要全程排序、复制、多次落盘，IO 开销巨大；</li>
<li>Map 端 Join 利用输入可预分区、可广播等假设，把连接提前到 Mapper 里做，省掉 Shuffle/Sort/Reduce，速度成倍提升，但只适用于满足特定条件的数据集。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">算法</th>
<th style="text-align:left">Nested Loop Join</th>
<th style="text-align:left">Hash Join</th>
<th style="text-align:left">Sort-Merge Join</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>核心思想</strong></td>
<td style="text-align:left">左表每行遍历右表所有行匹配</td>
<td style="text-align:left">小表建哈希表，大表查表匹配</td>
<td style="text-align:left">两表先排序，再双指针归并匹配</td>
</tr>
<tr>
<td style="text-align:left"><strong>时间复杂度</strong></td>
<td style="text-align:left">O(M × N)</td>
<td style="text-align:left">O(M + N)</td>
<td style="text-align:left">O(M log M + N log N + M + N)</td>
</tr>
<tr>
<td style="text-align:left"><strong>空间复杂度</strong></td>
<td style="text-align:left">O(1)</td>
<td style="text-align:left">O(min(M, N))</td>
<td style="text-align:left">O(1) 或 O(B)（外排序缓冲）</td>
</tr>
<tr>
<td style="text-align:left"><strong>适用场景</strong></td>
<td style="text-align:left">极小数据、无索引、复杂条件兜底</td>
<td style="text-align:left">一小一大表、等值连接、内存充足</td>
<td style="text-align:left">两大表、已排序或可接受排序开销</td>
</tr>
<tr>
<td style="text-align:left"><strong>是否要求等值连接</strong></td>
<td style="text-align:left">❌ 否</td>
<td style="text-align:left">✅ 是</td>
<td style="text-align:left">✅ 是（通常）</td>
</tr>
<tr>
<td style="text-align:left"><strong>是否要求预排序</strong></td>
<td style="text-align:left">❌ 否</td>
<td style="text-align:left">❌ 否</td>
<td style="text-align:left">✅ 是</td>
</tr>
<tr>
<td style="text-align:left"><strong>I/O 效率</strong></td>
<td style="text-align:left">低（右表重复扫描）</td>
<td style="text-align:left">中（小表加载一次，大表扫一次）</td>
<td style="text-align:left">高（各表只扫一次）</td>
</tr>
<tr>
<td style="text-align:left"><strong>内存效率</strong></td>
<td style="text-align:left">高（几乎无额外内存）</td>
<td style="text-align:left">低（小表必须能放入内存）</td>
<td style="text-align:left">中（可外排，内存压力小）</td>
</tr>
<tr>
<td style="text-align:left"><strong>并行化难度</strong></td>
<td style="text-align:left">中（可分块左表）</td>
<td style="text-align:left">易（广播或分区）</td>
<td style="text-align:left">易（按排序区间分片）</td>
</tr>
<tr>
<td style="text-align:left"><strong>典型系统</strong></td>
<td style="text-align:left">MySQL（无索引小表）、SQLite</td>
<td style="text-align:left">Spark、Flink、Presto、Oracle</td>
<td style="text-align:left">Hive、Spark（大表）、MapReduce</td>
</tr>
<tr>
<td style="text-align:left"><strong>优点</strong></td>
<td style="text-align:left">简单、通用、支持任意条件</td>
<td style="text-align:left">快、适合星型模型、并行友好</td>
<td style="text-align:left">适合超大表、I/O 高效、稳定</td>
</tr>
<tr>
<td style="text-align:left"><strong>缺点</strong></td>
<td style="text-align:left">大数据下性能灾难</td>
<td style="text-align:left">内存敏感、不支持非等值连接</td>
<td style="text-align:left">排序开销大、不适合频繁更新</td>
</tr>
</tbody>
</table>
<h4 id="广播哈希-join">广播哈希 join</h4>
<p>大表 × 小表连接时，只要把整个小表复制到每台 Mapper 的内存（或本地索引），就能在 Map 端直接完成连接，彻底跳过 Shuffle/Reduce 阶段，这种技巧叫广播散列连接（Broadcast Hash Join）。</p>
<h4 id="分区哈希-join">分区哈希 join</h4>
<p>当两个表已经用相同哈希函数、相同分区数、按连接键预分区时，每个 Mapper 只需把各自对应分区的小片段装进内存做散列连接，就能在 Map 端完成 Join，既省 Shuffle 又省内存。</p>
<h4 id="map端合并-join">Map端合并 join</h4>
<p>若两表已按<strong>相同键预分区 + 排好序</strong>，Mapper 就能直接做归并连接（merge join）：顺序扫描两边文件，相同键即配对，完全不用内存散列表，也跳过 Reduce。</p>
<h3 id="批处理工作流的输出">批处理工作流的输出</h3>
<p>MapReduce 批处理既不是在线事务，也不同于传统“出报表”的即时分析；它更像一场离线大扫描**，目的是把原始数据加工成另一种结构化数据，为后续系统（索引、推荐、报表、线上服务）提供可复用的“二次原料”。**</p>
<h4 id="生成搜索索引">生成搜索索引</h4>
<p>MapReduce 并没有“过时”，在“文档集合固定、需要全文搜索”这一经典场景下，它仍是构建搜索索引的利器：</p>
<p>通过 Mapper 分文档并行扫描 → Reducer 并行建倒排段 → 输出不可变索引文件，既充分利用了分布式并行能力，又天然生成易于复制、分发、缓存的只读索引，是成本最低、实现最简单的批量化索引方案。</p>
<p>即使谷歌内部已升级到实时系统，MapReduce 批处理模式依然适用于绝大多数周期性、全量重建的搜索索引需求</p>
<h4 id="批处理输出键值">批处理输出键值</h4>
<p>不要把 MapReduce 的结果一条条写进线上数据库；应该把整个结果写成<strong>一批只读文件</strong>，再原子式地批量加载到 Web 服务能查的专用 KV 存储里。</p>
<h4 id="批处理输出的哲学">批处理输出的哲学</h4>
<p>把 MapReduce 当成 Unix 工具来用——输入只读、输出全替换、无副作用——就能兼得高吞吐 + 易调试 + 快回滚 + 人类容错。</p>
<h3 id="对比-hadoop-与分布式数据库">对比 Hadoop 与分布式数据库</h3>
<p>MapReduce 的算法套路早就在 MPP 数据库里玩过了；它的“新”不在于技术，而在于把分布式并行计算从“专用 SQL 引擎”降级成“通用操作系统”，让任何代码都能跑在千台机器上。</p>
<h4 id="存储多样性">存储多样性</h4>
<p>Hadoop 的“野蛮”做法是先不管格式，把原始数据一股脑丢进 HDFS，事后用 MapReduce 慢慢清洗、建模、再进仓库；这样收集快、跨域连接灵活，也比先设计完美模式更能适应未来多变的需求——这就是数据湖 / 寿司原则：“原始数据更好”。</p>
<h4 id="处理模型多样性">处理模型多样性</h4>
<p>MPP 数据库把存储、查询优化、调度做成一个紧耦合的“黑盒”，只为 SQL 分析跑得快；Hadoop 则把 HDFS 当通用分布式操作系统，谁都能在上面跑自己的代码——SQL、机器学习、图像分析、推荐系统…同一份数据，想怎么玩就怎么玩，不用搬来搬去。</p>
<h4 id="针对频繁故障设计">针对频繁故障设计</h4>
<p>MapReduce 的“慢吞吞写磁盘 + 单任务级重试”不是为硬件故障，而是为谷歌内部高抢占率（≈5 %/小时）买单——随时可能被高优先级进程踢走，所以必须把中间结果刷盘、任务级容错；在开源集群几乎没有如此频繁的抢占，这套设计就显得过度笨重。</p>
<h2 id="超越-mapreduce">超越 MapReduce</h2>
<pre><code class="hljs mermaid">graph TD
    A[MapReduce&lt;br&gt;2000s流行&lt;br&gt;稳健但笨重] --&gt; B[高级抽象&lt;br&gt;Pig/Hive/Cascading/Crunch&lt;br&gt;简化常见批处理]
    A --&gt; C[局限性&lt;br&gt;实体化中间状态&lt;br&gt;性能差]
    
    C --&gt; D[数据流引擎&lt;br&gt;Spark/Tez/Flink&lt;br&gt;DAG执行 更快]
    
    D --&gt; D1[&quot;优化特点:\n内存/本地磁盘存中间状态\n流水线执行\n减少排序与I/O&quot;]
    D --&gt; D2[&quot;容错方式:\nRDD谱系(Spark)\n算子状态(Flink)\n重算而非写HDFS&quot;]
    
    D --&gt; E[图计算模型&lt;br&gt;Pregel/Giraph/GraphX/Gelly&lt;br&gt;BSP并行]
    E --&gt; E1[迭代计算&lt;br&gt;顶点消息传递&lt;br&gt;适合PageRank/推荐系统]
    E --&gt; E2[容错:检查点+回滚]
    
    D --&gt; F[高级API&lt;br&gt;FlumeJava风格&lt;br&gt;DataFrame/DataSet]
    F --&gt; F1[关系型构建块&lt;br&gt;连接/分组/过滤/聚合]
    F --&gt; F2[交互式Shell开发&lt;br&gt;类似Unix哲学]
    
    F --&gt; G[声明式查询&lt;br&gt;Hive/SparkSQL/FlinkSQL]
    G --&gt; G1[基于代价的优化器&lt;br&gt;自动选择join算法]
    G --&gt; G2[向量化执行/列存储&lt;br&gt;生成字节码]
    
    G --&gt; H[专业化领域]
    H --&gt; H1[机器学习&lt;br&gt;Mahout/MADlib]
    H --&gt; H2[统计/数值算法]
    H --&gt; H3[空间/基因组分析]
    
    style A fill:#ffd580,stroke:#333,stroke-width:2px
    style D fill:#c2e0ff,stroke:#333,stroke-width:2px
    style E fill:#c8f7c5,stroke:#333,stroke-width:2px
    style G fill:#f8c6ff,stroke:#333,stroke-width:2px</code></pre>
<pre><code class="hljs mermaid">timeline
    title 大数据批处理与数据流系统演进
    2004 : MapReduce : Google 提出，Hadoop 实现，稳健但性能受限
    2008 : Hive / Pig : 提供 SQL / 脚本抽象，简化 MapReduce 编程
    2010 : Pregel : Google 图计算模型，启发 Giraph / GraphX / Gelly
    2012 : Spark : 内存计算，RDD，支持迭代与交互式查询
    2014 : Flink / Tez : 通用数据流引擎，支持流批统一与低延迟
    2015 : SparkSQL / FlinkSQL : 声明式查询，代价优化器，向量化执行</code></pre>
<pre><code class="hljs mermaid">timeline
    title 大数据批处理与数据流系统演进
    2004 : MapReduce : 批处理新范式&lt;br&gt;自动分布式容错&lt;br&gt;Hadoop 实现开源生态
    2008 : Hive / Pig : SQL 与脚本抽象&lt;br&gt;降低编程门槛&lt;br&gt;适合 ETL / 报表
    2010 : Pregel : 图计算 BSP 模型&lt;br&gt;顶点并行+消息传递&lt;br&gt;启发 Giraph / GraphX
    2012 : Spark : RDD 抽象&lt;br&gt;内存迭代计算&lt;br&gt;支持交互与机器学习
    2014 : Flink / Tez : DAG 数据流执行&lt;br&gt;流批统一&lt;br&gt;低延迟流水线
    2015 : SparkSQL / FlinkSQL : 声明式查询&lt;br&gt;代价优化器&lt;br&gt;列存/向量化执行</code></pre>
<table>
<thead>
<tr>
<th>系统 / 框架</th>
<th>抽象层次</th>
<th>容错机制</th>
<th>流处理支持</th>
<th>声明式接口</th>
<th>典型应用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>MapReduce (2004)</strong></td>
<td>Key-Value 批处理</td>
<td>任务重试 + 数据落盘</td>
<td>否</td>
<td>否</td>
<td>批量日志处理、大规模索引构建</td>
</tr>
<tr>
<td><strong>Hive (2008)</strong></td>
<td>SQL → MapReduce 翻译</td>
<td>继承 MR 容错</td>
<td>否</td>
<td>是 (SQL)</td>
<td>数据仓库、ETL、报表</td>
</tr>
<tr>
<td><strong>Pig (2008)</strong></td>
<td>数据流脚本 Pig Latin</td>
<td>继承 MR 容错</td>
<td>否</td>
<td>半声明式</td>
<td>数据预处理、ETL</td>
</tr>
<tr>
<td><strong>Pregel (2010)</strong></td>
<td>BSP 图计算 (顶点并行)</td>
<td>Checkpoint + 消息重放</td>
<td>否</td>
<td>否</td>
<td>PageRank、图遍历、社交图分析</td>
</tr>
<tr>
<td><strong>Spark (2012)</strong></td>
<td>RDD (弹性分布式数据集)</td>
<td>谱系回溯 (Lineage)</td>
<td>否 (初期)</td>
<td>否</td>
<td>迭代计算、机器学习、交互分析</td>
</tr>
<tr>
<td><strong>Flink / Tez (2014)</strong></td>
<td>通用 DAG 数据流</td>
<td>检查点 + 状态恢复</td>
<td>是</td>
<td>否</td>
<td>流批统一、低延迟流水线计算</td>
</tr>
<tr>
<td><strong>SparkSQL (2015)</strong></td>
<td>DataFrame / SQL</td>
<td>继承 Spark 容错</td>
<td>部分 (结构化流)</td>
<td>是 (SQL)</td>
<td>BI 查询、交互式分析、ETL</td>
</tr>
<tr>
<td><strong>FlinkSQL (2015)</strong></td>
<td>Table API / SQL</td>
<td>继承 Flink 容错</td>
<td>是</td>
<td>是 (SQL)</td>
<td>实时流分析、复杂事件处理 CEP</td>
</tr>
</tbody>
</table>
<p>虽然MapReduce在二十世纪二十年代后期变得非常流行，并受到大量的炒作，但<strong>它只是分布式系统的许多可能的编程模型之一</strong>-虽然通用，但是似乎 HDFS的通用性更重要。对于不同的数据量，数据结构和处理类型，其他工具可能更适合特定的计算。</p>
<p>它是分布式文件系统的一种相当简单明晰的抽象。在这里，简单意味着我们能理解它在做什么，而不是意味着使用它很简单。恰恰相反：使用原始的MapReduce API来实现复杂的处理工作实际上是非常困难和费力的。</p>
<p>MapReduce 是更廉价、在不可靠多租户环境下健壮但是仍然很慢的编程模型：</p>
<p>但是，MapReduce 执行模型本身也存在一些问题，这些问题并没有通过增加另一个抽象层次而解决，而对于某些类型的处理，它表现得非常差劲。一方面，MapReduce非常稳健：你可以使用它在任务会频繁终止的多租户系统上处理几乎任意大量级的数据，并且仍然可以完成工作（虽然速度很慢）。另一方面，对于某些类型的处理而言，其他工具有时会快上几个数量级。</p>
<h3 id="中间状态实体化">中间状态实体化</h3>
<p>MapReduce 实体化中间状态的核心目的：实体化是为了实现作业间松耦合和容错，通过分布式文件系统传递数据，让每个作业独立运行。适合数据需跨团队共享或长期复用的场景。</p>
<p>实体化在紧耦合工作流中的三大问题：</p>
<ol>
<li>它导致后续作业必须等待前驱完全结束，无法流式处理，拖慢整体流程。</li>
<li>Mapper 常做重复分区排序，若规则一致本可跳过。</li>
<li>中间数据多副本存储，对临时结果而言资源浪费严重。</li>
</ol>
<p>与 Unix 管道的关键差异：Unix 管道增量流式传输，进程并行启动，无持久化开销。MapReduce 选择稳定性牺牲效率，这是批处理架构的典型权衡。</p>
<h4 id="数据流引擎">数据流引擎</h4>
<p>这些框架只是执行引擎之间的替换。</p>
<ol>
<li>MapReduce 是低层抽象的执行引擎。</li>
<li>Spark &amp; Flink 是更高级别的通用分布式计算引擎。</li>
<li>Hive 是 DW 工具和 SQL 查询引擎。Hive 在现代数据栈中依然有不可替代的价值，主要不是作为“执行引擎”，而是作为“元数据管理中心”和“数仓标准层”。“今天用 Hive，不是为了跑 SQL，而是为了管元数据、定标准、保兼容 —— 执行交给 Spark 或 Flink。”</li>
</ol>
<pre><code class="hljs mermaid">graph TD
    subgraph &quot;Storage Layer&quot;
        HDFS[HDFS / Cloud Storage]
    end

    subgraph &quot;Compute / Processing Layer&quot;
        direction TB
        MR[MapReduce Engine] --&gt;|Processes| HDFS
        SP[Spark Engine] --&gt;|Processes| HDFS
        FL[Flink Engine] --&gt;|Processes| HDFS

        subgraph &quot;SQL Abstraction Layer (Optional)&quot;
            HIVE[Hive Metastore &amp; Compiler]
            HIVE --&gt;|Translates to &amp; Runs on| MR
            HIVE --&gt;|Translates to &amp; Runs on| SP
            HIVE --&gt;|Translates to &amp; Runs on| FL
        end

        SP_SQL[Spark SQL] --&gt;|Built-in SQL| SP
        FL_SQL[Flink SQL/Table API] --&gt;|Built-in SQL| FL
    end

    USER[User / Application]
    USER --&gt;|HiveQL| HIVE
    USER --&gt;|Spark SQL| SP_SQL
    USER --&gt;|Flink SQL| FL_SQL
    USER --&gt;|Spark API: RDD/DF| SP
    USER --&gt;|Flink API: DataStream| FL
    USER --&gt;|MapReduce API| MR

    classDef storage fill:#e0f7fa,stroke:#0097a7;
    classDef compute fill:#fff3e0,stroke:#fb8c00;
    classDef sql fill:#f3e5f5,stroke:#7b1fa2;
    classDef user fill:#e8f5e8,stroke:#388e3c;

    class HDFS storage
    class MR,SP,FL compute
    class HIVE,SP_SQL,FL_SQL sql
    class USER user</code></pre>
<p>数据流引擎是新的<strong>执行引擎</strong>，它们的设计方式有很多区别，但有一个共同点：<strong>把整个工作流作为单个作业来处理，而不是把它分解为独立的子作业</strong>。​ 由于它们将工作流显式建模为<strong>数据从几个处理阶段穿过</strong>（而不是像 MapReduce 一样数据从不同的处理作业穿过），所以这些系统被称为数据流引擎（dataflow engines）。</p>
<p>像MapReduce一样，它们在一条线上通过反复调用用户定义的函数来一次处理一条记录，它们通过输入分区来<strong>并行化载荷</strong>，它们通过网络将<strong>一个函数的输出复制到另一个函数的输入</strong>。</p>
<p>与MapReduce不同，这些功能<strong>不需要严格扮演交织的Map与Reduce的角色，而是可以以更灵活的方式进行组合。我们称这些函数为算子（operators）</strong>-函数即算子，数据流引擎提供了几种不同的选项来将一个算子的输出连接到另一个算子的输入：</p>
<p>改进：</p>
<ol>
<li>排序等昂贵的工作只需要在实际需要的地方执行。</li>
<li>没有不必要的Map任务，因为Mapper所做的工作通常可以合并到前面的Reduce算子中。</li>
<li>由于工作流中的<strong>所有连接和数据依赖都是显式声明的，因此调度程序能够总览全局</strong>，知道哪里需要哪些数据，因而能够利用局部性进行优化。<strong>DAG 优化就是在这里</strong>。</li>
<li>通常，算子间的中间状态足以保存在内存中或写入本地磁盘，这比写入HDFS需要更少的I/O。</li>
<li>算子可以在输入就绪后立即开始执行；后续阶段无需等待前驱阶段整个完成后再开始。</li>
<li>与MapReduce（<strong>为每个任务启动一个新的JVM</strong>）相比，现有Java虚拟机（JVM）进程可以重用来运行新算子，从而减少启动开销。</li>
</ol>
<p>Pig，Hive或Cascading中实现的工作流可以无需修改代码，可以通过修改配置，简单地从MapReduce切换到Tez或Spark。</p>
<h4 id="容错">容错</h4>
<p><strong>完全实体化中间状态至分布式文件系统的一个优点是，它具有持久性</strong>，这使得MapReduce中的容错相当容易：如果一个任务失败，它可以在另一台机器上重新启动，并从文件系统重新读取相同的输入。</p>
<p>Spark，Flink和Tez避免将中间状态写入HDFS，因此它们采取了不同的方法来容错：如果一台机器发生故障，并且该机器上的中间状态丢失，则它会从其他<strong>仍然可用的数据重新计算</strong>（在可行的情况下是先前的中间状态，要么就只能是原始输入数据，通常在HDFS上）。</p>
<ol>
<li>Spark使用弹性分布式数据集（RDD）的抽象来跟踪数据的谱系。</li>
<li>而Flink对算子状态存档，允许恢复运行在执行过程中遇到错误的算子。</li>
</ol>
<p>在重新计算数据时，重要的是要知道计算是否是确定性的：也就是说，给定相同的输入数据，算子是否始终产生相同的输出？​ 为了避免级联故障，最好让算子具有确定性。</p>
<p>通过重算数据来从故障中恢复并不总是正确的答案：如果中间状态数据要比源数据小得多，或者如果计算量非常大，那么将<strong>中间数据实体化为文件可能要比重新计算廉价的多</strong>。</p>
<h4 id="关于实体化的讨论">关于实体化的讨论</h4>
<p>MapReduce就像是将每个命令的输出写入临时文件，而数据流引擎看起来更像是Unix管道。尤其是Flink是基于管道执行的思想而建立的：也就是说，将算子的输出增量地传递给其他算子，不待输入完成便开始处理。</p>
<p>不断的流像 Java Stream，Unix pipeline 和 Flink。</p>
<p>排序算子不可避免地需要消费全部的输入后才能生成任何输出。</p>
<p>当作业完成时，它的输出需要持续到某个地方，以便用户可以找到并使用它—— 很可能它会再次写入分布式文件系统。因此，在使用数据流引擎时，HDFS上的实体化数据集通常仍是作业的输入和最终输出。和MapReduce一样，<strong>输入是不可变的，输出被完全替换</strong>。<strong>比起MapReduce的改进是，你不用再自己去将中间状态写入文件系统了</strong>。</p>
<h3 id="图与迭代处理">图与迭代处理</h3>
<p>我们在之前的章节里讨论了<strong>用图来建模数据</strong>，由此可以<strong>使用图查询语言来遍历边和顶点</strong>。</p>
<p>最着名的图形分析算法之一是PageRank。</p>
<p>一个误区：数据流引擎（DataStreamEngine）也有图，<strong>但是这些图里的 Vertext 是算子，数据流形成了图。数据本身还是关系元组</strong>。</p>
<p>一个典型的图算法是这样的：</p>
<ol>
<li>一次遍历一个边。</li>
<li>将顶点和相邻顶点 join 起来传递某种信息。</li>
<li>重复该过程直到满足某种条件位置。</li>
</ol>
<p>我们可以在<strong>分布式文件系统（通常是 HDFS）里存储图</strong>，但是 MapReduce 却不适合执行这种迭代算法：因为 <strong>MapReduce 每次都会读取整个输入数据集</strong>并产生全新的数据集。</p>
<h4 id="pregel-处理模型">Pregel 处理模型</h4>
<p>“Pregel 是 Google 为解决大规模图计算在 MapReduce 上效率低、表达难、容错差的问题，提出的基于 BSP 模型的分布式图处理框架 —— 它让开发者能‘像写单机图算法一样’写分布式图程序，同时保证高性能和容错性。”</p>
<p>Pregel 的设计哲学：</p>
<ul>
<li>“像顶点一样思考”：每个顶点是计算单元，只关心自己和邻居。</li>
<li>“同步迭代”：所有顶点在 Superstep 中并行计算，结束后统一同步，避免竞态。</li>
<li>“消息驱动”：顶点间通过消息通信，无共享状态，天然分布式。</li>
<li>“容错轻量”：按 Worker 粒度 checkpoint，故障局部恢复。</li>
</ul>
<p>典型应用场景：</p>
<ul>
<li>PageRank / 社交网络影响力分析</li>
<li>单源最短路径（SSSP）、广度优先搜索（BFS）</li>
<li>连通分量、社区发现</li>
<li>图神经网络（GNN）的预处理或采样</li>
<li>欺诈检测、推荐系统中的图特征计算</li>
</ul>
<pre><code class="hljs mermaid">graph TD
    S[Superstep 0: 初始化] --&gt; V1[每个顶点设置初始值&lt;br&gt;（如 PageRank=1/N）]
    V1 --&gt; S1[Superstep 1]
    S1 --&gt; M1[每个顶点发送消息&lt;br&gt;（如当前 PageRank 值）&lt;br&gt;给邻居]
    M1 --&gt; C1[所有消息被传递&lt;br&gt;（同步屏障）]
    C1 --&gt; U1[每个顶点接收消息&lt;br&gt;并更新自身状态]
    U1 --&gt; S2&#123;是否收敛或&lt;br&gt;达到最大轮数？&#125;
    S2 -- 否 --&gt; S3[Superstep 2]
    S3 --&gt; M2[重复：发送→同步→更新]
    S2 -- 是 --&gt; E[输出最终顶点状态]

    classDef superstep fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;
    classDef step fill:#e0f7fa,stroke:#0097a7;
    class S,S1,S2,S3 superstep
    class V1,M1,C1,U1,M2,E step</code></pre>
<pre><code class="hljs mermaid">sequenceDiagram
    participant Master
    participant Worker1
    participant Worker2
    participant Worker3

    Note over Master,Worker3: Superstep 0: 初始化

    Master-&gt;&gt;Worker1: 分配顶点 V1, V2
    Master-&gt;&gt;Worker2: 分配顶点 V3, V4
    Master-&gt;&gt;Worker3: 分配顶点 V5
    Worker1-&gt;&gt;Worker1: V1.setValue(1.0), V2.setValue(0.5)
    Worker2-&gt;&gt;Worker2: V3.setValue(0.8), V4.setValue(0.2)
    Worker3-&gt;&gt;Worker3: V5.setValue(1.0)
    Master-&gt;&gt;Master: 等待所有 Worker 报告初始化完成

    Note over Master,Worker3: Superstep 1: 并发计算 + 消息发送

    Master-&gt;&gt;All Workers: 启动 Superstep 1
    Worker1-&gt;&gt;Worker1: V1.sendMsgTo(V3, 1.0)&lt;br&gt;V2.sendMsgTo(V4, 0.5)
    Worker2-&gt;&gt;Worker2: V3.sendMsgTo(V5, 0.8)&lt;br&gt;V4.sendMsgTo(V1, 0.2)
    Worker3-&gt;&gt;Worker3: V5.sendMsgTo(V2, 1.0)

    Note over Worker1,Worker3: 消息通过网络异步传递&lt;br&gt;Worker 间无共享状态

    Worker1-&gt;&gt;Worker2: 消息 (V1→V3: 1.0)
    Worker1-&gt;&gt;Worker2: 消息 (V2→V4: 0.5)
    Worker2-&gt;&gt;Worker3: 消息 (V3→V5: 0.8)
    Worker2-&gt;&gt;Worker1: 消息 (V4→V1: 0.2)
    Worker3-&gt;&gt;Worker1: 消息 (V5→V2: 1.0)

    Note over Master,Worker3: 同步屏障：等待所有消息送达

    Worker1-&gt;&gt;Master: 报告 Superstep 1 消息发送完成
    Worker2-&gt;&gt;Master: 报告 Superstep 1 消息发送完成
    Worker3-&gt;&gt;Master: 报告 Superstep 1 消息发送完成
    Master-&gt;&gt;All Workers: 广播：进入消息接收阶段

    Worker1-&gt;&gt;Worker1: V1.recvMsgs([0.2]) → 更新值&lt;br&gt;V2.recvMsgs([1.0]) → 更新值
    Worker2-&gt;&gt;Worker2: V3.recvMsgs([1.0]) → 更新值&lt;br&gt;V4.recvMsgs([0.5]) → 更新值
    Worker3-&gt;&gt;Worker3: V5.recvMsgs([0.8]) → 更新值

    Worker1-&gt;&gt;Master: 报告本地顶点是否 active&lt;br&gt;(V1.active=true, V2.active=true)
    Worker2-&gt;&gt;Master: (V3.active=true, V4.active=true)
    Worker3-&gt;&gt;Master: (V5.active=true)
    Master-&gt;&gt;Master: 检查全局活跃状态 → 未收敛，继续

    Note over Master,Worker3: Superstep 2: Worker2 故障模拟 + 容错恢复

    Master-&gt;&gt;All Workers: 启动 Superstep 2
    Worker1-&gt;&gt;Worker1: 正常执行
    Worker2-&gt;&gt;Worker2: 崩溃（模拟故障）
    Master-&gt;&gt;Master: 检测 Worker2 超时无响应

    Master-&gt;&gt;Worker1: 重新分配 V3, V4 到 Worker1
    Master-&gt;&gt;Worker3: 请求 Worker3 发送 V3,V4 的最近 checkpoint
    Worker3-&gt;&gt;Worker1: 传输 V3,V4 状态 (值+边)
    Worker1-&gt;&gt;Worker1: 重建 V3, V4，恢复计算

    Worker1-&gt;&gt;Worker1: V1, V2, V3, V4 并发执行 Superstep 2
    Worker3-&gt;&gt;Worker3: V5 执行 Superstep 2
    Master-&gt;&gt;Master: 收集活跃状态 → 若全 inactive 或达最大轮数，终止

    Note over Master,Worker3: 最终输出

    Master-&gt;&gt;All Workers: 终止信号
    Worker1-&gt;&gt;Master: 返回 V1, V2, V3, V4 最终值
    Worker3-&gt;&gt;Master: 返回 V5 最终值
    Master-&gt;&gt;Client: 汇总输出所有顶点最终状态</code></pre>
<h3 id="高级-api-和语言">高级 API 和语言</h3>
<ol>
<li>从“手写底层”到“高级抽象”。</li>
<li>从“静态批处理”到“交互式探索”。</li>
<li>从“人效提升”到“机效优化”。</li>
</ol>
<h4 id="转向声明式查询">转向声明式查询</h4>
<ul>
<li>声明式 Join 配合代价优化器，能自动选择最优连接算法（如 Hash Join 或 Sort-Merge Join），无需人工干预；优化器还可调整 Join 顺序，减少中间数据量，提升执行效率。</li>
<li>声明式编程比硬编码更优，用户只需描述“要什么”，系统决定“如何做”；这既降低使用门槛，又使引擎能实施深度优化，如列裁剪、向量化执行、代码生成，性能远超手写 MapReduce。</li>
<li>MapReduce 的核心优势是支持自由运行任意代码，可集成 NLP、图像处理、统计模型等任意库，生态开放灵活；传统 MPP 数据库的 UDF 功能受限，依赖管理困难，生态封闭。</li>
<li>新一代引擎（如 Spark、Flink、Hive）在保留任意代码能力的同时，引入声明式 API（如 DataFrame/Table）；对简单操作（filter/select），引擎可自动优化，如利用列存储、向量化循环、JVM 或 LLVM 代码生成，显著提升 CPU 和 I/O 效率。</li>
<li>最终趋势是批处理引擎越来越像 MPP 数据库（具备优化器、向量化、列存等能力），同时保留开放生态（支持任意代码和数据格式），实现高性能与高灵活性的统一。</li>
</ul>
<h4 id="不同领域的专业化">不同领域的专业化</h4>
<ul>
<li>批处理系统虽然支持运行任意代码，但很多任务有重复模式，值得封装成可重用的通用模块。</li>
<li>传统 MPP 数据库主要用于商业智能和报表，但批处理的应用范围远不止于此。</li>
<li>机器学习领域（如分类器、推荐系统）越来越依赖批处理，出现了如 Mahout（支持 MapReduce/Spark/Flink）和 MADlib（支持 MPP 数据库）等可重用算法库。</li>
<li>空间算法（如 kNN 最近邻搜索）在多维数据相似性分析中很重要，也用于基因组分析等需要近似匹配的场景。</li>
<li>批处理引擎正被用于执行越来越多领域的分布式算法，覆盖范围持续扩大。</li>
<li>随着批处理系统内置更多功能和高级声明式算子，MPP 数据库也变得更灵活、更易编程，两者的界限逐渐模糊。</li>
<li>最终，批处理引擎和 MPP 数据库本质上都是存储和处理数据的系统，技术演进让它们越来越相似。</li>
</ul>
<h2 id="小结">小结</h2>
<ul>
<li>本章探讨批处理系统，从 Unix 工具（awk、grep、sort）的设计哲学出发，延伸到 MapReduce 和现代数据流引擎，核心原则包括：输入不可变、输出可作为未知下游输入、复杂问题通过“专注单一功能”的小工具组合解决。</li>
<li>Unix 用文件和管道作为程序组合的统一接口；MapReduce 用分布式文件系统（如 HDFS）作为作业间通信接口；现代数据流引擎引入内存管道机制，减少中间状态写盘，但初始输入和最终输出仍多依赖 HDFS。</li>
<li>分布式批处理需解决两大核心问题：分区和容错。</li>
<li>分区目标是将相关数据（如同键记录）聚集到同一计算节点。MapReduce 中，Mapper 按输入分块处理，输出经重分区、排序、合并后送入 Reducer；后 MapReduce 引擎尽量避免排序，但仍沿用类似分区逻辑。</li>
<li>容错方面，MapReduce 频繁写盘，利于单任务恢复但拖慢正常执行；现代引擎更多用内存缓存中间状态，节点故障时需重算，但通过确定性算子减少重算范围。</li>
<li>常见连接算法（如排序合并连接、广播哈希连接、分区哈希连接）在 MapReduce、MPP 数据库和数据流引擎中通用，也体现分区机制如何工作：排序合并靠键分区与排序；广播哈希适合小表全加载；分区哈希要求两表预分区一致。</li>
<li>批处理框架刻意限制编程模型：回调函数（如 Mapper/Reducer）必须无状态、无外部副作用；这一限制使框架能自动重试失败任务、丢弃无效输出、保证最终一致性，开发者无需手动实现容错。</li>
<li>批处理提供强可靠性语义：框架保证最终输出等价于无故障执行结果，相比在线服务（写数据库有副作用），容错更彻底、更自动化。</li>
<li>批处理的核心特征是：输出从输入派生、输入有界（固定大小，如日志快照或数据库导出），因此作业总有明确终点，能正常完成。</li>
</ul>
<h1>流处理系统</h1>
<ul>
<li>第10章讨论批处理技术：以一组输入文件为基础，生成一组输出文件，输出属于“派生数据”，可通过重跑批处理重建。</li>
<li>批处理依赖“输入有界”的假设：输入大小固定、已知，系统能明确判断何时读完数据，例如 MapReduce 的排序必须等全部输入读完才能输出，因为最后一条记录可能需排在最前。<strong>排序需要数据是有界流</strong>。</li>
<li>现实中很多数据是“无界”的：用户行为、日志、传感器数据等持续产生，永远不会真正“完成”，除非业务停止。</li>
<li>为处理无界数据，批处理常将数据按固定时间窗口切割（如每天/每小时处理一次），但导致输出延迟高（如T+1），无法满足实时性需求。</li>
<li>为降低延迟，可提高批处理频率（如每秒一次），或彻底放弃固定时间切片，采用“事件发生即处理”的方式 —— 这就是流处理的核心思想。</li>
<li>“流”泛指随时间逐步到达的数据，在 Unix 管道、编程语言惰性列表、文件读取、TCP、音视频传输中广泛存在。</li>
<li>本章聚焦“事件流”作为数据管理机制：强调无界性、增量处理，与第10章的批处理形成对比。</li>
<li>本章结构：先讨论<strong>流的表示、存储、传输</strong>（用队列来解释流，流比我们想象中更熟悉）；再探讨流与数据库的关系；最后介绍流处理的方法、工具及其在应用构建中的使用方式。</li>
</ul>
<h2 id="发送事件流">发送事件流</h2>
<ul>
<li>在批处理中，输入和输出是文件（可能位于分布式文件系统上）；在流处理中，对应的单元是持续到达的事件流。</li>
<li>文件通常被解析为一系列记录；在流处理中，这些记录被称为“事件”——即小的、自包含、不可变的对象，描述某个时间点发生的事实，通常包含时间戳。</li>
<li>事件可以来自用户行为（如页面浏览、购买）或机器系统（如传感器读数、CPU 使用率）；例如，Web 服务器日志的每一行就是一个事件。</li>
<li>事件可采用文本、JSON 或二进制格式编码，便于存储（如追加到文件、写入关系表或文档数据库）或通过网络传输到其他节点处理。</li>
<li>类似于批处理中一个文件被写入一次、供多个作业读取，流处理中一个事件由生产者（发布者）生成一次，可被多个消费者（订阅者）独立处理。</li>
<li>批处理用“文件名”组织相关记录；流处理用“主题（topic）”或“流（stream）”来聚合相关事件。</li>
<li>理论上，普通文件或数据库可通过“生产者写入 + 消费者轮询”实现事件传递，这正是每日批处理（如 T+1）的工作方式。</li>
<li>但在低延迟连续处理场景下，轮询效率低下：轮询越频繁，空请求比例越高，系统开销越大。</li>
<li>理想机制是“<strong>事件到达时主动通知消费者</strong>”，而非<strong>被动轮询</strong>。</li>
<li>传统数据库对通知支持有限：虽有触发器，但功能弱、扩展性差、难以维护，不适合作为流处理基础设施。</li>
<li>因此，专门的流处理系统（如 Kafka、Pulsar）被设计出来，以高效支持事件发布、订阅、持久化和低延迟通知。</li>
</ul>
<h3 id="消息系统-messaging">消息系统（Messaging）</h3>
<ul>
<li>流处理中通知消费者新事件的常用方式是消息传递系统：生产者发送消息，系统将消息推送给消费者。</li>
<li><strong>Unix 管道或 TCP 是最简单的消息传递形式</strong>，但仅支持一对一通信；而现代消息系统支持多生产者向同一主题发送、多消费者订阅同一主题（发布/订阅模型）。</li>
<li>不同消息系统在处理生产与消费速率不匹配时有三种主要策略：丢弃消息、缓冲到队列、或<strong>使用背压（阻塞生产者）；例如 Unix 管道和 TCP 使用背压</strong>。</li>
<li>若使用缓冲队列，需关注队列溢出问题：内存不足时是否会崩溃？是否支持写入磁盘？磁盘 I/O 会显著影响系统吞吐和延迟。</li>
<li>节点故障时的行为至关重要：消息是否可能丢失？可靠传递通常需依赖磁盘持久化和/或复制，但这会带来性能开销。</li>
<li>是否允许消息丢失取决于应用场景：<strong>周期性指标（如传感器读数）可容忍少量丢失</strong>；但计数类或事务类事件必须可靠送达，否则会导致结果错误。</li>
<li>批处理系统（如第10章所述）提供强可靠性保证：失败任务自动重试，无效中间输出自动丢弃，最终输出与无故障执行一致。</li>
<li>流处理系统也需追求类似<strong>可靠性语义</strong>，后续章节将探讨如何在无界数据流中实现容错与精确一次处理。</li>
</ul>
<h4 id="生产者与消费者之间的直接消费传递">生产者与消费者之间的直接消费传递</h4>
<ul>
<li>许多消息传递系统采用生产者与消费者之间的直接网络通信（<strong>只依赖常见协议+应用层语义增强</strong>），不依赖中间代理节点。</li>
<li>UDP 组播常用于金融行业（如股票行情），因低延迟需求高；<strong>虽 UDP 本身不可靠，但应用层可实现重传机制</strong>，要求生产者缓存已发数据包。</li>
<li><strong>无代理消息库</strong>（如 <strong>ZeroMQ、nanomsg</strong>）<strong>基于 TCP 或 IP 多播实现发布/订阅</strong>，同样依赖端到端的可靠性逻辑。</li>
<li>StatsD 和 Brubeck 使用不可靠 UDP 收集监控指标，接受数据近似性，不保证精确计数。</li>
<li>生产者也可<strong>通过 HTTP 或 RPC 直接向消费者推送消息，例如 webhook</strong> 机制：一个服务注册回调 URL，事件发生时主动调用该 URL。</li>
<li><strong>这类直接通信系统通常要求应用层显式处理消息丢失风险</strong>，容错能力有限。</li>
<li>它们普遍假设生产者和消费者始终在线；若消费者离线，期间消息可能永久丢失。</li>
<li><strong>虽部分协议支持重试，但若生产者崩溃，其内存中的待发消息缓冲区会丢失</strong>，导致消息无法恢复。</li>
</ul>
<h4 id="消息代理">消息代理</h4>
<ul>
<li>一种主流消息传递方式是使用消息代理（也称消息队列）：代理作为中心服务器，生产者和消费者作为客户端连接。</li>
<li>消息代理本质上是<strong>为处理消息流优化的专用数据库</strong>，负责接收、存储和转发消息。</li>
<li>通过集中管理消息，代理能更好地容忍客户端频繁上下线、断连或崩溃，将持久性责任从客户端转移到自身。</li>
<li>消息代理可配置为仅内存存储（高性能但易丢失）或持久化到磁盘（保障崩溃后不丢消息）。</li>
<li>针对消费速度慢的场景，代理通常支持消息排队（可配置为无上限），避免丢弃消息或施加背压。</li>
<li>消费者通常是异步的：生产者发送消息后只需等待代理确认接收，不等待消费者处理完成。</li>
<li>消息投递给消费者的时间不确定——通常很快（毫秒级），但在积压严重时可能显著延迟。</li>
</ul>
<h4 id="消息代理与数据库对比">消息代理与数据库对比</h4>
<ul>
<li><strong>部分消息代理支持 XA 或 JTA，可参与两阶段提交协议</strong>，功能上类似数据库，但实际用途和设计目标仍有显著差异。</li>
<li>数据库通常长期保留数据直到显式删除；<strong>而消息代理在消息成功投递给消费者后通常自动删除</strong>，因此不适合用作长期数据存储。</li>
<li><strong>消息代理假设工作集较小</strong>（队列短），若因消费者缓慢导致大量消息堆积（尤其溢出到磁盘），处理延迟增加，整体吞吐量可能下降。</li>
<li>数据库支持二级索引和灵活查询；<strong>消息代理通常仅支持基于主题（topic）或模式匹配的订阅机制，用于筛选感兴趣的消息流</strong>。</li>
<li>数据库查询返回某时间点的数据快照，结果不会自动更新；<strong>消息代理不支持任意查询，但能在新数据（消息）到达时主动通知消费者</strong>。</li>
<li>上述特性构成了对消息代理的传统理解，体现在 JMS、AMQP 等标准中，并被 RabbitMQ、ActiveMQ、IBM MQ、Azure Service Bus、Google Cloud Pub/Sub 等系统实现。</li>
</ul>
<h4 id="多个消费者">多个消费者</h4>
<ul>
<li>当多个消费者订阅同一主题时，主要有两种消息传递模式：负载均衡和扇出。</li>
<li>负载均衡：每条消息只发送给一个消费者，<strong>多个消费者共同分担处理负载</strong>，适用于高成本消息处理场景；在 AMQP 中通过多客户端消费同一队列实现，在 JMS 中称为共享订阅。</li>
<li>扇出（<strong>复制发送</strong>）：每条消息广播给所有消费者，各消费者独立处理相同消息流，互不影响；对应批处理中多个作业读取同一输入文件；JMS 的主题订阅和 AMQP 的交换器绑定支持此模式。</li>
<li>两种模式可组合使用：例如，多个消费者组各自订阅同一主题，组间实现扇出（<strong>每组都收到全部消息</strong>），组内实现负载均衡（<strong>每条消息仅由组内一个成员处理</strong>）。</li>
</ul>
<p><img src="fig11-1.png" alt="（a）负载平衡：在消费者间共享消费主题；（b）扇出：将每条消息传递给多个消费者"></p>
<h4 id="确认与重新传递">确认与重新传递</h4>
<p><img src="fig11-2.png" alt="在处理m3时消费者2崩溃，因此稍后重传至消费者1"></p>
<ul>
<li>消费者可能崩溃，导致消息未处理或仅部分处理；为防止消息丢失，消息代理依赖显式确认（acknowledgment）机制：只有收到确认后，才从队列中删除消息。</li>
<li>若消费者断连或超时未确认，代理会认为消息未成功处理，并将其重新投递给其他消费者。</li>
<li><strong>由于网络问题，可能出现“消息已处理但确认丢失”的情况，此时消息会被重复投递；解决此问题需原子提交协议（如两阶段提交）</strong>，但大多数消息系统不默认提供。</li>
<li>在负载均衡模式下，消息重传会破坏顺序：例如，消费者2处理 m3 时崩溃，m3 被重传给正在处理 m4 的消费者1，导致 m4 在 m3 之前被处理，交付顺序与生产者发送顺序不一致。</li>
<li>即使消息代理本身保证队列内顺序（如 JMS/AMQP 要求），负载均衡 + 重传的组合仍会导致跨消费者的消息乱序。</li>
<li>若需严格保序，可为每个消费者分配独立队列（放弃负载均衡-<strong>负载均衡会导致乱序</strong>）；若消息彼此独立，乱序通常无影响；<strong>但若消息存在因果依赖，乱序将引发正确性问题</strong>。</li>
</ul>
<h3 id="分区日志">分区日志</h3>
<ul>
<li>传统网络通信（如数据包发送、HTTP 请求）是短暂的，通常不留永久痕迹；即使消息代理将消息写入磁盘，也往往在送达后立即删除，体现“短暂消息”的设计哲学。</li>
<li>数据库和文件系统则采用持久化思维：数据一经写入，默认永久保存，直到被显式删除。</li>
<li>这种差异深刻影响派生数据的构建方式：批处理可反复重跑（输入只读、不可变），而 AMQP/JMS 风格的消息消费是破坏性的——确认即删除，无法重放，导致结果不可重现。</li>
<li>新消费者加入传统消息系统时，只能接收订阅之后的新消息，历史消息不可追溯；而数据库或文件系统允许新客户端随时读取任意历史数据。</li>
<li>为结合两者优势——数据库的持久性与消息系统的低延迟通知——<strong>催生了基于日志的消息代理</strong>（如 Kafka、Pulsar），它将消息持久存储并支持重放，实现**“可重放的流”**。</li>
</ul>
<h4 id="基于日志的消息存储">基于日志的消息存储</h4>
<p><img src="fig11-3.png" alt="生产者通过将消息追加写入主题分区文件来发送消息，消费者依次读取这些文件"></p>
<ul>
<li>日志是一种仅追加的记录序列，已在第3章（存储引擎、WAL）和第5章（复制）中讨论过，也可用于实现消息代理。</li>
<li>在基于日志的消息代理中，生产者通过向日志末尾追加消息来发送数据，消费者通过顺序读取日志来接收消息；读到末尾时等待新消息通知，类似 Unix 的 tail -f。</li>
<li>为支持高吞吐量，日志可按分区（partition）拆分，每个分区独立存储于不同机器，可并行读写；一个主题（topic）由一组同类型消息的分区组成。</li>
<li>每个分区内，消息按追加顺序获得单调递增的偏移量（offset），因此分区内消息是严格有序的。</li>
<li>不同分区之间不保证全局顺序，仅保证分区内有序。</li>
<li>Apache Kafka、Amazon Kinesis Streams 和 Twitter 的 DistributedLog 都是典型的基于日志的消息代理。</li>
<li>Google Cloud Pub/Sub 架构上类似，但对外提供 JMS 风格的 API，而非<strong>直接暴露日志抽象</strong>。</li>
<li>这些系统虽将所有消息写入磁盘，但通过分区实现横向扩展-<strong>横向扩展意味着横向负载均衡</strong>，可达到每秒百万级消息吞吐，并通过<strong>消息复制提供容错能力</strong>。</li>
</ul>
<h4 id="对比日志与传统消息系统">对比日志与传统消息系统</h4>
<ul>
<li><strong>基于日志的消息系统（如 Kafka、Kinesis）天然支持扇出</strong>（fan-out）：多个消费者可独立读取同一日志，互不影响，因为读取操作不会删除或移动日志中的消息，每个消费者维护自己的读取位置（offset）。</li>
<li>相比之下，某些简单队列实现（如 Redis 的 List 结构配合 LPOP/RPOP）不支持扇出：消息一旦被一个消费者取出，就从队列中永久移除，其他消费者无法再看到该消息，只能实现<strong>点对点或负载均衡</strong>模式。</li>
<li>类似地，传统 JMS 队列（Queue）模式也默认不支持扇出：每条消息仅被一个消费者消费；<strong>若要实现广播，必须显式使用主题（Topic）模式</strong>。</li>
<li>因此，是否支持扇出取决于底层存储模型：<strong>可重复读的持久日志支持扇出，而“取即删”的队列结构不支持</strong>。</li>
<li>负载均衡通过将整个分区分配给消费者组中的某个节点实现，而非逐条分配消息；每个消费者负责处理其被分配分区中的全部消息。</li>
<li>消费者通常以单线程顺序方式读取所分配分区的消息，这种粗粒度负载均衡存在两个主要缺点：
<ul>
<li>消费者组内并行度受限于分区数量，无法超过主题的分区数。</li>
<li>分区内某条消息处理缓慢会阻塞后续消息处理（即“行首阻塞”）。</li>
</ul>
</li>
<li>因此，在以下场景中，JMS/AMQP 风格的消息代理（基于队列和单条消息分发）更为合适：
<ul>
<li>消息处理逻辑复杂或耗时较长，需要细粒度并行；</li>
<li>消费者处理能力不均，需动态分配空闲消费者；</li>
<li>消息无严格顺序依赖；</li>
<li>需要灵活扩缩消费者数量，不受分区数限制；</li>
<li>需支持工作窃取或优先级队列等调度策略。</li>
</ul>
</li>
<li>相反，在消息吞吐量极高、处理轻量、且顺序性至关重要的场景（如日志管道、事件溯源），基于日志的方法表现更优。</li>
</ul>
<p>“绑定 partition + offset” 是日志型系统的核心特征，JMS/AMQP 标准本身不包含这种形式，因为它们的设计目标是提供通用的消息传递语义（如<strong>点对点队列</strong>和<strong>无 offset 的发布/订阅主题</strong>），而非暴露底层存储结构；在 JMS/AMQP 中，消息一旦被消费并确认，通常就从代理中删除，消费者无法回溯或重新读取历史消息，也无法精确控制从哪个位置开始消费；而日志型系统将消息持久化存储在<strong>可重放的日志</strong>中，每个消费者独立维护其在每个 partition 上的 offset，从而支持任意时间点重放、多消费者独立消费同一数据流、以及强顺序保证（分区内）；这种差异使得日志型系统更适合构建事件溯源、流处理和高吞吐数据管道，而传统消息队列更适合任务分发、异步解耦等场景。</p>
<h4 id="消费者偏移量">消费者偏移量</h4>
<ul>
<li>顺序消费分区使处理状态判断变得简单：所有偏移量小于当前消费者偏移量的消息已被处理，更大的则尚未处理，因此代理无需逐条跟踪消息确认，只需定期记录消费者偏移量。</li>
<li><strong>这种基于偏移量的机制大幅减少簿记开销，提升日志型系统在批处理和流处理中的吞吐量</strong>。</li>
<li>消息偏移量与单领导者数据库复制中的日志序列号（LSN）高度相似：两者都允许下游节点断连后从断点精确恢复，避免数据丢失或重复。</li>
<li>在此模型中，<strong>消息代理如同数据库主库，消费者如同从库</strong>，通过偏移量实现可靠的数据同步。</li>
<li>若消费者节点失效，其负责的分区会被重新分配给其他节点，并从最后记录的偏移量开始继续消费。</li>
<li>如果消费者已处理某些消息但未及时提交偏移量，故障恢复后这些消息会被重复处理，导致至少一次（at-least-once）语义；该问题需通过幂等性或事务机制在应用层或系统层解决</li>
</ul>
<h4 id="磁盘空间使用">磁盘空间使用</h4>
<ul>
<li>日志采用仅追加写入，但磁盘空间有限，<strong>因此会被分割为段（segments）</strong>，旧段定期删除或归档以回收空间。</li>
<li>若消费者处理太慢，其偏移量指向已被删除的日志段，则会永久丢失中间消息；<strong>因此日志本质上是一个有限大小的缓冲区</strong>。</li>
<li>这种缓冲区在磁盘上实现，容量可很大，行为类似循环缓冲区（circular/ring buffer）：写满后覆盖最旧数据。</li>
<li>举例：一块 6TB 硬盘以 150MB/s 持续写入，约需 11 小时填满；实际部署中因写入带宽未打满，通常可保留数天甚至数周的消息。</li>
<li><strong>日志系统的吞吐量基本恒定，因为每条消息始终写入磁盘</strong>，性能不受保留时长影响。</li>
<li>这与<strong>内存优先型消息系统</strong>形成鲜明对比：后者在队列短时极快**，但一旦队列溢出需写磁盘，吞吐量会显著下降**，性能依赖于历史数据量。</li>
</ul>
<h4 id="当消费者跟不上生产者时">当消费者跟不上生产者时</h4>
<ul>
<li>基于日志的消息系统属于“缓冲”策略的一种，其缓冲区容量大但固定，受限于可用磁盘空间。</li>
<li>若消费者严重滞后，其请求的数据已超出日志保留范围，则无法读取，相当于代理自动丢弃了过旧的消息。</li>
<li>可通过监控消费者与日志头部的距离（lag）来预警，因缓冲区通常很大，运维有充足时间修复慢消费者，避免消息丢失。</li>
<li>即使某个消费者因滞后而丢失消息，也仅影响该消费者自身，不会干扰其他消费者或生产者，保障系统整体稳定性。</li>
<li><strong>这一特性支持安全地进行开发、测试或调试：临时消费者可随意订阅生产日志，无需担心影响线上服务</strong>-类似 Hadoop 的特性。</li>
<li>消费者关闭或崩溃后，仅保留其偏移量元数据，不再占用处理资源或存储空间。</li>
<li>与传统消息代理形成鲜明对比：传统系统中若未及时删除已失效消费者的队列，会导致消息堆积，占用内存并影响活跃消费者的性能。</li>
</ul>
<h4 id="重新处理消息">重新处理消息</h4>
<p>关键设计在于：副作用是发生在逻辑层面的，发生在另一层的旁路数据结构- offset 上的。</p>
<ul>
<li>在 AMQP/JMS 风格的消息代理中，消息处理和确认是破坏性操作，会导致消息从代理中永久删除。</li>
<li>而在基于日志的消息代理中，消费消息是只读操作，不会修改或删除日志内容，类似于从文件读取数据。</li>
<li>消息处理的唯一副作用是消费者偏移量的推进，而偏移量由消费者自身控制，可灵活调整。</li>
<li>因此，可以轻松重置偏移量（如回退到昨天的位置），用相同或不同的处理逻辑重新消费历史数据，并将结果输出到新位置。</li>
<li>这种可重放性使得基于日志的消息系统更接近批处理模型：输入数据不可变，输出是通过可重复转换生成的派生数据。</li>
<li>该特性支持安全实验、快速回溯修复错误、验证新算法，极大提升了数据流系统的可调试性、可恢复性和协作效率。</li>
<li>正因如此，基于日志的消息传递成为组织内构建可靠、可演进数据集成管道的理想工具。</li>
</ul>
<h2 id="数据库与流">数据库与流</h2>
<ul>
<li>传统上消息代理和数据库被视为两类独立系统，<strong>但基于日志的消息代理借鉴了数据库的设计</strong>思想，反之亦然。</li>
<li>事件不仅包括用户行为或传感器读数，也包括“对数据库的写入操作”本身——数据库变更可被建模为事件。</li>
<li>数据库的<strong>复制日志本质上就是一个写入事件流</strong>：主库生成变更事件，从库按序重放，实现数据同步。</li>
<li>状态机复制原理指出：<strong>若多个副本以相同顺序处理相同的确定性写入事件，最终状态必然一致</strong>——这进一步揭示了数据库与事件流的深层联系。</li>
<li>本节将探讨如何利用事件流的思想解决异构数据系统中的集成与一致性问题。</li>
</ul>
<h3 id="保持系统同步">保持系统同步</h3>
<p><img src="fig11-4.png" alt="在数据库中X首先被设置为A，然后被设置为B，而在搜索索引处，写入以相反的顺序到达"></p>
<ul>
<li>现实中没有单一系统能满足所有数据需求，重要应用通常组合使用 OLTP 数据库、缓存、搜索索引、数据仓库等，每种系统持有数据的不同副本并独立优化。</li>
<li>不同系统间的数据需保持同步：例如数据库更新后，缓存、搜索索引和数据仓库也应更新。</li>
<li>问题在于怎样设计 ETL：<strong>数据仓库通常通过 ETL 批处理实现同步</strong>：定期全量或增量抽取数据库数据，转换后批量加载，延迟较高。</li>
<li>为降低延迟，有人采用“双写”（dual write）-<strong>有顺序保证但没有原子保证的伪可相互切换的写入</strong>：应用在修改数据时，同时写入数据库、更新索引、失效缓存等。</li>
<li>双写存在严重问题（无原子性）：
<ul>
<li>并发竞争条件：多个客户端并发写入时，不同系统可能以不同顺序接收更新，导致永久不一致（如数据库最终为 B，搜索索引为 A）；</li>
<li>部分写入失败：一个系统写入成功，另一个失败，造成数据不一致，且难以自动恢复。</li>
</ul>
</li>
<li>即使无错误，双写也无法保证顺序一致性，除非引入额外机制（如版本向量），但通常应用层不会实现。</li>
<li>重要：<strong>双写本质上面临分布式原子提交问题</strong>，若要保证“全成功或全失败”，需 2PC 等昂贵协议，实践中很少采用。</li>
<li><strong>若存在单一权威写入源（如数据库作为唯一领导者），并让其他系统（如搜索索引）作为其“追随者”</strong>，按相同顺序重放变更，则可避免不一致。</li>
<li>关键问题在于：能否在实践中让搜索索引、缓存等系统真正成为数据库变更流的可靠追随者？这引出了变更数据捕获（CDC Change Data Capture）和事件流集成的解决方案。</li>
</ul>
<h3 id="变更数据捕获">变更数据捕获</h3>
<p>最重要的思想是：<strong>把多写转成单主多从，注册触发器、消费者异步复制</strong>。</p>
<ul>
<li>大多数数据库的<strong>复制日志长期被视为内部实现细节</strong>，未作为公开 API 提供，客户端应通过标准查询接口访问数据，而非直接解析日志。</li>
<li>历史上，许多数据库缺乏文档化或稳定的变更日志访问机制，导致难以可靠地捕获所有数据变更以同步到其他系统（如搜索索引、缓存、数据仓库）。</li>
<li>近年来，变更数据捕获（CDC）技术受到广泛关注，它能实时捕获数据库的写入变更，并将其转换为可被外部系统消费的事件流。</li>
<li>CDC 的核心价值在于：变更一旦写入数据库，即可近乎实时地作为流式事件输出，实现低延迟数据同步。</li>
<li>通过将数据库变更流按相同顺序应用到派生系统（如搜索索引），可确保这些系统与源数据库最终保持一致。</li>
<li>在此模型中，搜索索引、缓存、数据仓库等都<strong>成为数据库变更流的消费者</strong>，<strong>整个架构从“双写”转向“单一写入 + 流式分发”</strong>。</li>
</ul>
<p><img src="%E5%B0%86%E6%95%B0%E6%8D%AE%E6%8C%89%E9%A1%BA%E5%BA%8F%E5%86%99%E5%85%A5%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E7%84%B6%E5%90%8E%E6%8C%89%E7%85%A7%E7%9B%B8%E5%90%8C%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%B0%86%E8%BF%99%E4%BA%9B%E6%9B%B4%E6%94%B9%E5%BA%94%E7%94%A8%E5%88%B0%E5%85%B6%E4%BB%96%E7%B3%BB%E7%BB%9F" alt="fig11-5.png"></p>
<h4 id="实现变更数据捕获">实现变更数据捕获</h4>
<ul>
<li>派生数据系统（如搜索索引、数据仓库）是对记录系统（主数据库）数据的额外视图，变更数据捕获（CDC）确保这些视图能准确反映源数据的所有更改。</li>
<li>CDC 本质上将源数据库确立为“领导者”，其他系统作为“追随者”，通过消费变更流实现数据同步。</li>
<li>基于日志的消息代理非常适合传输 CDC 事件，因其保留分区内消息顺序，避免了负载均衡导致的乱序问题。</li>
<li>CDC 可通过数据库触发器实现（<strong>将变更写入日志表</strong>），但通常性能开销大、稳定性差；更稳健的方式是<strong>直接解析数据库的复制日志</strong>（如 WAL、binlog、oplog），但需处理模式变更等复杂情况。</li>
<li>多个工业级系统已大规模应用 CDC：LinkedIn 的 Databus、Facebook 的 Wormhole、Yahoo! 的 Sherpa；开源工具如 Debezium、Maxwell（MySQL）、Bottled Water（PostgreSQL）、Mongoriver（MongoDB）以及 Oracle 的 GoldenGate 均基于日志解析实现 CDC。</li>
<li>CDC 通常是异步的：源数据库提交事务时不等待派生系统处理变更，因此慢消费者不会拖慢主库，但会引入复制延迟，带来与常规数据库复制相同的延迟相关问题。</li>
</ul>
<h4 id="初始快照">初始快照</h4>
<ul>
<li>保留完整的数据库变更日志理论上可通过重放重建整个数据库状态，但因磁盘空间和重放时间成本过高，日志通常会被截断。</li>
<li>构建派生系统（如全文索引）需要数据库的完整初始状态，仅靠近期变更日志无法覆盖未更新过的数据项。</li>
<li>因此，<strong>实际 CDC 方案需结合一个一致性快照（snapshot）作为起点</strong>，再从该快照对应的日志偏移量开始应用后续变更。</li>
<li><strong>快照必须与变更日志中的特定位置（如 LSN 或 binlog 偏移）精确对齐，以确保变更能无缝衔接</strong>，避免数据丢失或重复。</li>
<li>部分 CDC 工具（如 Debezium）内置快照功能，自动完成初始数据导出与日志位置对齐；其他工具则需用户手动准备快照并配置起始偏移。</li>
</ul>
<h4 id="日志压缩">日志压缩</h4>
<ol>
<li>构建完整系统只要最新值就行，日志要压缩成表里的一行。</li>
<li>墓碑是用更新表达删除的逻辑方法：MVCC 的 readview 就是这样做的。</li>
</ol>
<ul>
<li>当日志只能保留有限历史时，每次新增派生数据系统都需依赖数据库快照；日志压缩（log compaction）提供了一种更高效的替代方案。</li>
<li>日志压缩的原理是：后台定期扫描日志，对相同主键的多条记录只保留最新值，丢弃旧值；删除操作通过“墓碑”（tombstone，如 NULL 值）标记，并在压缩时移除。</li>
<li>压缩后日志的大小仅取决于数据库当前状态（键的数量），而非历史写入总量，大幅节省存储空间。</li>
<li>在 CDC 和基于日志的消息系统中，若每条变更包含主键且代表对该键的完整覆盖，则日志压缩可确保每个键至少保留最新状态。</li>
<li>通过从压缩日志的起始偏移量消费，新消费者能获取数据库当前所有键的最新值，从而重建完整的派生数据系统（如搜索索引），无需额外快照。</li>
<li>Apache Kafka 支持日志压缩功能，使消息主题能作为持久化状态存储，而不仅是临时消息通道。</li>
</ul>
<h4 id="变更流的api支持">变更流的API支持</h4>
<p><strong>一开始 CDC 只是外部工程的方案，现在越来越变成数据存储的标准API或者组件/接口</strong>。</p>
<ul>
<li>越来越多的数据库将变更流作为原生（first-class）接口，而非依赖后期加装或逆向工程实现 CDC。</li>
<li>RethinkDB 支持查询订阅，当查询结果发生变化时主动推送通知给客户端。</li>
<li>Firebase 和 CouchDB 基于内置的变更流实现数据同步，该流也可供应用直接使用。</li>
<li>Meteor 利用 MongoDB 的 oplog 实时订阅数据变更，并驱动用户界面自动更新。</li>
<li>VoltDB 支持将事务输出以流的形式连续导出：通过一个只写不读的特殊表，事务提交时插入元组，形成按提交顺序排列的变更日志，供外部系统异步消费。</li>
<li>Kafka Connect 提供标准化框架，集成多种数据库的 CDC 工具，将变更事件统一接入 Kafka。</li>
<li>一旦变更事件进入 Kafka，即可用于更新搜索索引、缓存等派生数据系统，或作为流处理系统的输入源。</li>
</ul>
<h3 id="事件溯源">事件溯源</h3>
<p>我们在这里讨论的想法和事件溯源（ Event Sourcing） 之间有一些相似之处，这是一个在 领域驱动设计（domain-driven design, DDD） 社区中折腾出来的技术。</p>
<p>已经进入：</p>
<ol>
<li>数据集成领域-流处理领域。</li>
<li>前端领域。</li>
</ol>
<p>CDC还是和时间溯源对比：</p>
<ol>
<li>产生 immutable event log，cdc 是透明产生的；而事件溯源在应用层提供事件表-<strong>这正是 DDD 的原始设计</strong>。</li>
<li>cdc 和事件溯源都不依赖于特定工具。</li>
</ol>
<ul>
<li>事件溯源（Event Sourcing）与变更数据捕获（CDC）有相似之处，都基于将状态变更记录为不可变事件日志，但应用层次和设计哲学不同。</li>
<li>在 CDC 中，应用以传统可变方式操作数据库（更新/删除记录），变更日志由系统底层（如复制日志）自动提取，应用无需感知 CDC 的存在。</li>
<li>在事件溯源中，<strong>应用逻辑直接构建在不可变事件之上</strong>：所有状态变更必须通过写入事件日志完成，禁止或不鼓励直接更新/删除，事件反映业务行为而非底层数据变化。</li>
<li>事件溯源是一种强大的数据建模方法：<strong>记录“用户做了什么”（如“学生取消选课”）比记录“数据变成什么样”更具业务语义</strong>，便于理解、调试和演化。</li>
<li>由于事件不可变且意图明确，新增业务逻辑（如“将位置留给候补者”）可直接基于已有事件触发，无需修改历史数据或原有副作用逻辑。</li>
<li>事件溯源类似于编年史数据模型，其事件日志在概念上与数据仓库星型模型中的**“事实表”相似，都记录随时间发生的业务事实**。</li>
<li>专用数据库（如 Event Store）支持事件溯源，但该模式不依赖特定工具，也可基于传统数据库或基于日志的消息代理（如 Kafka）实现。</li>
</ul>
<h4 id="从事件日志导出当前状态">从事件日志导出当前状态</h4>
<p><strong>compact成current状态是优化手段</strong>，系统的核心原则是永久保存所有原始事件。</p>
<ul>
<li>事件日志本身对用户价值有限，因为用户通常需要系统的当前状态（如购物车内容），而非完整的变更历史。</li>
<li>采用事件溯源的应用必须通过确定性逻辑将事件日志转换为可读的当前状态，该转换过程可重复执行，确保状态重建的一致性。</li>
<li>与 CDC 类似，重放事件日志可重建当前状态，但两者对日志压缩的适用性不同。<br>
CDC 事件通常包含记录的完整新值，因此日志压缩可安全丢弃同一主键的旧事件，仅保留最新值。</li>
<li>事件溯源中的事件表达的是业务意图（如“取消选课”），而非状态快照，后续事件通常不覆盖先前事件，因此必须保留完整历史才能正确重建状态，无法进行类似 CDC 的日志压缩。</li>
<li>为提升读取性能和恢复速度，事件溯源系统通常会定期存储当前状态的快照，但这只是优化手段。</li>
<li>系统的核心原则是永久保存所有原始事件，确保在任何时候都能通过重放完整日志重新生成状态，这是事件溯源可靠性和可审计性的基础。</li>
</ul>
<h4 id="命令和事件">命令和事件</h4>
<ul>
<li>事件溯源严格区分命令（command）和事件（event）：命令是用户的请求，可能失败；事件是已验证、已接受、不可变的事实。</li>
<li>命令在被应用接受前需经过验证（如检查用户名或座位是否可用），只有验证通过后，才会生成对应的持久化事件。</li>
<li>一旦事件被写入日志，它就成为不可更改的事实，即使后续有取消或修改操作，原始事件依然保留，新的变更以额外事件形式追加。</li>
<li>事件流的消费者不能拒绝或否定事件，因为事件已是日志中不可变的部分，且可能已被其他消费者处理。</li>
<li>因此，所有业务规则和完整性验证必须在命令阶段完成，通常通过同步事务确保验证与事件发布原子性。</li>
<li>也可将一个用户请求拆分为多个事件（如“临时预约” + “确认”），使验证过程异步化，同时保持事件流的不可变性和最终一致性。</li>
</ul>
<h3 id="状态-流与不可变性">状态，流与不可变性</h3>
<p>状态易变，而日志只能被追加写改变，已写入部分不可变。</p>
<p><img src="fig11-6.png" alt="应用当前状态与事件流之间的关系"></p>
<ul>
<li>函数式的不变性是批处理和流处理的共同基石：<strong>批处理的可靠性源于输入文件的不可变性</strong>；同样，<strong>事件溯源和变更数据捕获的强大之处也在于依赖不可变的事件日志</strong>。</li>
<li>传统数据库存储的是当前状态，针对读取优化，但状态本身是可变的，通过增删改操作不断演化。</li>
<li>所有状态的变化都由一系列不可变事件驱动：当前座位列表源于预订事件，账户余额源于借贷事件，性能指标源于请求事件。</li>
<li>即使事务回滚，相关事件的发生本身仍是事实；<strong>可变状态与不可变事件日志并非对立</strong>，而是一体两面：状态是事件作用的结果，事件是状态变化的记录。</li>
<li>用数学类比：应用状态是事件流对时间的“积分”，事件流是状态对时间的“微分”；状态反映“现在是什么”，事件流记录“是如何变成这样的”。</li>
<li>若持久保存变更日志，即可随时重放以重建任意时刻的状态；将事件日志视为唯一真相源（system of record），所有派生状态（包括数据库）都从中派生，使数据流更清晰、可追溯。</li>
<li>如 Pat Helland 所言：<strong>数据库内容实质上是日志中最新值的缓存，而日志才是真相本身</strong>。</li>
<li>日志压缩通过保留每个键的最新事件、丢弃旧值，架起了不可变日志与可变数据库状态之间的桥梁，使日志既能代表完整历史，又能高效表达当前状态。</li>
</ul>
<h4 id="不变事件的优势">不变事件的优势</h4>
<p>所有系统的<strong>可追溯</strong>都是很重要的，<strong>比把账做平了更重要</strong>。</p>
<ul>
<li>数据库中的不变性并非新概念，会计系统数百年来一直使用仅追加的分类账记录交易事件，账目（如利润、资产负债表）由这些事件汇总派生而来。</li>
<li>会计中若发生错误，不会修改或删除原始记录，而是通过新增一笔补偿性交易（如退款）来纠正，原始错误记录保留以供审计。</li>
<li><strong>这种不可变性极大提升了系统的可审计性和可追溯性</strong>，不仅适用于金融系统，在普通应用中同样有价值。</li>
<li>若应用使用可变数据库且错误代码覆写数据，恢复原始状态极其困难；而基于不可变事件日志的系统可轻松重放、诊断并修复问题。</li>
<li>不可变事件日志保留了比当前状态更丰富的信息：例如用户将商品加入又移出购物车的行为，虽对订单无影响，但对用户行为分析极具价值。</li>
<li>在可变数据库中，移出购物车即删除记录，此类中间行为信息会永久丢失；而在事件日志中，所有操作都被完整保留，支持更深入的数据洞察。</li>
</ul>
<h4 id="相同的事件日志派生多个视图">相同的事件日志派生多个视图</h4>
<p>这段话的意思是：<strong>以不可变事件流作为系统写入的唯一入口，并从该流按需生成多种读取优化的状态视图。</strong>。</p>
<ul>
<li>通过将不可变事件日志与可变状态分离，可从同一日志派生出多种针对不同读取场景优化的数据视图，如同一个流的多个消费者。</li>
<li>实际案例包括：Druid 从 Kafka 直接摄取数据用于分析，Pistachio 用 Kafka 作为提交日志构建键值存储，Kafka Connect 将事件导出到各类数据库和索引系统。</li>
<li>引入从事件日志到状态的显式转换，使系统更易演进：新增功能可构建独立的读取视图，无需修改现有系统，新旧系统可并行运行，旧系统废弃后直接下线即可。</li>
<li>数据存储本身简单，复杂性主要来自对特定查询模式的支持；将写入形式（事件日志）与读取形式（实体化视图）分离，能极大提升架构灵活性。</li>
<li>这种分离思想被称为命令查询责任分离（CQRS）：写入路径处理命令并生成事件，读取路径消费事件并构建查询优化视图。</li>
<li>传统数据库设计常误以为“写入格式必须匹配查询格式”；而基于事件日志的架构解耦了二者，使读取视图可自由非规范化，无需纠结于规范化争论。</li>
<li>推特主页时间线是典型读取优化状态：高度非规范化（每条推文重复存储到所有粉丝时间线），通过扇出服务与事件流（发推、关注变更）保持同步，确保重复数据的一致性与可维护性。</li>
</ul>
<h4 id="不可变的限制">不可变的限制</h4>
<ul>
<li>许多非事件溯源系统也依赖不可变性：<strong>数据库使用不可变结构或多版本并发控制（MVCC）支持时间点快照</strong>，版本控制系统（如 Git、Mercurial）依靠不可变对象保存文件历史。</li>
<li>永久保留完整变更历史的可行性取决于数据流失率：以追加为主、更新/删除少的场景适合不可变模型；高更新/删除率的场景会导致日志膨胀、碎片化，需依赖高效的压缩和垃圾回收机制。</li>
<li>除性能外，法规和管理需求也可能要求真正删除数据：如隐私法规（GDPR）要求用户注销后删除其信息，或需撤回错误/敏感数据。</li>
<li>仅追加“删除事件”（如墓碑）不足以满足合规要求，因为原始数据仍存在于历史中；某些系统提供“改写历史”能力，如 Datomic 的 切除（excision） 和 Fossil 的 避免（shunning），试图从逻辑上抹除数据。</li>
<li>真正彻底删除数据极其困难：数据可能存在于存储引擎内部、文件系统、SSD 的磨损均衡区域、只读备份、缓存、日志副本等多处；删除通常只是“提高恢复难度”，而非“物理不可恢复”。</li>
<li>尽管技术上难以完全清除，但在法律或合规压力下，系统仍需尽力实现数据删除，这已成为现代数据系统必须面对的现实挑战。</li>
</ul>
<h2 id="流处理">流处理</h2>
<ul>
<li>本章已讨论流的来源（用户事件、传感器数据、数据库变更）和传输方式（直接消息、消息代理、事件日志），接下来聚焦流的处理用途。</li>
<li>流处理主要有三种使用模式：
<ol>
<li>写入存储系统：将事件写入数据库、缓存、搜索索引等，供其他客户端查询，实现系统间状态同步（如图11-5）；</li>
<li>推送给人：向用户发送警报、通知，或实时更新仪表盘，此时人是最终消费者；</li>
<li>流到流转换：消费一个或多个输入流，经过处理生成一个或多个输出流，可构成多阶段流水线，最终输出用于前两种模式。</li>
</ol>
</li>
<li>本章后续重点讨论第3种：流到流的派生处理，其处理单元称为算子（operator）或作业（job）。</li>
<li>流处理器与 Unix 进程、MapReduce 作业理念相似：以只读方式消费输入流，以仅追加方式写入输出流。</li>
<li>流处理的分区、并行化、Map 类操作（过滤、转换）与批处理引擎（如 MapReduce）高度相似，不再重复。</li>
<li>与批处理的关键区别在于：流是无界的，永不停止，这带来根本性影响：
<ul>
<li><strong>无法对整个流排序</strong>，因此排序合并连接不适用；</li>
<li>容错不能依赖“从头重跑”（对运行数年的流不现实），<strong>需更精细的恢复机制（如 checkpoint、状态管理，只能从故障点恢复）</strong>。</li>
</ul>
</li>
</ul>
<h3 id="流处理的适用场景">流处理的适用场景</h3>
<h4 id="复合事件处理">复合事件处理</h4>
<ul>
<li>复合事件处理（CEP）是 1990 年代为分析事件流而发展出的技术，主要用于在流中检测特定的事件模式，类似于正则表达式在字符串中匹配字符模式。</li>
<li>CEP 系统通常提供高层次的声明式语言（如 SQL）或图形界面，让用户定义要检测的事件模式；处理引擎内部维护状态机，持续匹配输入流中的事件。</li>
<li>当检测到匹配的事件序列时，CEP 引擎会生成一个“复合事件”（complex event），作为输出，包含匹配模式的详细信息。</li>
<li>CEP 颠覆了传统数据库中“数据静态、查询临时”的模型：在 CEP 中，<strong>查询是长期驻留的，而事件是流动的</strong>，不断流经查询进行匹配。</li>
<li>典型 CEP 实现包括 Esper、IBM InfoSphere Streams、Apama、TIBCO StreamBase 和 SQLstream；现代分布式流处理框架（如 <strong>Samza</strong>）也支持在流上使用 SQL 进行声明式模式匹配。</li>
</ul>
<h4 id="流分析-重点">流分析（重点）</h4>
<ul>
<li>流分析是流处理的重要应用领域，与 CEP 边界模糊，但侧重点不同：<strong>流分析关注大量事件上的聚合与统计指标</strong>，而<strong>非特定事件序列的匹配</strong>。</li>
<li>常见流分析任务包括：
<ul>
<li>测量事件发生速率（如每秒请求数）；</li>
<li><strong>滚动计算时间窗口内</strong>的平均值、百分位等<strong>统计量</strong>；</li>
<li>对比当前与历史时段的指标（如同比异常检测）。</li>
</ul>
</li>
<li>这些计算通常在时间窗口（window）内进行，例如“过去5分钟的 QPS 和响应时间 P99”，窗口能平滑短期波动，揭示长期趋势。</li>
<li>流分析系统常采用<strong>概率算法</strong>以节省资源：
<ul>
<li>Bloom Filter 用于成员资格判断；</li>
<li>HyperLogLog 用于基数估计；</li>
<li>各类近似算法用于高效计算百分位。这些算法提供近似结果，但显著降低内存开销。</li>
</ul>
</li>
<li>流处理本身并非 inherently 近似：概率算法只是可选优化，系统仍可支持精确计算；认为流处理“总是不精确”是一种误解。</li>
<li>多个开源流处理框架专为分析设计，包括 Apache Storm、Spark Streaming、Flink、Concord、Samza 和 Kafka Streams。</li>
<li>主流云厂商也提供托管流分析服务，如 Google Cloud Dataflow 和 Azure Stream Analytics。</li>
</ul>
<h4 id="维护实体化视图">维护实体化视图</h4>
<p>缓存、索引和 dw，都是实体化视图，通常需要全量数据。</p>
<ul>
<li>数据库变更流可用于维护缓存、搜索索引、数据仓库等派生系统，使其与源数据同步，这本质上是实体化视图（materialized view）的一种实现：基于源数据构建高效查询的替代视图，并在源数据变更时自动更新。</li>
<li>在事件溯源中，应用的当前状态是通过重放事件日志构建的，这种状态也是一种实体化视图，但它通常需要全量历史事件（从时间起点开始），而不仅仅是某个时间窗口内的数据。</li>
<li>与流分析不同（后者聚焦滑动/滚动窗口内的聚合），<strong>实体化视图的维护往往要求无限时间窗口</strong>（或至少覆盖所有未被日志压缩丢弃的事件），以确保状态完整准确。</li>
<li>理论上，任何流处理引擎都可用于维护实体化视图，<strong>但许多面向分析的框架（如 Spark Streaming）默认假设处理有限窗口</strong>，与“永远运行、持续更新状态”的实体化视图需求不符。</li>
<li>Samza 和 Kafka Streams 明确支持实体化视图场景，它们利用 Kafka 的日志压缩（log compaction）功能，确保每个键的最新状态可被长期保留和高效重建。</li>
</ul>
<h4 id="在流上搜索">在流上搜索</h4>
<ul>
<li>除了 CEP（复合事件处理）中对多个事件之间时序或逻辑模式的搜索（如“用户先点击广告后5秒内购买”），有时也需要基于复杂条件（如全文搜索、结构化过滤）对单个事件的内容进行实时匹配。</li>
<li>典型场景包括：媒体监测服务扫描新闻/播客流以匹配用户预设关键词（如公司名、产品），或房产网站在新房源上架时通知订阅用户——这些需求只关心单条事件是否满足条件，不涉及事件间的顺序或关联。</li>
<li>这类功能通过预先注册查询，让事件流持续与这些查询匹配来实现；Elasticsearch 的 Percolator（反向搜索）是典型方案：它将查询持久化存储，新文档到达时自动匹配所有注册查询，并返回匹配结果用于触发通知——例如向用户推送邮件、更新仪表盘、写入告警队列，或触发后续自动化工作流。</li>
<li>虽然 CEP 和流式搜索都采用“查询驻留、数据流动”的架构（与传统数据库“数据静态、查询临时”相反），但二者目标不同：<strong>CEP 检测跨事件的复合模式，流式搜索则对单事件做独立内容过滤</strong>。</li>
<li>当查询量大时，为避免全量比对，系统会为查询建立索引（如倒排索引），快速筛选可能匹配的子集，提升匹配效率。</li>
</ul>
<h4 id="消息传递和-rpc">消息传递和 RPC</h4>
<ul>
<li>消息传递系统（如 Actor 模型）虽<strong>基于消息/事件</strong>，但通常不被视为流处理组件，因其设计目标和使用模式不同。</li>
<li>Actor <strong>框架主要用于管理模块间的并发与分布式执行</strong>，属于计算协调机制；而流处理是一种数据管理技术，聚焦于数据的持续转换与派生。</li>
<li>Actor 通信通常是短暂、一对一、<strong>请求/响应式的</strong>，且允许任意拓扑（包括循环调用）；而事件日志是持久、多订阅者、仅追加的，流处理流水线通常为无环、数据驱动的 DAG。</li>
<li>尽管有区别，两者存在交叉：例如 Apache Storm 的分布式 RPC 功能，可将用户查询与事件流交织处理，并汇总结果返回，结合了交互式请求与流式计算。</li>
<li>Actor 框架也可用于流处理，但多数默认不提供强容错保证（如消息不丢失、处理不重复），需额外实现重试、持久化等机制才能达到流处理所需的可靠性。</li>
</ul>
<h3 id="流的时间问题">流的时间问题</h3>
<ul>
<li>流处理常依赖时间窗口（如“过去五分钟的平均值”），但“最后五分钟”的定义在实践中非常复杂，并非表面看起来那样清晰无歧义。</li>
<li><strong>批处理</strong>处理的是历史数据，通常在几分钟内完成对一年事件的分析；此时应使用<strong>事件时间</strong>（event time），即每个事件自带的时间戳，而非处理机器的系统时钟。</li>
<li>使用事件时间使批处理具有确定性：相同输入重复运行总能得到相同结果，且分析反映的是事件真实发生的时间线，而非处理时间线。</li>
<li>相比之下，<strong>许多流处理框架默认使用处理时间</strong>（processing time），即处理机器的本地系统时钟来划分窗口。</li>
<li>处理时间的优点是实现简单、延迟低；但一旦出现显著处理延迟（如网络拥堵、故障恢复、数据重放），窗口计算就会失真，导致结果不准确甚至失效。</li>
</ul>
<h4 id="事件时间与处理时间">事件时间与处理时间</h4>
<p><img src="fig11-7.png" alt="按处理时间分窗，会因为处理速率的变动引入结果异常"></p>
<ul>
<li>处理延迟可能由多种原因引起：消息排队、网络故障、系统资源争用、流消费者重启、重放历史事件，或修复 Bug 后的故障恢复。</li>
<li>延迟会导致事件到达顺序与实际发生顺序不一致：例如，Web 服务器 A 和 B 分别处理两个先后请求，但 B 的事件可能先于 A 的事件到达流处理器，造成乱序。</li>
<li>这类似于《星球大战》电影的上映顺序与叙事顺序不一致：集数编号代表事件时间（事件真实发生顺序），而观看日期代表处理时间（事件被处理的顺序）。</li>
<li>人类能理解这种顺序错乱，但流处理算法必须显式处理事件时间和处理时间的差异，否则会得出错误结论。</li>
<li>混淆事件时间与处理时间会导致分析失真：例如，流处理器停机一分钟后再恢复，若按处理时间计算请求速率，会将积压事件误判为突发流量高峰，而实际请求速率是平稳的。</li>
<li>因此，基于处理时间的窗口容易受系统处理速度波动影响，引入人为偏差；<strong>准确的流分析应尽可能基于事件时间</strong>。</li>
</ul>
<h4 id="了解什么时候准备就绪">了解什么时候准备就绪</h4>
<ul>
<li>使用事件时间定义窗口的核心难题是：无法确定是否已收齐某个窗口的所有事件，因为后续可能仍有延迟事件（滞留事件）到达。</li>
<li>例如，按一分钟窗口统计请求数：当系统已开始处理第38、39分钟的事件时，仍无法确定第37分钟的窗口是否完整。</li>
<li>常见做法是设置超时机制：在一段时间未收到新事件后，宣布窗口完成；但网络延迟或缓冲可能导致滞留事件在窗口关闭后才到达。</li>
<li>面对滞留事件，主要有两种处理策略：
<ol>
<li>忽略滞留事件：假设其占比很小，同时监控丢弃量，异常时告警；</li>
<li>发布更正：输出更新后的窗口结果，并可能撤回或覆盖之前的输出。</li>
</ol>
</li>
<li>某些系统可通过水位线（watermark）机制辅助判断：生产者发送“此后无早于时间 t 的事件”信号，消费者据此触发窗口计算。</li>
<li>但在多生产者场景下，每个生产者需独立维护其时间进度，消费者需分别跟踪所有生产者的水位线，导致动态增删生产者变得复杂。</li>
</ul>
<h4 id="你用谁的时钟？">你用谁的时钟？</h4>
<ul>
<li>当事件在系统中多处缓冲（如移动设备离线缓存），准确分配时间戳变得困难：设备可能在脱机时记录用户行为，数小时甚至数天后才上报，对流消费者而言表现为极端滞留事件。</li>
<li>理想的事件时间戳应为用户交互发生的真实时间（基于设备本地时钟），但设备时钟通常不可靠，可能被用户无意或故意设置错误。</li>
<li>服务器接收时间（基于服务器时钟）更准确，但反映的是上报时间而非行为发生时间，业务语义价值有限。</li>
<li>一种校正方法是记录三个时间戳：
<ul>
<li>事件发生时间（设备时钟）</li>
<li>事件发送时间（设备时钟）</li>
<li>事件接收时间（服务器时钟）</li>
</ul>
</li>
<li>通过 <strong>接收时间</strong> − <strong>发送时间</strong> 估算设备与服务器时钟的偏移量（假设网络延迟可忽略），再将该偏移应用于事件发生时间，从而推算更接近真实的发生时间（假设时钟偏移在事件发生到发送期间保持稳定）。</li>
<li>此类时间推理问题并非流处理独有，批处理同样存在；但流处理因强调实时性和窗口计算，使时间语义问题更加突出和亟需处理。</li>
</ul>
<h4 id="窗口的类型">窗口的类型</h4>
<p>窗口用于按时间对<strong>事件分组聚合</strong>，常见类型有：</p>
<ul>
<li>滚动窗口：固定长度，不重叠，每个事件只属于一个窗口（如每1分钟一组）。</li>
<li>跳动窗口：固定长度，可重叠，通过设置步长实现平滑聚合（如每1分钟输出一个5分钟窗口的结果）。</li>
<li>滑动窗口：无固定边界，包含任意时间间隔不超过窗口长度的事件（如任意两个5分钟内发生的事件归为一组）。</li>
<li>会话窗口：按用户活动划分，无固定时长，空闲超时（如30分钟无事件）即结束当前会话。</li>
</ul>
<h2 id="流式-join">流式 join</h2>
<p>批处理让数据和数据集进行 join，对流这种无界数据集进行增量处理，进而进行 join 是可行的。</p>
<h3 id="流和流-join-窗口-join">流和流 join（窗口 join）</h3>
<p>流与流最好限定关联范围，才能平衡效果和开销。</p>
<ul>
<li>为计算搜索结果的点击率，需将“搜索事件”和“点击事件”按会话ID关联，两者缺一不可（仅靠点击事件无法统计未点击的搜索）。</li>
<li>搜索与点击之间的时间间隔高度可变：可能几秒，也可能数天；且因网络延迟，点击事件甚至可能早于搜索事件到达。</li>
<li>可设定连接窗口（如1小时内）来限定关联范围，平衡准确性与资源开销。</li>
<li>流处理器需维护状态：按会话ID缓存窗口期内的搜索和点击事件。</li>
<li>每当新事件到达，系统检查是否有匹配的会话ID事件；若有，输出“已点击”；若搜索事件超时仍未匹配，则输出“未点击”，确保点击率计算完整。</li>
</ul>
<h3 id="流和表-join">流和表 join</h3>
<ul>
<li><strong>将用户活动事件流与用户档案数据库连接</strong>，以“扩充”（enrich）事件（如将用户ID替换为完整档案），是流处理中的常见需求。</li>
<li>一种方式是为<strong>每个活动事件实时查询远程数据</strong>库，但可能因延迟高、负载大而影响性能和稳定性。</li>
<li>更高效的方式是<strong>将数据库副本加载到流处理器本地</strong>（内存哈希表或本地索引），实现低延迟查询，类似批处理中的 Map 端 Hash Join。</li>
<li>与批处理不同，流处理器长期运行，而数据库会持续更新，因此本地副本必须保持同步。</li>
<li>可通过变更数据捕获（CDC）解决同步问题：流处理器订阅用户档案表的变更日志，实时更新本地副本。</li>
<li>这样，流表连接本质上变成两个流的连接：<strong>活动事件流 + 档案变更流。</strong></li>
<li>流表连接与流流连接类似，关键区别在于：
<ul>
<li><strong>表的变更流使用概念上无限的窗口（从时间起点开始）</strong>，新记录覆盖旧记录；</li>
<li>活动事件流通常不维护窗口，<strong>仅与当前表状态连接</strong>。</li>
</ul>
</li>
</ul>
<h3 id="表表-join-实体化视图维护">表表 join（实体化视图维护）</h3>
<ul>
<li>推特主页时间线若在读取时实时合并关注用户的推文，开销巨大；因此需预先实体化一个“收件箱式”缓存，写时更新、读时直接查询。</li>
<li>维护该缓存需处理四类事件：
<ul>
<li>用户发推 → 推文加入所有粉丝的时间线；</li>
<li>用户删推 → 从所有粉丝时间线中移除该推文；</li>
<li>用户关注他人 → 将被关注者近期推文加入关注者时间线；</li>
<li>用户取消关注 → 从时间线中移除被取消关注者的推文。</li>
</ul>
</li>
<li>流处理器需消费两个事件流：推文流（含发送/删除）和关注关系流（含关注/取关），并维护一个粉丝关系数据库，以确定每条推文应更新哪些用户的时间线。</li>
<li>该过程本质上是维护一个实体化视图，对应 SQL 中推文表与关注表的连接、分组和聚合（按 follower_id 聚合其时间线）。</li>
<li>流处理中的连接操作直接对应 SQL 查询中的 JOIN；时间线缓存即该查询结果的实时实体化版本。</li>
<li>从微分视角看，实体化视图的变更流遵循“乘积（叉乘）法则”：<strong>推文变化需与当前关注关系结合，关注关系变化也需与当前推文结合，共同驱动缓存更新</strong>。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> follows.follower_id <span class="hljs-keyword">AS</span> timeline_id, <br>    <span class="hljs-built_in">array_agg</span>(tweets.<span class="hljs-operator">*</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> tweets.timestamp <span class="hljs-keyword">DESC</span>)<br><span class="hljs-keyword">FROM</span> tweets<br><span class="hljs-keyword">JOIN</span> follows <span class="hljs-keyword">ON</span> follows.followee_id <span class="hljs-operator">=</span> tweets.sender_id <br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> follows.follower_id<br></code></pre></td></tr></table></figure>
<h3 id="join-的时间依赖性">join 的时间依赖性</h3>
<ul>
<li>流流连接、流表连接、表表连接的共通点是：<strong>流处理器需维护一侧的状态</strong>（如点击事件、用户档案、关注列表），并在另一侧事件到达时查询该状态进行关联。</li>
<li>状态的正确性依赖于<strong>事件的处理顺序</strong>（如先关注后取关），而<strong>分区日志仅保证单个分区内事件有序，不保证跨流或跨分区的全局顺序</strong>。</li>
<li>当多个流的事件时间相近时，处理顺序不确定会导致连接结果模糊：例如，用户档案更新前后到达的活动事件，应关联旧值还是新值？这本质上是**“用哪个时间点的状态做连接”**的问题。</li>
<li>此类时序依赖广泛存在：如销售发票需关联<strong>销售发生时</strong>的税率，而非当前税率；重新处理历史数据时，必须使用历史上下文。</li>
<li>若跨流事件顺序不确定，连接结果将<strong>非确定性</strong>：相同输入重跑可能因事件交织顺序不同而产生不同输出。</li>
<li>数据仓库中将此问题称为<strong>缓慢变化维度（SCD）</strong>，常用解决方案是：
<ul>
<li>为状态的每个版本分配唯一标识符（如税率版本ID）；</li>
<li>事件记录时绑定当时状态的版本ID；</li>
<li>连接时通过版本ID精确匹配，确保结果确定性。</li>
</ul>
</li>
<li>但该方法要求保留所有历史版本记录，导致无法使用日志压缩（因旧版本不可丢弃）。</li>
</ul>
<h2 id="流处理的容错">流处理的容错</h2>
<p>无限流甚至不能用 exactly-once 来处理。本书认为，<strong>恰好一次应该叫有效一次更妥当</strong>。</p>
<ul>
<li>批处理容错简单有效：任务失败可透明重试，因输入不可变、输出写入独立文件，仅成功任务的输出可见，确保最终结果与无故障执行一致。</li>
<li>批处理通过重试实现恰好一次语义（exactly-once semantics）：尽管记录可能被多次处理，但输出效果如同每条记录仅处理一次（更准确应称“有效一次”）。</li>
<li>流处理面临相同容错需求，但无法直接套用批处理方法：流是无限的，无法等待“任务完成”后再暴露输出，因此不能简单依赖“成功才可见”的输出机制。</li>
<li>这使得流处理的容错设计更复杂，需在持续处理的同时保证结果的正确性和一致性。</li>
</ul>
<h3 id="微批处理和校验点">微批处理和校验点</h3>
<ul>
<li>微批次（Microbatching）将无限流切分为小批次（如1秒），以批处理方式处理每个块，Spark Streaming 采用此方法；批次大小是延迟与调度开销的折中。</li>
<li><strong>微批次隐式提供一个按处理时间划分的滚动窗口</strong>（窗口大小等于批次大小）；若需更大或基于事件时间的窗口，必须显式跨批次传递状态。</li>
<li>Apache Flink 采用检查点（checkpointing）：<strong>定期将算子状态快照写入持久存储，崩溃时从最近检查点恢复，并丢弃检查点之后的输出</strong>；检查点由流中的 barrier 触发，不强制固定窗口大小。</li>
<li><strong>在流处理框架内部，微批次和检查点均可实现恰好一次语义</strong>（exactly-once）。</li>
<li>但当输出离开流处理器（如写数据库、发邮件、发消息到外部系统），框架无法撤回已产生的外部副作用；此时仅靠微批次或检查点不足以保证端到端的恰好一次，需额外机制（如幂等写入、事务性输出）。</li>
</ul>
<h3 id="重新审视原子提交">重新审视原子提交</h3>
<ul>
<li><strong>为实现恰好一次处理语义</strong>，必须确保所有副作用（输出消息、数据库写入、状态变更、输入确认、偏移量提交等）<strong>仅在处理成功时生效</strong>，失败时全部回滚。</li>
<li>这些操作必须<strong>原子地发生或全部不发生</strong>，不能部分生效，否则会导致状态不一致或重复处理。</li>
<li>该要求本质上与<strong>分布式事务</strong>（如两阶段提交）的目标一致：保证跨多个操作的原子性。</li>
<li>传统分布式事务（如 XA）因跨异构系统、性能开销大而难以在流处理中高效应用。</li>
<li>新一代系统（如 Google Cloud Dataflow、VoltDB）<strong>在受限但可控的</strong>环境中高效实现了此类原子提交：
<ul>
<li>将状态管理、消息处理、输出写入统一纳入流处理框架内部；</li>
<li>不依赖跨异构系统的通用事务协议，而是<strong>内化事务逻辑</strong>；</li>
<li>通过<strong>单事务处理多条消息</strong>分摊协议开销，提升吞吐。</li>
</ul>
</li>
<li>Apache Kafka 也计划引入类似机制，以支持端到端的恰好一次语义。</li>
</ul>
<h4 id="幂等性">幂等性</h4>
<ul>
<li>实现容错重试而不产生重复副作用的目标，可通过<strong>分布式事务</strong>或<strong>幂等性</strong>（idempotence）达成。</li>
<li><strong>幂等操作</strong>指多次执行与单次执行效果相同，例如“将键设为某值”是幂等的，而“递增计数器”不是。</li>
<li>即使操作本身非幂等，也可通过<strong>附加元数据</strong>使其幂等：例如，利用 Kafka 消息的<strong>持久偏移量</strong>作为唯一标识，写入外部数据库时一并记录，从而在重试时检测并跳过已处理的消息。</li>
<li>Storm 的 Trident 等系统基于此思想实现状态更新的幂等性。</li>
<li>依赖幂等性需满足若干前提：
<ul>
<li>失败任务重试时<strong>必须重放相同消息且顺序一致</strong>（日志型消息系统如 Kafka 可保证）；</li>
<li><strong>处理逻辑必须是确定性的</strong>；</li>
<li><strong>无其他并发进程同时修改相同状态</strong>。</li>
</ul>
</li>
<li>在<strong>故障切换时</strong>，还需<strong>防护</strong>（fencing）机制（如版本号、租约）防止旧节点（假死）继续写入，造成冲突。</li>
<li>尽管有上述约束，幂等性仍是实现<strong>恰好一次语义</strong>的有效方式，且相比分布式事务，<strong>额外开销较小</strong>。</li>
</ul>
<h4 id="故障后重建状态">故障后重建状态</h4>
<ul>
<li>任何有状态的流处理（如窗口聚合、流表连接中的索引或缓存）都必须保证状态在故障后可恢复，以避免数据丢失或结果错误。</li>
<li>两种主要状态管理策略：
<ol>
<li>远程存储：将状态存于外部数据库**，天然支持复制**，但每次处理需远程查询，延迟高、可能压垮数据库；</li>
<li>本地存储 + 复制：状态保存在流处理器本地以提升性能，<strong>并通过定期复制实现容错</strong>，故障时从副本恢复。</li>
</ol>
</li>
<li>主流框架的具体实现：
<ul>
<li>Flink：定期对算子状态做快照（checkpoint），写入 HDFS 等持久化存储；</li>
<li>Samza / Kafka Streams：将状态变更写入专用 Kafka 主题（启用日志压缩），通过重放变更流重建状态，类似 CDC；</li>
<li>VoltDB：通过在多个节点上冗余执行相同消息来同步复制状态。</li>
</ul>
</li>
<li>在某些场景下，无需显式复制状态：
<ul>
<li>若状态基于短窗口，<strong>可直接重放窗口内事件快速重建</strong>；</li>
<li>若状态是数据库的本地副本，<strong>可通过日志压缩的变更流完整恢复</strong>。</li>
</ul>
</li>
<li>状态管理方案的选择高度依赖底层基础设施性能（如网络延迟 vs 磁盘 I/O、带宽对比），没有通用最优解；随着硬件技术演进（如高速网络、持久内存），本地与远程状态的优劣关系也可能发生变化。</li>
</ul>
<h2 id="小结">小结</h2>
<ul>
<li>本章探讨事件流的本质、来源、传输与处理，指出流处理是批处理在无限、永不停止的数据流上的自然延伸；消息代理和事件日志可视为文件系统的流式等价物。</li>
<li>对比两类消息代理：
<ul>
<li>AMQP/JMS 风格：单条消息分配给消费者，确认后删除，适合任务队列或异步 RPC，不支持重放或顺序强保证；</li>
<li>基于日志的消息代理（如 Kafka）：按分区分配，保证分区内顺序，消费者通过偏移量跟踪进度，消息持久化支持重放，适用于构建派生状态和流处理。</li>
</ul>
</li>
<li>流的来源包括：用户行为事件、传感器读数、市场数据 Feed，以及数据库变更（通过 CDC 或事件溯源）；日志压缩使流能完整表示数据库当前状态。</li>
<li>将数据库视为流，为系统集成提供强大能力：通过消费变更日志，可实时更新搜索索引、缓存、数据仓库等派生系统，甚至从头重建全新数据视图。</li>
<li>流处理的<strong>核心用途</strong>包括：
<ul>
<li>复杂事件处理（CEP）：检测事件模式；</li>
<li>流分析：基于时间窗口的聚合与统计；</li>
<li>实体化视图维护：保持派生数据系统与源同步。</li>
</ul>
</li>
<li>流处理中的时间推理面临挑战：需区分事件时间（event time）与处理时间（processing time），并处理窗口关闭后到达的滞留事件（stragglers）。</li>
<li>三种主要流连接类型：
<ul>
<li>流流连接：关联两个活动事件流（或自连接），通常在时间窗口内匹配相关事件；</li>
<li>流表连接：活动事件流与数据库变更流连接，用最新表状态扩充事件；</li>
<li>表表连接：两个数据库变更流连接，输出实体化视图的变更流。</li>
</ul>
</li>
<li>流处理容错需实现恰好一次语义，但因流无限运行，不能简单丢弃全部输出；解决方案包括：
<ul>
<li>微批次（Spark Streaming）；</li>
<li>检查点/存档点（Flink）；</li>
<li>事务性输出；</li>
<li>幂等写入；</li>
</ul>
</li>
</ul>
<p>这些机制在细粒度上协调状态、输入与输出，确保故障恢复后结果一致。</p>
<h1>数据系统的未来</h1>
<p>第1章概述了本书的目标：探索如何创建<strong>可靠</strong>，<strong>可扩展</strong>和<strong>可维护</strong>的应用与系统。这一主题贯穿了所有的章节：例如，我们讨论了许多有助于提高可靠性的容错算法，有助于提高可扩展性的分区，以及有助于提高可维护性的演化与抽象机制。</p>
<h2 id="数据集成">数据集成</h2>
<p>本书中反复出现的主题是，对于<strong>任何给定的问题都会有好几种解决方案</strong>，所有这些解决方案都有不同的优缺点与利弊权衡。</p>
<p>如果你有一个类似于“我想存储一些数据并稍后再查询”的问题，<strong>那么并没有一种正确的解决方案</strong>。但对于不同的具体环境，总会有不同的合适方法。</p>
<h3 id="采用派生数据来组合工具">采用派生数据来组合工具</h3>
<ul>
<li>将 OLTP 数据库与全文搜索索引集成是常见需求：虽然部分数据库（如 PostgreSQL）提供基础全文搜索，但复杂场景仍需专业检索工具（如 Elasticsearch）；而<strong>搜索索引通常不适合作为主记录系统</strong>，因此需组合多种技术。</li>
<li><strong>随着系统复杂度提升，数据需在多种表示形式间同步</strong>：除数据库和搜索索引外，还包括数据仓库、缓存、反规范化视图、机器学习/推荐系统输入，以及基于数据变更的通知服务。</li>
<li>数据集成需求<strong>在单个应用中可能不明显，但在组织级数据流视角下变得至关重要</strong>：不同团队和系统对数据的使用方式差异巨大。</li>
<li><strong>看似边缘的功能，可能是他人业务的核心</strong>；数据处理需求的多样性决定了集成架构的必要性。</li>
</ul>
<h4 id="为何需要数据流">为何需要数据流</h4>
<p>总之一切都是<strong>日志状态机</strong>最好。</p>
<ul>
<li>当在多个存储系统（如数据库、搜索索志、缓存）中维护同一数据的副本时，必须清晰定义：数据源头、写入顺序、派生关系和同步路径。</li>
<li>推荐做法：所有写入首先提交到单一记录系统（如 OLTP 数据库），再通过变更数据捕获（CDC）将变更按相同顺序应用到派生系统（如搜索索引），确保逻辑一致性。</li>
<li>若允许应用同时直写多个系统（如既写数据库又写索引），则可能因处理顺序不一致导致永久性数据不一致（如图11-4所示的竞态条件）。</li>
<li>通过单一写入入口（single source of truth）决定全局写入顺序，是避免不一致的关键；这本质上是状态机复制（State Machine Replication）思想的应用：所有副本按相同顺序重放操作。</li>
<li>无论是 CDC 还是事件溯源，其可靠性都依赖于对写入顺序达成共识；顺序一致性比具体技术选型更重要。</li>
<li>基于事件日志更新派生系统的架构，天然支持确定性处理和幂等写入，使得故障恢复简单可靠。</li>
</ul>
<h4 id="派生数据与分布式事务">派生数据与分布式事务</h4>
<p>派生数据的传统方案是分布式事务，<strong>现代方案是基于日志派生数据</strong>，后者最有前途。</p>
<ul>
<li>保持多数据系统一致的<strong>传统方法是分布式事务</strong>（如 2PC），而<strong>现代替代方案是基于日志的派生数据系统</strong>（如 CDC、事件溯源）；两者目标相似，但机制不同。</li>
<li>核心机制对比：
<ul>
<li>分布式事务通过锁（如 2PL）决定写入顺序，通过原子提交确保变更生效一次；</li>
<li>基于日志的系统通过有序日志确定顺序，依靠确定性重放和幂等性实现一致性。</li>
</ul>
</li>
<li>一致性模型差异：
<ul>
<li>分布式事务通常提供线性一致性，支持强保证（如“读己之写”）；</li>
<li>派生数据系统多为异步更新，默认只提供最终一致性，不保证即时可见性。</li>
</ul>
</li>
<li>实用性考量：
<ul>
<li>XA 等传统分布式事务协议在容错性、性能和运维复杂度上表现不佳，限制了其广泛应用；</li>
<li>尽管设计更好的事务协议理论上可行，但推动现有生态采纳难度大、周期长。</li>
</ul>
</li>
<li>作者立场：
<ul>
<li>在缺乏高效通用分布式事务的现实下，基于日志的派生数据是集成异构系统的最有前途方法；</li>
<li>但不应简单要求用户“接受最终一致性”，而应提供实用的中间方案来增强保障（如读己之写）。</li>
</ul>
</li>
<li>未来方向：
<ul>
<li>后续章节将探讨如何在异步派生系统之上构建更强的一致性保证，在分布式事务与纯异步日志系统之间找到实用的中间地带。</li>
</ul>
</li>
</ul>
<h4 id="全序的局限">全序的局限</h4>
<p>重要结论：共识不支持横向扩展。</p>
<ul>
<li>对于小型系统，构建完全有序的事件日志是可行的（如单主复制数据库所示），但系统规模扩大后面临根本性限制。</li>
<li>单点瓶颈：全序日志通常依赖单一主节点决定事件顺序；当吞吐量超过单机处理能力时，必须分区，但不同分区间的事件顺序无法定义。</li>
<li>地理分布挑战：为容灾常在多数据中心部署独立主库（多主复制），但跨数据中心的事件因缺乏全局协调而顺序不确定。</li>
<li>微服务架构影响：各服务独立管理状态，来自不同服务的事件天然无全局顺序。</li>
<li>客户端状态问题：支持离线操作的客户端可本地立即更新状态，导致客户端与服务器对事件顺序的认知不一致。</li>
<li>理论本质：全局事件排序即全序广播，等价于共识问题；<strong>现有共识算法（如 Paxos、Raft）假设单节点可处理全部负载，不支持跨节点分担负载的排序</strong>。<br>
研究现状：设计既能横向扩展吞吐量，又能在地理分散环境中高效工作的可扩展共识算法，仍是开放性难题。</li>
</ul>
<h4 id="排序事件以捕获因果关系">排序事件以捕获因果关系</h4>
<ul>
<li>当事件之间无因果关系时，缺乏全局顺序影响不大，因为并发事件可任意排序；同一对象的更新可通过路由到同一日志分区实现局部全序。</li>
<li>但因果关系可能隐式存在，若未显式建模，会导致逻辑错误：例如用户先删除好友再发消息，若两事件在不同系统处理且顺序错乱，前任可能错误收到消息。</li>
<li>此类问题本质是跨数据源连接的时间依赖性：通知服务需正确关联“好友关系”与“消息”事件的因果顺序。</li>
<li>目前无完美解决方案，但可考虑以下方向：
<ul>
<li>逻辑时间戳（如 Lamport 时钟）：提供无需协调的偏序或近似全序，但接收方仍需处理乱序事件，并携带额外元数据；</li>
<li>显式记录因果上下文：事件包含用户决策时所见状态的唯一标识，后续事件引用该标识以表达依赖；</li>
<li>冲突解决算法：适用于状态合并，但对外部副作用（如发通知）效果有限。</li>
</ul>
</li>
<li>未来可能需要新的应用开发模式，在避免全序广播瓶颈的同时，有效捕获和维护因果依赖，确保派生状态正确性。</li>
</ul>
<h2 id="批处理与流处理集成">批处理与流处理集成</h2>
<ul>
<li>数据集成的目标是确保数据最终在所有需要的地方以正确的形式存在，实现方式包括消费输入、转换、连接、过滤、聚合、模型训练与评估，并输出到合适的目标系统。</li>
<li>批处理和流处理是实现数据集成的核心工具，其<strong>输出均为派生数据集（derived data set）</strong>，例如<strong>搜索索引、实体化视图、推荐结果、聚合指标</strong>等。</li>
<li>批处理与流处理共享许多核心原则（<strong>如不可变输入、确定性转换、容错机制</strong>），根本区别在于：批处理处理有界数据集，流处理处理无界数据流。</li>
<li>尽管实现细节存在差异（如窗口模型、容错策略），两者的界限正逐渐模糊：
<ul>
<li>Spark 在批处理引擎上实现流处理，通过微批次（microbatching）模拟流；</li>
<li>Apache Flink 在流处理引擎上实现批处理，将批作业视为有界流。</li>
</ul>
</li>
<li>原则上，批处理可模拟流（通过极小批次），流也可模拟批（通过处理完整历史流），但性能特征不同：例如，微批次在实现跳跃窗口或滑动窗口时可能效率较低。</li>
</ul>
<h3 id="维护派生状态">维护派生状态</h3>
<ul>
<li>批处理具有<strong>强烈的函数式风格</strong>：强调确定性纯函数，输出仅依赖输入，无副作用，输入不可变，输出仅追加；流处理继承这一风格，并扩展支持<strong>受管理、容错</strong>的状态。</li>
<li>确定性函数和清晰的输入/输出边界不仅便于容错（如幂等重试），也简化了对组织内数据流的推理；无论派生数据是索引、模型还是缓存，都可视为<strong>从源数据通过函数式管道派生</strong>的结果。</li>
<li>派生数据系统原则上可同步维护（如数据库事务内更新索引），但<strong>异步维护更稳健</strong>：基于事件日志的异步机制能将故障隔离在局部，而分布式事务会因任一参与者失败而中止，放大故障影响范围。</li>
<li>二级索引常<strong>跨越分区边界</strong>，需跨分区写入或读取；若索引<strong>异步维护</strong>，此类跨分区通信更可靠、更具可扩展性，<strong>避免同步事务带来的协调开销</strong>与失败传播。</li>
</ul>
<h3 id="为应用程序演化而重新处理数据">为应用程序演化而重新处理数据</h3>
<ul>
<li>批处理和流处理在维护派生数据时各有优势：
<ul>
<li><strong>流处理实现低延迟</strong>，使派生视图能快速反映输入变化；</li>
<li><strong>批处理</strong>支持重处理海量历史数据，用于<strong>构建全新视图</strong>或应对需求变更。</li>
</ul>
</li>
<li>重处理历史数据是系统演进的关键机制：<strong>仅靠模式演化（如加字段）只能支持简单变更</strong>；通过<strong>重处理</strong>，可将数据彻底重组为全新模型，以满足复杂新需求。</li>
<li>大规模系统演化可借鉴“铁路轨距迁移”案例：
<ul>
<li>19世纪英国铁路存在多种轨距，互不兼容；</li>
<li>通过引入双轨距（三条轨道），新旧列车可并行运行；</li>
<li>待所有列车切换至标准轨距后，再移除旧轨道；</li>
<li>该过程耗时长、成本高，但避免了服务中断，至今仍有系统保留非标准轨距（如旧金山BART）。</li>
</ul>
</li>
<li>派生视图支持类似的渐进演化：
<ul>
<li>无需一次性切换，可同时维护新旧架构作为同一源数据的两个独立派生视图；</li>
<li>先将少量用户切到新视图进行验证，逐步扩大比例，最终下线旧视图。</li>
</ul>
</li>
<li>渐进迁移的核心优势是可逆性：
<ul>
<li>每个阶段都可回滚到稳定状态，极大降低变更风险；</li>
<li>通过减少对不可逆损害的担忧，团队能更自信、更快速地迭代和改进系统。</li>
</ul>
</li>
</ul>
<h3 id="lambda架构">Lambda架构</h3>
<p>DDIA 中的 Lambda 架构是一种结合批处理与流处理的大数据架构模式（2010左右发表），与 AWS Lambda 无服务器计算服务毫无关系，仅名称巧合。</p>
<ul>
<li>Lambda 架构提出将批处理与流处理结合：<strong>用不可变事件日志作为统一输入源</strong>，同时运行两个独立系统——<strong>批处理层</strong>（如 MapReduce）和<strong>流处理层</strong>（如 Storm）。</li>
<li>其核心设计逻辑是：
<ul>
<li>流处理器快速生成近似、低延迟的派生视图；</li>
<li>批处理器稍后用相同事件生成精确、可靠的修正版本；</li>
<li>背后假设是批处理更简单可靠，而流处理易出错且难容错。</li>
</ul>
</li>
<li>Lambda 架构的积极影响在于推广了关键原则：基于不可变事件流构建派生视图，并支持重处理以实现演化。</li>
<li>但 Lambda 架构存在显著实践问题：
<ul>
<li>逻辑重复：需在两个不同框架中实现和维护相同业务逻辑，即使有 Summingbird 等抽象库，调试、调优和运维复杂度仍高；</li>
<li>结果合并困难：用户请求需合并流层和批层的输出，简单聚合尚可处理，但涉及连接、会话化或非时间序列输出时，合并逻辑极其复杂；</li>
<li>批处理层难以真正“重处理全量”：因成本过高，实际常退化为增量批处理（如每小时处理一小时数据），导致需处理跨批次窗口、乱序等问题，使批处理层复杂度上升，违背其“简单可靠”的初衷。</li>
</ul>
</li>
</ul>
<h3 id="统一批处理和流处理">统一批处理和流处理</h3>
<ul>
<li>近期技术发展使得 Lambda 架构的优点（<strong>低延迟流处理 + 可重放批处理</strong>）可在单一系统中实现，避免了维护两套逻辑的复杂性。</li>
<li>实现统一批流处理需具备以下关键能力，且这些能力正变得越来越普及：
<ul>
<li>历史事件重放能力：同一<strong>处理引擎既能处理实时事件流，也能重放历史事件</strong>（如从基于日志的消息代理或 HDFS 读取），确保逻辑一致性。</li>
<li>恰好一次语义（exactly-once semantics）：流处理器需在<strong>故障时丢弃部分输出并重试</strong>，保证<strong>最终结果与无故障执行一致</strong>，与批处理的容错模型对齐。</li>
<li>基于事件时间的窗口化：<strong>窗口计算必须依据事件自身的时间戳，而非处理时间</strong>，以<strong>正确处理历史数据重放和乱序事件</strong>；Apache Beam 等 API 已支持此类表达，并可在 Flink、Cloud Dataflow 等引擎上运行。</li>
</ul>
</li>
</ul>
<h2 id="分拆数据库">分拆数据库</h2>
<ul>
<li>在最抽象层面，数据库、Hadoop 和操作系统都提供相同的核心功能：存储数据并支持处理与查询，本质都是信息管理系统。</li>
<li>实现方式不同：数据库以结构化模型（表、文档、图等）组织记录，文件系统以字节序列形式存储文件；Hadoop 生态则类似 Unix 的分布式版本。</li>
<li>实际能力有显著差异：例如文件系统难以高效管理千万级小文件，而数据库处理同等规模的小记录则很常见。</li>
<li>Unix 与关系数据库代表两种对立哲学：
<ul>
<li>Unix 提供低层次硬件抽象，强调简单、组合（管道、字节流）；</li>
<li>关系数据库 提供高层次逻辑抽象，隐藏并发、恢复、存储等复杂性，通过声明式 SQL 和事务简化开发。</li>
</ul>
</li>
<li>“哪种更好”取决于场景：
<ul>
<li>Unix 的“<strong>简单</strong>”在于贴近硬件、灵活组合；</li>
<li>数据库的“<strong>更简单</strong>”在于用简短声明式语句自动利用强大底层机制（优化器、索引、事务等）。</li>
</ul>
</li>
<li>这一哲学分歧自 1970 年代延续至今；NoSQL 运动可视为将 Unix 式低层抽象理念引入分布式 OLTP 存储的尝试。</li>
<li>作者目标是调和两者，融合 Unix 的灵活性与数据库的高级抽象，取长补短。</li>
</ul>
<h3 id="组合使用数据存储技术">组合使用数据存储技术</h3>
<ul>
<li>数据库提供的核心功能包括：
<ul>
<li>次级索引：支持按字段值高效查询记录；</li>
<li>实体化视图：预计算并缓存查询结果，提升读取性能；</li>
<li>复制日志：用于在其他节点上同步和维护数据副本；</li>
<li>全文搜索索引：支持文本内容的关键字搜索，部分关系数据库已内置该能力。</li>
</ul>
</li>
<li>在第10章（批处理）和第11章（流处理）中，出现了高度相似的概念：
<ul>
<li>使用批处理构建全文搜索索引；</li>
<li>通过流或批处理维护实体化视图；</li>
<li>利用变更数据捕获（CDC）将数据库变更同步到外部派生系统（如缓存、数据仓库）。</li>
</ul>
</li>
<li>这表明：数据库内置功能与通过批处理/流处理构建的派生数据系统在本质上是同构的——都是从源数据派生出优化查询或集成用途的辅助数据结构。</li>
</ul>
<h4 id="创建一个索引">创建一个索引</h4>
<p>创建索引就是扫描一个一致性快照，写出一个精简的从副本。</p>
<h4 id="元数据库">元数据库</h4>
<ul>
<li><strong>整个组织的数据流可被视为一个巨大的分布式数据库</strong>：批处理、流处理和 ETL 作业如同数据库内部机制，负责将数据从一处传输到另一处，并维护索引或实体化视图。</li>
<li>批处理和流处理器实质上是触发器、存储过程和实体化视图维护例程的精细化、分布式实现；它们所维护的派生系统（如搜索索引、缓存、数据仓库）相当于不同类型的索引（B树、哈希、空间索引等），只是由不同软件、团队和机器管理。</li>
<li>面向未来，有两种主要路径可将异构存储与处理工具整合为统一系统：
<ul>
<li>联合数据库（统一读取）：
<ul>
<li>问题来源于怎样从多个系统统一读</li>
<li>提供统一查询接口（如 PostgreSQL 外部数据包装器），跨多个底层存储引擎执行联合查询；</li>
<li>保留专用系统直接访问能力，同时支持跨源数据组合；</li>
<li>遵循传统关系数据库的集成理念，但实现复杂，语义协调困难。</li>
</ul>
</li>
<li>分拆数据库（统一写入）：
<ul>
<li>问题来源于怎样统一写入多个系统</li>
<li>不强求统一查询，而是通过可靠写入同步（如 CDC、事件日志）确保所有派生系统最终一致；</li>
<li>将数据库的索引维护功能“拆分”到独立系统，通过事件流可靠联动；</li>
<li>遵循 Unix 哲学：小型专用工具 + 标准化低级通信（如日志/管道）+ 高级语言组合，强调写入可靠性和系统解耦。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="分离式如何工作">分离式如何工作</h5>
<ul>
<li><strong>联合（统一读取）<strong>与</strong>分拆（统一写入）<strong>是构建可靠、可扩展、可维护系统的两种互补路径；作者认为</strong>同步写入到多个异构系统是更困难且关键的工程挑战</strong>，因此重点聚焦于此。</li>
<li>传统同步写入依赖分布式事务（如 XA），但作者认为这是错误方案：<strong>跨异构技术的分布式事务缺乏标准化、实现复杂、容错性差</strong>；相比之下，基于有序事件日志的异步写入配合幂等消费者是更健壮、实用的方法。</li>
<li>分布式事务<strong>在单一系统内部（如流处理引擎内）可有效支持恰好一次语义</strong>，但跨系统边界（如流处理器写入搜索索引或键值存储）时，因缺乏通用协议而难以集成；幂等消费的事件日志则提供更简单、普适的抽象。</li>
</ul>
<h5 id="分离式与集成式系统">分离式与集成式系统</h5>
<ul>
<li>即使“分拆”成为未来趋势，<strong>传统数据库不会被取代</strong>：它们仍用于维护流处理状态、提供批处理/流处理结果的查询服务，以及支持专用工作负载（如 MPP 数据仓库的分析查询）。</li>
<li><strong>运行多种基础设施会带来复杂性</strong>：每种工具都有学习成本、配置挑战和运维特性；因此应尽量减少组件数量，避免不必要的拼接。</li>
<li><strong>单一集成系统在特定场景下仍有优势</strong>：针对其设计目标，往往能提供更优、更可预测的性能；为不需要的规模或功能过度设计是一种过早优化，可能导致架构僵化。</li>
<li>分拆的目标不是超越单一数据库的深度性能，<strong>而是扩展能力的广度</strong>：通过组合多种专用系统，覆盖更广泛的工作负载类型，实现单一系统无法兼顾的多样性需求。</li>
<li><strong>核心原则是按需选择</strong>：如果单一技术能满足所有需求，就应优先使用它；只有当现有产品无法覆盖全部场景时，分拆或联合架构的优势才真正显现。</li>
</ul>
<h5 id="遗漏了什么">遗漏了什么</h5>
<ul>
<li>当前用于构建数据系统的工具日益成熟，但仍缺少一个关键组件：一种类似 Unix shell 的高级声明式语言，用于简单、统一地组装异构存储与处理系统（即“分拆数据库”的 shell）。</li>
<li>理想情况下，用户应能通过简洁声明（如 mysql | elasticsearch）自动实现跨系统集成：
<ul>
<li>初始全量同步 MySQL 数据到 Elasticsearch；</li>
<li>持续捕获数据库变更并自动更新索引；</li>
<li>无需编写自定义应用代码；</li>
<li>该模式可推广到几乎任意存储或索引系统，作为 CREATE INDEX 的分布式、跨系统等价物。</li>
</ul>
</li>
<li>同样，实体化视图应作为通用缓存机制被简化使用：用户只需声明复杂查询（包括图递归查询或含应用逻辑的计算），系统自动预计算并持续维护其结果。</li>
<li>已有前沿研究（如 差分数据流（differential dataflow））探索高效增量计算与视图维护，作者期望这些技术未来能落地于生产系统，推动声明式数据集成的发展。</li>
</ul>
<h3 id="围绕数据流设计应用系统">围绕数据流设计应用系统</h3>
<h4 id="应用程序代码作为派生函数">应用程序代码作为派生函数</h4>
<ul>
<li>派生数据集由源数据集通过转换函数生成，不同场景对应不同复杂度的函数：
<ul>
<li>次级索引：使用简单、标准化的转换函数——提取索引字段值并按键排序（如 B 树或 SSTable），因此被大多数数据库内置，通过 CREATE INDEX 即可创建。</li>
<li>全文搜索索引：应用复杂的自然语言处理函数，如语言检测、分词、词干提取、拼写纠正、同义词识别等，再构建倒排索引；基础功能可能内置，但高级特征通常需领域定制。</li>
<li>机器学习模型：模型本身是从训练数据通过特征提取和统计分析函数派生的；模型对新输入的预测结果，也间接源自训练数据，特征工程高度依赖应用上下文和用户行为知识。</li>
<li>缓存：通常聚合为 UI 所需格式，其填充逻辑与前端结构紧密耦合；UI 变更常需调整缓存逻辑并重建缓存。</li>
</ul>
</li>
<li>标准化派生函数（如二级索引）被数据库原生支持，而非标准、应用特定的转换（如复杂 NLP、ML 特征、UI 缓存逻辑）需要自定义代码。</li>
<li>尽管数据库提供触发器、存储过程、UDF 等机制执行自定义逻辑，但这些功能常被视为“事后补充”，在灵活性、生态集成、开发体验上难以满足现代应用需求，导致许多团队转向外部系统（如流处理器）实现复杂派生逻辑。</li>
</ul>
<h4 id="应用程序代码与状态分离">应用程序代码与状态分离</h4>
<ul>
<li>理论上数据库可作为通用应用代码运行环境，但实践中严重缺乏现代开发所需能力：
<ul>
<li>依赖与包管理、版本控制、滚动升级、可演化性、监控指标、外部服务调用、系统集成等支持薄弱。</li>
</ul>
</li>
<li>专用部署平台（如 Mesos、YARN、Docker、Kubernetes）专为运行应用代码设计，因其专注单一职责，在灵活性、生态和运维上远超数据库内置执行机制。</li>
<li>现代架构趋势是<strong>分离无状态应用逻辑与有状态数据存储</strong>：
<ul>
<li>应用作为无状态服务部署，可弹性扩缩；</li>
<li>状态集中于数据库；</li>
<li>避免将业务逻辑嵌入数据库，也避免在应用中维护持久状态；</li>
<li>即所谓“Church 与 State 的分离”——计算（无状态函数）与状态（可变数据）解耦。</li>
</ul>
</li>
<li>在典型 Web 应用中，数据库充当<strong>可通过网络访问的可变共享变量</strong>，负责持久化、并发控制和容错，而应用负责业务逻辑。</li>
<li>但传统编程语言和数据库均采用<strong>被动式状态访问模型</strong>：
<ul>
<li>无法直接订阅变量或数据变更；</li>
<li>只能通过轮询（定期查询）检测变化；</li>
<li>虽可手动实现观察者模式，但非语言或数据库原生能力。</li>
</ul>
</li>
<li>数据库正逐步支持变更订阅（如变更数据捕获、变更流 API），但该能力仍是新兴特性，尚未成为默认交互范式。</li>
</ul>
<h4 id="数据流：状态变化和应用程序代码之间的相互影响">数据流：状态变化和应用程序代码之间的相互影响</h4>
<p>我们要用容错的方式主动把数据集从数据库里导出到别的地方。</p>
<ul>
<li>从数据流角度思考应用，意味着重构应用代码与状态的关系：不再将数据库视为被动变量，而是关注状态、状态变更与处理逻辑之间的协同互动——<strong>应用通过响应状态变更来触发新的状态变更</strong>。</li>
<li>这一思想体现在多个领域：
<ul>
<li>数据库变更日志作为可订阅的事件流；</li>
<li>Actor 模型中的事件驱动响应；</li>
<li>早期元组空间（tuple space）模型对“观察-反应”式计算的探索；</li>
<li>数据库内部的触发器和索引更新机制。</li>
</ul>
</li>
<li>“分拆数据库”将此模式扩展到主<strong>数据库之外</strong>：使用流处理和消息系统，将缓存、搜索索引、ML 模型、分析系统等作为<strong>派生数据集</strong>，由源数据变更驱动更新。</li>
<li><strong>维护派生数据与执行异步任务有本质区别</strong>：
<ul>
<li>派生数据要求严格的消息顺序：所有派生视图必须按相同顺序处理事件，以保持彼此一致；</li>
<li>派生数据要求强容错：丢失任一消息都会导致永久不一致；</li>
<li>传统消息队列（如 AMQP/JMS）和双写模式通常无法满足这两点。</li>
</ul>
</li>
<li>许多系统（如默认内存状态的 Actor 框架）在崩溃时会丢失状态和消息，不适合派生数据场景。</li>
<li>现代流处理引擎（如 Flink、Kafka Streams）能提供：
<ul>
<li>稳定的事件顺序（分区内）；</li>
<li>容错处理（通过 checkpoint、幂等性等）；</li>
<li>支持任意应用逻辑作为流算子运行。</li>
</ul>
</li>
<li>流算子可像 Unix 管道一样组合：每个算子消费状态变更流，执行自定义处理（超越数据库内置功能），并输出新的状态变更流，从而构建复杂、可靠的数据驱动系统。</li>
</ul>
<h4 id="流式处理与服务">流式处理与服务</h4>
<p>最好的网络请求是没有实时网络请求，依赖于订阅的强语义来更新。</p>
<ul>
<li>当前主流应用开发采用<strong>微服务架构</strong>：通过同步 REST/RPC 调用拆分功能，实现团队解耦和独立部署，提升组织可扩展性。</li>
<li><strong>数据流架构与微服务在模块化上有相似性</strong>，但通信机制本质不同：
<ul>
<li>微服务依赖<strong>同步请求/响应</strong>；</li>
<li>数据流采用<strong>单向异步消息流</strong>-类似 React。</li>
</ul>
</li>
<li>数据流方法在性能和容错上更具优势，以“货币兑换”为例：
<ul>
<li><strong>微服务方式</strong>：处理订单时同步调用汇率服务，引入网络延迟和故障依赖；</li>
<li><strong>数据流方式</strong>：提前订阅汇率变更流，将最新汇率本地缓存，订单处理时仅查本地数据，<strong>消除实时网络调用</strong>。</li>
</ul>
</li>
<li>即使微服务使用本地缓存，仍需通过轮询或订阅变更流来保证新鲜度——这本质上已趋近数据流模型。</li>
<li><strong>连接具有时间相关性</strong>：若重放历史订单，需使用当时的汇率而非当前值；无论采用查询还是流订阅，都必须处理事件时间与状态版本的对齐问题。</li>
<li><strong>订阅变更流而非按需查询</strong>，使系统更接近电子表格的响应式模型：源数据变更自动触发所有依赖项更新。</li>
<li>尽管仍存在挑战（如时间相关连接的正确处理），但围绕数据流构建应用被视作一个极具前景的方向。</li>
</ul>
<h3 id="观察派生状态">观察派生状态</h3>
<p><img src="fig12-1.png" alt="在搜索索引中，写（文档更新）遇上读（查询）"></p>
<ul>
<li>数据流系统在抽象层面提供了一种机制：通过批处理和流处理创建并持续更新派生数据集（如搜索索引、实体化视图、预测模型），这一过程称为<strong>写路径（write path）</strong>。</li>
<li>创建派生数据集的目的是为了后续高效查询，即<strong>读路径（read path）</strong>：在响应用户请求时，从派生数据集中读取数据，可能辅以轻量后处理，生成最终结果。</li>
<li><strong>写路径与读路径共同构成数据的完整生命周期</strong>：从数据写入开始，到数据被消费结束。</li>
<li>写路径是<strong>预计算</strong>（eager evaluation）：数据一进入系统就立即处理并更新派生视图，无论是否会被读取；读路径是<strong>按需计算</strong>（lazy evaluation）：仅在用户请求时执行。</li>
<li><strong>派生数据集是写路径与读路径的交汇点</strong>，体现了系统设计中的核心权衡：在写入时多做工作以减轻读取负担，还是反之。</li>
</ul>
<h4 id="实体化视图和缓存">实体化视图和缓存</h4>
<ul>
<li>全文搜索索引是写路径与读路径权衡的典型例子：
<ul>
<li>写路径：更新文档时，需为文档中所有关键词更新倒排索引条目；</li>
<li>读路径：执行查询时，需查找关键词并应用布尔逻辑（如 AND/OR）合并结果。</li>
</ul>
</li>
<li>若<strong>无索引，写路径开销最小</strong>（无需维护索引），但读路径需全量扫描所有文档（如 grep），在数据量大时性能不可接受。</li>
<li>若<strong>预计算所有可能查询的结果</strong>，读路径可达到极致轻量（直接返回结果），但写路径不可行——因查询组合近乎无限，存储与计算成本爆炸。</li>
<li>折中方案：<strong>仅对高频查询预计算结果</strong>（即缓存或实体化视图），常见查询走缓存，罕见查询走索引；当新文档加入时，需增量更新受影响的高频查询缓存。</li>
<li><strong>索引、缓存、实体化视图的本质相同</strong>：它们都是调整写路径与读路径之间工作边界的机制——通过在写入时多做预计算，换取读取时的性能提升。</li>
<li>这一思想早在本书开头“推特时间线”案例中已清晰体现，但需准确理解其逻辑：
<ul>
<li><strong>当用户关注了大量账号时</strong>（如关注上千人），系统倾向于在<strong>读取时合并</strong>所关注用户的推文（即<strong>读路径重</strong>），因为写时为每个被关注者扇出会带来巨大写放大；</li>
<li><strong>当某用户拥有海量粉丝时</strong>（如名人），系统采用写时扇出（fan-out-on-write）：其发推时，将内容<strong>预先写入活跃粉丝的时间线缓存</strong>（即<strong>写路径重</strong>），避免每次读取都触发对名人推文的高成本扫描。</li>
<li>这种策略并非按“普通用户 vs 名人”简单划分，而是根据<strong>数据访问模式</strong>（关注数 vs 粉丝数）——对<strong>高读放大风险</strong>（名人推文被频繁读）用写时预计算，对<strong>高写放大风险</strong>（用户关注极多）用读时合并。</li>
</ul>
</li>
<li>至此，从第1章到第12章，围绕“<strong>如何在写与读之间合理分配计算工作</strong>”这一核心问题，完成了从具体案例到抽象架构的完整认知闭环。</li>
</ul>
<h4 id="有状态-可离线客户端">有状态，可离线客户端</h4>
<ul>
<li><strong>写路径与读路径之间的边界并非固定</strong>，主动调整这一边界能带来不同的系统设计和实际效果，值得在不同上下文中深入探讨。</li>
<li>过去二十年，Web 应用普遍采用“无状态客户端 + 中央权威服务器”的客户端/服务器模型，这一范式已深入人心，但技术演进要求我们重新审视其局限性。</li>
<li>传统浏览器是无状态的，仅能在线工作；而现代单页应用（SPA）和移动应用具备<strong>本地状态管理能力</strong>：支持客户端 UI 交互、本地持久化存储，多数操作无需实时联网。</li>
<li>这推动了 “<strong>离线优先</strong>”（offline-first）架构的复兴：应用优先使用设备本地数据库，用户操作不依赖网络，在后台连接恢复时再与服务器同步，显著提升弱网或离线场景下的用户体验。</li>
<li>放弃“客户端必须无状态”的假设，转而<strong>在终端设备维护状态</strong>，开启了新设计空间：
<ul>
<li>设备本地状态可视为<strong>服务器状态的缓存</strong>；</li>
<li>UI 界面是本地模型对象的<strong>实体化视图</strong>；</li>
<li>本地模型本身是远程数据中心状态的<strong>副本</strong>。</li>
</ul>
</li>
<li>这一转变将数据流和状态同步的边界从“服务器内部”延伸至“端云协同”，使客户端成为数据生命周期中更主动的一环。</li>
</ul>
<h4 id="将状态变更推送给客户端">将状态变更推送给客户端</h4>
<ul>
<li>传统网页采用静态模型：浏览器加载页面后，无法感知服务器数据的后续变更，除非用户手动刷新或通过轮询（如 RSS）主动查询，导致本地状态容易陈旧。</li>
<li>现代协议（如 EventSource、WebSockets）突破了 HTTP 请求/响应限制，允许服务器通过长连接主动推送状态变更到浏览器，使客户端能及时更新，减少数据陈旧性。</li>
<li>从写路径/读路径视角看：
<ul>
<li>初始化时，客户端通过读路径获取初始状态；</li>
<li>之后，通过订阅服务器的状态变更流，写路径被延伸至终端设备，实现持续同步。</li>
</ul>
</li>
<li>这一模式将流处理与消息传递的思想从数据中心扩展到终端用户设备：每个设备成为事件流的订阅者，消费状态变更事件以更新本地状态。</li>
<li>设备离线时虽无法接收实时通知，但可借鉴基于日志的消息系统机制：
<ul>
<li>设备记录消费位置（类似偏移量）；</li>
<li>重连后从断点继续拉取变更，确保不丢失离线期间的更新；</li>
<li>从而在弱网或间歇连接场景下仍能保证最终一致性。</li>
</ul>
</li>
</ul>
<h4 id="端到端的事件流">端到端的事件流</h4>
<ul>
<li>现代客户端状态管理工具（如 Elm、React/Flux/Redux）通过<strong>订阅事件流</strong>（用户输入、服务器响应）来驱动 UI 状态更新，其模式与事件溯源高度相似。</li>
<li>将此模型自然延伸：<strong>服务器可将状态变更事件推送至客户端的事件管道，形成端到端的写路径</strong>——从一个设备的用户操作出发，经事件日志、流处理器、派生系统，最终实时更新另一设备的 UI 状态，延迟可低至秒级。</li>
<li>即时通讯、在线游戏等应用已采用此类“实时”架构，但尚未普及到所有应用，主要障碍在于：
<ul>
<li>现有技术栈（数据库、库、框架、协议）深度绑定无状态客户端 + 请求/响应范式；</li>
<li>大多数数据系统仅支持<strong>一次性读写操作，缺乏变更订阅能力</strong>（即返回随时间变化的数据流）。</li>
</ul>
</li>
<li>要实现写路径延伸至终端用户，需<strong>根本性转变系统设计哲学</strong>：从请求/响应转向<strong>发布/订阅数据流</strong>。</li>
<li>这种转变能带来<strong>更响应的 UI 和 更强的离线支持</strong>，作者认为其收益远超改造成本，并呼吁数据系统设计者重视变更订阅能力，而不仅限于查询当前状态。</li>
</ul>
<h4 id="读也是事件">读也是事件</h4>
<ul>
<li>在流处理架构中，<strong>存储系统</strong>（数据库、缓存、索引）通常作为<strong>写路径</strong>与<strong>读路径</strong>的边界：流处理器通过写路径更新存储，用户通过读路径发起随机访问查询；若无此类存储，查询需扫描整个事件日志，效率低下。</li>
<li>虽然存储常与流处理器分离，但流处理器本身也需维护内部状态（用于聚合、连接）；部分框架允许外部直接查询该状态，使流处理器<strong>兼具简单数据库</strong>的功能。</li>
<li>可进一步将<strong>读取请求也建模为事件</strong>：
<ul>
<li>读请求作为事件流入流处理器；</li>
<li>流处理器处理该“读事件”，并将结果作为输出事件返回；</li>
<li>读写均通过事件流统一处理。</li>
</ul>
</li>
<li>当读写事件被路由到同一流算子时，服务读请求本质上等同于执行流表连接：
<ul>
<li><strong>读事件（查询）与状态数据（表）在相同分区</strong>上连接；</li>
<li>需确保读事件被路由到持有对应数据的分区，类似流连接中的键一致性分区。</li>
</ul>
</li>
<li><strong>一次性读请求</strong>相当于瞬时连接后丢弃；<strong>订阅式读请求</strong>则是与数据流建立持久连接，持续接收更新。</li>
<li><strong>记录读取事件日志</strong>有助于追踪因果关系和数据血缘：
<ul>
<li>可重现用户决策时所见的数据状态（如商品库存、预计送达时间）；</li>
<li>对行为分析、审计、调试具有重要价值。</li>
</ul>
</li>
<li>将读事件持久化虽增加存储与 I/O 开销，但若系统已因运维需要记录读日志，则将其作为事件源仅需小幅改造；如何高效实现此类因果追踪仍是开放研究问题。</li>
</ul>
<h4 id="多分区数据处理">多分区数据处理</h4>
<ul>
<li>对于<strong>单分区查询</strong>，通过流发送查询和收集响应可能过于复杂、得不偿失；但该模式在<strong>跨多分区的复杂查询</strong>中展现出价值，可复用流处理器已有的消息路由、分区和连接能力。</li>
<li><strong>Storm 的分布式 RPC</strong> 是典型应用：
<ul>
<li>用于计算“浏览过某推文 URL 的人数”，需合并该推文所有转发者（分布在多个分区）的粉丝集合；</li>
<li>本质是跨分区聚合，依赖流系统协调多节点结果。</li>
</ul>
</li>
<li><strong>欺诈检测</strong>是另一场景：
<ul>
<li>评估一笔交易风险需查询用户 IP、邮箱、账单地址、收货地址等多个维度的信用分；</li>
<li>这些信用数据各自分区存储，需跨多个分区连接才能生成完整风险画像。</li>
</ul>
</li>
<li>此类多分区连接与 <strong>MPP 数据库的分布式查询执行图</strong>在结构上相似；若需求匹配，直接使用 MPP 数据库通常更简单高效。</li>
<li>但将查询建模为流提供了一种<strong>可扩展的替代方案</strong>，适用于<strong>超大规模、定制化或传统数据库无法支持的场景</strong>，为构建超越现成解决方案的系统提供了可能。</li>
</ul>
<h2 id="端到端的正确性-将事情做正确">端到端的正确性（将事情做正确）</h2>
<ul>
<li>无状态服务容错简单：出错后重启即可恢复；而<strong>有状态系统（如数据库）需永久记住数据</strong>，一旦出错，错误状态可能持久存在，因此需要更严谨的设计。</li>
<li>事务（ACID）长期被视为构建正确应用的基石，但其基础并不如表面牢固：
<ul>
<li>弱隔离级别易引发隐蔽错误；</li>
<li>“一致性”等术语定义模糊，常被误用；</li>
<li>“拥抱弱一致性”等口号缺乏对实际语义的清晰理解。</li>
</ul>
</li>
<li>确定特定应用在给定隔离级别或复制配置下是否安全极为困难：
<ul>
<li>简单场景下看似正常，高并发或故障时暴露微妙缺陷；</li>
<li>Jepsen 实验揭示了多款数据库产品在宣称保证与实际行为间的严重差距；</li>
<li>即使数据库本身正确，应用若误用其功能（如错误配置 quorum、隔离级别），仍会导致数据错误。</li>
</ul>
</li>
<li>若应用能容忍数据损坏或丢失，系统设计可大幅简化；但若需强正确性保证，则需依赖可串行化与原子提交，但代价高昂：
<ul>
<li>通常限于单数据中心，难以支持地理分布式架构；</li>
<li>限制系统规模与容错能力。</li>
</ul>
</li>
<li>尽管事务仍是重要工具，但作者认为它并非处理正确性的终极方案；本节将探索在数据流架构中实现可靠、灵活且可扩展的正确性保障的新思路。</li>
</ul>
<h3 id="数据库的端到端争论">数据库的端到端争论</h3>
<ul>
<li>即使应用使用具备强安全属性的数据系统（如支持可串行化事务的数据库），也无法防止因应用自身 Bug 或人为错误导致的数据损坏或丢失——<strong>事务保证的是操作的原子性和隔离性，而非业务逻辑的正确性</strong>。</li>
<li>这类问题并非理论假设，而是现实风险：错误代码可能写入无效数据或误删关键记录，而事务机制对此无能为力。</li>
<li>正因如此，<strong>不可变性与仅追加写入</strong>（如事件日志、事件溯源）被提倡：通过禁止就地更新和删除，使错误无法覆盖历史数据，从而<strong>大幅简化故障诊断与恢复</strong>。</li>
<li>然而，不可变性本身并非万能解决方案——它虽能保留历史，但<strong>仍可能因逻辑错误导致派生状态不一致或语义错误</strong>，例如在流处理中因时序或连接逻辑缺陷引发隐蔽的数据损坏。</li>
</ul>
<h4 id="exactly-once-执行操作">exactly-once 执行操作</h4>
<ul>
<li>在容错场景中，处理消息失败时若选择重试，可能因无法确认首次是否成功而导致消息被处理两次，这属于一种数据损坏（如重复扣款、计数器多增）。</li>
<li>“恰好一次语义”的目标是：<strong>即使发生重试，最终效果也等同于消息仅被处理一次</strong>，从而避免重复副作用。</li>
<li>实现该目标的有效方法之一是<strong>幂等性</strong>（idempotence）：确保操作无论执行一次还是多次，结果都相同。</li>
<li>但使非幂等操作变为幂等需额外工作：
<ul>
<li>维护元数据（如已处理消息的唯一 ID 集合）；</li>
<li>在节点故障切换时实施<strong>防护机制</strong>（fencing），防止旧节点继续操作造成冲突。</li>
</ul>
</li>
</ul>
<h4 id="重复消除">重复消除</h4>
<ul>
<li>TCP 的重复抑制仅作用于单连接内：通过序列号去重和重传，确保单条 TCP 连接上的数据不重复、不丢失，<strong>但无法跨连接去重</strong>。</li>
<li><strong>数据库事务与 TCP 连接常绑定</strong>：同一连接上的多个查询被视为同一事务；但若客户端在发送 COMMIT 后因网络中断未收到响应，<strong>无法确定事务是否已提交</strong>。</li>
<li><strong>重连后重试非幂等事务会导致重复执行</strong>：如例 12-1 中的转账操作（非幂等），重试会使金额被转两次（<code>$22</code>而非 <code>$11</code>），尽管使用了事务，仍造成逻辑错误。</li>
<li><strong>两阶段提交（2PC）</strong>：协调器可在故障后重连并决议存疑事务，但<strong>仍无法解决客户端与协调器之间的重复请求问题</strong>，因为重试被视为全新事务。</li>
<li><strong>终端用户层面的重试更难控制</strong>：
<ul>
<li>Web 浏览器在 HTTP POST 超时时可能提示用户重试；</li>
<li>用户点击“确认”后，服务器会收到<strong>全新请求</strong>，触发<strong>全新事务</strong>；</li>
<li>此时 TCP、数据库事务、2PC 等底层机制均无法识别这是重复操作。</li>
</ul>
</li>
<li><strong>根本问题：缺乏端到端的幂等性保障</strong>。即使底层协议可靠，若应用层操作非幂等，且无全局唯一请求标识，重复提交就无法避免。</li>
<li>因此，<strong>仅靠事务和网络协议不足以保证“恰好一次”业务语义</strong>，必须在应用层设计幂等操作（如带唯一 ID 的请求）才能真正防止重复。</li>
</ul>
<h4 id="操作标识符">操作标识符</h4>
<ul>
<li>仅靠数据库事务无法保证跨多跳网络通信的幂等性，必须在端到端请求流中设计幂等机制。</li>
<li>实现方式：为每个业务操作生成<strong>唯一标识符</strong>（如 UUID 或表单字段哈希），并将其从客户端一路传递至数据库。</li>
<li>数据库通过<strong>唯一约束</strong>（如 UNIQUE(request_id)）确保同一操作 ID 只能成功执行一次：重复请求因违反唯一性而失败，事务自动回滚。</li>
<li>该方法优于应用层“先查后插”逻辑，因为<strong>数据库的唯一约束在弱隔离级别下仍能可靠工作</strong>，而应用级检查在不可串行化隔离下可能失效（如写入偏差）。</li>
<li>此外，记录操作 ID 的 requests 表本质上是一种<strong>事件日志</strong>，与<strong>事件溯源</strong>（Event Sourcing）思想一致：
<ul>
<li>账户余额更新可视为从请求事件派生的派生状态；</li>
<li>甚至可将余额计算移出事务，由下游消费者重放请求日志重建，只要保证请求被恰好处理一次（仍依赖 request_id 去重）。</li>
</ul>
</li>
<li>因此，<strong>唯一操作 ID 不仅解决重复提交问题，还为构建基于事件的可靠数据流架构奠定基础</strong>。</li>
</ul>
<h4 id="端到端的争论">端到端的争论</h4>
<ul>
<li>端到端原则/论证/争论（End-to-End Argument）指出：<strong>只有通信两端的应用层才能完全、正确地实现某项功能，底层通信系统无法替代，最多只能提供辅助以提升性能</strong>。</li>
<li>重复抑制是典型例子：
<ul>
<li>TCP 可在连接内去重数据包，流处理器可提供“恰好一次”语义，但无法阻止用户因超时手动重试导致的重复请求；</li>
<li>唯一可靠方案是端到端传递唯一请求 ID，由数据库通过唯一约束确保全局幂等。</li>
</ul>
</li>
<li>数据完整性同样适用：
<ul>
<li>以太网、TCP、TLS 的校验和可检测传输中损坏，但无法发现应用 Bug 或磁盘静默损坏；</li>
<li>真正可靠的完整性需端到端校验和（如应用层哈希）。</li>
</ul>
</li>
<li>加密亦如此：
<ul>
<li>WiFi 密码仅防本地窃听，TLS 仅防网络中间人，无法防恶意服务器；</li>
<li>端到端加密（如 Signal 协议）才能确保只有通信双方可解密内容。</li>
</ul>
</li>
<li>低层机制仍有价值：
<ul>
<li>TCP 保证有序传输，避免 HTTP 请求乱序；</li>
<li>校验和减少传输错误；</li>
<li>但它们不能替代端到端保障，仅作为辅助提升整体可靠性。</li>
</ul>
</li>
<li>核心启示：<strong>关键正确性保障必须在应用层实现</strong>，不能依赖底层协议；底层功能是性能优化，而非正确性基础。</li>
</ul>
<h4 id="在数据系统中采用端到端的思路">在数据系统中采用端到端的思路</h4>
<ul>
<li>即使应用使用了具备强安全属性的数据系统（如可串行化事务），<strong>仍无法避免因应用逻辑错误导致的数据丢失或损坏</strong>；必须在应用层实现<strong>端到端的容错机制</strong>（如请求去重）。</li>
<li>容错机制本身极难正确实现：底层机制（如 TCP）已相当可靠，但<strong>高层错误</strong>（如用户重试、网络分区、非幂等操作）仍会导致数据不一致。</li>
<li>理想情况下，这些高层容错应被封装为<strong>通用抽象</strong>，让应用无需手动处理；但目前尚未找到足够普适且高效的抽象。</li>
<li>事务曾被视为<strong>理想抽象：它将并发、崩溃、网络故障等问题简化为“提交/中止”两种结果</strong>，极大简化了编程模型；但它并非万能。</li>
<li><strong>事务代价高昂</strong>，尤其在涉及异构存储系统时，分布式事务的性能和运维复杂性使其常被弃用；结果开发者被迫在应用代码中重新实现容错逻辑。</li>
<li>然而，<strong>正确处理并发与部分失败极其困难且反直觉</strong>，多数应用层容错机制存在缺陷，最终导致数据损坏或丢失。</li>
<li>因此，<strong>探索新的容错抽象至关重要</strong>：目标是既能提供<strong>应用特定的端到端正确性保证</strong>，又能在大规模分布式系统中保持<strong>高性能与可运维性</strong>。</li>
</ul>
<h3 id="强制约束">强制约束</h3>
<h4 id="唯一性约束需要达成共识">唯一性约束需要达成共识</h4>
<ul>
<li>在分布式系统中，强制唯一性（如用户名、座位、文件名）本质是共识问题：多个并发写入需就“哪个操作被接受”达成一致。</li>
<li>常见方案是单主节点决策，但会成为性能瓶颈；主节点故障时仍需共识协议恢复。</li>
<li><strong>可通过按唯一字段（如用户名哈希）分区实现扩展</strong>：冲突请求路由到同一分区，<strong>由本地顺序处理</strong>。</li>
<li>异步多主复制无法保证唯一性，因不同主库可能同时接受冲突写入；若需立即拒绝违规写入，必须同步协调。</li>
</ul>
<h4 id="基于日志消息传递中的唯一性">基于日志消息传递中的唯一性</h4>
<ul>
<li>基于日志的系统提供全序广播（等价于共识），确保所有消费者以相同顺序看到消息。</li>
<li>流处理器单线程顺序消费单个日志分区，可确定性地处理冲突请求（如用户名注册）：
<ul>
<li>请求按唯一字段（如用户名哈希）路由到对应分区；</li>
<li>处理器本地维护已占用状态，对每个请求返回成功或拒绝；</li>
<li>客户端监听输出流获取结果。</li>
</ul>
</li>
<li>该方法可水平扩展（增加分区数），且适用于其他约束（如余额非负、库存限制），因流处理器可执行任意验证逻辑。</li>
</ul>
<h4 id="多分区请求处理">多分区请求处理</h4>
<ul>
<li>多分区事务（如转账涉及请求ID、付款人、收款人三个分区）传统上需跨分区原子提交（如2PC），影响吞吐。</li>
<li>新方法避免分布式事务：
<ul>
<li>客户端将完整请求（含唯一ID）原子写入单一分区日志（单对象写入天然原子）；</li>
<li>流处理器从该日志派生出多条分区指令（如借记、贷记），并携带原请求ID；</li>
<li>各分区处理器按请求ID去重后执行，确保每条请求仅生效一次。</li>
</ul>
</li>
<li>容错机制：流处理器崩溃后从 checkpoint 恢复，重发指令但因确定性处理 + 请求ID去重，结果仍正确。</li>
<li>可扩展校验逻辑：例如额外流处理器按付款人账户分区，验证余额是否充足，仅有效请求才写入请求日志。</li>
<li>核心优势：在无原子提交协议下，通过单点写入 + 派生 + 端到端去重，实现多分区操作的正确性与高吞吐。</li>
</ul>
<h3 id="时效性与完整性">时效性与完整性</h3>
<h4 id="及时性与完整性">及时性与完整性</h4>
<ul>
<li><strong>及时性</strong>（Timeliness）：指用户能否观察到系统的最新状态；违反时表现为暂时不一致（如读到陈旧副本），但可通过等待或重试解决；CAP 中的“一致性”通常指强及时性（如线性一致性），但较弱形式（如读己之写）也实用。</li>
<li><strong>完整性</strong>（Integrity）：指数据无丢失、无矛盾、无逻辑错误；违反时导致永久性损坏（如索引缺失记录、资金消失），无法通过重试修复，需显式校验与修复；ACID 中的“C”常指此类应用特定的完整性。</li>
<li><strong>关键区分</strong>：违反及时性 → “最终一致性”；违反完整性 → “永无一致性”；<strong>完整性比及时性更重要</strong>——交易延迟可接受，但账目错误不可容忍。</li>
<li><strong>数据流系统的特点</strong>：天然异步，<strong>不保证及时性</strong>（除非显式等待输出），<strong>但核心目标是保障完整性</strong>；通过恰好一次语义、幂等性、端到端去重等机制防止数据丢失或重复，从而维护完整性。</li>
</ul>
<h4 id="数据流系统的正确性：">数据流系统的正确性：</h4>
<ul>
<li>流处理系统通过组合多种机制在<strong>无分布式事务</strong>的前提下保障完整性：
<ul>
<li>将操作表示为<strong>单条不可变消息</strong>（原子写入日志），契合事件溯源；</li>
<li>使用<strong>确定性派生函数</strong>（类似存储过程）从消息生成所有状态变更；</li>
<li><strong>端到端传递请求 ID</strong>，实现跨处理阶段的幂等与去重；</li>
<li><strong>不可变事件 + 可重放</strong>，使错误恢复更简单。</li>
</ul>
</li>
<li>这种架构在保持强完整性的同时，避免了 2PC 等同步协调的性能与运维代价，是构建高可用容错应用的有前景方向。</li>
</ul>
<h4 id="宽松地解释约束">宽松地解释约束</h4>
<ul>
<li>严格唯一性需共识与同步协调，但<strong>许多真实业务可接受临时违反约束 + 事后补偿</strong>：
<ul>
<li>用户名冲突 → 发送道歉邮件，要求重选；</li>
<li>超卖库存/机票/客房 → 补货、退款、升级服务；</li>
<li>账户透支 → 收取费用并追偿。</li>
</ul>
</li>
<li><strong>补偿性事务</strong>（compensating transaction）是商业流程的自然组成部分，使得强一致性约束非必需；<strong>乐观写入 + 事后校验</strong>在多数场景更灵活高效。</li>
<li>关键仍是<strong>完整性</strong>：不能丢失订单或导致资金不平，但<strong>约束执行无需强及时性</strong>。</li>
</ul>
<h4 id="无协调数据系统">无协调数据系统</h4>
<ul>
<li>两大观察：
<ul>
<li>数据流系统可在<strong>无原子提交、无线性一致性、无跨分区同步</strong>下保障完整性；</li>
<li>许多应用可接受<strong>宽松约束 + 补偿机制</strong>，无需强及时性。</li>
</ul>
</li>
<li>由此可构建无<strong>协调</strong>（coordination-avoiding）：
<ul>
<li>支持多主、跨数据中心异步复制，各区域独立运行；</li>
<li>牺牲及时性（非线性一致），但保留强完整性；</li>
<li>局部仍可使用可串行化事务（如单分区内），但<strong>避免全局异构事务</strong>（如 XA）。</li>
</ul>
</li>
<li><strong>协调的本质权衡</strong>：减少不一致道歉 vs. 增加系统不可用道歉；<strong>最优设计是在两者间找平衡</strong>，而非追求零道歉。</li>
</ul>
<h3 id="信任-但要确认">信任，但要确认</h3>
<ul>
<li>系统正确性依赖于系统模型（system model）：我们假设某些故障会发生（如进程崩溃、网络丢包），而某些不会（如磁盘 fsync 后数据不丢、CPU 计算正确）。</li>
<li>但现实中，极低概率事件确实会发生：内存位翻转（如 Rowhammer 攻击）、磁盘静默损坏、TCP 校验和漏检等，尤其在大规模部署下。</li>
<li>虽然硬件错误罕见，但不能假设其绝对不发生；系统设计应对此保持警惕。</li>
</ul>
<h4 id="软件缺陷时的完整性">软件缺陷时的完整性</h4>
<ul>
<li>软件 Bug 是更常见的风险源：即使是成熟数据库（如 MySQL、PostgreSQL）也曾出现唯一性约束失效、可串行化隔离漏洞等问题。</li>
<li>应用代码更易出错：多数应用缺乏充分测试，且常误用数据库功能（如忽略外键、滥用弱隔离级别）。</li>
<li>ACID 的“一致性”依赖无 Bug 假设：若应用逻辑错误，即使数据库正确执行事务，整体数据完整性仍会破坏。</li>
</ul>
<h4 id="不要盲目信任承诺">不要盲目信任承诺</h4>
<ul>
<li>数据损坏难以完全避免，因此必须具备审计（auditing）能力：能检测、定位并修复损坏。</li>
<li>成熟系统（如 HDFS、S3）采用<strong>主动验证</strong>：后台持续读取数据、比对副本、迁移文件，以应对静默损坏。</li>
<li>备份必须定期恢复验证：否则损坏可能在真正需要时才被发现，为时已晚。</li>
</ul>
<h4 id="验证的文化">验证的文化</h4>
<ul>
<li>当前系统多依赖“盲目信任”，缺乏持续自检机制；应推动自我验证/自我审计系统的发展。</li>
<li>ACID 文化助长了过度信任：因事务机制通常可靠，开发者忽视审计投入；但在 NoSQL 和弱一致性普及的今天，风险更高。</li>
<li>应转向“信任但验证”文化：即使组件大概率可靠，也需持续检查端到端完整性。</li>
</ul>
<h4 id="可审计性的设计">可审计性的设计</h4>
<ul>
<li>传统数据库事务难以追溯<strong>业务意图</strong>：日志仅记录“做了什么”，而非“为什么做”。</li>
<li>事件溯源（Event Sourcing）提供天然可审计性：
<ul>
<li>用户输入作为不可变事件持久化；</li>
<li>所有状态变更由确定性派生函数生成，可重放验证；</li>
<li>数据血缘（provenance）清晰，便于调试与完整性校验。</li>
</ul>
</li>
<li>可通过哈希校验事件日志、重运行派生流程、并行冗余计算等方式验证派生状态正确性。</li>
</ul>
<h4 id="端到端论点的再讨论">端到端论点的再讨论</h4>
<ul>
<li>若无法信任每个组件，完整性检查必须端到端覆盖整个数据流：涵盖所有存储、网络、服务和算法环节。</li>
<li>持续端到端审计可提升系统信心，降低变更风险，支持安全演进；类似自动化测试，能快速暴露错误。</li>
</ul>
<h4 id="用于可审计数据系统的工具">用于可审计数据系统的工具</h4>
<ul>
<li>当前专用审计工具稀缺；应用自建审计表难以保证与主数据的一致性。</li>
<li>密码学技术提供新思路：
<ul>
<li>Merkle 树支持高效证明数据存在性与完整性；</li>
<li>应用于证书透明性（Certificate Transparency）、区块链等系统。</li>
</ul>
</li>
<li>尽管加密货币存在吞吐低、能耗高等问题，但其完整性验证机制值得借鉴；未来通用数据系统可集成类似算法，在可控开销下实现强可审计性。</li>
</ul>
<h2 id="做正确的事情">做正确的事情</h2>
<p>技术要帮社会变好。</p>
<h2 id="小结">小结</h2>
<ul>
<li>没有单一工具能满足所有需求，现代应用需组合多种系统；数据集成通过批处理与事件流实现，使数据变更在异构系统间可靠流动。</li>
<li>以<strong>记录系统为源头</strong>，通过异步、松耦合的转换派生索引、实体化视图、ML 模型等；此方式提升系统容错性，防止单点故障扩散。</li>
<li>派生过程支持<strong>灵活演化与修复</strong>：可重跑新逻辑重建输出，或修复代码后重处理数据恢复状态。</li>
<li>此模式本质是**“分拆数据库”<strong>：将传统数据库的索引、实体化视图等功能</strong>解耦为独立、可组合的流处理组件**。</li>
<li>数据流可延伸至<strong>终端设备</strong>，构建动态更新、支持离线的用户界面，实现端到端响应式体验。</li>
<li>正确性保障不依赖分布式事务，而是通过：
<ul>
<li>端到端操作 ID 实现幂等；</li>
<li>异步约束检查；</li>
<li>客户端可选等待结果或接受“事后道歉”；</li>
<li>在保证完整性的同时实现高可扩展性与地理容灾能力。</li>
</ul>
</li>
<li><strong>审计与验证</strong>是维护长期完整性的关键，需持续检查数据是否损坏。</li>
<li>道德责任不可忽视：数据系统可能造成歧视、监控、隐私侵犯与不可逆伤害；工程师应主动设计尊重人性、可申诉、可修复的系统。</li>
<li>技术塑造世界，我们有责任推动构建一个尊重人、保护尊严、公平透明的数字未来。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://magicliang.github.io">magicliang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://magicliang.github.io/2020/10/11/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-Designing-Data-Intensive-Applications/">https://magicliang.github.io/2020/10/11/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-Designing-Data-Intensive-Applications/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/">系统架构</a></div><div class="post-share"><div class="social-share" data-image="/2020/10/11/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-Designing-Data-Intensive-Applications/ddia.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2018/01/30/%E5%87%A0%E7%A7%8D%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/" title="几种共识算法"><img class="cover" src="/img/wall-paper-143.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-01-30</div><div class="info-item-2">几种共识算法</div></div><div class="info-2"><div class="info-item-1">达成共识的英文原文是 come to consensus。达成共识以后，也未必代表数据是完全一致的（Raft 算法中 leader 发出 append log 的 commit 命令即算达成共识？但如果中途数据丢失，则还是会有子节点数据不一致）。 在分布式环境下，多个系统协同工作的效率，受制于系统交叉点的性能。在需要达成分布式共识的场景下，分布式共识算法在保证系统安全性的同时，限制了全系统横向扩展的性能提升。 根据环境的不同，可以应用不同的共识算法。 在完全互信的环境下-私有链、私有的分布式数据库，节点之间可以使用 Paxos 或者 Raft 这种 leader 相对固定的算法。 在有限互信的环境下-联盟链，可以使用 PBFT。PBFT 算法是依据确定性的投票（可能是漫长的投票，也可能进入死循环）达到确定性一致的算法。 在没有互信的情况下-公有链，可以使用 POW/POS/DPOS/POA。这类算法是基于概率得到正确的最终一致性，性能比 PBFT 要稍微好点。 最好的共识算法应该模块化，例如 Corda 中的 notary，Hyperledger fabric 中的 solo/k...</div></div></div></a><a class="pagination-related" href="/2018/04/02/%E4%B8%80%E4%B8%AA%E6%BB%9A%E5%8A%A8%E9%87%8D%E5%90%AF%E7%9A%84%E7%8A%B6%E6%80%81%E4%BF%9D%E5%AD%98%E9%97%AE%E9%A2%98/" title="一个滚动重启的状态保存问题"><img class="cover" src="/img/wall-paper-124.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-04-02</div><div class="info-item-2">一个滚动重启的状态保存问题</div></div><div class="info-2"><div class="info-item-1">很多时候滚动重启，都会导致状态丢失。比较好的设计方法是把服务本身设计成无状态的，然后在上游的服务上做好 failover，然后增加 standby server，让 sticky 数据 transmit 到 standby 机器上，让 request 失败以后可以自己由上游重传到 standby server。然后就可以滚动重启了。 这大部分场景下还要考虑幂等的问题。 这就看得出热配置热替换的重要性了。在大多数情况下，除了发布新的 feature 升级以外，都应该尽量用热配置来避免重启。 </div></div></div></a><a class="pagination-related" href="/2018/11/28/%E6%AD%A3%E4%BA%A4%E6%80%A7/" title="正交性"><img class="cover" src="/img/wall-paper-62.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-11-28</div><div class="info-item-2">正交性</div></div><div class="info-2"><div class="info-item-1">所谓正交性（orthogonal 意为正交的），就是设计的维度与其他维度完全隔离，一个正交的设计/值域设计，其变化绝不会受其他正交维度影响，也不会影响其他正交维度。 我们可以把 API 设计成正交的。这样 API 有独立变化的空间的。 我们可以把问题域切分清楚。问题域之间完全不相互干涉（注意跨问题域问题）。 我们可以把变量、字段、列设计成正交的。这样不同业务场景下，列之间的赋值不会相互覆盖。 </div></div></div></a><a class="pagination-related" href="/2019/08/30/%E3%80%8A%E9%AB%98%E5%8F%AF%E7%94%A8%E6%81%A2%E5%A4%8D%E6%80%9D%E8%B7%AF%E3%80%8B%E7%AC%94%E8%AE%B0/" title="《高可用恢复思路》笔记"><img class="cover" src="/img/wall-paper-90.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2019-08-30</div><div class="info-item-2">《高可用恢复思路》笔记</div></div><div class="info-2"><div class="info-item-1">遇到线上问题，经常陷入一个误区：一定要找到问题的根因（root cause）。但实际上对线上应用而言，最重要的是恢复可用性，所以在开发设计环境除了完成功能性需求以外，还需要加入非功能性设计的需求：  限流保护。抵挡来自突发流量冲垮整个集群。 降级保护，对调用的服务接口保持警惕，其各种因素导致不可用，可以对齐降级，从而确保核心功能可用。 削峰填谷（traffic shaping），不因突发数据来袭，造成任务消费陡增，造成调用系统的连串抖动。  这些基本的系统保护，是应对未来的各种突发不确定事件的高可用思考。 以上描述的是问题的应对机制设计，问题的发现机制，也需要结构化地考虑，体系化地建设：  发现机制，是我们的眼睛，也是基础。 监控主指标，需要找对业务的主要指标，常见的主指标一般是：RT（响应时间）、总量、成功量、失败量、成功率。 主指标有异常，还要有细分维度（即结果还可以内部 group by aggregation）。 快速恢复 根据监控快速寻找问题发生的方向和位置。 找对恢复的人、恢复的预案。 倾向于选择成本低的恢复手段。---- 并不是所有的恢复都用大招（熔断、限流），大招...</div></div></div></a><a class="pagination-related" href="/2019/09/05/%E3%80%8A%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E4%B9%8B%E9%81%93%E3%80%8B%E7%AC%94%E8%AE%B0/" title="《应用架构之道》笔记"><img class="cover" src="/img/wall-paper-121.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2019-09-05</div><div class="info-item-2">《应用架构之道》笔记</div></div><div class="info-2"><div class="info-item-1">架构师的职责 化繁为简。架构师是职责就是把复杂的问题简单化，使得其他人能够更好地在架构里工作。 架构师要努力训练自己的思维，用它去理解复杂的系统，通过合理的分解和抽象，做出合理的设计。 软件架构 软件架构是一个系统的草图。软件架构描述的对象是直接构成系统的抽象组件。各个组件的链接则明确和相对细致地描述组件之间的通信。  软件架构为软件系统提供了结构、行为和属性的高级抽象。，由构件的描述、构件的相互作用、指导构件集成的模式以及这些模式的约束组成。软件架构不仅显示了软件需求和软件结构之间的对应关系，而且指定了整个软件系统的组织和拓扑结构，提供了一些设计决策的基本原理。 软件架构的核心价值应该只围绕一个核心命题：控制复杂性。  软件架构分类  业务架构：由业务架构师负责，也可以称为业务领域专家、行业专家。业务架构属于顶层设计，其对业务的定义和划分会影响组织结构和技术架构。 应用架构：由应用架构师负责，他需要根据业务场景的需要，设计应用的层次结构，制定应用规范、定义接口和数据交互协议等。并尽量将应用的复杂度控制在一个可以接受的水平，从而在快速的支撑业务发展的同时，在保证系统的可用性和可维...</div></div></div></a><a class="pagination-related" href="/2019/09/26/%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E7%AC%94%E8%AE%B0/" title="架构整洁之道笔记"><img class="cover" src="/img/wall-paper-80.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2019-09-26</div><div class="info-item-2">架构整洁之道笔记</div></div><div class="info-2"><div class="info-item-1">最早的《The Clean Architecture》诞生于 2012年，这个问题很早就被讨论清楚了。 思维导图：   注意，所有的接口都是在高层声明的：UseCase Input Port 和 UseCase Output port，所以高层可以实现高层的接口，低层也可以实现高层的接口。 注意，sofa的分层就是在一个横向的模块里声明了业务用例的接口和 core-model 的接口，这样源代码级的依赖都集中在抽象上：   Use Case Interactor 和 Presenter 应该是可测试的，而 Data Access Interface、View、ORM 应该是 humble object。所以一个应用的低层（外层）应该是被排除掉不做测试的。 附件下载： xmind 关于源代码中的依赖关系的一些澄清：  “使用”并不意味着“定义”，而只是引用  dashed outline 代表虚线框，也代表抽象。           </div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">数据系统基础</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">可靠、可扩展与可维护的应用系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E9%9D%A0%E6%80%A7-reliability"><span class="toc-number">3.1.</span> <span class="toc-text">可靠性（Reliability）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E6%95%85%E9%9A%9C"><span class="toc-number">3.1.1.</span> <span class="toc-text">硬件故障</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E9%94%99%E8%AF%AF"><span class="toc-number">3.1.2.</span> <span class="toc-text">软件错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%BA%E4%B8%BA%E5%A4%B1%E8%AF%AF"><span class="toc-number">3.1.3.</span> <span class="toc-text">人为失误</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7-scalability"><span class="toc-number">3.2.</span> <span class="toc-text">可扩展性（ Scalability）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0%E8%B4%9F%E8%BD%BD"><span class="toc-number">3.2.1.</span> <span class="toc-text">描述负载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#twitter-%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">Twitter 的例子</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#lazy-%E6%96%B9%E6%A1%88"><span class="toc-number">3.2.1.1.1.</span> <span class="toc-text">lazy 方案</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#eager-%E6%96%B9%E6%A1%88"><span class="toc-number">3.2.1.1.2.</span> <span class="toc-text">eager 方案</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0%E6%80%A7%E8%83%BD"><span class="toc-number">3.2.2.</span> <span class="toc-text">描述性能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7"><span class="toc-number">3.3.</span> <span class="toc-text">可维护性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%BF%90%E7%BB%B4%E6%80%A7"><span class="toc-number">3.3.1.</span> <span class="toc-text">可运维性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%80%A7"><span class="toc-number">3.3.2.</span> <span class="toc-text">简单性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E6%BC%94%E5%8C%96%E6%80%A7"><span class="toc-number">3.3.3.</span> <span class="toc-text">可演化性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">数据模型与查询语言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%96%87%E6%A1%A3%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.1.</span> <span class="toc-text">关系模型与文档模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%86%E5%8F%B2"><span class="toc-number">4.1.1.</span> <span class="toc-text">历史</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%81%B5%E6%B4%BB%E6%80%A7"><span class="toc-number">4.1.2.</span> <span class="toc-text">模式灵活性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%B1%80%E9%83%A8%E6%80%A7%E4%B8%8E%E6%80%A7%E8%83%BD"><span class="toc-number">4.1.2.1.</span> <span class="toc-text">数据局部性与性能</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%9E%8D%E5%90%88%E7%9A%84%E8%B6%8B%E5%8A%BF"><span class="toc-number">4.1.3.</span> <span class="toc-text">融合的趋势</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80"><span class="toc-number">4.2.</span> <span class="toc-text">数据查询语言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E9%87%8C%E7%9A%84%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80"><span class="toc-number">4.2.1.</span> <span class="toc-text">数据库里的查询语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#web-%E9%A2%86%E5%9F%9F%E7%9A%84%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80"><span class="toc-number">4.2.2.</span> <span class="toc-text">web 领域的查询语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mapreduce-%E6%9F%A5%E8%AF%A2"><span class="toc-number">4.2.3.</span> <span class="toc-text">MapReduce 查询</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.3.</span> <span class="toc-text">图计算模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E5%9B%BE"><span class="toc-number">4.3.1.</span> <span class="toc-text">属性图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cypher-%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80"><span class="toc-number">4.3.2.</span> <span class="toc-text">Cypher 查询语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E5%85%83%E5%AD%98%E5%82%A8%E4%B8%8E-sparql"><span class="toc-number">4.3.3.</span> <span class="toc-text">三元存储与 SPARQL</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%AD%E4%B9%89%E7%BD%91"><span class="toc-number">4.3.3.0.1.</span> <span class="toc-text">语义网</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sparql"><span class="toc-number">4.3.3.1.</span> <span class="toc-text">SPARQL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#datalog-%E5%87%BA%E7%8E%B0%E5%BE%97%E6%9B%B4%E6%97%A9"><span class="toc-number">4.3.3.2.</span> <span class="toc-text">Datalog 出现得更早</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">4.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">数据存储和检索</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A0%B8%E5%BF%83%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">5.1.</span> <span class="toc-text">数据库核心：数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E5%BF%97"><span class="toc-number">5.1.1.</span> <span class="toc-text">日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-number">5.1.2.</span> <span class="toc-text">索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95"><span class="toc-number">5.1.2.1.</span> <span class="toc-text">哈希索引</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E9%87%8C%E7%9A%84-hash-%E8%A1%A8%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-number">5.1.2.1.1.</span> <span class="toc-text">内存里的 hash 表有什么缺点？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sstables-%E5%92%8C-lsm-tree"><span class="toc-number">5.1.2.2.</span> <span class="toc-text">SSTables 和 LSM-Tree</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-tree"><span class="toc-number">5.1.2.3.</span> <span class="toc-text">B-tree</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF-b-tree-%E6%9B%B4%E5%8F%AF%E9%9D%A0%EF%BC%9F"><span class="toc-number">5.1.2.3.1.</span> <span class="toc-text">如何使 B-tree 更可靠？</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96-b-tree%EF%BC%9F"><span class="toc-number">5.1.2.3.1.1.</span> <span class="toc-text">如何优化 B-tree？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94-b-tree-%E5%92%8C-lsm-tree"><span class="toc-number">5.1.2.4.</span> <span class="toc-text">对比 B-tree 和 LSM-tree</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#lsm-tree-%E7%9A%84%E4%BC%98%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">5.1.2.4.1.</span> <span class="toc-text">LSM-tree 的优点是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#lsm-tree-%E7%9A%84%E7%BC%BA%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">5.1.2.4.1.1.</span> <span class="toc-text">LSM-tree 的缺点是什么？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84"><span class="toc-number">5.1.2.5.</span> <span class="toc-text">其他索引结构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E5%A4%84%E7%90%86"><span class="toc-number">5.2.</span> <span class="toc-text">事务处理与分析处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93"><span class="toc-number">5.2.1.</span> <span class="toc-text">数据仓库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#oltp-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E4%B9%8B%E9%97%B4%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="toc-number">5.2.2.</span> <span class="toc-text">OLTP 数据库和数据仓库之间的差异</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%9F%E5%9E%8B%E4%B8%8E%E9%9B%AA%E8%8A%B1%E5%9E%8B%E5%88%86%E6%9E%90%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.2.3.</span> <span class="toc-text">星型与雪花型分析模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%97%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-number">5.3.</span> <span class="toc-text">列式存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E5%8E%8B%E7%BC%A9"><span class="toc-number">5.3.1.</span> <span class="toc-text">列压缩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%B8%A6%E5%AE%BD%E5%92%8C%E7%9F%A2%E9%87%8F%E5%8C%96%E5%A4%84%E7%90%86"><span class="toc-number">5.3.2.</span> <span class="toc-text">内存带宽和矢量化处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E5%AD%98%E5%82%A8%E4%B8%AD%E7%9A%84%E6%8E%92%E5%BA%8F"><span class="toc-number">5.3.3.</span> <span class="toc-text">列存储中的排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%A0%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%9A%84%E6%8E%92%E5%BA%8F"><span class="toc-number">5.3.3.1.</span> <span class="toc-text">几种不同的排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E5%AD%98%E5%82%A8%E7%9A%84%E5%86%99%E6%93%8D%E4%BD%9C"><span class="toc-number">5.3.4.</span> <span class="toc-text">列存储的写操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E5%90%88%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%AB%8B%E6%96%B9%E4%BD%93%E5%92%8C%E5%AE%9E%E4%BD%93%E5%8C%96%E8%A7%86%E5%9B%BE"><span class="toc-number">5.3.5.</span> <span class="toc-text">聚合：数据立方体和实体化视图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">5.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">数据编码与演化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F"><span class="toc-number">6.1.</span> <span class="toc-text">数据编码格式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E4%BE%8B%E5%AD%90"><span class="toc-number">6.1.1.</span> <span class="toc-text">三个例子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E6%A0%BC%E5%BC%8F"><span class="toc-number">6.2.</span> <span class="toc-text">数据流格式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-number">6.2.1.</span> <span class="toc-text">基于数据库的数据流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B5%81%EF%BC%9Arest-%E5%92%8C-prc"><span class="toc-number">6.2.2.</span> <span class="toc-text">基于服务的数据流：REST 和 PRC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1"><span class="toc-number">6.2.2.1.</span> <span class="toc-text">网络服务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8-rpc-%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">6.2.2.2.</span> <span class="toc-text">远程过程调用（RPC）的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rpc-%E7%9A%84%E5%8F%91%E5%B1%95%E6%96%B9%E5%90%91"><span class="toc-number">6.2.2.3.</span> <span class="toc-text">RPC 的发展方向</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rpc-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A0%81%E5%92%8C%E6%BC%94%E5%8C%96"><span class="toc-number">6.2.2.4.</span> <span class="toc-text">RPC 的数据编码和演化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-number">6.2.3.</span> <span class="toc-text">基于消息传递的数据流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%BB%A3%E7%90%86"><span class="toc-number">6.2.3.1.</span> <span class="toc-text">消息代理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F-actor-%E6%A1%86%E6%9E%B6"><span class="toc-number">6.2.3.2.</span> <span class="toc-text">分布式 Actor 框架</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">6.3.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">分布式数据系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%B1%95%E8%83%BD%E5%8A%9B"><span class="toc-number">7.1.</span> <span class="toc-text">系统扩展能力</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E5%85%B1%E4%BA%AB%E6%9E%B6%E6%9E%84"><span class="toc-number">7.1.1.</span> <span class="toc-text">无共享架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E4%B8%8E%E5%88%86%E5%8C%BA"><span class="toc-number">7.1.2.</span> <span class="toc-text">复制与分区</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">数据复制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E8%8A%82%E7%82%B9%E5%92%8C%E4%BB%8E%E8%8A%82%E7%82%B9"><span class="toc-number">8.1.</span> <span class="toc-text">主节点和从节点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%A4%8D%E5%88%B6%E4%B8%8E%E5%BC%82%E6%AD%A5%E5%A4%8D%E5%88%B6"><span class="toc-number">8.1.1.</span> <span class="toc-text">同步复制与异步复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%B0%E7%9A%84%E4%BB%8E%E8%8A%82%E7%82%B9"><span class="toc-number">8.1.2.</span> <span class="toc-text">配置新的从节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E8%8A%82%E7%82%B9%E5%A4%B1%E6%95%88"><span class="toc-number">8.1.3.</span> <span class="toc-text">处理节点失效</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E8%8A%82%E7%82%B9%E5%A4%B1%E6%95%88%EF%BC%9A%E8%BF%BD%E8%B5%B6%E5%BC%8F%E6%81%A2%E5%A4%8D"><span class="toc-number">8.1.3.1.</span> <span class="toc-text">从节点失效：追赶式恢复</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E8%8A%82%E7%82%B9%E5%A4%B1%E6%95%88%EF%BC%9A%E8%8A%82%E7%82%B9%E5%88%87%E6%8D%A2"><span class="toc-number">8.1.3.2.</span> <span class="toc-text">主节点失效：节点切换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E6%97%A5%E5%BF%97%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">8.1.4.</span> <span class="toc-text">复制日志的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="toc-number">8.1.4.1.</span> <span class="toc-text">基于语句的复制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E9%A2%84%E5%86%99%E6%97%A5%E5%BF%97%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="toc-number">8.1.4.2.</span> <span class="toc-text">基于预写日志的复制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E8%A1%8C%E7%9A%84%E9%80%BB%E8%BE%91%E6%97%A5%E5%BF%97%E5%A4%8D%E5%88%B6"><span class="toc-number">8.1.4.3.</span> <span class="toc-text">基于行的逻辑日志复制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E8%A7%A6%E5%8F%91%E5%99%A8%E7%9A%84%E6%8E%A7%E5%88%B6"><span class="toc-number">8.1.4.4.</span> <span class="toc-text">基于触发器的控制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E6%BB%9E%E5%90%8E%E9%97%AE%E9%A2%98-replication-lag"><span class="toc-number">8.2.</span> <span class="toc-text">复制滞后问题（replication lag）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E8%87%AA%E5%B7%B1%E7%9A%84%E5%86%99-read-your-writes"><span class="toc-number">8.2.1.</span> <span class="toc-text">读自己的写（read-your-writes）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E8%AF%BB-monotonic-read"><span class="toc-number">8.2.2.</span> <span class="toc-text">单调读（monotonic-read）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E4%B8%80%E8%87%B4%E8%AF%BB-consistent-prefix-reads"><span class="toc-number">8.2.3.</span> <span class="toc-text">前缀一致读（consistent prefix reads）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E6%BB%9E%E5%90%8E%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">8.2.4.</span> <span class="toc-text">复制滞后的解决方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E4%B8%BB%E8%8A%82%E7%82%B9%E5%A4%8D%E5%88%B6"><span class="toc-number">8.3.</span> <span class="toc-text">多主节点复制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">8.3.1.</span> <span class="toc-text">适用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83"><span class="toc-number">8.3.1.1.</span> <span class="toc-text">多数据中心</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A6%BB%E7%BA%BF%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%93%8D%E4%BD%9C"><span class="toc-number">8.3.1.2.</span> <span class="toc-text">离线客户端操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E4%BD%9C%E7%BC%96%E8%BE%91"><span class="toc-number">8.3.1.3.</span> <span class="toc-text">协作编辑</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%86%99%E5%86%B2%E7%AA%81"><span class="toc-number">8.3.2.</span> <span class="toc-text">处理写冲突</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5%E5%86%B2%E7%AA%81%E6%A3%80%E6%B5%8B"><span class="toc-number">8.3.2.1.</span> <span class="toc-text">同步与异步冲突检测</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E5%86%B2%E7%AA%81"><span class="toc-number">8.3.2.2.</span> <span class="toc-text">避免冲突</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E6%95%9B%E4%BA%8E%E4%B8%80%E8%87%B4%E7%8A%B6%E6%80%81"><span class="toc-number">8.3.2.3.</span> <span class="toc-text">收敛于一致状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E9%80%BB%E8%BE%91"><span class="toc-number">8.3.2.4.</span> <span class="toc-text">自定义冲突解决逻辑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%B2%E7%AA%81"><span class="toc-number">8.3.2.5.</span> <span class="toc-text">什么是冲突</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84"><span class="toc-number">8.3.3.</span> <span class="toc-text">拓扑结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E4%B8%BB%E8%8A%82%E7%82%B9%E5%A4%8D%E5%88%B6-leaderless"><span class="toc-number">8.4.</span> <span class="toc-text">无主节点复制（leaderless）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#gossip-%E4%B8%8D%E6%98%AF%E6%97%A0%E4%B8%BB%E5%A4%8D%E5%88%B6-%E5%8F%AA%E6%98%AF%E6%97%A0%E4%B8%BB%E7%89%A9"><span class="toc-number">8.4.1.</span> <span class="toc-text">Gossip 不是无主复制，只是无主物</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E5%A4%B1%E6%95%88%E6%97%B6%E5%86%99%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">8.4.2.</span> <span class="toc-text">节点失效时写数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E4%BF%AE%E5%A4%8D%E5%92%8C%E5%8F%8D%E7%86%B5"><span class="toc-number">8.4.2.1.</span> <span class="toc-text">读修复和反熵</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB%E4%BF%AE%E5%A4%8D-read-repair"><span class="toc-number">8.4.2.1.1.</span> <span class="toc-text">读修复（Read repair）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%8D%E7%86%B5-anti-entropy-process"><span class="toc-number">8.4.2.1.2.</span> <span class="toc-text">反熵（Anti-entropy process）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E7%9A%84%E6%B3%95%E5%AE%9A%E4%BA%BA%E6%95%B0"><span class="toc-number">8.4.2.2.</span> <span class="toc-text">读写的法定人数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#quorum-%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-number">8.4.3.</span> <span class="toc-text">Quorum 一致性的局限性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%91%E6%8E%A7%E6%97%A7%E5%80%BC"><span class="toc-number">8.4.3.1.</span> <span class="toc-text">监控旧值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%BD%E6%9D%BE%E6%B3%95%E5%AE%9A%E7%A5%A8%E6%95%B0-quorum-%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%9B%9E%E4%BC%A0"><span class="toc-number">8.4.3.2.</span> <span class="toc-text">宽松法定票数（quorum）与数据回传</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E7%BB%B4%E5%A4%9A%E4%B8%AA%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83"><span class="toc-number">8.4.3.3.</span> <span class="toc-text">运维多个数据中心</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E5%B9%B6%E5%8F%91%E5%86%99"><span class="toc-number">8.4.4.</span> <span class="toc-text">检测并发写</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%90%8E%E5%86%99%E5%85%A5%E8%80%85%E8%83%9C-%E4%B8%A2%E5%BC%83%E5%B9%B6%E5%8F%91%E5%86%99%E5%85%A5"><span class="toc-number">8.4.4.1.</span> <span class="toc-text">最后写入者胜（丢弃并发写入）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#happens-before-%E5%85%B3%E7%B3%BB%E5%92%8C%E5%B9%B6%E5%8F%91"><span class="toc-number">8.4.4.2.</span> <span class="toc-text">Happens-before 关系和并发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A%E5%B9%B6%E5%8F%91%E5%85%B3%E7%B3%BB"><span class="toc-number">8.4.4.3.</span> <span class="toc-text">确定并发关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E5%90%8C%E6%97%B6%E5%86%99%E5%85%A5%E7%9A%84%E5%80%BC"><span class="toc-number">8.4.4.4.</span> <span class="toc-text">合并同时写入的值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%88%E6%9C%AC%E5%90%91%E9%87%8F"><span class="toc-number">8.4.4.5.</span> <span class="toc-text">版本向量</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">8.5.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">9.</span> <span class="toc-text">数据分区</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E4%B8%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">9.1.</span> <span class="toc-text">分区与复制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%AE-%E5%80%BC%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%86%E5%8C%BA"><span class="toc-number">9.2.</span> <span class="toc-text">键-值数据的分区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E9%94%AE%E7%9A%84%E8%8C%83%E5%9B%B4%E5%88%86%E5%8C%BA"><span class="toc-number">9.2.1.</span> <span class="toc-text">根据键的范围分区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E9%94%AE%E7%9A%84%E6%95%A3%E5%88%97%E5%88%86%E5%8C%BA"><span class="toc-number">9.2.2.</span> <span class="toc-text">根据键的散列分区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%80%BE%E6%96%9C%E4%B8%8E%E6%B6%88%E9%99%A4%E7%83%AD%E7%82%B9"><span class="toc-number">9.2.3.</span> <span class="toc-text">负载倾斜与消除热点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E4%B8%8E%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95"><span class="toc-number">9.3.</span> <span class="toc-text">分区与二级索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E6%96%87%E6%A1%A3%E7%9A%84%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95-document-partitioned"><span class="toc-number">9.3.1.</span> <span class="toc-text">按文档的二级索引（document partitioned）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E5%85%B3%E9%94%AE%E8%AF%8D%E7%9A%84%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95-term-partitioned"><span class="toc-number">9.3.2.</span> <span class="toc-text">按关键词的二级索引（term partitioned）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E5%86%8D%E5%B9%B3%E8%A1%A1"><span class="toc-number">9.4.</span> <span class="toc-text">分区再平衡</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E7%AD%96%E7%95%A5"><span class="toc-number">9.4.1.</span> <span class="toc-text">平衡策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E9%9D%A2%E6%95%99%E6%9D%90%EF%BC%9Ahash-mod-n"><span class="toc-number">9.4.1.1.</span> <span class="toc-text">反面教材：hash mod N</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A%E6%95%B0%E9%87%8F%E7%9A%84%E5%88%86%E5%8C%BA"><span class="toc-number">9.4.1.2.</span> <span class="toc-text">固定数量的分区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA"><span class="toc-number">9.4.1.3.</span> <span class="toc-text">动态分区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E8%8A%82%E7%82%B9%E6%AF%94%E4%BE%8B%E5%88%86%E5%8C%BA"><span class="toc-number">9.4.1.4.</span> <span class="toc-text">按节点比例分区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E7%BB%B4%EF%BC%9A%E6%89%8B%E5%8A%A8%E8%BF%98%E6%98%AF%E8%87%AA%E5%8A%A8%E5%B9%B3%E8%A1%A1"><span class="toc-number">9.4.1.5.</span> <span class="toc-text">运维：手动还是自动平衡</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E8%B7%AF%E7%94%B1"><span class="toc-number">9.5.</span> <span class="toc-text">请求路由</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E5%B9%B6%E8%A1%8C%E6%9F%A5%E8%AF%A2"><span class="toc-number">9.5.1.</span> <span class="toc-text">执行并行查询</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">9.6.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">10.</span> <span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%BA%8B%E5%8A%A1"><span class="toc-number">10.1.</span> <span class="toc-text">深入理解事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#acid-%E7%9A%84%E5%90%AB%E4%B9%89"><span class="toc-number">10.1.1.</span> <span class="toc-text">ACID 的含义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7-atomicity"><span class="toc-number">10.1.1.1.</span> <span class="toc-text">原子性（Atomicity）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7-consistency"><span class="toc-number">10.1.1.2.</span> <span class="toc-text">一致性（Consistency）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%94%E7%A6%BB%E6%80%A7-isolation"><span class="toc-number">10.1.1.3.</span> <span class="toc-text">隔离性（Isolation）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E6%80%A7-durability"><span class="toc-number">10.1.1.4.</span> <span class="toc-text">持久性（Durability）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%A4%9A%E5%AF%B9%E8%B1%A1%E4%BA%8B%E5%8A%A1%E6%93%8D%E4%BD%9C"><span class="toc-number">10.1.2.</span> <span class="toc-text">单对象和多对象事务操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E5%AF%B9%E8%B1%A1%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7"><span class="toc-number">10.1.2.1.</span> <span class="toc-text">多对象事务的必要性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%B1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">10.2.</span> <span class="toc-text">弱隔离级别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A4"><span class="toc-number">10.2.1.</span> <span class="toc-text">读已提交</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B2%E6%AD%A2%E8%84%8F%E8%AF%BB"><span class="toc-number">10.2.1.1.</span> <span class="toc-text">防止脏读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B2%E6%AD%A2%E8%84%8F%E5%86%99"><span class="toc-number">10.2.1.2.</span> <span class="toc-text">防止脏写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A4"><span class="toc-number">10.2.1.3.</span> <span class="toc-text">实现读已提交</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E7%85%A7%E9%9A%94%E7%A6%BB%E5%92%8C%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB"><span class="toc-number">10.2.2.</span> <span class="toc-text">快照隔离和可重复读</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%BF%AB%E7%85%A7%E9%9A%94%E7%A6%BB"><span class="toc-number">10.2.2.1.</span> <span class="toc-text">实现快照隔离</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E5%BF%AB%E7%85%A7%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E8%A7%84%E5%88%99"><span class="toc-number">10.2.2.2.</span> <span class="toc-text">一致性快照的可见性规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%92%8C%E5%BF%AB%E7%85%A7%E9%9A%94%E7%A6%BB"><span class="toc-number">10.2.2.3.</span> <span class="toc-text">索引和快照隔离</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E4%B8%8E%E5%91%BD%E5%90%8D%E6%B7%B7%E6%B7%86"><span class="toc-number">10.2.2.4.</span> <span class="toc-text">可重复读与命名混淆</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B2%E6%AD%A2%E6%9B%B4%E6%96%B0%E4%B8%A2%E5%A4%B1"><span class="toc-number">10.2.3.</span> <span class="toc-text">防止更新丢失</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E5%86%99"><span class="toc-number">10.2.3.1.</span> <span class="toc-text">原子写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E9%94%81%E5%AE%9A"><span class="toc-number">10.2.3.2.</span> <span class="toc-text">显式锁定</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E5%80%BE%E6%96%9C%E4%B8%8E%E5%B9%BB%E8%AF%BB"><span class="toc-number">10.2.4.</span> <span class="toc-text">写倾斜与幻读</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%86%99%E5%80%BE%E6%96%9C"><span class="toc-number">10.2.4.1.</span> <span class="toc-text">定义写倾斜</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E5%A4%9A%E5%86%99%E5%80%BE%E6%96%9C%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">10.2.4.2.</span> <span class="toc-text">更多写倾斜的例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BD%95%E4%BA%A7%E7%94%9F%E5%86%99%E5%80%BE%E6%96%9C"><span class="toc-number">10.2.4.3.</span> <span class="toc-text">为何产生写倾斜</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BD%93%E5%8C%96%E5%86%B2%E7%AA%81"><span class="toc-number">10.2.4.4.</span> <span class="toc-text">实体化冲突</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E4%B8%B2%E8%A1%8C%E5%8C%96"><span class="toc-number">10.2.5.</span> <span class="toc-text">可串行化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E4%B8%B2%E8%A1%8C%E6%89%A7%E8%A1%8C"><span class="toc-number">10.2.5.1.</span> <span class="toc-text">实际串行执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%B0%81%E8%A3%85%E4%BA%8B%E5%8A%A1"><span class="toc-number">10.2.5.2.</span> <span class="toc-text">在存储过程中封装事务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%8C%BA"><span class="toc-number">10.2.5.3.</span> <span class="toc-text">分区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E5%8A%A0%E9%94%81"><span class="toc-number">10.2.5.4.</span> <span class="toc-text">两阶段加锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%A4%E9%98%B6%E6%AE%B5%E9%94%81"><span class="toc-number">10.2.5.4.1.</span> <span class="toc-text">实现两阶段锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E9%94%81%E7%9A%84%E6%80%A7%E8%83%BD%E4%B8%8D%E5%A5%BD"><span class="toc-number">10.2.5.4.2.</span> <span class="toc-text">两阶段锁的性能不好</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B0%93%E8%AF%8D%E9%94%81-predicate-lock"><span class="toc-number">10.2.5.4.3.</span> <span class="toc-text">谓词锁（predicate lock）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E9%94%81"><span class="toc-number">10.2.5.4.4.</span> <span class="toc-text">索引范围锁</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8A%A0%E9%94%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">10.2.5.4.4.1.</span> <span class="toc-text">加锁示例</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E5%BF%AB%E7%85%A7%E9%9A%94%E7%A6%BB-ssi"><span class="toc-number">10.3.</span> <span class="toc-text">序列化快照隔离（SSI）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">10.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">11.</span> <span class="toc-text">分布式系统的挑战</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%85%E9%9A%9C%E4%B8%8E%E9%83%A8%E5%88%86%E5%A4%B1%E6%95%88"><span class="toc-number">11.1.</span> <span class="toc-text">故障与部分失效</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%91%E8%AE%A1%E7%AE%97%E5%92%8C%E8%B6%85%E7%AE%97"><span class="toc-number">11.1.1.</span> <span class="toc-text">云计算和超算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E9%9D%A0%E7%9A%84%E7%BD%91%E7%BB%9C"><span class="toc-number">11.2.</span> <span class="toc-text">不可靠的网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9C%9F%E5%AE%9E%E4%B8%96%E7%95%8C%E7%9A%84%E7%BD%91%E7%BB%9C%E6%95%85%E9%9A%9C"><span class="toc-number">11.2.1.</span> <span class="toc-text">真实世界的网络故障</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E6%95%85%E9%9A%9C"><span class="toc-number">11.2.2.</span> <span class="toc-text">检测故障</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B6%85%E6%97%B6%E4%B8%8E%E6%97%A0%E7%A9%B7%E7%9A%84%E5%BB%B6%E8%BF%9F"><span class="toc-number">11.2.3.</span> <span class="toc-text">超时与无穷的延迟</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%8B%A5%E5%A1%9E%E5%92%8C%E6%8E%92%E9%98%9F"><span class="toc-number">11.2.4.</span> <span class="toc-text">网络拥塞和排队</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E7%BD%91%E7%BB%9C-vs-%E5%BC%82%E6%AD%A5%E7%BD%91%E7%BB%9C"><span class="toc-number">11.2.5.</span> <span class="toc-text">同步网络 vs 异步网络</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E9%9D%A0%E7%9A%84%E6%97%B6%E9%92%9F"><span class="toc-number">11.3.</span> <span class="toc-text">不可靠的时钟</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E9%92%9F%E4%B8%8E%E6%97%B6%E9%92%9F"><span class="toc-number">11.3.1.</span> <span class="toc-text">单调钟与时钟</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%90%8C%E6%AD%A5%E6%97%B6%E9%92%9F"><span class="toc-number">11.3.2.</span> <span class="toc-text">依赖同步时钟</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E6%88%B3%E4%B8%8E%E4%BA%8B%E4%BB%B6%E9%A1%BA%E5%BA%8F"><span class="toc-number">11.3.2.1.</span> <span class="toc-text">时间戳与事件顺序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E6%97%B6%E9%92%9F-logical-clock"><span class="toc-number">11.3.2.1.1.</span> <span class="toc-text">逻辑时钟 (Logical Clock)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#lamport-%E6%97%B6%E9%92%9F-lamport-clock"><span class="toc-number">11.3.2.1.2.</span> <span class="toc-text">Lamport 时钟 (Lamport Clock)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%91%E9%87%8F%E6%97%B6%E9%92%9F-vector-clock-%E7%89%88%E6%9C%AC%E5%90%91%E9%87%8F-version-vector"><span class="toc-number">11.3.2.1.3.</span> <span class="toc-text">向量时钟 (Vector Clock) &#x2F; 版本向量 (Version Vector)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%92%9F%E8%AF%BB%E6%95%B0%E5%AD%98%E5%9C%A8%E7%BD%AE%E4%BF%A1%E5%8C%BA%E9%97%B4"><span class="toc-number">11.3.3.</span> <span class="toc-text">时钟读数存在置信区间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%BF%AB%E7%85%A7%E7%9A%84%E5%90%8C%E6%AD%A5%E6%97%B6%E9%92%9F"><span class="toc-number">11.3.4.</span> <span class="toc-text">全局快照的同步时钟</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9A%82%E5%81%9C%E8%BF%9B%E7%A8%8B"><span class="toc-number">11.3.5.</span> <span class="toc-text">暂停进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E6%95%B4%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E6%96%B9%E6%B3%95-%E9%9D%9E%E5%B8%B8%E9%87%8D%E8%A6%81"><span class="toc-number">11.3.5.1.</span> <span class="toc-text">调整垃圾回收的方法（非常重要!）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86-%E7%9C%9F%E7%9B%B8%E4%B8%8E%E8%B0%8E%E8%A8%80"><span class="toc-number">11.4.</span> <span class="toc-text">知识、真相与谎言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9C%9F%E7%90%86%E7%94%B1%E5%A4%9A%E6%95%B0%E6%89%80%E5%AE%9A%E4%B9%89"><span class="toc-number">11.4.1.</span> <span class="toc-text">真理由多数所定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#fencing-%E4%BB%A4%E7%89%8C"><span class="toc-number">11.4.1.1.</span> <span class="toc-text">fencing 令牌</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%9C%E5%8D%A0%E5%BA%AD%E6%95%85%E9%9A%9C"><span class="toc-number">11.4.2.</span> <span class="toc-text">拜占庭故障</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%8E%B0%E5%AE%9E"><span class="toc-number">11.4.3.</span> <span class="toc-text">系统模型与现实</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%80%A7"><span class="toc-number">11.4.3.1.</span> <span class="toc-text">算法的正确性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#safety-%E5%92%8C-liveness"><span class="toc-number">11.4.3.2.</span> <span class="toc-text">safety 和 liveness</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9E%8B%E6%98%A0%E5%B0%84%E5%88%B0%E7%8E%B0%E5%AE%9E%E4%B8%96%E7%95%8C"><span class="toc-number">11.4.3.3.</span> <span class="toc-text">将系统模型映射到现实世界</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93"><span class="toc-number">11.5.</span> <span class="toc-text">本章小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">12.</span> <span class="toc-text">一致性与共识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E4%BF%9D%E8%AF%81"><span class="toc-number">12.1.</span> <span class="toc-text">一致性保证</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E7%BA%BF%E6%80%A7%E5%8C%96"><span class="toc-number">12.2.</span> <span class="toc-text">可线性化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%BE%BE%E5%88%B0%E5%8F%AF%E7%BA%BF%E6%80%A7%E5%8C%96"><span class="toc-number">12.2.1.</span> <span class="toc-text">如何达到可线性化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E7%BA%BF%E6%80%A7%E5%8C%96%E4%B8%8D%E6%98%AF%E5%8F%AF%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">12.2.1.1.</span> <span class="toc-text">可线性化不是可序列化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E7%BA%BF%E6%80%A7%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-number">12.2.2.</span> <span class="toc-text">依赖线性一致性的场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E5%AE%9A%E5%92%8C%E9%A2%86%E5%AF%BC%E9%80%89%E4%B8%BE"><span class="toc-number">12.2.2.1.</span> <span class="toc-text">锁定和领导选举</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%A6%E6%9D%9F%E5%92%8C%E5%94%AF%E4%B8%80%E6%80%A7%E4%BF%9D%E8%AF%81"><span class="toc-number">12.2.2.2.</span> <span class="toc-text">约束和唯一性保证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%A8%E4%BF%A1%E9%81%93%E7%9A%84%E6%97%B6%E5%BA%8F%E4%BE%9D%E8%B5%96"><span class="toc-number">12.2.2.3.</span> <span class="toc-text">跨信道的时序依赖</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8F%AF%E7%BA%BF%E6%80%A7%E5%8C%96%E7%B3%BB%E7%BB%9F"><span class="toc-number">12.2.3.</span> <span class="toc-text">实现可线性化系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E7%BA%BF%E6%80%A7%E5%8C%96%E5%92%8C-quorum"><span class="toc-number">12.2.3.1.</span> <span class="toc-text">可线性化和 quorum</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E7%BA%BF%E6%80%A7%E5%8C%96%E7%9A%84%E4%BB%A3%E4%BB%B7"><span class="toc-number">12.2.4.</span> <span class="toc-text">可线性化的代价</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#cap-%E7%90%86%E8%AE%BA"><span class="toc-number">12.2.4.1.</span> <span class="toc-text">CAP 理论</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E4%B8%80%E8%87%B4%E6%80%A7%E5%92%8C%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F"><span class="toc-number">12.2.4.2.</span> <span class="toc-text">线性一致性和网络延迟</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E4%BF%9D%E8%AF%81"><span class="toc-number">12.3.</span> <span class="toc-text">顺序保证</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E4%B8%8E%E5%9B%A0%E6%9E%9C%E5%85%B3%E7%B3%BB"><span class="toc-number">12.3.1.</span> <span class="toc-text">顺序与因果关系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%A0%E6%9E%9C%E5%85%B3%E7%B3%BB%E5%B9%B6%E9%9D%9E%E5%85%A8%E5%BA%8F-%E8%BF%99%E4%B8%80%E7%AB%A0%E6%98%AF%E6%9C%AC%E4%B9%A6%E8%87%B3%E5%85%B3%E9%87%8D%E8%A6%81%E7%9A%84%E7%82%B9"><span class="toc-number">12.3.1.1.</span> <span class="toc-text">因果关系并非全序（这一章是本书至关重要的点）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%A8%E5%BA%8F%E5%B0%B1%E6%98%AF%E5%85%81%E8%AE%B8%E5%8D%95%E4%B8%80%E6%97%B6%E9%97%B4%E7%BA%BF%E6%8E%92%E5%BA%8F"><span class="toc-number">12.3.1.1.1.</span> <span class="toc-text">全序就是允许单一时间线排序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%BA%8B%E4%BB%B6%E8%A6%81%E4%BD%BF%E7%94%A8%E5%8D%95%E7%8B%AC%E6%97%B6%E9%97%B4%E7%BA%BF%E6%8E%92%E5%BA%8F-%E5%81%8F%E5%BA%8F-%E5%9B%A0%E6%AD%A4%E4%B9%9F%E4%B8%8D%E6%BB%A1%E8%B6%B3%E5%8F%AF%E7%BA%BF%E6%80%A7%E5%8C%96"><span class="toc-number">12.3.1.1.2.</span> <span class="toc-text">并发事件要使用单独时间线排序-偏序，因此也不满足可线性化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E7%BA%BF%E6%80%A7%E5%8C%96%E5%8C%85%E5%90%AB%E5%9B%A0%E6%9E%9C%E4%B8%80%E8%87%B4%E6%80%A7-%E4%BD%86%E5%BC%BA%E4%BA%8E%E5%9B%A0%E6%9E%9C%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">12.3.1.1.3.</span> <span class="toc-text">可线性化包含因果一致性，但强于因果一致性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8D%95%E8%8E%B7%E5%9B%A0%E6%9E%9C%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB"><span class="toc-number">12.3.1.1.4.</span> <span class="toc-text">捕获因果依赖关系</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8F%B7%E6%8E%92%E5%BA%8F"><span class="toc-number">12.3.2.</span> <span class="toc-text">序列号排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E5%9B%A0%E6%9E%9C%E5%BA%8F%E5%88%97%E5%8F%91%E7%94%9F%E5%99%A8"><span class="toc-number">12.3.2.1.</span> <span class="toc-text">非因果序列发生器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lamport-%E6%97%B6%E9%97%B4%E6%88%B3"><span class="toc-number">12.3.2.2.</span> <span class="toc-text">Lamport 时间戳</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E6%88%B3%E6%8E%92%E5%BA%8F%E4%BE%9D%E7%84%B6%E4%B8%8D%E5%A4%9F"><span class="toc-number">12.3.2.3.</span> <span class="toc-text">时间戳排序依然不够</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%BA%8F%E5%85%B3%E7%B3%BB%E5%B9%BF%E6%92%AD-total-order-broadcast"><span class="toc-number">12.3.3.</span> <span class="toc-text">全序关系广播（total order broadcast）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%85%A8%E5%BA%8F%E5%85%B3%E7%B3%BB%E5%B9%BF%E6%92%AD"><span class="toc-number">12.3.3.1.</span> <span class="toc-text">使用全序关系广播</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%85%A8%E5%BA%8F%E5%B9%BF%E6%92%AD%E5%AE%9E%E7%8E%B0%E7%BA%BF%E6%80%A7%E4%B8%80%E8%87%B4%E6%80%A7%E5%AD%98%E5%82%A8"><span class="toc-number">12.3.3.2.</span> <span class="toc-text">使用全序广播实现线性一致性存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BA%BF%E6%80%A7%E4%B8%80%E8%87%B4%E6%80%A7%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%BA%8F%E5%B9%BF%E6%92%AD"><span class="toc-number">12.3.3.3.</span> <span class="toc-text">使用线性一致性存储实现全序广播</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B8%8E%E5%85%B1%E8%AF%86"><span class="toc-number">12.4.</span> <span class="toc-text">分布式事务与共识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%8F%90%E4%BA%A4%E4%B8%8E%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4-2pc"><span class="toc-number">12.4.1.</span> <span class="toc-text">原子提交与二阶段提交（2PC）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E5%8D%95%E8%8A%82%E7%82%B9%E5%88%B0%E5%88%86%E5%B8%83%E5%BC%8F%E5%8E%9F%E5%AD%90%E6%8F%90%E4%BA%A4"><span class="toc-number">12.4.1.1.</span> <span class="toc-text">从单节点到分布式原子提交</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4"><span class="toc-number">12.4.1.2.</span> <span class="toc-text">两阶段提交</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%89%BF%E8%AF%BA"><span class="toc-number">12.4.1.3.</span> <span class="toc-text">系统的承诺</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E8%B0%83%E8%80%85%E6%95%85%E9%9A%9C"><span class="toc-number">12.4.1.4.</span> <span class="toc-text">协调者故障</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4"><span class="toc-number">12.4.1.5.</span> <span class="toc-text">三阶段提交</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E8%B7%B5%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">12.4.2.</span> <span class="toc-text">实践中的分布式事务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%81%B0%E5%A5%BD%E4%B8%80%E6%AC%A1%E7%9A%84%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86"><span class="toc-number">12.4.2.1.</span> <span class="toc-text">恰好一次的消息处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#xa%E4%BA%8B%E5%8A%A1"><span class="toc-number">12.4.2.2.</span> <span class="toc-text">XA事务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%9C%E9%A1%BF%E6%97%B6%E6%8C%81%E6%9C%89%E9%94%81"><span class="toc-number">12.4.2.3.</span> <span class="toc-text">停顿时持有锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E5%8D%8F%E8%B0%83%E8%80%85%E6%95%85%E9%9A%9C%E4%B8%AD%E6%81%A2%E5%A4%8D"><span class="toc-number">12.4.2.4.</span> <span class="toc-text">从协调者故障中恢复</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-number">12.4.2.5.</span> <span class="toc-text">分布式事务的限制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E9%94%99%E5%85%B1%E8%AF%86"><span class="toc-number">12.4.3.</span> <span class="toc-text">容错共识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95%E4%B8%8E%E5%85%A8%E5%BA%8F%E5%B9%BF%E6%92%AD"><span class="toc-number">12.4.3.1.</span> <span class="toc-text">共识算法与全序广播</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%B8%8E%E5%85%B1%E8%AF%86"><span class="toc-number">12.4.3.2.</span> <span class="toc-text">主从复制与共识</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#epoch-%E5%92%8C-quorum"><span class="toc-number">12.4.3.3.</span> <span class="toc-text">Epoch 和 Quorum</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E8%AF%86%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-number">12.4.3.4.</span> <span class="toc-text">共识的局限性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E4%B8%8E%E5%8D%8F%E8%B0%83%E6%9C%8D%E5%8A%A1"><span class="toc-number">12.4.4.</span> <span class="toc-text">成员与协调服务</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E5%B8%A6-paxos-%E7%9A%84%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E6%B5%81%E7%A8%8B"><span class="toc-number">12.5.</span> <span class="toc-text">附带 Paxos 的一个简单流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#raft-%E7%9A%84%E7%AE%80%E5%8D%95%E6%B5%81%E7%A8%8B"><span class="toc-number">12.6.</span> <span class="toc-text">Raft 的简单流程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">13.</span> <span class="toc-text">数据派生系统</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">14.</span> <span class="toc-text">批处理系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-unix-%E5%B7%A5%E5%85%B7%E8%BF%9B%E8%A1%8C%E6%89%B9%E5%A4%84%E7%90%86"><span class="toc-number">14.1.</span> <span class="toc-text">使用 UNIX 工具进行批处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#unix-%E7%9A%84%E5%93%B2%E5%AD%A6"><span class="toc-number">14.1.1.</span> <span class="toc-text">Unix 的哲学</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%9F%E4%B8%80%E6%8E%A5%E5%8F%A3"><span class="toc-number">14.1.1.1.</span> <span class="toc-text">统一接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E4%B8%8E%E5%B8%83%E7%BA%BF%E5%88%86%E7%A6%BB"><span class="toc-number">14.1.1.2.</span> <span class="toc-text">逻辑与布线分离</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%8F%E6%98%8E%E4%B8%8E%E6%B5%8B%E8%AF%95"><span class="toc-number">14.1.1.3.</span> <span class="toc-text">透明与测试</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mapreduce-%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">14.2.</span> <span class="toc-text">MapReduce 与分布式文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mapreduce-%E4%BD%9C%E4%B8%9A%E6%89%A7%E8%A1%8C"><span class="toc-number">14.2.1.</span> <span class="toc-text">MapReduce 作业执行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%89%A7%E8%A1%8Cmapreduce"><span class="toc-number">14.2.1.1.</span> <span class="toc-text">分布式执行MapReduce</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mapreduce%E5%B7%A5%E4%BD%9C%E6%B5%81"><span class="toc-number">14.2.1.2.</span> <span class="toc-text">MapReduce工作流</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reduce%E7%AB%AF%E8%BF%9E%E6%8E%A5%E4%B8%8E%E5%88%86%E7%BB%84"><span class="toc-number">14.2.2.</span> <span class="toc-text">Reduce端连接与分组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E6%94%BE%E5%9C%A8%E4%B8%80%E8%B5%B7"><span class="toc-number">14.2.2.1.</span> <span class="toc-text">将相关数据放在一起</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%BB%84"><span class="toc-number">14.2.2.2.</span> <span class="toc-text">分组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C"><span class="toc-number">14.2.2.3.</span> <span class="toc-text">处理数据倾斜</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mapper-%E7%AB%AF-join-%E6%93%8D%E4%BD%9C"><span class="toc-number">14.2.3.</span> <span class="toc-text">Mapper 端 join 操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%BF%E6%92%AD%E5%93%88%E5%B8%8C-join"><span class="toc-number">14.2.3.1.</span> <span class="toc-text">广播哈希 join</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E5%93%88%E5%B8%8C-join"><span class="toc-number">14.2.3.2.</span> <span class="toc-text">分区哈希 join</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map%E7%AB%AF%E5%90%88%E5%B9%B6-join"><span class="toc-number">14.2.3.3.</span> <span class="toc-text">Map端合并 join</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%B9%E5%A4%84%E7%90%86%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%9A%84%E8%BE%93%E5%87%BA"><span class="toc-number">14.2.4.</span> <span class="toc-text">批处理工作流的输出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E6%90%9C%E7%B4%A2%E7%B4%A2%E5%BC%95"><span class="toc-number">14.2.4.1.</span> <span class="toc-text">生成搜索索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%B9%E5%A4%84%E7%90%86%E8%BE%93%E5%87%BA%E9%94%AE%E5%80%BC"><span class="toc-number">14.2.4.2.</span> <span class="toc-text">批处理输出键值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%B9%E5%A4%84%E7%90%86%E8%BE%93%E5%87%BA%E7%9A%84%E5%93%B2%E5%AD%A6"><span class="toc-number">14.2.4.3.</span> <span class="toc-text">批处理输出的哲学</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94-hadoop-%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">14.2.5.</span> <span class="toc-text">对比 Hadoop 与分布式数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%A4%9A%E6%A0%B7%E6%80%A7"><span class="toc-number">14.2.5.1.</span> <span class="toc-text">存储多样性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%A8%A1%E5%9E%8B%E5%A4%9A%E6%A0%B7%E6%80%A7"><span class="toc-number">14.2.5.2.</span> <span class="toc-text">处理模型多样性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%92%88%E5%AF%B9%E9%A2%91%E7%B9%81%E6%95%85%E9%9A%9C%E8%AE%BE%E8%AE%A1"><span class="toc-number">14.2.5.3.</span> <span class="toc-text">针对频繁故障设计</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B6%85%E8%B6%8A-mapreduce"><span class="toc-number">14.3.</span> <span class="toc-text">超越 MapReduce</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E9%97%B4%E7%8A%B6%E6%80%81%E5%AE%9E%E4%BD%93%E5%8C%96"><span class="toc-number">14.3.1.</span> <span class="toc-text">中间状态实体化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E5%BC%95%E6%93%8E"><span class="toc-number">14.3.1.1.</span> <span class="toc-text">数据流引擎</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E9%94%99"><span class="toc-number">14.3.1.2.</span> <span class="toc-text">容错</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%AE%9E%E4%BD%93%E5%8C%96%E7%9A%84%E8%AE%A8%E8%AE%BA"><span class="toc-number">14.3.1.3.</span> <span class="toc-text">关于实体化的讨论</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%A4%84%E7%90%86"><span class="toc-number">14.3.2.</span> <span class="toc-text">图与迭代处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#pregel-%E5%A4%84%E7%90%86%E6%A8%A1%E5%9E%8B"><span class="toc-number">14.3.2.1.</span> <span class="toc-text">Pregel 处理模型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7-api-%E5%92%8C%E8%AF%AD%E8%A8%80"><span class="toc-number">14.3.3.</span> <span class="toc-text">高级 API 和语言</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E5%90%91%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%9F%A5%E8%AF%A2"><span class="toc-number">14.3.3.1.</span> <span class="toc-text">转向声明式查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E9%A2%86%E5%9F%9F%E7%9A%84%E4%B8%93%E4%B8%9A%E5%8C%96"><span class="toc-number">14.3.3.2.</span> <span class="toc-text">不同领域的专业化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">14.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">15.</span> <span class="toc-text">流处理系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E4%BA%8B%E4%BB%B6%E6%B5%81"><span class="toc-number">15.1.</span> <span class="toc-text">发送事件流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E7%B3%BB%E7%BB%9F-messaging"><span class="toc-number">15.1.1.</span> <span class="toc-text">消息系统（Messaging）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%B4%E6%8E%A5%E6%B6%88%E8%B4%B9%E4%BC%A0%E9%80%92"><span class="toc-number">15.1.1.1.</span> <span class="toc-text">生产者与消费者之间的直接消费传递</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%BB%A3%E7%90%86"><span class="toc-number">15.1.1.2.</span> <span class="toc-text">消息代理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%BB%A3%E7%90%86%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%B9%E6%AF%94"><span class="toc-number">15.1.1.3.</span> <span class="toc-text">消息代理与数据库对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">15.1.1.4.</span> <span class="toc-text">多个消费者</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AE%E8%AE%A4%E4%B8%8E%E9%87%8D%E6%96%B0%E4%BC%A0%E9%80%92"><span class="toc-number">15.1.1.5.</span> <span class="toc-text">确认与重新传递</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E6%97%A5%E5%BF%97"><span class="toc-number">15.1.2.</span> <span class="toc-text">分区日志</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%97%A5%E5%BF%97%E7%9A%84%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8"><span class="toc-number">15.1.2.1.</span> <span class="toc-text">基于日志的消息存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E6%97%A5%E5%BF%97%E4%B8%8E%E4%BC%A0%E7%BB%9F%E6%B6%88%E6%81%AF%E7%B3%BB%E7%BB%9F"><span class="toc-number">15.1.2.2.</span> <span class="toc-text">对比日志与传统消息系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E5%81%8F%E7%A7%BB%E9%87%8F"><span class="toc-number">15.1.2.3.</span> <span class="toc-text">消费者偏移量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E4%BD%BF%E7%94%A8"><span class="toc-number">15.1.2.4.</span> <span class="toc-text">磁盘空间使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%93%E6%B6%88%E8%B4%B9%E8%80%85%E8%B7%9F%E4%B8%8D%E4%B8%8A%E7%94%9F%E4%BA%A7%E8%80%85%E6%97%B6"><span class="toc-number">15.1.2.5.</span> <span class="toc-text">当消费者跟不上生产者时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E6%96%B0%E5%A4%84%E7%90%86%E6%B6%88%E6%81%AF"><span class="toc-number">15.1.2.6.</span> <span class="toc-text">重新处理消息</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E6%B5%81"><span class="toc-number">15.2.</span> <span class="toc-text">数据库与流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E6%8C%81%E7%B3%BB%E7%BB%9F%E5%90%8C%E6%AD%A5"><span class="toc-number">15.2.1.</span> <span class="toc-text">保持系统同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E6%9B%B4%E6%95%B0%E6%8D%AE%E6%8D%95%E8%8E%B7"><span class="toc-number">15.2.2.</span> <span class="toc-text">变更数据捕获</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8F%98%E6%9B%B4%E6%95%B0%E6%8D%AE%E6%8D%95%E8%8E%B7"><span class="toc-number">15.2.2.1.</span> <span class="toc-text">实现变更数据捕获</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%BF%AB%E7%85%A7"><span class="toc-number">15.2.2.2.</span> <span class="toc-text">初始快照</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E5%8E%8B%E7%BC%A9"><span class="toc-number">15.2.2.3.</span> <span class="toc-text">日志压缩</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E6%9B%B4%E6%B5%81%E7%9A%84api%E6%94%AF%E6%8C%81"><span class="toc-number">15.2.2.4.</span> <span class="toc-text">变更流的API支持</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E6%BA%AF%E6%BA%90"><span class="toc-number">15.2.3.</span> <span class="toc-text">事件溯源</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E4%BA%8B%E4%BB%B6%E6%97%A5%E5%BF%97%E5%AF%BC%E5%87%BA%E5%BD%93%E5%89%8D%E7%8A%B6%E6%80%81"><span class="toc-number">15.2.3.1.</span> <span class="toc-text">从事件日志导出当前状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E5%92%8C%E4%BA%8B%E4%BB%B6"><span class="toc-number">15.2.3.2.</span> <span class="toc-text">命令和事件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81-%E6%B5%81%E4%B8%8E%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7"><span class="toc-number">15.2.4.</span> <span class="toc-text">状态，流与不可变性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%8F%98%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">15.2.4.1.</span> <span class="toc-text">不变事件的优势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%90%8C%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%97%A5%E5%BF%97%E6%B4%BE%E7%94%9F%E5%A4%9A%E4%B8%AA%E8%A7%86%E5%9B%BE"><span class="toc-number">15.2.4.2.</span> <span class="toc-text">相同的事件日志派生多个视图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-number">15.2.4.3.</span> <span class="toc-text">不可变的限制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E5%A4%84%E7%90%86"><span class="toc-number">15.3.</span> <span class="toc-text">流处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E5%A4%84%E7%90%86%E7%9A%84%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">15.3.1.</span> <span class="toc-text">流处理的适用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86"><span class="toc-number">15.3.1.1.</span> <span class="toc-text">复合事件处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E5%88%86%E6%9E%90-%E9%87%8D%E7%82%B9"><span class="toc-number">15.3.1.2.</span> <span class="toc-text">流分析（重点）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%B4%E6%8A%A4%E5%AE%9E%E4%BD%93%E5%8C%96%E8%A7%86%E5%9B%BE"><span class="toc-number">15.3.1.3.</span> <span class="toc-text">维护实体化视图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E6%B5%81%E4%B8%8A%E6%90%9C%E7%B4%A2"><span class="toc-number">15.3.1.4.</span> <span class="toc-text">在流上搜索</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E5%92%8C-rpc"><span class="toc-number">15.3.1.5.</span> <span class="toc-text">消息传递和 RPC</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%9A%84%E6%97%B6%E9%97%B4%E9%97%AE%E9%A2%98"><span class="toc-number">15.3.2.</span> <span class="toc-text">流的时间问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E6%97%B6%E9%97%B4%E4%B8%8E%E5%A4%84%E7%90%86%E6%97%B6%E9%97%B4"><span class="toc-number">15.3.2.1.</span> <span class="toc-text">事件时间与处理时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%86%E8%A7%A3%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%87%86%E5%A4%87%E5%B0%B1%E7%BB%AA"><span class="toc-number">15.3.2.2.</span> <span class="toc-text">了解什么时候准备就绪</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E7%94%A8%E8%B0%81%E7%9A%84%E6%97%B6%E9%92%9F%EF%BC%9F"><span class="toc-number">15.3.2.3.</span> <span class="toc-text">你用谁的时钟？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">15.3.2.4.</span> <span class="toc-text">窗口的类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E5%BC%8F-join"><span class="toc-number">15.4.</span> <span class="toc-text">流式 join</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E5%92%8C%E6%B5%81-join-%E7%AA%97%E5%8F%A3-join"><span class="toc-number">15.4.1.</span> <span class="toc-text">流和流 join（窗口 join）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E5%92%8C%E8%A1%A8-join"><span class="toc-number">15.4.2.</span> <span class="toc-text">流和表 join</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E8%A1%A8-join-%E5%AE%9E%E4%BD%93%E5%8C%96%E8%A7%86%E5%9B%BE%E7%BB%B4%E6%8A%A4"><span class="toc-number">15.4.3.</span> <span class="toc-text">表表 join（实体化视图维护）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#join-%E7%9A%84%E6%97%B6%E9%97%B4%E4%BE%9D%E8%B5%96%E6%80%A7"><span class="toc-number">15.4.4.</span> <span class="toc-text">join 的时间依赖性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E5%A4%84%E7%90%86%E7%9A%84%E5%AE%B9%E9%94%99"><span class="toc-number">15.5.</span> <span class="toc-text">流处理的容错</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E6%89%B9%E5%A4%84%E7%90%86%E5%92%8C%E6%A0%A1%E9%AA%8C%E7%82%B9"><span class="toc-number">15.5.1.</span> <span class="toc-text">微批处理和校验点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E6%96%B0%E5%AE%A1%E8%A7%86%E5%8E%9F%E5%AD%90%E6%8F%90%E4%BA%A4"><span class="toc-number">15.5.2.</span> <span class="toc-text">重新审视原子提交</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%82%E7%AD%89%E6%80%A7"><span class="toc-number">15.5.2.1.</span> <span class="toc-text">幂等性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%85%E9%9A%9C%E5%90%8E%E9%87%8D%E5%BB%BA%E7%8A%B6%E6%80%81"><span class="toc-number">15.5.2.2.</span> <span class="toc-text">故障后重建状态</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">15.6.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">16.</span> <span class="toc-text">数据系统的未来</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%9B%86%E6%88%90"><span class="toc-number">16.1.</span> <span class="toc-text">数据集成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%87%E7%94%A8%E6%B4%BE%E7%94%9F%E6%95%B0%E6%8D%AE%E6%9D%A5%E7%BB%84%E5%90%88%E5%B7%A5%E5%85%B7"><span class="toc-number">16.1.1.</span> <span class="toc-text">采用派生数据来组合工具</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BD%95%E9%9C%80%E8%A6%81%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-number">16.1.1.1.</span> <span class="toc-text">为何需要数据流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B4%BE%E7%94%9F%E6%95%B0%E6%8D%AE%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">16.1.1.2.</span> <span class="toc-text">派生数据与分布式事务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%BA%8F%E7%9A%84%E5%B1%80%E9%99%90"><span class="toc-number">16.1.1.3.</span> <span class="toc-text">全序的局限</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E4%BA%8B%E4%BB%B6%E4%BB%A5%E6%8D%95%E8%8E%B7%E5%9B%A0%E6%9E%9C%E5%85%B3%E7%B3%BB"><span class="toc-number">16.1.1.4.</span> <span class="toc-text">排序事件以捕获因果关系</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%B9%E5%A4%84%E7%90%86%E4%B8%8E%E6%B5%81%E5%A4%84%E7%90%86%E9%9B%86%E6%88%90"><span class="toc-number">16.2.</span> <span class="toc-text">批处理与流处理集成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%B4%E6%8A%A4%E6%B4%BE%E7%94%9F%E7%8A%B6%E6%80%81"><span class="toc-number">16.2.1.</span> <span class="toc-text">维护派生状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%BC%94%E5%8C%96%E8%80%8C%E9%87%8D%E6%96%B0%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE"><span class="toc-number">16.2.2.</span> <span class="toc-text">为应用程序演化而重新处理数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lambda%E6%9E%B6%E6%9E%84"><span class="toc-number">16.2.3.</span> <span class="toc-text">Lambda架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9F%E4%B8%80%E6%89%B9%E5%A4%84%E7%90%86%E5%92%8C%E6%B5%81%E5%A4%84%E7%90%86"><span class="toc-number">16.2.4.</span> <span class="toc-text">统一批处理和流处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%8B%86%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">16.3.</span> <span class="toc-text">分拆数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF"><span class="toc-number">16.3.1.</span> <span class="toc-text">组合使用数据存储技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%B4%A2%E5%BC%95"><span class="toc-number">16.3.1.1.</span> <span class="toc-text">创建一个索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%83%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">16.3.1.2.</span> <span class="toc-text">元数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E7%A6%BB%E5%BC%8F%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C"><span class="toc-number">16.3.1.2.1.</span> <span class="toc-text">分离式如何工作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E7%A6%BB%E5%BC%8F%E4%B8%8E%E9%9B%86%E6%88%90%E5%BC%8F%E7%B3%BB%E7%BB%9F"><span class="toc-number">16.3.1.2.2.</span> <span class="toc-text">分离式与集成式系统</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%81%97%E6%BC%8F%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number">16.3.1.2.3.</span> <span class="toc-text">遗漏了什么</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%B4%E7%BB%95%E6%95%B0%E6%8D%AE%E6%B5%81%E8%AE%BE%E8%AE%A1%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F"><span class="toc-number">16.3.2.</span> <span class="toc-text">围绕数据流设计应用系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%BB%A3%E7%A0%81%E4%BD%9C%E4%B8%BA%E6%B4%BE%E7%94%9F%E5%87%BD%E6%95%B0"><span class="toc-number">16.3.2.1.</span> <span class="toc-text">应用程序代码作为派生函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%BB%A3%E7%A0%81%E4%B8%8E%E7%8A%B6%E6%80%81%E5%88%86%E7%A6%BB"><span class="toc-number">16.3.2.2.</span> <span class="toc-text">应用程序代码与状态分离</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81%EF%BC%9A%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96%E5%92%8C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%BB%A3%E7%A0%81%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%B8%E4%BA%92%E5%BD%B1%E5%93%8D"><span class="toc-number">16.3.2.3.</span> <span class="toc-text">数据流：状态变化和应用程序代码之间的相互影响</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E5%BC%8F%E5%A4%84%E7%90%86%E4%B8%8E%E6%9C%8D%E5%8A%A1"><span class="toc-number">16.3.2.4.</span> <span class="toc-text">流式处理与服务</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E6%B4%BE%E7%94%9F%E7%8A%B6%E6%80%81"><span class="toc-number">16.3.3.</span> <span class="toc-text">观察派生状态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BD%93%E5%8C%96%E8%A7%86%E5%9B%BE%E5%92%8C%E7%BC%93%E5%AD%98"><span class="toc-number">16.3.3.1.</span> <span class="toc-text">实体化视图和缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E7%8A%B6%E6%80%81-%E5%8F%AF%E7%A6%BB%E7%BA%BF%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">16.3.3.2.</span> <span class="toc-text">有状态，可离线客户端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86%E7%8A%B6%E6%80%81%E5%8F%98%E6%9B%B4%E6%8E%A8%E9%80%81%E7%BB%99%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">16.3.3.3.</span> <span class="toc-text">将状态变更推送给客户端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AB%AF%E5%88%B0%E7%AB%AF%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%B5%81"><span class="toc-number">16.3.3.4.</span> <span class="toc-text">端到端的事件流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E4%B9%9F%E6%98%AF%E4%BA%8B%E4%BB%B6"><span class="toc-number">16.3.3.5.</span> <span class="toc-text">读也是事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E5%88%86%E5%8C%BA%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86"><span class="toc-number">16.3.3.6.</span> <span class="toc-text">多分区数据处理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AB%AF%E5%88%B0%E7%AB%AF%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%80%A7-%E5%B0%86%E4%BA%8B%E6%83%85%E5%81%9A%E6%AD%A3%E7%A1%AE"><span class="toc-number">16.4.</span> <span class="toc-text">端到端的正确性（将事情做正确）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%AB%AF%E5%88%B0%E7%AB%AF%E4%BA%89%E8%AE%BA"><span class="toc-number">16.4.1.</span> <span class="toc-text">数据库的端到端争论</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#exactly-once-%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C"><span class="toc-number">16.4.1.1.</span> <span class="toc-text">exactly-once 执行操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%A4%8D%E6%B6%88%E9%99%A4"><span class="toc-number">16.4.1.2.</span> <span class="toc-text">重复消除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-number">16.4.1.3.</span> <span class="toc-text">操作标识符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AB%AF%E5%88%B0%E7%AB%AF%E7%9A%84%E4%BA%89%E8%AE%BA"><span class="toc-number">16.4.1.4.</span> <span class="toc-text">端到端的争论</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E4%B8%AD%E9%87%87%E7%94%A8%E7%AB%AF%E5%88%B0%E7%AB%AF%E7%9A%84%E6%80%9D%E8%B7%AF"><span class="toc-number">16.4.1.5.</span> <span class="toc-text">在数据系统中采用端到端的思路</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E7%BA%A6%E6%9D%9F"><span class="toc-number">16.4.2.</span> <span class="toc-text">强制约束</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%94%AF%E4%B8%80%E6%80%A7%E7%BA%A6%E6%9D%9F%E9%9C%80%E8%A6%81%E8%BE%BE%E6%88%90%E5%85%B1%E8%AF%86"><span class="toc-number">16.4.2.1.</span> <span class="toc-text">唯一性约束需要达成共识</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%97%A5%E5%BF%97%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E4%B8%AD%E7%9A%84%E5%94%AF%E4%B8%80%E6%80%A7"><span class="toc-number">16.4.2.2.</span> <span class="toc-text">基于日志消息传递中的唯一性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E5%88%86%E5%8C%BA%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86"><span class="toc-number">16.4.2.3.</span> <span class="toc-text">多分区请求处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E6%95%88%E6%80%A7%E4%B8%8E%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="toc-number">16.4.3.</span> <span class="toc-text">时效性与完整性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8A%E6%97%B6%E6%80%A7%E4%B8%8E%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="toc-number">16.4.3.1.</span> <span class="toc-text">及时性与完整性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%80%A7%EF%BC%9A"><span class="toc-number">16.4.3.2.</span> <span class="toc-text">数据流系统的正确性：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%BD%E6%9D%BE%E5%9C%B0%E8%A7%A3%E9%87%8A%E7%BA%A6%E6%9D%9F"><span class="toc-number">16.4.3.3.</span> <span class="toc-text">宽松地解释约束</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E5%8D%8F%E8%B0%83%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F"><span class="toc-number">16.4.3.4.</span> <span class="toc-text">无协调数据系统</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E4%BB%BB-%E4%BD%86%E8%A6%81%E7%A1%AE%E8%AE%A4"><span class="toc-number">16.4.4.</span> <span class="toc-text">信任，但要确认</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E7%BC%BA%E9%99%B7%E6%97%B6%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="toc-number">16.4.4.1.</span> <span class="toc-text">软件缺陷时的完整性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E8%A6%81%E7%9B%B2%E7%9B%AE%E4%BF%A1%E4%BB%BB%E6%89%BF%E8%AF%BA"><span class="toc-number">16.4.4.2.</span> <span class="toc-text">不要盲目信任承诺</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E7%9A%84%E6%96%87%E5%8C%96"><span class="toc-number">16.4.4.3.</span> <span class="toc-text">验证的文化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E5%AE%A1%E8%AE%A1%E6%80%A7%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">16.4.4.4.</span> <span class="toc-text">可审计性的设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AB%AF%E5%88%B0%E7%AB%AF%E8%AE%BA%E7%82%B9%E7%9A%84%E5%86%8D%E8%AE%A8%E8%AE%BA"><span class="toc-number">16.4.4.5.</span> <span class="toc-text">端到端论点的再讨论</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E4%BA%8E%E5%8F%AF%E5%AE%A1%E8%AE%A1%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B7%A5%E5%85%B7"><span class="toc-number">16.4.4.6.</span> <span class="toc-text">用于可审计数据系统的工具</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%81%9A%E6%AD%A3%E7%A1%AE%E7%9A%84%E4%BA%8B%E6%83%85"><span class="toc-number">16.5.</span> <span class="toc-text">做正确的事情</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">16.6.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2017 - 2025 By magicliang</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional and Simplified Chinese">簡</button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>