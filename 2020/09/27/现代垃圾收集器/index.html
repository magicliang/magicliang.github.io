<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>现代垃圾收集器 | 守株阁</title><meta name="author" content="magicliang"><meta name="copyright" content="magicliang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="所有的垃圾收集器，都基于弱分代假设。实际的垃圾回收效率取决于堆内对象的分布状况。垃圾回收并不能解决内存泄漏或者应用程序逻辑的不良分配习惯问题，要处理 JVM 内存回收问题的根本方法是对程序进行调优。 有几个常用原则：  减少临时对象，尽量复用内存。 使用对象池。 主动提前释放对象。 主动 gc。 好的代码比 tuning 更重要。 选 gc 算法比 tuning 参数重要，tuning 参数是最后">
<meta property="og:type" content="article">
<meta property="og:title" content="现代垃圾收集器">
<meta property="og:url" content="https://magicliang.github.io/2020/09/27/%E7%8E%B0%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/index.html">
<meta property="og:site_name" content="守株阁">
<meta property="og:description" content="所有的垃圾收集器，都基于弱分代假设。实际的垃圾回收效率取决于堆内对象的分布状况。垃圾回收并不能解决内存泄漏或者应用程序逻辑的不良分配习惯问题，要处理 JVM 内存回收问题的根本方法是对程序进行调优。 有几个常用原则：  减少临时对象，尽量复用内存。 使用对象池。 主动提前释放对象。 主动 gc。 好的代码比 tuning 更重要。 选 gc 算法比 tuning 参数重要，tuning 参数是最后">
<meta property="og:locale">
<meta property="og:image" content="https://magicliang.github.io/2020/09/27/%E7%8E%B0%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/%E6%94%B6%E9%9B%86%E5%99%A8%E5%88%86%E7%B1%BB.jpeg">
<meta property="article:published_time" content="2020-09-27T08:12:22.000Z">
<meta property="article:modified_time" content="2026-01-24T07:32:07.042Z">
<meta property="article:author" content="magicliang">
<meta property="article:tag" content="JVM">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://magicliang.github.io/2020/09/27/%E7%8E%B0%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/%E6%94%B6%E9%9B%86%E5%99%A8%E5%88%86%E7%B1%BB.jpeg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "现代垃圾收集器",
  "url": "https://magicliang.github.io/2020/09/27/%E7%8E%B0%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/",
  "image": "https://magicliang.github.io/2020/09/27/%E7%8E%B0%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/%E6%94%B6%E9%9B%86%E5%99%A8%E5%88%86%E7%B1%BB.jpeg",
  "datePublished": "2020-09-27T08:12:22.000Z",
  "dateModified": "2026-01-24T07:32:07.042Z",
  "author": [
    {
      "@type": "Person",
      "name": "magicliang",
      "url": "https://magicliang.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://magicliang.github.io/2020/09/27/%E7%8E%B0%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: magicliang","link":"Link: ","source":"Source: 守株阁","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '现代垃圾收集器',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"><link rel="alternate" href="/atom.xml" title="守株阁" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      if ($loadingBox.classList.contains('loaded')) return
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()

  if (document.readyState === 'complete') {
    preloader.endLoading()
  } else {
    window.addEventListener('load', preloader.endLoading)
    document.addEventListener('DOMContentLoaded', preloader.endLoading)
    // Add timeout protection: force end after 7 seconds
    setTimeout(preloader.endLoading, 7000)
  }

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/2020/09/27/%E7%8E%B0%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/%E6%94%B6%E9%9B%86%E5%99%A8%E5%88%86%E7%B1%BB.jpeg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">守株阁</span></a><a class="nav-page-title" href="/"><span class="site-name">现代垃圾收集器</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">现代垃圾收集器</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2020-09-27T08:12:22.000Z" title="Created 2020-09-27 16:12:22">2020-09-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2026-01-24T07:32:07.042Z" title="Updated 2026-01-24 15:32:07">2026-01-24</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">12.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>41mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>所有的垃圾收集器，都基于<a target="_blank" rel="noopener" href="https://www.ps.uni-saarland.de/courses/gc-ws01/slides/generational_gc.pdf">弱分代假设</a>。实际的垃圾回收效率取决于堆内对象的分布状况。垃圾回收并不能解决内存泄漏或者应用程序逻辑的不良分配习惯问题，要处理 JVM 内存回收问题的根本方法是对程序进行调优。</p>
<p>有几个常用原则：</p>
<ul>
<li>减少临时对象，尽量复用内存。</li>
<li>使用对象池。</li>
<li>主动提前释放对象。</li>
<li>主动 gc。</li>
<li>好的代码比 tuning 更重要。</li>
<li>选 gc 算法比 tuning 参数重要，tuning 参数是最后一步。</li>
</ul>
<p>其他情况，可以通过 tuning garbage collector 来解决。</p>
<h1>操作系统的影响</h1>
<ul>
<li>SWAP 可能会显著增加 GC 时间，因为被换出的堆还要被换入。</li>
</ul>
<h1>美团的实践</h1>
<p>参考：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/2017/12/29/jvm-optimize.html">《从实际案例聊聊Java应用的GC优化》</a></li>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/2020/11/12/java-9-cms-gc.html">《Java中9种常见的CMS GC问题分析与解决》</a></li>
</ol>
<ul>
<li>Minor GC</li>
<li>Major GC</li>
<li>Full GC</li>
</ul>
<h2 id="垃圾收集器分类">垃圾收集器分类</h2>
<p><img src="%E6%94%B6%E9%9B%86%E5%99%A8%E5%88%86%E7%B1%BB.jpeg" alt="收集器分类"></p>
<p><img src="%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8benchmark.jpeg" alt="垃圾收集器benchmark"><br>
<img src="microbenchmark.png" alt="microbenchmark"></p>
<p>可以看到一个现象：在大部分时候，g1 比 CMS 快，但极端的百分位里，CMS 比 g1 快。</p>
<p>出处见<a target="_blank" rel="noopener" href="https://rodrigo-bruno.github.io/mentoring/77998-Carlos-Goncalves_dissertacao.pdf">这里</a>。</p>
<h2 id="常用工具">常用工具</h2>
<h3 id="命令行终端">命令行终端</h3>
<blockquote>
<ul>
<li>标准终端类：jps、jinfo、jstat、jstack、jmap</li>
<li>功能整合类：jcmd、vjtools、arthas、greys</li>
</ul>
</blockquote>
<h3 id="可视化界面">可视化界面</h3>
<blockquote>
<ul>
<li>简易：JConsole、JVisualvm、HA、GCHisto、GCViewer</li>
<li>进阶：MAT、JProfiler</li>
</ul>
<p>命令行推荐 arthas ，可视化界面推荐 JProfiler，此外还有一些在线的平台 gceasy、heaphero、fastthread<br>
，美团内部的 Scalpel（一款自研的 JVM 问题诊断工具，暂时未开源）也比较好用。</p>
</blockquote>
<h2 id="指标评价标准">指标评价标准</h2>
<p>评判 GC 的两个核心指标：</p>
<ul>
<li>
<p>延迟（Latency）： 也可以理解为最大停顿时间，即垃圾收集过程中一次 STW 的最长时间，越短越好，一定程度上可以接受频次的增大，GC 技术的主要发展方向。</p>
</li>
<li>
<p>吞吐量（Throughput）： 应用系统的生命周期内，由于 GC 线程会占用 Mutator 当前可用的 CPU 时钟周期，吞吐量即为 Mutator 有效花费的时间占系统总运行时间的百分比，例如系统运行了 100 min，GC 耗时 1 min，则系统吞吐量为 99%，吞吐量优先的收集器可以接受较长的停顿。</p>
</li>
</ul>
<p><img src="%E4%B8%A4%E7%A7%8D%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87%E5%85%AC%E5%BC%8F.jpeg" alt="两种评价指标公式"></p>
<blockquote>
<p>简而言之，即为一次停顿的时间不超过应用服务的 TP9999，GC 的吞吐量不小于 99.99%。举个例子，假设某个服务 A 的 TP9999<br>
为 80 ms，平均 GC 停顿为 30 ms，那么该服务的最大停顿时间最好不要超过 80 ms，GC 频次控制在 5 min<br>
以上一次。如果满足不了，那就需要调优或者通过更多资源来进行并联冗余。（大家可以先停下来，看看监控平台上面的 gc.meantime<br>
分钟级别指标，如果超过了 6 ms 那单机 GC 吞吐量就达不到 4 个 9 了。）</p>
</blockquote>
<h2 id="gc-动作耗时">gc 动作耗时</h2>
<p>比较容易被忽略的是：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">compaction &gt;= copying &gt; mark &gt; <span class="hljs-keyword">sweep</span><br><span class="hljs-keyword"></span>mark + <span class="hljs-keyword">sweep </span>&gt; copying<br></code></pre></td></tr></table></figure>
<p>所以年轻代的扫描如果大头是 copying 就会非常快。</p>
<h2 id="mutator-类型">Mutator 类型</h2>
<blockquote>
<p>Mutator 的类型根据对象存活时间比例图来看主要分为两种，在弱分代假说中也提到类似的说法，如下图所示 “Survival Time”<br>
表示对象存活时间，“Rate” 表示对象分配比例：</p>
<ul>
<li>
<p>IO 交互型： 互联网上目前大部分的服务都属于该类型，例如分布式 RPC、MQ、HTTP 网关服务等，对内存要求并不大，大部分对象在 TP9999 的时间内都会死亡， Young 区越大越好。</p>
</li>
<li>
<p>MEM 计算型： 主要是分布式数据计算 Hadoop，分布式存储 HBase、Cassandra，自建的分布式缓存等，对内存要求高，对象存活时间长，Old 区越大越好。</p>
</li>
</ul>
</blockquote>
<p>值得注意的是，中间件都是 IO 密集型应用，只要调大 young 区就可以解决问题，大部分的 young 区的收集器效果差异不大，Hadoop之类的业务反而需要 CMS/G1的调优。</p>
<h2 id="已提交的内存">已提交的内存</h2>
<p><img src="jvm%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9%E4%B8%8Ecommitted.jpeg" alt="jvm动态扩容与committed"></p>
<p>注意看，已使用内存对 JVM而言就是 committed memory。The committed memory is a sum of all of the memory which has been allocated by processes, even if it has not been “used” by them as of yet.</p>
<p>我们可以把动态扩容引起的空间震荡称作 thrash caused by heap expansion。</p>
<h2 id="关于-xx-disableexplicitgc的争论">关于<code>-XX:+DisableExplicitGC</code>的争论</h2>
<blockquote>
<p>此处补充一个知识点，CMS GC 共分为 Background 和 Foreground<br>
两种模式，前者就是我们常规理解中的并发收集，可以不影响正常的业务线程运行，但 Foreground Collector<br>
却有很大的差异，他会进行一次压缩式 GC。此压缩式 GC 使用的是跟 Serial Old GC 一样的 Lisp2 算法，其使用<br>
Mark-Compact 来做 Full GC，一般称之为 MSC（Mark-Sweep-Compact），它收集的范围是 Java 堆的<br>
Young 区和 Old 区以及 MetaSpace。由上面的算法章节中我们知道 compact 的代价是巨大的，那么使用<br>
Foreground Collector 时将会带来非常长的 STW。如果在应用程序中 System.gc 被频繁调用，那就非常危险了。</p>
</blockquote>
<p>这里提到的 Foreground 可以被<code>System.gc</code>显式触发<code>MSC（Mark-Sweep-Compact）</code>导致。</p>
<p>但值得注意的是：</p>
<blockquote>
<p>目前互联网中的 RPC 通信会大量使用 NIO</p>
</blockquote>
<p>这也就意味着堆外内存的收集有时候是必须的-因为 NIO内部自己触发垃圾收集也需要引用 <code>System.gc</code> 的能力。不过要配合<code>XX:+ExplicitGCInvokesConcurrent</code>、<code>-Dsun.rmi.dgc.client.gcInterval</code>、<code>-Dsun.rmi.dgc.server.gcInterval</code>一起使用。</p>
<p>值得关注的资料有：</p>
<ol>
<li><a target="_blank" rel="noopener" href="http://lovestblog.cn/blog/2015/05/12/direct-buffer/">《JVM源码分析之堆外内存完全解读》</a></li>
</ol>
<h2 id="如何追踪新-load-class">如何追踪新 load class</h2>
<p><code>jcmd &lt;PID&gt; GC.class_stats|awk '{print$13}'|sed  's/\(.*\)\.\(.*\)/\1/g'|sort |uniq -c|sort -nrk1</code></p>
<p>如果有必要，使用<code>-XX:+TraceClassLoading</code>和<code>-XX:+TraceClassUnLoading</code></p>
<h2 id="过早晋升">过早晋升</h2>
<p>一个容易被忽略的过早晋升的原因是，<strong>分配速率接近于晋升速率，对象晋升年龄较小</strong>。通常产生这个问题的根因是 young 区过小。如果一次 Major GC 后 tenured 或者 humongous 的区域大规模减少，则其实老年代里的对象大部分都是过早晋升的对象。<br>
注意：MaxTenuringThreshold 最大值为 15（因为 JVM 中使用 4 个比特来表示对象的年龄）。</p>
<h2 id="分析内存泄漏的基本思路">分析内存泄漏的基本思路</h2>
<p><img src="%E5%88%86%E6%9E%90%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E6%80%9D%E8%B7%AF.jpeg" alt="分析内存泄漏的思路"></p>
<p>两次 dump，diff 顽固分子。不过捕捉 gc 前后的堆非常困难。</p>
<p>频繁 Major GC 或者 Major GC 时间过长，通常指向程序内存泄漏或者空间过小-程序内存泄漏触发的频繁 ygc 可能会让它提前晋升了。</p>
<h2 id="cms-退化">CMS 退化</h2>
<p>MSC 的出现就意味着真正意义上的 Full GC 出现了，这种时候我们的要调优 CMS 的执行频率，让高水位的 GC 问题通过 GC 前置来解决。</p>
<h2 id="堆外内存泄漏">堆外内存泄漏</h2>
<blockquote>
<p>内存使用率不断上升，甚至开始使用 SWAP 内存，同时可能出现 GC 时间飙升，线程被 Block 等现象，通过 top 命令发现 Java<br>
进程的 RES 甚至超过了 -Xmx 的大小。出现这些现象时，基本可以确定是出现了堆外内存泄漏。</p>
</blockquote>
<p>也就是说堆外内存的数据除了 NMT 来确定，也可以通过 RES 来确定。</p>
<blockquote>
<p>首先，我们需要确定是哪种原因导致的堆外内存泄漏。这里可以使用 NMT（NativeMemoryTracking） 进行分析。在项目中添加<br>
-XX:NativeMemoryTracking=detail JVM参数后重启项目（需要注意的是，打开 NMT 会带来 5%~10% 的性能损耗）。使用命令 jcmd pid VM.native_memory detail 查看内存分布。重点观察 total 中的<br>
committed，因为 jcmd 命令显示的内存包含堆内内存、Code 区域、通过 Unsafe.allocateMemory 和<br>
DirectByteBuffer 申请的内存，但是不包含其他 Native Code（C 代码）申请的堆外内存。</p>
<p>如果 total 中的 committed 和 top 中的 RES<br>
相差不大，则应为主动申请的堆外内存未释放造成的，如果相差较大，则基本可以确定是 JNI 调用造成的。</p>
</blockquote>
<p>整体而言，堆外内存的分布是不透明的，目前没有工具可以简单地告诉我们全部的堆外内存的分布情况，只能间接推算出问题的根因，转而去代码里寻找原因。</p>
<p><img src="%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8Fsop.png" alt="堆外内存泄漏sop"></p>
<h2 id="gclocker-initiated-gc">GCLocker Initiated GC</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">2020-09-23T16:49:09.812+0800: 504426.827: [Full GC (GCLocker Initiated GC) 504426.827: [CMS: 1341583K-&gt;419699K(2097152K), 1.8482275 secs] 1347626K-&gt;419699K(3984640K), [Metaspace: 297780K-&gt;297780K(1329152K)], 1.8490564 secs] [Times: user=1.62 sys=0.20, real=1.85 secs]<br></code></pre></td></tr></table></figure>
<blockquote>
<p>由于 Native 代码直接使用了 JVM 堆区的指针，如果这时发生 GC，就会导致数据错误。因此，在发生此类 JNI 调用时，禁止 GC<br>
的发生，同时阻止其他线程进入 JNI 临界区，直到最后一个线程退出临界区时触发一次 GC。</p>
</blockquote>
<blockquote>
<p>添加 -XX+PrintJNIGCStalls 参数，可以打印出发生 JNI 调用时的线程，进一步分析，找到引发问题的 JNI 调用。</p>
</blockquote>
<p>GC 调优的三大思路（解决这些问题的 ROI 从高到低）：</p>
<ol>
<li>代码问题</li>
<li>区域配置问题</li>
<li>垃圾回收行为问题</li>
</ol>
<h2 id="根因鱼骨图">根因鱼骨图</h2>
<p><img src="%E6%A0%B9%E5%9B%A0%E9%B1%BC%E9%AA%A8%E5%9B%BE.png" alt="根因鱼骨图"></p>
<h2 id="其他建议">其他建议</h2>
<blockquote>
<ul>
<li>主动式 GC： 也有另开生面的做法，通过监控手段监控观测 Old 区的使用情况，即将到达阈值时将应用服务摘掉流量，手动触发一次 Major GC，减少 CMS GC 带来的停顿，但随之系统的健壮性也会减少，如非必要不建议引入。</li>
<li>禁用偏向锁： 偏向锁在只有一个线程使用到该锁的时候效率很高，但是在竞争激烈情况会升级成轻量级锁，此时就需要先消除偏向锁，这个过程是 STW 的。如果每个同步资源都走这个升级过程，开销会非常大，所以在已知并发激烈的前提下，一般会禁用偏向锁<br>
-XX:-UseBiasedLocking 来提高性能。</li>
<li>虚拟内存： 启动初期有些操作系统（例如 Linux）并没有真正分配物理内存给 JVM ，而是在虚拟内存中分配，使用的时候才会在物理内存中分配内存页，这样也会导致 GC 时间较长。这种情况可以添加<br>
-XX:+AlwaysPreTouch 参数，让 VM 在 commit 内存时跑个循环来强制保证申请的内存真的 commit，避免运行时触发缺页异常。在一些大内存的场景下，有时候能将前几次的 GC<br>
时间降一个数量级，但是添加这个参数后，启动的过程可能会变慢。</li>
</ul>
</blockquote>
<p>所以 AlwaysPreTouch 会让 reserved 内存变成 committed内存。这个参数在超卖内存的 docker 容器里会导致进程死亡，只要申请足够大的容器就能避免这个问题-比如不要给 4g 的容器使用 4g 的 heap。</p>
<h2 id="jvm-启动参数">JVM 启动参数</h2>
<table>
<thead>
<tr>
<th style="text-align:center">分类</th>
<th style="text-align:center">参数</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">基本参数</td>
<td style="text-align:center">-XX:+PrintGCDetails、-XX:+PrintGCDateStamps、-XX:+PrintGCTimeStamps</td>
<td style="text-align:center">GC 日志的基本参数</td>
</tr>
<tr>
<td style="text-align:center">时间相关</td>
<td style="text-align:center">-XX:+PrintGCApplicationConcurrentTime、-XX:+PrintGCApplicationStoppedTime</td>
<td style="text-align:center">详细步骤的并行时间，STW 时间等等</td>
</tr>
<tr>
<td style="text-align:center">年龄相关</td>
<td style="text-align:center">-XX:+PrintTenuringDistribution</td>
<td style="text-align:center">可以观察 GC 前后的对象年龄分布，方便发现过早晋升问题</td>
</tr>
<tr>
<td style="text-align:center">引用相关</td>
<td style="text-align:center">-XX:+PrintReferenceGC</td>
<td style="text-align:center">观察系统的软引用，弱引用，虚引用等回收情况</td>
</tr>
<tr>
<td style="text-align:center">空间变化</td>
<td style="text-align:center">-XX:+PrintHeapAtGC</td>
<td style="text-align:center">各个空间在 GC 前后的回收情况，非常详细</td>
</tr>
</tbody>
</table>
<p>这些参数在 CMS 开始的垃圾收集器都可以广泛采用。</p>
<p>printAssembly 之类的 option 要慎用，没有装插件会导致 JVM 启动失败。</p>
<h2 id="老的配比公式">老的配比公式</h2>
<table>
<thead>
<tr>
<th style="text-align:center">空间</th>
<th style="text-align:center">倍数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">总大小</td>
<td style="text-align:center">3-4 倍活跃数据的大小</td>
</tr>
<tr>
<td style="text-align:center">新生代</td>
<td style="text-align:center">1-1.5 活跃数据的大小</td>
</tr>
<tr>
<td style="text-align:center">老年代</td>
<td style="text-align:center">2-3 倍活跃数据的大小</td>
</tr>
<tr>
<td style="text-align:center">永久代</td>
<td style="text-align:center">1.2-1.5 倍Full GC后的永久代空间占用</td>
</tr>
</tbody>
</table>
<p>例如，根据GC日志获得老年代的活跃数据大小为300M，那么各分区大小可以设为：<br>
先计算新生代的大小，再反推其他堆的大小。</p>
<blockquote>
<p>总堆：1200MB = 300MB × 4* 新生代：450MB = 300MB × 1.5* 老年代： 750MB = 1200MB - 450MB*</p>
</blockquote>
<h2 id="gc-对业务的影响">GC 对业务的影响</h2>
<blockquote>
<p>明确应用程序的系统需求是性能优化的基础，系统的需求是指应用程序运行时某方面的要求，譬如：</p>
<ul>
<li>高可用，可用性达到几个9。</li>
<li>低延迟，请求必须多少毫秒内完成响应。</li>
<li>高吞吐，每秒完成多少次事务。</li>
</ul>
<p>明确系统需求之所以重要，是因为上述性能指标间可能冲突。比如通常情况下，缩小延迟的代价是<strong>降低吞吐量或者消耗更多的内存或者两者同时发生</strong>。</p>
</blockquote>
<p>延迟和吞吐量和内存占用中存在一个不可能三角形。</p>
<blockquote>
<p>举例：假设单位时间T内发生一次持续25ms的GC，接口平均响应时间为50ms，且请求均匀到达，根据下图所示：</p>
</blockquote>
<p><img src="gc-%E6%97%B6%E9%97%B4%E7%BA%BF.png" alt="gc-时间线"></p>
<blockquote>
<p>那么有(50ms+25ms)/T比例的请求会受GC影响，其中GC前的50ms内到达的请求都会增加25ms，GC期间的25ms内到达的请求，会增加0-25ms不等，如果时间T内发生N次GC，<strong>受GC影响请求占比=(接口响应时间+GC时间)×N/T</strong><br>
。可见无论降低单次GC时间还是降低GC次数N都可以有效减少GC对响应时间的影响。</p>
</blockquote>
<p>为什么接口响应时间内的请求受影响呢，因为 50ms 的请求都没有走完自己的生命周期，就被停顿。</p>
<h2 id="案例">案例</h2>
<h3 id="案例1">案例1</h3>
<blockquote>
<p>Minor GC每分钟100次 ，Major GC每4分钟一次，单次Minor GC耗时25ms，单次Major<br>
GC耗时200ms，接口响应时间50ms。</p>
<p>（50ms+25ms）× 100次/60000ms = 12.5%，50ms × 100次/60000ms = 8.3% 。</p>
</blockquote>
<p>按照通常的观点，每分钟 100 次 Minor GC 是很频繁的，这也意味着 Eden 区过小。</p>
<blockquote>
<p>更重要的是对于虚拟机来说，复制对象的成本要远高于扫描成本</p>
</blockquote>
<p>这句话存疑，从现代的 gc 日志来看，单纯 scan 的时间非常久，copy 的时间非常短。</p>
<p>这个案例的意思是：</p>
<p>如果新生代临时对象非常多，而新生代非常小，则对象晋升非常快，既会导致频繁的 Minor GC，也会导致频繁的 Major GC。所以足够大的 young 区会总体降低 gc 的频次，而不会显著提升单次 Minor GC 的时间。</p>
<h3 id="案例2">案例2</h3>
<p>cms 的 remark <strong>不能只扫描老年代，只能全堆扫描（新生代+老年代）</strong>。由此可见堆中对象的数目影响了Remark阶段耗时。<br>
remark 的时间久意味着新生代的使用率比较高（反过来也一样），而触发了较多的跨代引用（注意，remark 是 MajorGC cms 的一个阶段<br>
）。remark 存在的意义就是正确地校正浮动垃圾的影响。这种类似活锁的问题在两类线程并发时是难以彻底解决的。</p>
<blockquote>
<p>降低Remark阶段耗时问题转换成如何减少新生代对象数量。</p>
</blockquote>
<blockquote>
<p>新生代GC和老年代的GC是各自分开独立进行的，只有 Minor GC 时才会使用根搜索算法</p>
</blockquote>
<p>这句话存疑，至少对 g1 而言，根搜索算法是不局限于年轻代的。</p>
<p>可以使用 CMSScavengeBeforeRemark 配合 CMSMaxAbortablePrecleanTime 参数，强制在 remark 之前进行 preclean（<strong>也就是一次隐藏的 Minor GC</strong>），可以减少 Remark 的耗时（<strong>这样可以减少跨代引用扫描的时间</strong>）。因为这个隐藏的 preclean存在，并发标记也并不一定是纯并发的。</p>
<p>新生代持有老年代多是正常的，老年代持有新生代的比例不足 1%，所以只要使用一个抽象的卡表来代表老年代的 dirty 情况，就可以用空间换时间，而避免 <strong>Minor GC</strong> 的问题。</p>
<h3 id="案例3">案例3</h3>
<blockquote>
<p>首先，什么时候可能会触发STW的Full GC呢？</p>
<ol>
<li>Perm空间不足；</li>
<li>CMS GC时出现promotion failed和concurrent mode failure（concurrent mode failure发生的原因一般是CMS正在进行，但是由于老年代空间不足，需要尽快回收老年代里面的不再被使用的对象，这时停止所有的线程，同时终止CMS，直接进行Serial<br>
Old GC）；</li>
<li>统计得到的Young GC晋升到老年代的平均大小大于老年代的剩余空间；</li>
<li>主动触发Full GC（执行jmap -histo:live [pid]）来避免碎片问题。</li>
</ol>
</blockquote>
<p>解决方法：</p>
<ol>
<li>Perm 区不要扩容，一开始就锁定资源。</li>
<li>使用 CMSPermGenSweepingEnabled、CMSClassUnloadingEnabled-这要求有动态类可以被回收，如果大量的类不是可回收的动态类，那么方案 1 才有用。</li>
</ol>
<h3 id="案例4">案例4</h3>
<p>老年代gc后，老年代的内存迅速下降，这意味着老年代的对象应该也是一种 age = x的年轻代对象，只是因为年轻代过小或者年轻代动态晋升阈值的关系，晋升到了老年代。这时候提升年轻代的区域大小或者调整晋升阈值，可以减少 Major GC 的次数，不过这需要考虑 ygc 的时间是否可以被接受。</p>
<h3 id="案例-5">案例 5</h3>
<p>在 docker 容器里，存在内存超卖。在 old 区没有扩张到满时，即使设置了 8g 的堆内存，实际上的 top/free 里的 no cache mem% 也不高，但 old 区 used 上来以后，就会触发容器告警。</p>
<p>合理的做法有：</p>
<ol>
<li>给非堆内存流出差不多 3g 的容量。</li>
<li>提前触发 y/f gc。以保证老年代的空余空间不太大，总是用 gc 来降低内存水位来提高内存利用率。</li>
<li>采用 y 大 o 小的策略，倾向于 ygc 更多，但 ygc 的 stw 对整体的时延影响更大；或者 o 大 y 小，倾向于 CMS 来获得更小的停顿。但 CMS 一定会留有更多的水位，导致内存利用率更大。</li>
</ol>
<h1>CMS</h1>
<p>CMS 的垃圾收集器默认在新生代就使用 ParNew，ParNew 天然是个 STW 收集器。</p>
<p>ParNew 使用标记-复制算法。标记-复制算法可以分为三个阶段：</p>
<ul>
<li>标记阶段，即从GC Roots集合开始，标记活跃对象；</li>
<li>转移阶段，即把活跃对象复制到新的内存地址上；</li>
<li>重定位阶段，因为转移导致对象的地址发生了变化，在重定位阶段，所有指向对象旧地址的指针都要调整到对象新的地址上。</li>
</ul>
<p>CMS 是个并发收集器。其操作步骤包括：</p>
<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>再标记</li>
<li>并发收集</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/363">CMS 将在 Java 14 中被 removed 掉</a>。</p>
<p>ParallelGCThreads 可以和 ParNew，Parallel Scavenge 一起工作，却不能改变 CMS 的线程数。</p>
<p>Parallel Scavenge 与 G1都可以设置停顿时间目标（都是 MaxGCPauseMillis，不过 PS 是 young 区收集器，G1 是全区收集器，PS 有个 PS old，算是 parallel 化的 serial），CMS 却偏偏没有。</p>
<p>一个样例参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">-Xmx5500m -Xms5500m -Xmn3072m -server -XX:MetaspaceSize=256m -XX:MaxMetaspaceSize=256m  -XX:+CMSClassUnloadingEnabled -XX:+PrintGCDetails -Xloggc:./logs/gc-%p-%t.log -XX:+PrintGCDateStamps -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=./log/hprof/ -XX:ErrorFile=./log/hs_err_%p.log -XX:+UseConcMarkSweepGC -XX:+PrintSafepointStatistics -XX:PrintSafepointStatisticsCount=1 -XX:-OmitStackTraceInFastThrow -XX:+UseCMSCompactAtFullCollection -XX:-UseBiasedLocking -XX:-UseCounterDecay -XX:CMSInitiatingOccupancyFraction=70 -XX:+UseCMSInitiatingOccupancyOnly -XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses -XX:+ParallelRefProcEnabled -XX:+PrintGCApplicationStoppedTime -XX:+PrintGCApplicationConcurrentTime -XX:+CMSParallelRemarkEnabled -XX:+ScavengeBeforeFullGC -XX:CMSFullGCsBeforeCompaction=0 -XX:+CMSScavengeBeforeRemark -XX:+PrintCompilation<br></code></pre></td></tr></table></figure>
<p>cms 的回收日志的耗时是分开计算的：</p>
<p><img src="%E5%88%86%E5%BC%80%E8%AE%A1%E7%AE%97%E7%9A%84gc%E6%97%B6%E9%97%B4.jpg" alt="分开计算的gc时间"></p>
<h1>G1</h1>
<p>老的垃圾收集器总是面临几个问题：</p>
<ul>
<li>所有针对老年代的操作必须扫描整个老年代空间；</li>
<li>年轻代和老年代是独立的连续的内存块，必须先决定年轻代和老年代在虚拟地址空间的位置。</li>
</ul>
<p>G1是一种服务端应用使用的垃圾收集器，目标是用在多核、大内存的机器上，它在大多数情况下可以实现指定的GC暂停时间（因为它引入了更好的停顿预测模型），同时还能保持较高的吞吐量。</p>
<p>G1的缺点是：停顿预测模型还不够智能-即使使用了 pre-write barrier 和 post-write barrier。 并发标记的准确度不够高，所以需要重标记，甚至依然有 concurrent mode 失败的场景。</p>
<p>G1 在发生垃圾回收的前后，各种 region 的配比会变化，比如：Eden: 3072.0K(194.0M)-&gt;0.0B(201.0M) 显示垃圾回收后，有 7mb 的 region 增加给了 eden 区。如果不指定 region，则 G1 会根据实际可用的机器内存大小来决定 region，尽量达到 2048 region。</p>
<p>这种调整 young 区、tenure 区的行为会在 <strong>mixedgc</strong> 或者<strong>冷启动</strong>的时候发生得很剧烈，会造成一波 stw 的小高潮，这在有高峰时段的服务上小心谨慎。</p>
<p><a target="_blank" rel="noopener" href="https://hllvm-group.iteye.com/group/topic/44381#post-272188">早期关于 G1 性能和算法的经典讨论</a>。</p>
<blockquote>
<p>Garbage<br>
First（简称G1）收集器是垃圾收集器技术发展历史上的里程碑式的成果，它开创了收集器面向局部收集的设计思路和基于Region的内存布局形式。早在JDK<br>
7刚刚确立项目目标、Oracle公司制定的JDK 7 RoadMap里面，G1收集器就被视作JDK<br>
7中HotSpot虚拟机的一项重要进化特征。从JDK 6 Update 14开始就有Early<br>
Access版本的G1收集器供开发人员实验和试用，但由此开始G1收集器的“实验状态”（Experimental）持续了数年时间，直至JDK<br>
7 Update 4，Oracle才认为它 达到足够成熟的商用程度，移除了“Experimental”的标识；到了JDK 8 Update<br>
40的时候，G1提供并发的类卸载的支持，补全了其计划功能的最后一块拼图。这个版本以后的G1收集器才被Oracle官方称为“全功能的垃圾收集器”（Fully-Featured<br>
Garbage Collector）。</p>
</blockquote>
<p>JDK 8 Update 40 的发行日期是 2015-03-03。</p>
<h2 id="g1-phases">G1 phases</h2>
<p><img src="g1-gc-cycle.png" alt="g1-gc-cycle.png"><br>
其中：</p>
<ul>
<li>蓝色 Young-only</li>
<li>黄色 标记过程的停顿</li>
<li>红色 Mixed gc 停顿</li>
</ul>
<h2 id="g1-region">G1 region</h2>
<p><img src="g1-regions.jpg" alt="g1-regions.jpg"></p>
<p>关于 gc 日志可以参考<a target="_blank" rel="noopener" href="https://dzone.com/articles/understanding-g1-gc-log-format">《Understanding G1 GC Log Format》</a>。</p>
<p>在 jvm 里，minor gc 是一种 minor gc event。</p>
<h2 id="查看-gc-日志的命令">查看 gc 日志的命令</h2>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">grep</span> -rn --color <span class="hljs-string">&quot;G1 Evacuation Pause&quot;</span> gc.<span class="hljs-built_in">log</span>.<span class="hljs-number">20210923</span> | <span class="hljs-keyword">grep</span> <span class="hljs-string">&quot;2021-10-04T11:11&quot;</span><br></code></pre></td></tr></table></figure>
<h2 id="minor-gc-的日志">minor gc 的日志</h2>
<blockquote>
<p>发生在年轻代的GC算法，一般对象（除了巨型对象）都是在eden region中分配内存，当所有eden<br>
region被耗尽无法申请内存时，就会触发一次young gc，这种触发机制和之前的young gc差不多，执行完一次young<br>
gc，活跃对象会被拷贝到survivor region或者晋升到old<br>
region中，空闲的region会被放入空闲列表中，等待下次被使用。</p>
</blockquote>
<p>ParallelTime 到 Eden 就是 PrintGCDetails 的结果。</p>
<p>一般 8 核的 cpu，就会产生 8 个<strong>并行 gc worker 线程</strong>。</p>
<p>从这个图我们也可以看出，如果让 g1 自己选择 region 里面新老分布的比例的话，（通常）young 会多小（在一个 4g 的堆上，可能只有 200m 的年轻代），g1 的年轻代往往会有一个自动扩容的过程。如果 gc 时间不到 10ms，real 都显示不出来。</p>
<h2 id="global-concurrent-marking-的日志">global concurrent marking 的日志</h2>
<p>InitiatingHeapOccupancyPercent 到了是最容易触发触发并发收集的。</p>
<p>Percentage of the (entire) heap occupancy to start a concurrent GC cycle. GCs that trigger a concurrent GC cycle based on the occupancy of the entire heap and not just one of the generations, including G1, use this option. A value of 0 denotes ‘do constant GC cycles’. The default value is 45.</p>
<p>但实际上我们在实践中发现，8g 的堆，y 区到了 4g 的满状态，也只是触发 ygc，而不是 mixed gc。</p>
<p><img src="global-concurrent-marking.png" alt="global-concurrent-marking.png"></p>
<p>现实中的 Concurrent Cycles 往往会执行一轮又一轮，直到内存空间的比例降到足够低的水位为止。</p>
<p>搜索 GC pause 可以看到各种各样的 gc 停顿。要找混合垃圾回收直接搜“mixed GCs”或者“(G1 Evacuation Pause) (mixed)”。</p>
<p>实际上 mixed 的 phase 之间的顺序是：young -&gt; initial mark -&gt; concurrent mark 的其他阶段 + clean up -&gt; young -&gt; mixed gc。其中 initial mark 的时间最久，整体来讲也是 stw 的。concurrent clean up 的 stw 一般不会被 jmx 工具统计到，但它的时间非常长，而且混合了并发和 stw 的事件。</p>
<p>一般的 gc 日志的顺序是“[GC pause (G1 Evacuation Pause) (young)” -&gt; “concurrent-root-region-scan-start” -&gt; “Concurrent Cycles” -&gt; “ [GC pause (G1 Evacuation Pause) (young)” -&gt; “[G1Ergonomics (Mixed GCs) start mixed GCs” -&gt;“(G1 Evacuation Pause) (mixed)”（这一步会循环执行）。</p>
<p>每次 gc 开始时，Heap before GC invocations=15872 (full 0)，其中invocations=15872是自JVM启动以来，执行GC的次数。每一次 initial-mark，这个值就会加 1。</p>
<h2 id="可中断的-mixedgc">可中断的 mixedgc</h2>
<blockquote>
<p>一旦收集器确定了 GC 回收集 并且 GC 回收、整理工作已经开始，这个过程是without stopping的，即 G1<br>
收集器必须完成收集集合的所有区域中的所有活动对象之后才能停止；但是如果收集器选择过大的 GC<br>
回收集，此时的STW时间会过长超出目标pause time。</p>
<p>这种情况在mixed collections时候比较明显。这个特性启动了一个机制，当选择了一个比较大的collection<br>
set，Java12 中将把 GC 回收集（混合收集集合）拆分为mandatory（必需或强制）及optional两部分(<br>
当完mandatory的部分，如果还有剩余时间则会去处理optional部分)来将mixed collections从without<br>
stopping变为abortable，以更好满足指定pause time的目标。</p>
<p>其中必需处理的部分包括 G1 垃圾收集器不能递增处理的 GC 回收集的部分（如：年轻代），同时也可以包含老年代以提高处理效率。</p>
<p>将 GC 回收集拆分为必需和可选部分时，垃圾收集过程优先处理必需部分。同时，需要为可选 GC 回收集部分维护一些其他数据，这会产生轻微的<br>
CPU 开销，但小于 1 ％的变化，同时在 G1 回收器处理 GC 回收集期间，本机内存使用率也可能会增加，使用上述情况只适用于包含可选<br>
GC 回收部分的 GC 混合回收集合。</p>
</blockquote>
<p>参考：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/androidsuperman/p/11742876.html">《Java12新特性 – 可中断的 G1 Mixed GC》</a></li>
</ol>
<h2 id="full-gc">full gc</h2>
<p>Full GC (Allocation Failure) 是最常见的 fgc 的原因。</p>
<h2 id="常用的-jvm-配置">常用的 jvm 配置</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#jvm arg</span><br>-server -Dfile.encoding=UTF-8 -Dsun.jnu.encoding=UTF-8 -Djava.io.tmpdir=/tmp -Djava.net.preferIPv6Addresses=<span class="hljs-literal">false</span> -Duser.timezone=GMT+08 -Djava.security.egd=file:/dev/./urandom<br><br><span class="hljs-comment"># jvm gc</span><br>-XX:+AlwaysPreTouch -XX:CICompilerCount=4 -XX:ErrorFile=/var/company/logs/com.company.application/vmerr.log.20200928 -XX:G1HeapRegionSize=4194304 -XX:GCLogFileSize=10485760 -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=./log/hprof/ -XX:ErrorFile=./log/hs_err_%p.log -XX:InitialHeapSize=4294967296 -XX:InitiatingHeapOccupancyPercent=40 -XX:MaxGCPauseMillis=100 -XX:MaxHeapSize=4294967296 -XX:MaxMetaspaceSize=536870912 -XX:MetaspaceSize=536870912 -XX:NumberOfGCLogFiles=10 -XX:+PrintAdaptiveSizePolicy -XX:+PrintFlagsFinal -XX:+PrintGC -XX:+PrintGCApplicationStoppedTime -XX:+PrintGCDateStamps -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintHeapAtGC -XX:+PrintStringTableStatistics -XX:+PrintTenuringDistribution -XX:ThreadStackSize=512 -XX:+TieredCompilation -XX:-UseBiasedLocking -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseG1GC -XX:-UseGCLogFileRotation -XX:-OmitStackTraceInFastThrow  -XX:-UseCounterDecay -XX:+PrintCompilation<br><br><span class="hljs-comment"># jvm heap</span><br>-Xss512k -Xmx$(实际内存/2)m -Xms$(实际内存/2)m -XX:MetaspaceSize=$(实际内存/16)m -XX:MaxMetaspaceSize=$(实际内存/16)m -XX:+AlwaysPreTouch -XX:+HeapDumpOnOutOfMemoryError<br><br><span class="hljs-comment"># 一种能够把 avg ygc 控制在 10ms 到 20ms 之间，一分钟 avg 的 ygc count 6-7 次的配置</span><br>JVM_HEAP=<span class="hljs-string">&quot;-XX:NewRatio=1 -XX:SurvivorRatio=208 -XX:MaxTenuringThreshold=7&quot;</span><br>JVM_SIZE=<span class="hljs-string">&quot;-Xms7G -Xmx7G &quot;</span><br><br><span class="hljs-comment"># JVM 的参数里的名词就是被除数</span><br><span class="hljs-comment"># NewRatio=1 old 区和 young 区的比例是1:1，常态是 2，也就是 old 是 young 的 2 倍。young 非常大，大量的对象可以进入 young 区而触发触发 ygc 的时机比较少-一分钟大概 6-7 次。</span><br><span class="hljs-comment"># SurvivorRatio=208 eden 是 s2（to）的 208 倍。所以 eden 非常非常大。s 非常小，所以回收目标要么快速进入 s 区（因为 s 区很小），要么快速进入 old 区。</span><br><span class="hljs-comment"># MaxTenuringThreshold=7 对象停留在 s 区的时机非常小，小到很快就进入 old 区。</span><br><span class="hljs-comment"># old 区每次回收 3g 左右的堆，需要经过7次 mixed gc，每次 10ms-20ms。每轮 mixed gc 回收 old 区 200mb 到 400mb，每一次 ygc 会让 old 区增长 0.x MB。</span><br><span class="hljs-comment"># 总结：先扩大 young 区，然后扩大 eden 区，然后缩小 tenuring threshold。</span><br><br><br>问题是为什么这样能够起作用呢？这个配置本身是按比例配置的，大致上是可伸缩的。<br>只能认为尽量让 eden 区的 gc 时间延迟，而把不能回收进 s 区的对象扔到 old 区去。理论上 MaxTenuringThreshold 调得很高可能会让 JVM 表现得更好（前提是每次回收完 S 区并不显著增大，否则动态年龄计算也能够起到调节 MaxTenuringThreshold 的作用）。<br><br>对于 young 区的调优的基本思路是：<br>1. 尽量增大年轻大的大小和 eden 的比例，来降低 young 区的 gc 频次。<br>2. 让稍微年龄大一点的对象提前进入 old 区，来避免 s 区的反复拷贝，让 s 区始终很小，这就看出来真正朝生夕死的对象都非常短命。这可以反推出来，我们真正合理的 MaxTenuringThreshold 应该是某几个不再变小的 threshold 之间。<br><br>- age   1:   25047656 bytes,   25047656 total<br>- age   2:     786792 bytes,   25834448 total<br>- age   3:     615104 bytes,   26449552 total<br>- age   4:     845128 bytes,   27294680 total<br>- age   5:    5844016 bytes,   33138696 total<br>- age   6:    1223224 bytes,   34361920 total<br>- age   7:   24372296 bytes,   58734216 total<br>- age   8:    3789440 bytes,   62523656 total<br>- age   9:    6253976 bytes,   68777632 total<br><br>- age   1:   24826808 bytes,   24826808 total<br>- age   2:     688504 bytes,   25515312 total<br>- age   3:     679288 bytes,   26194600 total<br>- age   4:     603968 bytes,   26798568 total<br>- age   5:     839352 bytes,   27637920 total<br>- age   6:    5831024 bytes,   33468944 total<br>- age   7:    1216568 bytes,   34685512 total<br>- age   8:   24311896 bytes,   58997408 total<br>- age   9:    3789440 bytes,   62786848 total<br>- age  10:    6253976 bytes,   69040824 total<br><br>注意看，age 9 和 age10 开始，某类对象就不再减少，而整体一直年龄递增，所以 age 设置为 9 也是一个可以尝试的思路。<br><br>TODO：怎样做个实验来验证这里面的问题？<br></code></pre></td></tr></table></figure>
<p>另外：</p>
<ul>
<li>G1MixedGCLiveThresholdPercent：每个 region 里 live 对象到达多少的时候可以进入 CSet。</li>
<li>XX:G1MixedGCCountTarget=8 能够决定  mixed gc 的轮数。</li>
</ul>
<p>参考：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/161427950">《G1从入门到放弃》</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/54048685">《可能是最全面的G1学习笔记》</a></li>
<li>g1 的 gc 日志可以看<a target="_blank" rel="noopener" href="https://blogs.oracle.com/poonam/understanding-g1-gc-logs">《Understanding G1 GC Logs》</a>。</li>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/2016/09/23/g1.html">《Java Hotspot G1 GC的一些关键技术》</a></li>
<li><a target="_blank" rel="noopener" href="https://product.hubspot.com/blog/g1gc-fundamentals-lessons-from-taming-garbage-collection">《G1GC Fundamentals: Lessons from Taming Garbage Collection》</a></li>
</ol>
<h1>ZGC</h1>
<p>zgc 是 java11 推出的垃圾收集器，在 java16 中做到了 max pause 1ms。它基本基于 Azul 的 pauseless gc 和 c4，做到了它们的早期方案，但不支持分代收集。zgc 在 allocation rate 高的时候的 tuning 手段就是加大堆。</p>
<blockquote>
<p>ZGC（The Z Garbage Collector）是JDK 11中推出的一款低延迟垃圾回收器，它的设计目标包括：</p>
<ul>
<li>停顿时间不超过10ms；</li>
<li>停顿时间不会随着堆的大小，或者活跃对象的大小而增加；</li>
<li>支持8MB~4TB级别的堆（未来支持16TB）。</li>
</ul>
<p>与CMS中的ParNew和G1类似，ZGC也采用标记-复制算法，不过ZGC对该算法做了重大改进：ZGC在标记、转移和重定位阶段几乎都是并发的，这是ZGC实现停顿时间小于10ms目标的最关键原因。</p>
</blockquote>
<p><img src="zgc%E8%BF%87%E7%A8%8B.png" alt="zgc过程.png"></p>
<blockquote>
<p>ZGC只有三个STW阶段：初始标记，再标记，初始转移。其中，初始标记和初始转移分别都只需要扫描所有GC Roots，其处理时间和GC<br>
Roots的数量成正比，一般情况耗时非常短；再标记阶段STW时间很短，最多1ms，超过1ms则再次进入并发标记阶段。即，ZGC几乎所有暂停都只依赖于GC<br>
Roots集合大小，停顿时间不会随着堆的大小或者活跃对象的大小而增加。与ZGC对比，G1的转移阶段完全STW的，且停顿时间随存活对象的大小增加而增加。</p>
<p>ZGC通过着色指针和读屏障技术，解决了转移过程中准确访问对象的问题，实现了并发转移。大致原理描述如下：并发转移中“并发”意味着GC线程在转移对象的过程中，应用线程也在不停地访问对象。假设对象发生转移，但对象地址未及时更新，那么应用线程可能访问到旧地址，从而造成错误。而在ZGC中，应用线程访问对象将触发“读屏障”，如果发现对象被移动了，那么“读屏障”会把读出来的指针更新到对象的新地址上，这样应用线程始终访问的都是对象的新地址。那么，JVM是如何判断对象被移动过呢？就是利用对象引用的地址，即着色指针。下面介绍着色指针和读屏障技术细节。</p>
</blockquote>
<h2 id="着色指针">着色指针</h2>
<p><img src="zgc-%E7%9A%8464%E4%BD%8D%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4.png" alt="zgc-的64位地址空间"></p>
<blockquote>
<p>其中，[0~4TB) 对应Java堆，[4TB ~ 8TB) 称为M0地址空间，[8TB ~ 12TB) 称为M1地址空间，[12TB ~<br>
16TB) 预留未使用，[16TB ~ 20TB) 称为Remapped空间。</p>
<p>当应用程序创建对象时，首先在堆空间申请一个虚拟地址，但该虚拟地址并不会映射到真正的物理地址。ZGC同时会为该对象在M0、M1和Remapped地址空间分别申请一个虚拟地址，且这三个虚拟地址对应同一个物理地址，但这三个空间在同一时间有且只有一个空间有效。ZGC之所以设置三个虚拟地址空间，是因为它使用“空间换时间”思想，去降低GC停顿时间。“空间换时间”中的空间是虚拟空间，而不是真正的物理空间。后续章节将详细介绍这三个空间的切换过程。</p>
<p>与上述地址空间划分相对应，ZGC实际仅使用64位地址空间的第0~41位，而第42~45位存储元数据，第47~63位固定为0。</p>
</blockquote>
<p><img src="%E7%9D%80%E8%89%B2%E6%8C%87%E9%92%88.png" alt="着色指针.png"></p>
<blockquote>
<p>ZGC将对象存活信息存储在42~45位中，这与传统的垃圾回收并将对象存活信息放在对象头中完全不同。</p>
</blockquote>
<h2 id="读屏障">读屏障</h2>
<blockquote>
<p>读屏障是JVM向应用代码插入一小段代码的技术。当应用线程从堆中读取对象引用时，就会执行这段代码。需要注意的是，仅“从堆中读取对象引用”才会触发这段代码。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> obj.FieldA   <span class="hljs-comment">// 从堆中读取引用，需要加入屏障</span><br>&lt;Load barrier&gt;<br><span class="hljs-type">Object</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> o  <span class="hljs-comment">// 无需加入屏障，因为不是从堆中读取引用</span><br>o.dosomething() <span class="hljs-comment">// 无需加入屏障，因为不是从堆中读取引用</span><br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span>  obj.FieldB  <span class="hljs-comment">//无需加入屏障，因为不是对象引用</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>ZGC中读屏障的代码作用：在对象标记和转移过程中，用于确定对象的引用地址是否满足条件，并作出相应动作。</p>
</blockquote>
<h2 id="zgc并发处理演示">ZGC并发处理演示</h2>
<blockquote>
<p>接下来详细介绍ZGC一次垃圾回收周期中地址视图的切换过程：</p>
<ul>
<li>初始化：ZGC初始化之后，整个内存空间的地址视图被设置为Remapped。程序正常运行，在内存中分配对象，满足一定条件后垃圾回收启动，此时进入标记阶段。</li>
<li>并发标记阶段：第一次进入标记阶段时视图为M0，如果对象被GC标记线程或者应用线程访问过，那么就将对象的地址视图从Remapped调整为M0。所以，在标记阶段结束之后，对象的地址要么是M0视图，要么是Remapped。如果对象的地址是M0视图，那么说明对象是活跃的；如果对象的地址是Remapped视图，说明对象是不活跃的。</li>
<li>并发转移阶段：标记结束后就进入转移阶段，此时地址视图再次被设置为Remapped。如果对象被GC转移线程或者应用线程访问过，那么就将对象的地址视图从M0调整为Remapped。</li>
</ul>
<p>其实，在标记阶段存在两个地址视图M0和M1，上面的过程显示只用了一个地址视图。之所以设计成两个，是为了区别前一次标记和当前标记。也即，第二次进入并发标记阶段后，地址视图调整为M1，而非M0。</p>
<p>着色指针和读屏障技术不仅应用在并发转移阶段，还应用在并发标记阶段：将对象设置为已标记，传统的垃圾回收器需要进行一次内存访问，并将对象存活信息放在对象头中；而在ZGC中，只需要设置指针地址的第42~45位即可，并且因为是寄存器访问，所以速度比访问内存更快。</p>
</blockquote>
<p>注意可能会有多轮并发标记。</p>
<p><img src="zgc-%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%E7%A4%BA%E8%8C%83.png" alt="zgc-并发标记示范"></p>
<p>这个图里的 0 和 1 属于同一个内存页面，因为 0 是活跃对象，所以 0 被转移出来，而 1 和整个页面都被回收了。</p>
<p>并发标记和并发转移是对称操作，从对象的稳定状态都应该是 remmaped 态。</p>
<h2 id="常用的-jvm-配置">常用的 jvm 配置</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">-Xms10G -Xmx10G <br>-XX:ReservedCodeCacheSize=256m -XX:InitialCodeCacheSize=256m <br>-XX:+UnlockExperimentalVMOptions -XX:+UseZGC <br>-XX:ConcGCThreads=2 -XX:ParallelGCThreads=6 <br>-XX:ZCollectionInterval=120 -XX:ZAllocationSpikeTolerance=5 <br>-XX:+UnlockDiagnosticVMOptions -XX:-ZProactive -XX:+PrintCompilation<br>-Xlog:safepoint,classhisto*=trace,age*,gc*=info:file=/opt/logs/logs/gc-%t.log:<span class="hljs-keyword">time</span>,tid,tags:filecount=5,filesize=50m <br></code></pre></td></tr></table></figure>
<blockquote>
<p>-Xms -Xmx：堆的最大内存和最小内存，这里都设置为10G，程序的堆内存将保持10G不变。 -XX:ReservedCodeCacheSize -XX:InitialCodeCacheSize：设置CodeCache的大小， JIT编译的代码都放在CodeCache中，一般服务64m或128m就已经足够。我们的服务因为有一定特殊性，所以设置的较大，后面会详细介绍。<br>
-XX:+UnlockExperimentalVMOptions -XX:+UseZGC：启用ZGC的配置。 -XX:ConcGCThreads：并发回收垃圾的线程。默认是总核数的12.5%，8核CPU默认是1。调大后GC变快，但会占用程序运行时的CPU资源，吞吐会受到影响。<br>
-XX:ParallelGCThreads：STW阶段使用线程数，默认是总核数的60%。 -XX:ZCollectionInterval：ZGC发生的最小时间间隔，单位秒。 -XX:ZAllocationSpikeTolerance：ZGC触发自适应算法的修正系数，默认2，数值越大，越早的触发ZGC。<br>
-XX:+UnlockDiagnosticVMOptions。开启诊断功能，默认关闭，不知道是不是需要单独编译虚拟机和对性能的影响如何 -XX:-ZProactive：是否启用主动回收，默认开启，这里的配置表示关闭。 -Xlog：设置GC日志中的内容、格式、位置以及每个日志的大小。</p>
</blockquote>
<h2 id="理解zgc触发时机">理解ZGC触发时机</h2>
<p>相比于CMS和G1的GC触发机制，ZGC的GC触发机制有很大不同。ZGC的核心特点是并发，GC过程中一直有新的对象产生。如何保证在GC完成之前，新产生的对象不会将堆占满，是ZGC参数调优的第一大目标。因为在ZGC中，当垃圾来不及回收将堆占满时，会导致正在运行的线程停顿，持续时间可能长达秒级之久。</p>
<p>ZGC有多种GC触发机制，总结如下：</p>
<ul>
<li>阻塞内存分配请求触发：当垃圾来不及回收，垃圾将堆占满时，会导致部分线程阻塞。我们应当避免出现这种触发方式。日志中关键字是“Allocation Stall”。</li>
<li>基于分配速率的自适应算法：最主要的GC触发方式，其算法原理可简单描述为”ZGC根据近期的对象分配速率以及GC时间，计算出当内存占用达到什么阈值时触发下一次GC”。自适应算法的详细理论可参考彭成寒《新一代垃圾回收器ZGC设计与实现》一书中的内容。通过ZAllocationSpikeTolerance参数控制阈值大小，该参数默认2，数值越大，越早的触发GC。我们通过调整此参数解决了一些问题。日志中关键字是“Allocation Rate”。</li>
<li>基于固定时间间隔：通过ZCollectionInterval控制，适合应对突增流量场景。流量平稳变化时，自适应算法可能在堆使用率达到95%以上才触发GC。流量突增时，自适应算法触发的时机可能会过晚，导致部分线程阻塞。我们通过调整此参数解决流量突增场景的问题，比如定时活动、秒杀等场景。日志中关键字是“Timer”。</li>
<li>主动触发规则：类似于固定间隔规则，但时间间隔不固定，是ZGC自行算出来的时机，我们的服务因为已经加了基于固定时间间隔的触发机制，所以通过-ZProactive参数将该功能关闭，以免GC频繁，影响服务可用性。 日志中关键字是“Proactive”。</li>
<li>预热规则：服务刚启动时出现，一般不需要关注。日志中关键字是“Warmup”。</li>
<li>外部触发：代码中显式调用System.gc()触发。日志中关键字是“System.gc()”。</li>
<li>元数据分配触发：元数据区不足时导致，一般不需要关注。 日志中关键字是“Metadata GC Threshold”。</li>
</ul>
<h2 id="理解zgc日志">理解ZGC日志</h2>
<blockquote>
<p>一次完整的GC过程，需要注意的点已在图中标出。</p>
</blockquote>
<p><img src="zgc-%E6%97%A5%E5%BF%97%E4%B8%BE%E4%BE%8B.png" alt="zgc-日志举例.png"></p>
<blockquote>
<p>注意：该日志过滤了进入安全点的信息。正常情况，在一次GC过程中还穿插着进入安全点的操作。</p>
<p>GC日志中每一行都注明了GC过程中的信息，关键信息如下：</p>
<ul>
<li>Start：开始GC，并标明的GC触发的原因。上图中触发原因是自适应算法。</li>
<li>Phase-Pause Mark Start：初始标记，会STW。</li>
<li>Phase-Pause Mark End：再次标记，会STW。</li>
<li>Phase-Pause Relocate Start：初始转移，会STW。</li>
<li>Heap 信息：记录了GC过程中Mark、Relocate前后的堆大小变化状况。High和Low记录了其中的最大值和最小值，我们一般关注High中Used的值，如果达到100%，在GC过程中一定存在内存分配不足的情况，需要调整GC的触发时机，更早或者更快地进行GC。</li>
<li>GC 信息统计：可以定时的打印垃圾收集信息，观察10秒内、10分钟内、10个小时内，从启动到现在的所有统计信息。利用这些统计信息，可以排查定位一些异常点。</li>
</ul>
</blockquote>
<p><img src="zgc-%E6%97%A5%E5%BF%97%E4%B8%BE%E4%BE%8B2.png" alt="zgc-日志举例2"></p>
<h2 id="理解-zgc-停顿原因">理解 ZGC 停顿原因</h2>
<ul>
<li>GC时，初始标记：日志中Pause Mark Start。</li>
<li>GC时，再标记：日志中Pause Mark End。</li>
<li>GC时，初始转移：日志中Pause Relocate Start。</li>
<li>内存分配阻塞：当内存不足时线程会阻塞等待GC完成，关键字是”Allocation Stall”。</li>
<li>安全点：所有线程进入到安全点后才能进行GC，ZGC定期进入安全点判断是否需要GC。先进入安全点的线程需要等待后进入安全点的线程直到所有线程挂起。</li>
<li>dump线程、内存：比如jstack、jmap命令。</li>
</ul>
<p>这 6 种 STW，在其他垃圾收集器里也是很常见的。</p>
<h1>Shenandoah</h1>
<p>RedHat 的分代收集器，只有 Openjdk 才有。</p>
<h1>总结</h1>
<p><a href="Garbage-Collector.xmind">Garbage-Collector.xmind</a></p>
<p><img src="Garbage-Collector.png" alt="Garbage-Collector.png"></p>
<p>关于 CMS 和 g1 的深入讨论，参考<a target="_blank" rel="noopener" href="https://hllvm-group.iteye.com/group/topic/44381">这个帖子</a>。</p>
<h1>调优经验</h1>
<p>在现代系统中，系统进入峰值时，峰值效应明显，要针对 peak server workloads 做好准备。 通常 ygc 始终是全 stw 的，fullgc 也不可避免的有好几个 stw 阶段。</p>
<p>指定堆的大小是为了保证垃圾回收的可预测性，也能进而保证堆扩展（heap expansion）不出错-在混布（mixed deployment）时保障资源有界。</p>
<p>指定最大停顿时间则意味着我们要指定系统在 high probability（90%的情况下）应该达到的一个软实时目标。PS 和 G1 都支持这种调优策略，而且能够自动适应调整堆内部大小。PS 是吞吐量收集器，G1 是 regionalized, parallel-concurrent, incremental garbage collector。PS 和 G1 的低延迟垃圾收集器。cms 可以被认为是一个并发收集器，而 g1 的 ygc 和 mixedgc 可以被认为都是 stw 的- mixed gc 的并发标记阶段是可以并发执行的。</p>
<p>对于有并发阶段存在的垃圾收集器而言，InitiatingHeapOccupancyPercent（全堆）/CMSInitiatingOccupancyFraction（老年代，需配合 CMSInitiatingOccupancyOnly 使用，否则只生效一次 ）等阈值保证了系统可以提前触发回收，这样可以保证并发收集留有余地，不至于有并发模式失败。</p>
<p>如果配置了-XX:MetaspaceSize，那么触发FGC的阈值就是配置的值；MaxMetaspaceSize 指的是元空间最大的大小-如果不设置则为无限大。 参考<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/b448c21d2e71">《JVM参数MetaspaceSize的误解》</a>。通常 MetaspaceSize == MaxMetaspaceSize，这实际上意味着对元空间的收集不一定需要采用类似 CMS 的那种 OccupancyFraction 的提前使用高水位线开始 gc，给 gc 留有余地的做法。</p>
<p>MinMetaspaceFreeRatio、MaxMetaspaceFreeRatio、MaxMetaspaceExpansion、MinMetaspaceExpansion 可以控制 metaspace 扩容的速度和幅度。</p>
<p>metaspace 和 permgen 的最重要区别就是，两者虽然都有最大值，但 permgen 是一开始就固定好在这个大小上，而 metaspace 是逐渐增长到这个大小上的。这就是 <a target="_blank" rel="noopener" href="https://openjdk.org/jeps/122">jeps 122</a> 力图达到的目标。其他关于类型元数据的驻留问题，还在其次。</p>
<p>如果配置了：-XX:+HeapDumpBeforeFullGC、-XX:+HeapDumpAfterFullGC，则可以看到fullgc 前后的元空间差异。如果我们有一个碎片化很严重的 metaspace一般可以看到各种各样的 DelegatingClassLoader。</p>
<p>gc 日志中的 Allocation Failure 可能代表 y 区内存分配失败，也可能代表 old 区内存分配失败。实际上，内存分配失败、回收后空间水位过高、经常越过高水位，都是持续发生 gc 的元凶，它们通常都由 gc 不友好、内存泄漏的代码导致。</p>
<p>ygc 有意想不到的直接晋升到 old 区的几种可能，所以 old 区通常要设计得比 y 区大：ygc 剩余垃圾大于 eden，触发担保机制；大对象；动态年龄判断。如果 old 区很稳定，可以证明应用的对象朝生夕死分布得很好。单纯的年龄阈值并不一定能够适应复杂的 ygc 的年龄分布，所以 MaxTenuringThreshold 会和 TargetSurvivorRatio 一起使用，如果 ygc 的结果超出了 desired_survivor_size，也会触发老年代晋升。</p>
<p>看待 gc 时间需要客观：ygc 的时间总是会造成 stw 的停顿。如果设定了很小的 gc 时间目标，则 jvm 可能很保守地制造小堆，进而在数据密集型应用上触发频繁的垃圾回收，进而是总的停顿时间变大。有时候稍微大的堆（在 8g 机器上使用 2-4g 的年轻代）或者稍微大的停顿时间目标 100 ms 可以解决我们的问题。否则，我们只能通过压测，不断调节年轻代的大小来解决我们的问题。</p>
<p>一般一个 mixed gc 一天才出现一次，算是比较健康的。但使用自适应策略导致冷启动和 mixed gc 以后堆布局的重建容易出现多轮回收的问题（多的时候会有 20 几轮 ygc 才能把 young 区的数量建设到比较稳定的状态），比较麻烦。当然，一般情况下，gc 对于 tp999、tp9999 的抬升效应并没有那么明显，有很多其他因素会导致我们的 rt 出现明显抬升。</p>
<p>垃圾调优一定要解决确定存在的问题-而不能解决不存在的问题。如果需要调优 cpu，则注意垃圾收集器、标记线程、回收线程和垃圾回收的频次。调优年轻代的时候是有代价的：更大的年轻代意味着更低的回收频率（这通常会优化次数相关的告警），但会带来更大的 ygc meantime，也意味着进入老年代的时间更缓慢，但老年代的大小会变小，可能又会导致老年代的 fgc（这又取决于老年代是不是稳定的）。</p>
<p>cms/g1 都使用了三色标记算法，白色（未被扫描）、灰色（field 未被扫描）、黑色（已全被扫描）三种对象里面，灰色对象和白色对象的引用交替增删，可能造成部分白色对象不被回收，这就是这类垃圾收集器的浮动垃圾的根源。</p>
<p>card 和 rset 本身都是帮助 gc 的过程工具，一个 point-out，一个 point-in。都是用空间换时间。g1 的停顿预测模型是以衰减标准偏差为理论基础。扫描 dirty_card 的时间，会占据预测停顿时间的一部分。</p>
<h2 id="gceasy-的经验">gceasy 的经验</h2>
<p><a target="_blank" rel="noopener" href="https://blog.gceasy.io/2020/03/18/7-jvm-arguments-of-highly-effective-applications/">《7 JVM arguments of Highly Effective Applications》</a></p>
<h3 id="账单与用户体验">账单与用户体验</h3>
<p>Xmx 决定堆大小，既决定了 GC 的时间成本（间接决定用户成本），也决定了账单金额。</p>
<h3 id="健康的堆">健康的堆</h3>
<p><img src="healthy-jvm.webp" alt="healthy-jvm.webp"><br>
<img src="sick-jvm.webp" alt="sick-jvm.webp"><br>
<img src="repeated-full-gc-oom.webp" alt="repeated-full-gc-oom.webp"></p>
<p>健康的 jvm 主要看底部的宽度，和底部的跌落高度。不健康的 jvm 高度的底部越来越高，fgc 之间的事件时间差越来越短。</p>
<h3 id="xss">XSS</h3>
<p>我们的建议是从低值开始（比如 256kb）。使用此设置运行彻底的回归、性能和 AB 测试。只有当您遇到 StackOverflowError 时才增加该值，否则请考虑坚持使用较低的值。</p>
<h3 id="容易被忽略的时间属性">容易被忽略的时间属性</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">-Dsun.net.client.defaultConnectTimeout=2000 -Dsun.net.client.defaultReadTimeout=2000 -Duser.timezone=US/Eastern<br></code></pre></td></tr></table></figure>
<p>这些 D 开头的是 properties，不是 vm option 或者 args。</p>
<h1>C4（Continuous Concurrently Compacting Collection）</h1>
<p>待续</p>
<p>参考：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/2020/08/06/new-zgc-practice-in-meituan.html">《新一代垃圾回收器ZGC的探索与实践》</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903893906751501">《【译】深入理解G1的GC日志（一）》</a></li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://magicliang.github.io">magicliang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://magicliang.github.io/2020/09/27/%E7%8E%B0%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/">https://magicliang.github.io/2020/09/27/%E7%8E%B0%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JVM/">JVM</a><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post-share"><div class="social-share" data-image="/2020/09/27/%E7%8E%B0%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/%E6%94%B6%E9%9B%86%E5%99%A8%E5%88%86%E7%B1%BB.jpeg" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2017/10/23/%E6%98%82%E8%B4%B5%E7%9A%84%E5%BC%82%E5%B8%B8/" title="昂贵的异常"><img class="cover" src="/img/wall-paper-151.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-10-23</div><div class="info-item-2">昂贵的异常</div></div><div class="info-2"><div class="info-item-1">抛出问题   Joshua Bloch 在《Effective Java》的 Item 57 里明确地提到过，不要试图用 Exception 的跳转来代替正常的程序控制流。他列举了很多原因，但特别提到了抛出异常会使得整个程序运行变慢。抛出异常远比普通的 return , break 等操作对控制流、数据流的性能影响要大，它就只适合拿来作异常分支的控制语句，而不能拿来编写正常的逻辑。  Throwing exception is expensive.    这句话在 Java 的程序员世界里面已经成为老生常谈。却很少有人谈及，但到底抛出异常比正常的程序跳转返回慢在哪里，有多慢。“不要滥用异常”好像一个猴子定律，人们忘记了为什么不能这么做，却不明白为什么不能这么做。   这几天读了一位同事写的好文[《Java虚拟机是如何处理异常的》][2]，深入地分析了 JVM 对异常跳转的处理过程: JVM 会通过异常表的机制，优化异常抛出和正常返回之间的性能差异。仅从程序计数器的移动上来讲，抛出一个异常对栈帧的弹栈并不比直接返回更昂贵。写在前头的结论是：“try-catch语句块几乎不会影响程序...</div></div></div></a><a class="pagination-related" href="/2018/10/13/%E5%8D%A1%E8%A1%A8%E5%92%8C-RSet/" title="卡表和 RSet"><img class="cover" src="/img/wall-paper-170.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-10-13</div><div class="info-item-2">卡表和 RSet</div></div><div class="info-2"><div class="info-item-1">上下文 卡表和 RSet（Remember Set），是 JVM 为了解决分代收集时，live set 扫描需要穿梭到不同的代的时候的效率问题。 使用缓存表来提高查询效率，是化顺序查找为部分随机查找的一种常用的设计思路。 例如，在传统的计算机体系结构中，当我们把内存分成页以后，会有一个页表，页表又会有一个快表，作为一个中间缓存项，来帮助我们查找我们需要使用的页表项（table entry）。 JVM 在进行垃圾收集的时候，有一项非常重要的工作就是确定这一次垃圾收集的对象到底有多少个，即确定 live set 的范围。 对于新生代垃圾收集器而言，这个问题又有其特殊之处。根据 JVM 的弱分代收集假设（weak generational hypothesis）的存在，每次垃圾收集的时候，新生代的扫描范围可能很大，但新生代的 live set 不应该太大。card table/Remember Set 的设计目的，就是尽量减少无用的垃圾扫描范围，使用类似操作系统或者数据库的脏页表的形式，来做类似快表的查询。 卡表（card table）  卡表是 CMS 的解决方案。 卡表通常在 JV...</div></div></div></a><a class="pagination-related" href="/2018/10/22/JDWP-%E4%B8%8E%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/" title="JDWP 与远程调试"><img class="cover" src="/img/wall-paper-168.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-10-22</div><div class="info-item-2">JDWP 与远程调试</div></div><div class="info-2"><div class="info-item-1">JDWP（Java Debug Wire Protocol），它提供了调试器和目标 JVM （target vm）之间的调试协议。 在 target vm 启动时，增加这个 JAVA_OPTS： 1JAVA_OPTS=&quot;-Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=26310&quot; 在服务器端，增加 remote debuging 的时候使用如下配置： 12345678# Java 9 以上-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:8000# Java 5-8-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=8000# Java 1.4.x -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,addre...</div></div></div></a><a class="pagination-related" href="/2019/09/05/%E9%87%8D%E8%BF%B0%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/" title="重述双亲委派模型"><img class="cover" src="/img/wall-paper-169.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2019-09-05</div><div class="info-item-2">重述双亲委派模型</div></div><div class="info-2"><div class="info-item-1">何时加载类  遇到 new、getstatic、putstatic 等指令时。 对类进行反射调用的时候。 初始化某个类的子类的时候。 虚拟机启动时会先加载设置的程序主类。 使用 dynamic 动态语言支持等相关特性时。  从 Java 到 cpp 源码分析  JVM 默认用于加载用户程序的ClassLoader为AppClassLoader，不过无论是什么ClassLoader，它的根父类都是java.lang.ClassLoader。在上面那个例子中，loadClass（）方法最终会调用到ClassLoader.definClass1（）中，这是一个 Native 方法。  12static native Class&lt;?&gt; defineClass1(ClassLoader loader, String name, byte[] b, int off, int len,                                        ProtectionDomain pd, String source);   definClass1（）对应的 JNI ...</div></div></div></a><a class="pagination-related" href="/2020/03/08/JMX-%E6%B7%B1%E5%BA%A6%E5%8E%86%E9%99%A9/" title="JMX 深度历险"><img class="cover" src="/img/wall-paper-38.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-03-08</div><div class="info-item-2">JMX 深度历险</div></div><div class="info-2"><div class="info-item-1">JMX 常见指标 JVM 指标 系统指标    System 相关指标 描述     system.load.average 系统load，如果是docker，此指标收集的物理机的load   cpu.system.load.percent 系统所有进程占用cpu的百分比   cpu.jvm.load.percent jvm占用cpu的百分比   system.process.used.phyical.memory 系统使用的物理内存   system.process.used.swap.size 系统使用的swap内存    JVM 内存指标    JVM相关指标 描述     jvm.gc.count GC的次数   jvm.gc.time GC的时间，单位毫秒   jvm.younggc.count 年轻代GC的次数 ，包括的GC算法（Copy，ParNew，PS Scavenge，G1 Young Generation）   jvm.younggc.time 年轻代GC的时间，单位毫秒   jvm.fullgc.count 年老代GC的次数，包括的GC算法   jvm.f...</div></div></div></a><a class="pagination-related" href="/2021/07/19/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%BE%AE%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/" title="如何实现正确的微基准测试"><img class="cover" src="/img/wall-paper-108.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-19</div><div class="info-item-2">如何实现正确的微基准测试</div></div><div class="info-2"><div class="info-item-1">原问题 FROM：《How do I write a correct micro-benchmark in Java?》 Tips about writing micro benchmarks from the creators of Java HotSpot: Rule 0: Read a reputable paper on JVMs and micro-benchmarking. A good one is Brian Goetz, 2005. Do not expect too much from micro-benchmarks; they measure only a limited range of JVM performance characteristics. Rule 1: Always include a warmup phase which runs your test kernel all the way through, enough to trigger all initializations and compilations before timi...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">操作系统的影响</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">美团的实践</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%88%86%E7%B1%BB"><span class="toc-number">2.1.</span> <span class="toc-text">垃圾收集器分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7"><span class="toc-number">2.2.</span> <span class="toc-text">常用工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BB%88%E7%AB%AF"><span class="toc-number">2.2.1.</span> <span class="toc-text">命令行终端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%A7%86%E5%8C%96%E7%95%8C%E9%9D%A2"><span class="toc-number">2.2.2.</span> <span class="toc-text">可视化界面</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E6%A0%87%E8%AF%84%E4%BB%B7%E6%A0%87%E5%87%86"><span class="toc-number">2.3.</span> <span class="toc-text">指标评价标准</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gc-%E5%8A%A8%E4%BD%9C%E8%80%97%E6%97%B6"><span class="toc-number">2.4.</span> <span class="toc-text">gc 动作耗时</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mutator-%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.5.</span> <span class="toc-text">Mutator 类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%B2%E6%8F%90%E4%BA%A4%E7%9A%84%E5%86%85%E5%AD%98"><span class="toc-number">2.6.</span> <span class="toc-text">已提交的内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E-xx-disableexplicitgc%E7%9A%84%E4%BA%89%E8%AE%BA"><span class="toc-number">2.7.</span> <span class="toc-text">关于-XX:+DisableExplicitGC的争论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%BF%BD%E8%B8%AA%E6%96%B0-load-class"><span class="toc-number">2.8.</span> <span class="toc-text">如何追踪新 load class</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%87%E6%97%A9%E6%99%8B%E5%8D%87"><span class="toc-number">2.9.</span> <span class="toc-text">过早晋升</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF"><span class="toc-number">2.10.</span> <span class="toc-text">分析内存泄漏的基本思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cms-%E9%80%80%E5%8C%96"><span class="toc-number">2.11.</span> <span class="toc-text">CMS 退化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">2.12.</span> <span class="toc-text">堆外内存泄漏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gclocker-initiated-gc"><span class="toc-number">2.13.</span> <span class="toc-text">GCLocker Initiated GC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B9%E5%9B%A0%E9%B1%BC%E9%AA%A8%E5%9B%BE"><span class="toc-number">2.14.</span> <span class="toc-text">根因鱼骨图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%BB%BA%E8%AE%AE"><span class="toc-number">2.15.</span> <span class="toc-text">其他建议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jvm-%E5%90%AF%E5%8A%A8%E5%8F%82%E6%95%B0"><span class="toc-number">2.16.</span> <span class="toc-text">JVM 启动参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%80%81%E7%9A%84%E9%85%8D%E6%AF%94%E5%85%AC%E5%BC%8F"><span class="toc-number">2.17.</span> <span class="toc-text">老的配比公式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gc-%E5%AF%B9%E4%B8%9A%E5%8A%A1%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">2.18.</span> <span class="toc-text">GC 对业务的影响</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-number">2.19.</span> <span class="toc-text">案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B1"><span class="toc-number">2.19.1.</span> <span class="toc-text">案例1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B2"><span class="toc-number">2.19.2.</span> <span class="toc-text">案例2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B3"><span class="toc-number">2.19.3.</span> <span class="toc-text">案例3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B4"><span class="toc-number">2.19.4.</span> <span class="toc-text">案例4</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-5"><span class="toc-number">2.19.5.</span> <span class="toc-text">案例 5</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">CMS</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">G1</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#g1-phases"><span class="toc-number">4.1.</span> <span class="toc-text">G1 phases</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#g1-region"><span class="toc-number">4.2.</span> <span class="toc-text">G1 region</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B-gc-%E6%97%A5%E5%BF%97%E7%9A%84%E5%91%BD%E4%BB%A4"><span class="toc-number">4.3.</span> <span class="toc-text">查看 gc 日志的命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#minor-gc-%E7%9A%84%E6%97%A5%E5%BF%97"><span class="toc-number">4.4.</span> <span class="toc-text">minor gc 的日志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#global-concurrent-marking-%E7%9A%84%E6%97%A5%E5%BF%97"><span class="toc-number">4.5.</span> <span class="toc-text">global concurrent marking 的日志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E4%B8%AD%E6%96%AD%E7%9A%84-mixedgc"><span class="toc-number">4.6.</span> <span class="toc-text">可中断的 mixedgc</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#full-gc"><span class="toc-number">4.7.</span> <span class="toc-text">full gc</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84-jvm-%E9%85%8D%E7%BD%AE"><span class="toc-number">4.8.</span> <span class="toc-text">常用的 jvm 配置</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">ZGC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9D%80%E8%89%B2%E6%8C%87%E9%92%88"><span class="toc-number">5.1.</span> <span class="toc-text">着色指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%B1%8F%E9%9A%9C"><span class="toc-number">5.2.</span> <span class="toc-text">读屏障</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#zgc%E5%B9%B6%E5%8F%91%E5%A4%84%E7%90%86%E6%BC%94%E7%A4%BA"><span class="toc-number">5.3.</span> <span class="toc-text">ZGC并发处理演示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84-jvm-%E9%85%8D%E7%BD%AE"><span class="toc-number">5.4.</span> <span class="toc-text">常用的 jvm 配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%90%86%E8%A7%A3zgc%E8%A7%A6%E5%8F%91%E6%97%B6%E6%9C%BA"><span class="toc-number">5.5.</span> <span class="toc-text">理解ZGC触发时机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%90%86%E8%A7%A3zgc%E6%97%A5%E5%BF%97"><span class="toc-number">5.6.</span> <span class="toc-text">理解ZGC日志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%90%86%E8%A7%A3-zgc-%E5%81%9C%E9%A1%BF%E5%8E%9F%E5%9B%A0"><span class="toc-number">5.7.</span> <span class="toc-text">理解 ZGC 停顿原因</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">Shenandoah</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">调优经验</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#gceasy-%E7%9A%84%E7%BB%8F%E9%AA%8C"><span class="toc-number">8.1.</span> <span class="toc-text">gceasy 的经验</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%A6%E5%8D%95%E4%B8%8E%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C"><span class="toc-number">8.1.1.</span> <span class="toc-text">账单与用户体验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%A5%E5%BA%B7%E7%9A%84%E5%A0%86"><span class="toc-number">8.1.2.</span> <span class="toc-text">健康的堆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#xss"><span class="toc-number">8.1.3.</span> <span class="toc-text">XSS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E6%98%93%E8%A2%AB%E5%BF%BD%E7%95%A5%E7%9A%84%E6%97%B6%E9%97%B4%E5%B1%9E%E6%80%A7"><span class="toc-number">8.1.4.</span> <span class="toc-text">容易被忽略的时间属性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">9.</span> <span class="toc-text">C4（Continuous Concurrently Compacting Collection）</span></a></li></ol></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2017 - 2026 By magicliang</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional and Simplified Chinese">簡</button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><script src="/js/tw_cn.js?v=5.5.2"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="/"></script></div></body></html>