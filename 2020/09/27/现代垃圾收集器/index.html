<!DOCTYPE html>

<html lang="zh-Hans">
    <head>
    <meta charset="utf-8">
    <!--
        hexo-theme-suka © SukkaW
        GitHub: https://github.com/SukkaW/hexo-theme-suka
    -->

    <!-- ### Resource Hint ### -->

    <!-- ## DNS Prefetch ## -->
    <meta http-equiv="x-dns-prefetch-control" content="on">

<!-- busuanzi -->

    <link rel="dns-prefetch" href="//busuanzi.ibruce.info">


<!-- comment -->







<!-- analytics -->







    <!-- ## Preload ## -->
    
    <!-- Busuanzi -->
    
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/busuanzi@2.3.0/bsz.pure.mini.js" as="script">







    <!-- ### Meta & Title & Info ### -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, maximum-scale=5, viewport-fit=cover">
    <meta name="renderer" content="webkit">

    <!-- Title -->
    <title>现代垃圾收集器 | 守株阁</title>

    <!-- Favicons -->
    <link rel="icon" type="image&#x2F;ico" href="/img/suka-favicon.ico">

    <!-- ### Import File ### -->
    <link rel="stylesheet" href="/lib/spectre/spectre.min.css"><style>
    body {
        background-color: #f8f9fa;
    }

    a, a:visited {
        color: #0070ff;
    }

    a:active, a:focus, a:hover {
        color: #0070ff;
        opacity: .75;
    }

    #post-content a,
    #post-content a:hover,
    #post-content a:focus,
    #post-content a:visited {
        color: #005eb9;
        opacity: 1;
    }

    

    .post-entry .card-body a {
        color: #0070ff;
    }

    .avatar {
        background: #444;
    }

    .navbar-link,
    .navbar-link:visited,
    .timeline .timeline-item .timeline-icon.icon-lg {
        color: #0070ff;
    }

    .navbar-link:hover {
        color: #0070ff;
        opacity: .8;
    }

    #search-input .btn,
    #disqus_click_btn,
    #disqus-switch-to-direct,
    #disqus-loadmore-button {
        background: #727e96;
        border-color: #727e96;
        color: #fff;
    }

    #post-toc a.post-toc-link,
    #post-toc a.post-toc-link:visited,
    .share-menu.menu .menu-item>a {
        color: #727e96;
    }

    .share-menu.menu .menu-item>a:hover,
    .share-menu.menu .menu-item>a:focus,
    .share-menu.menu .menu-item>a:visited {
        color: #50596c;
        background: #f8f9fa;
        opacity: .85;
    }
</style><link rel="stylesheet" href="/css/style.min.css">








    <!-- Prettify Theme -->
    
    <link rel="preload" href="/css/highlight/github.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="/css/highlight/github.min.css"></noscript>





<script>
/*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
!function(t){"use strict";t.loadCSS||(t.loadCSS=function(){});var e=loadCSS.relpreload={};if(e.support=function(){var e;try{e=t.document.createElement("link").relList.supports("preload")}catch(t){e=!1}return function(){return e}}(),e.bindMediaToggle=function(t){var e=t.media||"all";function a(){t.addEventListener?t.removeEventListener("load",a):t.attachEvent&&t.detachEvent("onload",a),t.setAttribute("onload",null),t.media=e}t.addEventListener?t.addEventListener("load",a):t.attachEvent&&t.attachEvent("onload",a),setTimeout(function(){t.rel="stylesheet",t.media="only x"}),setTimeout(a,3e3)},e.poly=function(){if(!e.support())for(var a=t.document.getElementsByTagName("link"),n=0;n<a.length;n++){var o=a[n];"preload"!==o.rel||"style"!==o.getAttribute("as")||o.getAttribute("data-loadcss")||(o.setAttribute("data-loadcss",!0),e.bindMediaToggle(o))}},!e.support()){e.poly();var a=t.setInterval(e.poly,500);t.addEventListener?t.addEventListener("load",function(){e.poly(),t.clearInterval(a)}):t.attachEvent&&t.attachEvent("onload",function(){e.poly(),t.clearInterval(a)})}"undefined"!=typeof exports?exports.loadCSS=loadCSS:t.loadCSS=loadCSS}("undefined"!=typeof global?global:this);
</script>

    <!-- ### Site Verification ### -->
    


    <link rel="alternate" type="application/atom+xml" href="/atom.xml"><meta name="mobile-web-app-capable" content="yes"><meta name="application-name" content="守株阁"><meta name="msapplication-starturl" content="http://magicliang.github.io"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="守株阁"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <!-- ### The Open Graph & Twitter Card Protocol ### -->
    <meta property="og:title" content="现代垃圾收集器 | 守株阁"><meta property="og:site_name" content="守株阁"><meta property="og:type" content="article"><meta property="og:url" content="http://magicliang.github.io/2020/09/27/%E7%8E%B0%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"><meta property="og:locale" content="zh-Hans"><meta name="description" content="所有的垃圾收集器，都基于弱分代假设。实际的垃圾回收效率取决于堆内对象的分布状况。垃圾回收并不能解决内存泄漏或者应用程序逻辑的不良分配习惯问题，要处理 JVM 内存回收问题的根本方法是对程序进行调优。 有几个常用原则：  减少临时对象，尽量复用内存。 使用对象池。 主动提前释放对象。 主动 gc。 好的代码比 tuning 更重要。 选 gc 算法比 tuning 参数重要，tuning 参数是最后 - magicliang - 守株阁"><meta name="keywords" content="JVM, Java"><meta property="og:image" content="http://magicliang.github.io/2020/09/27/%E7%8E%B0%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/%E6%94%B6%E9%9B%86%E5%99%A8%E5%88%86%E7%B1%BB.jpeg"><meta property="og:image" content="http://magicliang.github.io/2020/09/27/%E7%8E%B0%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8benchmark.jpeg"><meta property="og:image" content="http://magicliang.github.io/2020/09/27/%E7%8E%B0%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/%E4%B8%A4%E7%A7%8D%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87%E5%85%AC%E5%BC%8F.jpeg"><meta property="og:image" content="http://magicliang.github.io/2020/09/27/%E7%8E%B0%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/jvm%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9%E4%B8%8Ecommitted.jpeg"><meta property="og:image" content="http://magicliang.github.io/2020/09/27/%E7%8E%B0%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/%E5%88%86%E6%9E%90%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E6%80%9D%E8%B7%AF.jpeg"><meta property="og:image" content="http://magicliang.github.io/2020/09/27/%E7%8E%B0%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8Fsop.png"><meta property="og:image" content="http://magicliang.github.io/2020/09/27/%E7%8E%B0%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/%E6%A0%B9%E5%9B%A0%E9%B1%BC%E9%AA%A8%E5%9B%BE.png"><meta property="og:image" content="http://magicliang.github.io/2020/09/27/%E7%8E%B0%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/g1-gc-cycle.png"><meta property="og:image" content="http://magicliang.github.io/2020/09/27/%E7%8E%B0%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/g1-regions.jpg"><meta property="og:image" content="http://magicliang.github.io/2020/09/27/%E7%8E%B0%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/global-concurrent-marking.png"><meta property="og:image" content="http://magicliang.github.io/2020/09/27/%E7%8E%B0%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/%E7%9D%80%E8%89%B2%E6%8C%87%E9%92%88.png"><meta property="article:published_time" content="2020-09-27T08:12:22.000Z"><meta property="article:modified_time" content="2022-01-30T10:42:26.647Z"><meta property="og:updated_time" content="2022-01-30T10:42:26.647Z"><meta property="article:author" content="magicliang"><meta property="article:tag" content="JVM, Java"><meta name="twitter:card" content="summary">

    

    <!-- ### Canonical link ### -->
    <link rel="canonical" href="http://magicliang.github.io/2020/09/27/%E7%8E%B0%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/">

    <meta name="generator" content="Hexo 6.0.0">

    <!-- ### Analytics ### -->
    







    <!-- ### Structured Data ### -->
    



<script type="application/ld+json">
{
    "@context": "http://schema.org",
    "url": "http://magicliang.github.io/2020/09/27/%E7%8E%B0%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/",
    "@type": "BlogPosting",
    "logo": "http://magicliang.github.io/img/suka-favicon.ico",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "http://magicliang.github.io/2020/09/27/%E7%8E%B0%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"
    },
    "headline": "现代垃圾收集器 | 守株阁",
    
    "image": {
        "@type": "ImageObject",
        "url": "http://magicliang.github.io/img/suka-favicon.ico"
    },
    
    "datePublished": "2020-09-27T08:12:22.000Z",
    "dateModified": "2022-01-30T10:42:26.647Z",
    "author": {
        "@type": "Person",
        "name": "magicliang",
        "image": {
            "@type": "ImageObject",
            "url": "http://magicliang.github.io/img/default_avatar.png"
        },
        "description": "Hi, nice to meet you."
    },
    "publisher": {
        "@type": "Organization",
        "name": "守株阁",
        "logo": {
            "@type": "ImageObject",
            "url": "http://magicliang.github.io/img/suka-favicon.ico"
        }
    },
    
    "potentialAction": {
        "@type": "SearchAction",
        "target": "http://magicliang.github.io/search?s={search_term_string}",
        "query-input": "required name=search_term_string"
    },
    
    "keywords": "JVM, Java",
    "description": "所有的垃圾收集器，都基于弱分代假设。实际的垃圾回收效率取决于堆内对象的分布状况。垃圾回收并不能解决内存泄漏或者应用程序逻辑的不良分配习惯问题，要处理 JVM 内存回收问题的根本方法是对程序进行调优。 有几个常用原则：  减少临时对象，尽量复用内存。 使用对象池。 主动提前释放对象。 主动 gc。 好的代码比 tuning 更重要。 选 gc 算法比 tuning 参数重要，tuning 参数是最后 - magicliang - 守株阁"
}
</script>



    <!-- ### Custom Head ### -->
    
</head>

    <body>
            

            <!-- ### Main content ### -->
            <!-- ## Header ##-->
<header>
    <h1 class="header-title text-center"><a href="/">守株阁</a></h1>

    <p class="text-center header-slogan">
        
            
                Hi, nice to meet you.
            
        
    </p>

    <nav class="navbar-section text-center">
    
        <a href="/" class="navbar-link">Home</a>
    
    
        <a href="/archives/" class="navbar-link">Archives</a>
    
    
        <a href="/search" class="navbar-link">Search</a>
    
    
    
        <div class="dropdown dropdown-right">
    <a class="navbar-link dropdown-toggle" tabindex="0">Share</a>
    <ul class="menu share-menu">

        <!-- Share Weibo -->
        
        <li class="menu-item">
            <a href="http://service.weibo.com/share/share.php?appkey=&title=守株阁&url=http://magicliang.github.io&pic=http://magicliang.github.io/img/suka-favicon.ico&searchPic=false&style=simple" target="_blank" rel="external noopener noreferrer nofollow">Share to Weibo</a>
        </li>
        

        <!-- Share Twitter -->
        
        <li class="menu-item">
            <a href="https://twitter.com/intent/tweet?text=守株阁&url=http://magicliang.github.io&via=magicliang" target="_blank" rel="external noopener noreferrer nofollow">Share to Twitter</a>
        </li>
        

        <!-- Share Facebook -->
        
        <li class="menu-item">
            <a href="https://www.facebook.com/sharer/sharer.php?u=http://magicliang.github.io" target="_blank" rel="external noopener noreferrer nofollow">Share to Facebook</a>
        </li>
        

        <!-- Share Google+ -->
        
        <li class="menu-item">
            <a href="https://plus.google.com/share?url=http://magicliang.github.io" target="_blank" rel="external noopener noreferrer nofollow">Share to Google+</a>
        </li>
        

        <!-- Share LinkedIn -->
        
        <li class="menu-item">
            <a href="https://www.linkedin.com/shareArticle?mini=true&url=http://magicliang.github.io&title=现代垃圾收集器" target="_blank" rel="external noopener noreferrer nofollow">Share to LinkedIn</a>
        </li>
        

        <!-- Share QQ -->
        
        <li class="menu-item">
            <a href="http://connect.qq.com/widget/shareqq/index.html?site=守株阁&title=现代垃圾收集器&summary=关于技术以及人生&pics=http://magicliang.github.io/img/suka-favicon.ico&url=http://magicliang.github.io" target="_blank" rel="external noopener noreferrer nofollow"> Share to QQ</a>
        </li>
        

        <!-- Share Telegram -->
        
        <li class="menu-item">
            <a href="https://t.me/share/url?url=http://magicliang.github.io&text=现代垃圾收集器" target="_blank" rel="external noopener noreferrer nofollow">Share to Telegram</a>
        </li>
        

        <!-- QRCode -->
        
        <li class="menu-item">
            <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALQAAAC0CAAAAAAYplnuAAACoUlEQVR42u3dwU7DQAxF0f7/T5cVEqDY79pJkKrcbKqSNjmDcMdjT8Xr/YHHS7Ro0aIfiH41x/f5o9f+fP7rwn/ed3TNo/cmh2jRE/ThH33z8yPo0SCrQXTnO4do0RN0FYAp6I7OVwHXXTM5RIu+Ck0njG5wVQBW9xAt+m709CZpMCQ4RYs+i64Cp8KWSQ0Y/O1ZnujHo8nC9j8eL1+Ni34kGhf/ikSoC2DyeGvVVPQj0ZMEiRYQ6XuqxUblEi2aoAl+sgCeDKxLxkSLPoumxfNJ4XyLXCdMokWHJg8JkG4AdDFBkynRoim6a/ykgCSvnwx2XGESLTosAugGFbI4nS4I0oeDaNEUnRqY3XMy8UwnnPK+okUDNA0eciPSPJ0WJEWL3qBJ4jNt8NPGf9rYIlr0WTQdzGSD1bagjgNRtOiiqE4//LcTx2QRjaqmokWfrE/TL+OQyahbHJcTlWjREE2DJF28S7RIwhQTKNGiIZrcqCuwkwbnpQmTaNHLRlFKhkjjkww4DVa06Cm6a/ikzdmTDVybYrxo0Rs0ada/wTEp3nSJFu7YihYNvpzT3XzaFKUbyXGBXrRogCaLTIKn6NRoagcjWjRAp81QJDjpefILaJMu0aIBmnzwb4ouZCKiBU7RoqfozZcMppMHKdzHRYZo0QC9LQ6mIJ0UM0kyJlo0RZOGzqaBTwqSpAgqWvQUTZo6ZMNJLB4OmkplkiVaNECTQnlX/CYL1LRYwO8RLRqgUyCmhnsKrjS40aZa0aIhmjYyN5tLUsDRzViiRU/R200ktFGUNrugRE206AvRaWNgKjDSBAsnTKJFn/yHHWRjFSkw0uKmaNFn0RSTBjEJzhTYbaNItGjQR5xsLJw0lOjzy4s1oh+J/qRDtGjRoh+E/gLuSah2PLd9tQAAAABJRU5ErkJggg==" alr="QRCode">
        </li>
        

    </ul>
</div>
    
    
</nav>
</header>

            
    <!-- ## Post ## -->
    <div class="post-container">
    <div id="post-card" class="card">
        
        <div class="card-item-container">
            <div class="card-inner-cell">
                <!-- # Post Header Info # -->
                <div class="card-header">
                    
    <h1 class="card-title h3 mb-2">现代垃圾收集器</h1>




<div class="post-header-info">
    <p class="post-header-info-left text-gray">
        <img class="author-thumb lazyload" data-src="/img/default_avatar.png" src="/img/suka-lazyload.gif" alt="magicliang's Avatar">
        <span>2020-09-27</span>
        
        
            <!-- Busuanzi Post Views -->
<span id="busuanzi_container_page_pv" hidden>
    <span class="suka-devide-dot"></span>
    <span></span>
    <span id="busuanzi_value_page_pv"></span>
    <span>Views</span>
</span>
        
        
    </p>
    <div class="post-header-info-right">
        
            <div class="dropdown dropdown-right">
<a class="dropdown-toggle" tabindex="0">Share the post</a>
<ul class="menu share-menu">
    <!-- Share Weibo -->
    
    <li class="menu-item">
        <a href="http://service.weibo.com/share/share.php?appkey=&title=现代垃圾收集器&url=http://magicliang.github.io/2020/09/27/%E7%8E%B0%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/&pic=http://magicliang.github.io/img/suka-favicon.ico&searchPic=false&style=simple" target="_blank" rel="external noopener noreferrer nofollow">Share to Weibo</a>
    </li>
    

    <!-- Share Twitter -->
    
    <li class="menu-item">
        <a href="https://twitter.com/intent/tweet?text=现代垃圾收集器&url=http://magicliang.github.io/2020/09/27/%E7%8E%B0%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/&via=magicliang" target="_blank" rel="external noopener noreferrer nofollow">Share to Twitter</a>
    </li>
    

    <!-- Share Facebook -->
    
    <li class="menu-item">
        <a href="https://www.facebook.com/sharer/sharer.php?u=http://magicliang.github.io/2020/09/27/%E7%8E%B0%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/" target="_blank" rel="external noopener noreferrer nofollow">Share to Facebook</a>
    </li>
    

    <!-- Share Google+ -->
    
    <li class="menu-item">
        <a href="https://plus.google.com/share?url=http://magicliang.github.io/2020/09/27/%E7%8E%B0%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/" target="_blank" rel="external noopener noreferrer nofollow">Share to Google+</a>
    </li>
    

    <!-- Share LinkedIn -->
    
    <li class="menu-item">
        <a href="https://www.linkedin.com/shareArticle?mini=true&url=http://magicliang.github.io/2020/09/27/%E7%8E%B0%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/&title=守株阁" target="_blank" rel="external noopener noreferrer nofollow">Share to LinkedIn</a>
    </li>
    

    <!-- Share QQ -->
    
    <li class="menu-item">
        <a href="http://connect.qq.com/widget/shareqq/index.html?site=守株阁&title=守株阁&summary=关于技术以及人生&pics=http://magicliang.github.io/img/suka-favicon.ico&url=http://magicliang.github.io/2020/09/27/%E7%8E%B0%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/" target="_blank" rel="external noopener noreferrer nofollow"> Share to QQ</a>
    </li>
    

    <!-- Share Telegram -->
    
    <li class="menu-item">
        <a href="https://t.me/share/url?url=http://magicliang.github.io/2020/09/27/%E7%8E%B0%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/&text=守株阁" target="_blank" rel="external noopener noreferrer nofollow">Share to Telegram</a>
    </li>
    

    <!-- QRCode -->
    
    <li class="menu-item">
        <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALQAAAC0CAAAAAAYplnuAAACoUlEQVR42u3dwU7DQAxF0f7/T5cVEqDY79pJkKrcbKqSNjmDcMdjT8Xr/YHHS7Ro0aIfiH41x/f5o9f+fP7rwn/ed3TNo/cmh2jRE/ThH33z8yPo0SCrQXTnO4do0RN0FYAp6I7OVwHXXTM5RIu+Ck0njG5wVQBW9xAt+m709CZpMCQ4RYs+i64Cp8KWSQ0Y/O1ZnujHo8nC9j8eL1+Ni34kGhf/ikSoC2DyeGvVVPQj0ZMEiRYQ6XuqxUblEi2aoAl+sgCeDKxLxkSLPoumxfNJ4XyLXCdMokWHJg8JkG4AdDFBkynRoim6a/ykgCSvnwx2XGESLTosAugGFbI4nS4I0oeDaNEUnRqY3XMy8UwnnPK+okUDNA0eciPSPJ0WJEWL3qBJ4jNt8NPGf9rYIlr0WTQdzGSD1bagjgNRtOiiqE4//LcTx2QRjaqmokWfrE/TL+OQyahbHJcTlWjREE2DJF28S7RIwhQTKNGiIZrcqCuwkwbnpQmTaNHLRlFKhkjjkww4DVa06Cm6a/ikzdmTDVybYrxo0Rs0ada/wTEp3nSJFu7YihYNvpzT3XzaFKUbyXGBXrRogCaLTIKn6NRoagcjWjRAp81QJDjpefILaJMu0aIBmnzwb4ouZCKiBU7RoqfozZcMppMHKdzHRYZo0QC9LQ6mIJ0UM0kyJlo0RZOGzqaBTwqSpAgqWvQUTZo6ZMNJLB4OmkplkiVaNECTQnlX/CYL1LRYwO8RLRqgUyCmhnsKrjS40aZa0aIhmjYyN5tLUsDRzViiRU/R200ktFGUNrugRE206AvRaWNgKjDSBAsnTKJFn/yHHWRjFSkw0uKmaNFn0RSTBjEJzhTYbaNItGjQR5xsLJw0lOjzy4s1oh+J/qRDtGjRoh+E/gLuSah2PLd9tQAAAABJRU5ErkJggg==" alt="QRCode">
    </li>
    

</ul>
</div>
        
    </div>
</div>
                </div>
                <div class="card-body">
                    
                        
                        
                            <div id="post-toc"><ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="post-toc-number">1.</span> <span class="post-toc-text">操作系统的影响</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E7%BE%8E%E5%9B%A2%E7%9A%84%E5%AE%9E%E8%B7%B5"><span class="post-toc-number">2.</span> <span class="post-toc-text">美团的实践</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%88%86%E7%B1%BB"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">垃圾收集器分类</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">常用工具</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BB%88%E7%AB%AF"><span class="post-toc-number">2.2.1.</span> <span class="post-toc-text">命令行终端</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%8F%AF%E8%A7%86%E5%8C%96%E7%95%8C%E9%9D%A2"><span class="post-toc-number">2.2.2.</span> <span class="post-toc-text">可视化界面</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%8C%87%E6%A0%87%E8%AF%84%E4%BB%B7%E6%A0%87%E5%87%86"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">指标评价标准</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#gc-%E5%8A%A8%E4%BD%9C%E8%80%97%E6%97%B6"><span class="post-toc-number">2.4.</span> <span class="post-toc-text">gc 动作耗时</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Mutator-%E7%B1%BB%E5%9E%8B"><span class="post-toc-number">2.5.</span> <span class="post-toc-text">Mutator 类型</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%B7%B2%E6%8F%90%E4%BA%A4%E7%9A%84%E5%86%85%E5%AD%98"><span class="post-toc-number">2.6.</span> <span class="post-toc-text">已提交的内存</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%85%B3%E4%BA%8E-XX-DisableExplicitGC%E7%9A%84%E4%BA%89%E8%AE%BA"><span class="post-toc-number">2.7.</span> <span class="post-toc-text">关于-XX:+DisableExplicitGC的争论</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%A6%82%E4%BD%95%E8%BF%BD%E8%B8%AA%E6%96%B0-load-class"><span class="post-toc-number">2.8.</span> <span class="post-toc-text">如何追踪新 load class</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E8%BF%87%E6%97%A9%E6%99%8B%E5%8D%87"><span class="post-toc-number">2.9.</span> <span class="post-toc-text">过早晋升</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%88%86%E6%9E%90%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF"><span class="post-toc-number">2.10.</span> <span class="post-toc-text">分析内存泄漏的基本思路</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#CMS-%E9%80%80%E5%8C%96"><span class="post-toc-number">2.11.</span> <span class="post-toc-text">CMS 退化</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="post-toc-number">2.12.</span> <span class="post-toc-text">堆外内存泄漏</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#GCLocker-Initiated-GC"><span class="post-toc-number">2.13.</span> <span class="post-toc-text">GCLocker Initiated GC</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%A0%B9%E5%9B%A0%E9%B1%BC%E9%AA%A8%E5%9B%BE"><span class="post-toc-number">2.14.</span> <span class="post-toc-text">根因鱼骨图</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%85%B6%E4%BB%96%E5%BB%BA%E8%AE%AE"><span class="post-toc-number">2.15.</span> <span class="post-toc-text">其他建议</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#JVM-%E5%90%AF%E5%8A%A8%E5%8F%82%E6%95%B0"><span class="post-toc-number">2.16.</span> <span class="post-toc-text">JVM 启动参数</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E8%80%81%E7%9A%84%E9%85%8D%E6%AF%94%E5%85%AC%E5%BC%8F"><span class="post-toc-number">2.17.</span> <span class="post-toc-text">老的配比公式</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#GC-%E5%AF%B9%E4%B8%9A%E5%8A%A1%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="post-toc-number">2.18.</span> <span class="post-toc-text">GC 对业务的影响</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="post-toc-number">2.19.</span> <span class="post-toc-text">案例</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%A1%88%E4%BE%8B1"><span class="post-toc-number">2.19.1.</span> <span class="post-toc-text">案例1</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%A1%88%E4%BE%8B2"><span class="post-toc-number">2.19.2.</span> <span class="post-toc-text">案例2</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%A1%88%E4%BE%8B3"><span class="post-toc-number">2.19.3.</span> <span class="post-toc-text">案例3</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#CMS"><span class="post-toc-number">3.</span> <span class="post-toc-text">CMS</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#G1"><span class="post-toc-number">4.</span> <span class="post-toc-text">G1</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#G1-phases"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">G1 phases</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#G1-region"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">G1 region</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%9F%A5%E7%9C%8B-gc-%E6%97%A5%E5%BF%97%E7%9A%84%E5%91%BD%E4%BB%A4"><span class="post-toc-number">4.3.</span> <span class="post-toc-text">查看 gc 日志的命令</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#minor-gc-%E7%9A%84%E6%97%A5%E5%BF%97"><span class="post-toc-number">4.4.</span> <span class="post-toc-text">minor gc 的日志</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#global-concurrent-marking-%E7%9A%84%E6%97%A5%E5%BF%97"><span class="post-toc-number">4.5.</span> <span class="post-toc-text">global concurrent marking 的日志</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%8F%AF%E4%B8%AD%E6%96%AD%E7%9A%84-mixedgc"><span class="post-toc-number">4.6.</span> <span class="post-toc-text">可中断的 mixedgc</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#full-gc"><span class="post-toc-number">4.7.</span> <span class="post-toc-text">full gc</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84-jvm-%E9%85%8D%E7%BD%AE"><span class="post-toc-number">4.8.</span> <span class="post-toc-text">常用的 jvm 配置</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#ZGC"><span class="post-toc-number">5.</span> <span class="post-toc-text">ZGC</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E7%9D%80%E8%89%B2%E6%8C%87%E9%92%88"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">着色指针</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E8%AF%BB%E5%B1%8F%E9%9A%9C"><span class="post-toc-number">5.2.</span> <span class="post-toc-text">读屏障</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#ZGC%E5%B9%B6%E5%8F%91%E5%A4%84%E7%90%86%E6%BC%94%E7%A4%BA"><span class="post-toc-number">5.3.</span> <span class="post-toc-text">ZGC并发处理演示</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84-jvm-%E9%85%8D%E7%BD%AE-1"><span class="post-toc-number">5.4.</span> <span class="post-toc-text">常用的 jvm 配置</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E7%90%86%E8%A7%A3ZGC%E8%A7%A6%E5%8F%91%E6%97%B6%E6%9C%BA"><span class="post-toc-number">5.5.</span> <span class="post-toc-text">理解ZGC触发时机</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E7%90%86%E8%A7%A3ZGC%E6%97%A5%E5%BF%97"><span class="post-toc-number">5.6.</span> <span class="post-toc-text">理解ZGC日志</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E7%90%86%E8%A7%A3-ZGC-%E5%81%9C%E9%A1%BF%E5%8E%9F%E5%9B%A0"><span class="post-toc-number">5.7.</span> <span class="post-toc-text">理解 ZGC 停顿原因</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Shenandoah"><span class="post-toc-number">6.</span> <span class="post-toc-text">Shenandoah</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E6%80%BB%E7%BB%93"><span class="post-toc-number">7.</span> <span class="post-toc-text">总结</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E8%B0%83%E4%BC%98%E7%BB%8F%E9%AA%8C"><span class="post-toc-number">8.</span> <span class="post-toc-text">调优经验</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#C4%EF%BC%88Continuous-Concurrently-Compacting-Collection%EF%BC%89"><span class="post-toc-number">9.</span> <span class="post-toc-text">C4（Continuous Concurrently Compacting Collection）</span></a></li></ol></div>
                        
                    
                    <article id="post-content">
                        <p>所有的垃圾收集器，都基于<a target="_blank" rel="noopener" href="https://www.ps.uni-saarland.de/courses/gc-ws01/slides/generational_gc.pdf">弱分代假设</a>。实际的垃圾回收效率取决于堆内对象的分布状况。垃圾回收并不能解决内存泄漏或者应用程序逻辑的不良分配习惯问题，要处理 JVM 内存回收问题的根本方法是对程序进行调优。</p>
<p>有几个常用原则：</p>
<ul>
<li>减少临时对象，尽量复用内存。</li>
<li>使用对象池。</li>
<li>主动提前释放对象。</li>
<li>主动 gc。</li>
<li>好的代码比 tuning 更重要。</li>
<li>选 gc 算法比 tuning 参数重要，tuning 参数是最后一步。</li>
</ul>
<p>其他情况，可以通过 tuning garbage collector 来解决。</p>
<h1 id="操作系统的影响"><a href="#操作系统的影响" class="headerlink" title="操作系统的影响"></a>操作系统的影响</h1><ul>
<li>SWAP 可能会显著增加 GC 时间，因为被换出的堆还要被换入。</li>
</ul>
<h1 id="美团的实践"><a href="#美团的实践" class="headerlink" title="美团的实践"></a>美团的实践</h1><p>参考：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/2017/12/29/jvm-optimize.html">《从实际案例聊聊Java应用的GC优化》</a></li>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/2020/11/12/java-9-cms-gc.html">《Java中9种常见的CMS GC问题分析与解决》</a></li>
</ol>
<ul>
<li>Minor GC</li>
<li>Major GC</li>
<li>Full GC</li>
</ul>
<h2 id="垃圾收集器分类"><a href="#垃圾收集器分类" class="headerlink" title="垃圾收集器分类"></a>垃圾收集器分类</h2><p><img src="%E6%94%B6%E9%9B%86%E5%99%A8%E5%88%86%E7%B1%BB.jpeg" alt="收集器分类"></p>
<p><img src="%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8benchmark.jpeg" alt="垃圾收集器benchmark"></p>
<p>可以看到一个现象：在大部分时候，g1 比 cms 快，但极端的百分位里，cms比 g1 快。</p>
<h2 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h2><h3 id="命令行终端"><a href="#命令行终端" class="headerlink" title="命令行终端"></a>命令行终端</h3><blockquote>
<ul>
<li>标准终端类：jps、jinfo、jstat、jstack、jmap</li>
<li>功能整合类：jcmd、vjtools、arthas、greys</li>
</ul>
</blockquote>
<h3 id="可视化界面"><a href="#可视化界面" class="headerlink" title="可视化界面"></a>可视化界面</h3><blockquote>
<ul>
<li>简易：JConsole、JVisualvm、HA、GCHisto、GCViewer</li>
<li>进阶：MAT、JProfiler</li>
</ul>
<p>命令行推荐 arthas ，可视化界面推荐 JProfiler，此外还有一些在线的平台 gceasy、heaphero、fastthread<br>，美团内部的 Scalpel（一款自研的 JVM 问题诊断工具，暂时未开源）也比较好用。</p>
</blockquote>
<h2 id="指标评价标准"><a href="#指标评价标准" class="headerlink" title="指标评价标准"></a>指标评价标准</h2><p>评判 GC 的两个核心指标：</p>
<ul>
<li><p>延迟（Latency）： 也可以理解为最大停顿时间，即垃圾收集过程中一次 STW 的最长时间，越短越好，一定程度上可以接受频次的增大，GC 技术的主要发展方向。</p>
</li>
<li><p>吞吐量（Throughput）： 应用系统的生命周期内，由于 GC 线程会占用 Mutator 当前可用的 CPU 时钟周期，吞吐量即为 Mutator 有效花费的时间占系统总运行时间的百分比，例如系统运行了 100 min，GC 耗时 1 min，则系统吞吐量为 99%，吞吐量优先的收集器可以接受较长的停顿。</p>
</li>
</ul>
<p><img src="%E4%B8%A4%E7%A7%8D%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87%E5%85%AC%E5%BC%8F.jpeg" alt="两种评价指标公式"></p>
<blockquote>
<p>简而言之，即为一次停顿的时间不超过应用服务的 TP9999，GC 的吞吐量不小于 99.99%。举个例子，假设某个服务 A 的 TP9999<br>为 80 ms，平均 GC 停顿为 30 ms，那么该服务的最大停顿时间最好不要超过 80 ms，GC 频次控制在 5 min<br>以上一次。如果满足不了，那就需要调优或者通过更多资源来进行并联冗余。（大家可以先停下来，看看监控平台上面的 gc.meantime<br>分钟级别指标，如果超过了 6 ms 那单机 GC 吞吐量就达不到 4 个 9 了。）</p>
</blockquote>
<h2 id="gc-动作耗时"><a href="#gc-动作耗时" class="headerlink" title="gc 动作耗时"></a>gc 动作耗时</h2><p>比较容易被忽略的是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">compaction &gt;= copying &gt; mark &gt; sweep</span><br><span class="line">mark + sweep &gt; copying</span><br></pre></td></tr></table></figure>

<p>所以年轻代的扫描如果大头是 copying 就会非常快。</p>
<h2 id="Mutator-类型"><a href="#Mutator-类型" class="headerlink" title="Mutator 类型"></a>Mutator 类型</h2><blockquote>
<p>Mutator 的类型根据对象存活时间比例图来看主要分为两种，在弱分代假说中也提到类似的说法，如下图所示 “Survival Time”<br>表示对象存活时间，“Rate” 表示对象分配比例：</p>
<ul>
<li><p>IO 交互型： 互联网上目前大部分的服务都属于该类型，例如分布式 RPC、MQ、HTTP 网关服务等，对内存要求并不大，大部分对象在 TP9999 的时间内都会死亡， Young 区越大越好。</p>
</li>
<li><p>MEM 计算型： 主要是分布式数据计算 Hadoop，分布式存储 HBase、Cassandra，自建的分布式缓存等，对内存要求高，对象存活时间长，Old 区越大越好。</p>
</li>
</ul>
</blockquote>
<p>值得注意的是，中间件都是 IO 密集型应用，只要调大 young 区就可以解决问题，大部分的 young 区的收集器效果差异不大，Hadoop之类的业务反而需要 CMS/G1的调优。</p>
<h2 id="已提交的内存"><a href="#已提交的内存" class="headerlink" title="已提交的内存"></a>已提交的内存</h2><p><img src="jvm%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9%E4%B8%8Ecommitted.jpeg" alt="jvm动态扩容与committed"></p>
<p>注意看，已使用内存对 JVM而言就是 committed memory。The committed memory is a sum of all of the memory which has been allocated by processes, even if it has not been “used” by them as of yet.</p>
<p>我们可以把动态扩容引起的空间震荡称作 thrash caused by heap expansion。</p>
<h2 id="关于-XX-DisableExplicitGC的争论"><a href="#关于-XX-DisableExplicitGC的争论" class="headerlink" title="关于-XX:+DisableExplicitGC的争论"></a>关于<code>-XX:+DisableExplicitGC</code>的争论</h2><blockquote>
<p>此处补充一个知识点，CMS GC 共分为 Background 和 Foreground<br>两种模式，前者就是我们常规理解中的并发收集，可以不影响正常的业务线程运行，但 Foreground Collector<br>却有很大的差异，他会进行一次压缩式 GC。此压缩式 GC 使用的是跟 Serial Old GC 一样的 Lisp2 算法，其使用<br>Mark-Compact 来做 Full GC，一般称之为 MSC（Mark-Sweep-Compact），它收集的范围是 Java 堆的<br>Young 区和 Old 区以及 MetaSpace。由上面的算法章节中我们知道 compact 的代价是巨大的，那么使用<br>Foreground Collector 时将会带来非常长的 STW。如果在应用程序中 System.gc 被频繁调用，那就非常危险了。</p>
</blockquote>
<p>这里提到的 Foreground 可以被<code>System.gc</code>显式触发<code>MSC（Mark-Sweep-Compact）</code>导致。</p>
<p>但值得注意的是：</p>
<blockquote>
<p>目前互联网中的 RPC 通信会大量使用 NIO</p>
</blockquote>
<p>这也就意味着堆外内存的收集有时候是必须的-因为 NIO内部自己触发垃圾收集也需要引用 <code>System.gc</code> 的能力。不过要配合<code>XX:+ExplicitGCInvokesConcurrent</code>、<code>-Dsun.rmi.dgc.client.gcInterval</code>、<code>-Dsun.rmi.dgc.server.gcInterval</code>一起使用。</p>
<p>值得关注的资料有：</p>
<ol>
<li><a target="_blank" rel="noopener" href="http://lovestblog.cn/blog/2015/05/12/direct-buffer/">《JVM源码分析之堆外内存完全解读》</a></li>
</ol>
<h2 id="如何追踪新-load-class"><a href="#如何追踪新-load-class" class="headerlink" title="如何追踪新 load class"></a>如何追踪新 load class</h2><p><code>jcmd &lt;PID&gt; GC.class_stats|awk &#39;&#123;print$13&#125;&#39;|sed  &#39;s/\(.*\)\.\(.*\)/\1/g&#39;|sort |uniq -c|sort -nrk1</code></p>
<p>如果有必要，使用<code>-XX:+TraceClassLoading</code>和<code>-XX:+TraceClassUnLoading</code></p>
<h2 id="过早晋升"><a href="#过早晋升" class="headerlink" title="过早晋升"></a>过早晋升</h2><p>一个容易被忽略的过早晋升的原因是，<strong>分配速率接近于晋升速率，对象晋升年龄较小</strong>。通常产生这个问题的根因是 young 区过小。如果一次 Major GC 后 tenured 或者 humongous 的区域大规模减少，则其实老年代里的对象大部分都是过早晋升的对象。<br>注意：MaxTenuringThreshold 最大值为 15（因为 JVM 中使用 4 个比特来表示对象的年龄）。</p>
<h2 id="分析内存泄漏的基本思路"><a href="#分析内存泄漏的基本思路" class="headerlink" title="分析内存泄漏的基本思路"></a>分析内存泄漏的基本思路</h2><p><img src="%E5%88%86%E6%9E%90%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E6%80%9D%E8%B7%AF.jpeg" alt="分析内存泄漏的思路"></p>
<p>两次 dump，diff 顽固分子。不过捕捉 gc 前后的堆非常困难。</p>
<p>频繁 Major GC 或者 Major GC 时间过长，通常指向程序内存泄漏或者空间过小-程序内存泄漏触发的频繁 ygc 可能会让它提前晋升了。</p>
<h2 id="CMS-退化"><a href="#CMS-退化" class="headerlink" title="CMS 退化"></a>CMS 退化</h2><p>MSC 的出现就意味着真正意义上的 Full GC 出现了，这种时候我们的要调优 CMS 的执行频率，让高水位的 GC 问题通过 GC 前置来解决。</p>
<h2 id="堆外内存泄漏"><a href="#堆外内存泄漏" class="headerlink" title="堆外内存泄漏"></a>堆外内存泄漏</h2><blockquote>
<p>内存使用率不断上升，甚至开始使用 SWAP 内存，同时可能出现 GC 时间飙升，线程被 Block 等现象，通过 top 命令发现 Java<br>进程的 RES 甚至超过了 -Xmx 的大小。出现这些现象时，基本可以确定是出现了堆外内存泄漏。</p>
</blockquote>
<p>也就是说堆外内存的数据除了 NMT 来确定，也可以通过 RES 来确定。</p>
<blockquote>
<p>首先，我们需要确定是哪种原因导致的堆外内存泄漏。这里可以使用 NMT（NativeMemoryTracking） 进行分析。在项目中添加<br>-XX:NativeMemoryTracking=detail JVM参数后重启项目（需要注意的是，打开 NMT 会带来 5%~10% 的性能损耗）。使用命令 jcmd pid VM.native_memory detail 查看内存分布。重点观察 total 中的<br>committed，因为 jcmd 命令显示的内存包含堆内内存、Code 区域、通过 Unsafe.allocateMemory 和<br>DirectByteBuffer 申请的内存，但是不包含其他 Native Code（C 代码）申请的堆外内存。</p>
<p>如果 total 中的 committed 和 top 中的 RES<br>相差不大，则应为主动申请的堆外内存未释放造成的，如果相差较大，则基本可以确定是 JNI 调用造成的。</p>
</blockquote>
<p>整体而言，堆外内存的分布是不透明的，目前没有工具可以简单地告诉我们全部的堆外内存的分布情况，只能间接推算出问题的根因，转而去代码里寻找原因。</p>
<p><img src="%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8Fsop.png" alt="堆外内存泄漏sop"></p>
<h2 id="GCLocker-Initiated-GC"><a href="#GCLocker-Initiated-GC" class="headerlink" title="GCLocker Initiated GC"></a>GCLocker Initiated GC</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2020-09-23T16:49:09.812+0800: 504426.827: [Full GC (GCLocker Initiated GC) 504426.827: [CMS: 1341583K-&gt;419699K(2097152K), 1.8482275 secs] 1347626K-&gt;419699K(3984640K), [Metaspace: 297780K-&gt;297780K(1329152K)], 1.8490564 secs] [Times: user=1.62 sys=0.20, real=1.85 secs]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>由于 Native 代码直接使用了 JVM 堆区的指针，如果这时发生 GC，就会导致数据错误。因此，在发生此类 JNI 调用时，禁止 GC<br>的发生，同时阻止其他线程进入 JNI 临界区，直到最后一个线程退出临界区时触发一次 GC。</p>
</blockquote>
<blockquote>
<p>添加 -XX+PrintJNIGCStalls 参数，可以打印出发生 JNI 调用时的线程，进一步分析，找到引发问题的 JNI 调用。</p>
</blockquote>
<p>GC 调优的三大思路（解决这些问题的 ROI 从高到低）：</p>
<ol>
<li>代码问题</li>
<li>区域配置问题</li>
<li>垃圾回收行为问题</li>
</ol>
<h2 id="根因鱼骨图"><a href="#根因鱼骨图" class="headerlink" title="根因鱼骨图"></a>根因鱼骨图</h2><p><img src="%E6%A0%B9%E5%9B%A0%E9%B1%BC%E9%AA%A8%E5%9B%BE.png" alt="根因鱼骨图"></p>
<h2 id="其他建议"><a href="#其他建议" class="headerlink" title="其他建议"></a>其他建议</h2><blockquote>
<ul>
<li>主动式 GC： 也有另开生面的做法，通过监控手段监控观测 Old 区的使用情况，即将到达阈值时将应用服务摘掉流量，手动触发一次 Major GC，减少 CMS GC 带来的停顿，但随之系统的健壮性也会减少，如非必要不建议引入。</li>
<li>禁用偏向锁： 偏向锁在只有一个线程使用到该锁的时候效率很高，但是在竞争激烈情况会升级成轻量级锁，此时就需要先消除偏向锁，这个过程是 STW 的。如果每个同步资源都走这个升级过程，开销会非常大，所以在已知并发激烈的前提下，一般会禁用偏向锁</li>
<li>XX:-UseBiasedLocking 来提高性能。</li>
<li>虚拟内存： 启动初期有些操作系统（例如 Linux）并没有真正分配物理内存给 JVM ，而是在虚拟内存中分配，使用的时候才会在物理内存中分配内存页，这样也会导致 GC 时间较长。这种情况可以添加</li>
<li>XX:+AlwaysPreTouch 参数，让 VM 在 commit 内存时跑个循环来强制保证申请的内存真的 commit，避免运行时触发缺页异常。在一些大内存的场景下，有时候能将前几次的 GC<br>时间降一个数量级，但是添加这个参数后，启动的过程可能会变慢。</li>
</ul>
</blockquote>
<p>所以 AlwaysPreTouch 会让 reserved 内存变成 committed内存。</p>
<h2 id="JVM-启动参数"><a href="#JVM-启动参数" class="headerlink" title="JVM 启动参数"></a>JVM 启动参数</h2><table>
<thead>
<tr>
<th align="center">分类</th>
<th align="center">参数</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">基本参数</td>
<td align="center">-XX:+PrintGCDetails、-XX:+PrintGCDateStamps、-XX:+PrintGCTimeStamps</td>
<td align="center">GC 日志的基本参数</td>
</tr>
<tr>
<td align="center">时间相关</td>
<td align="center">-XX:+PrintGCApplicationConcurrentTime、-XX:+PrintGCApplicationStoppedTime</td>
<td align="center">详细步骤的并行时间，STW 时间等等</td>
</tr>
<tr>
<td align="center">年龄相关</td>
<td align="center">-XX:+PrintTenuringDistribution</td>
<td align="center">可以观察 GC 前后的对象年龄分布，方便发现过早晋升问题</td>
</tr>
<tr>
<td align="center">引用相关</td>
<td align="center">-XX:+PrintReferenceGC</td>
<td align="center">观察系统的软引用，弱引用，虚引用等回收情况</td>
</tr>
<tr>
<td align="center">空间变化</td>
<td align="center">-XX:+PrintHeapAtGC</td>
<td align="center">各个空间在 GC 前后的回收情况，非常详细</td>
</tr>
</tbody></table>
<h2 id="老的配比公式"><a href="#老的配比公式" class="headerlink" title="老的配比公式"></a>老的配比公式</h2><table>
<thead>
<tr>
<th align="center">空间</th>
<th align="center">倍数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">总大小</td>
<td align="center">3-4 倍活跃数据的大小</td>
</tr>
<tr>
<td align="center">新生代</td>
<td align="center">1-1.5 活跃数据的大小</td>
</tr>
<tr>
<td align="center">老年代</td>
<td align="center">2-3 倍活跃数据的大小</td>
</tr>
<tr>
<td align="center">永久代</td>
<td align="center">1.2-1.5 倍Full GC后的永久代空间占用</td>
</tr>
</tbody></table>
<p>例如，根据GC日志获得老年代的活跃数据大小为300M，那么各分区大小可以设为：<br>先计算新生代的大小，再反推其他堆的大小。</p>
<blockquote>
<p>总堆：1200MB = 300MB × 4* 新生代：450MB = 300MB × 1.5* 老年代： 750MB = 1200MB - 450MB*</p>
</blockquote>
<h2 id="GC-对业务的影响"><a href="#GC-对业务的影响" class="headerlink" title="GC 对业务的影响"></a>GC 对业务的影响</h2><blockquote>
<p>明确应用程序的系统需求是性能优化的基础，系统的需求是指应用程序运行时某方面的要求，譬如： </p>
<ul>
<li>高可用，可用性达到几个9。 </li>
<li>低延迟，请求必须多少毫秒内完成响应。 </li>
<li>高吞吐，每秒完成多少次事务。</li>
</ul>
<p>明确系统需求之所以重要，是因为上述性能指标间可能冲突。比如通常情况下，缩小延迟的代价是<strong>降低吞吐量或者消耗更多的内存或者两者同时发生</strong>。</p>
</blockquote>
<p>延迟和吞吐量和内存占用中存在一个不可能三角形。</p>
<blockquote>
<p>举例：假设单位时间T内发生一次持续25ms的GC，接口平均响应时间为50ms，且请求均匀到达，根据下图所示：</p>
</blockquote>
<p>![gc 时间线](gc 时间线.png)</p>
<blockquote>
<p>那么有(50ms+25ms)/T比例的请求会受GC影响，其中GC前的50ms内到达的请求都会增加25ms，GC期间的25ms内到达的请求，会增加0-25ms不等，如果时间T内发生N次GC，<strong>受GC影响请求占比=(接口响应时间+GC时间)×N/T</strong><br>。可见无论降低单次GC时间还是降低GC次数N都可以有效减少GC对响应时间的影响。</p>
</blockquote>
<p>为什么接口响应时间内的请求受影响呢，因为 50ms 的请求都没有走完自己的生命周期，就被停顿。</p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h3><blockquote>
<p>Minor GC每分钟100次 ，Major GC每4分钟一次，单次Minor GC耗时25ms，单次Major<br>GC耗时200ms，接口响应时间50ms。</p>
<p>（50ms+25ms）× 100次/60000ms = 12.5%，50ms × 100次/60000ms = 8.3% 。</p>
</blockquote>
<p>按照通常的观点，每分钟 100 次 Minor GC 是很频繁的，这也意味着 Eden 区过小。</p>
<blockquote>
<p>更重要的是对于虚拟机来说，复制对象的成本要远高于扫描成本</p>
</blockquote>
<p>这句话存疑，从现代的 gc 日志来看，单纯 scan 的时间非常久，copy 的时间非常短。</p>
<p>这个案例的意思是：</p>
<p>如果新生代临时对象非常多，而新生代非常小，则对象晋升非常快，既会导致频繁的 Minor GC，也会导致频繁的 Major GC。所以足够大的 young 区会总体降低 gc 的频次，而不会显著提升单次 Minor GC 的时间。</p>
<h3 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h3><p>cms 的 remark <strong>不能只扫描老年代，只能全堆扫描（新生代+老年代）</strong>。由此可见堆中对象的数目影响了Remark阶段耗时。<br>remark 的时间久意味着新生代的使用率比较高（反过来也一样），而触发了较多的跨代引用（注意，remark 是 MajorGC cms 的一个阶段<br>）。remark 存在的意义就是正确地校正浮动垃圾的影响。这种类似活锁的问题在两类线程并发时是难以彻底解决的。</p>
<blockquote>
<p>降低Remark阶段耗时问题转换成如何减少新生代对象数量。</p>
</blockquote>
<blockquote>
<p>新生代GC和老年代的GC是各自分开独立进行的，只有 Minor GC 时才会使用根搜索算法</p>
</blockquote>
<p>这句话存疑，至少对 g1 而言，根搜索算法是不局限于年轻代的。</p>
<p>可以使用 CMSScavengeBeforeRemark 配合 CMSMaxAbortablePrecleanTime 参数，强制在 remark 之前进行 preclean（<strong>也就是一次隐藏的 Minor GC</strong>），可以减少 Remark 的耗时（<strong>这样可以减少跨代引用扫描的时间</strong>）。因为这个隐藏的 preclean存在，并发标记也并不一定是纯并发的。</p>
<p>新生代持有老年代多是正常的，老年代持有新生代的比例不足 1%，所以只要使用一个抽象的卡表来代表老年代的 dirty 情况，就可以用空间换时间，而避免 <strong>Minor GC</strong> 的问题。</p>
<h3 id="案例3"><a href="#案例3" class="headerlink" title="案例3"></a>案例3</h3><blockquote>
<p>首先，什么时候可能会触发STW的Full GC呢？ </p>
<ol>
<li>Perm空间不足； </li>
<li>CMS GC时出现promotion failed和concurrent mode failure（concurrent mode failure发生的原因一般是CMS正在进行，但是由于老年代空间不足，需要尽快回收老年代里面的不再被使用的对象，这时停止所有的线程，同时终止CMS，直接进行Serial<br>Old GC）； </li>
<li>统计得到的Young GC晋升到老年代的平均大小大于老年代的剩余空间； </li>
<li>主动触发Full GC（执行jmap -histo:live [pid]）来避免碎片问题。</li>
</ol>
</blockquote>
<p>解决方法：</p>
<ol>
<li>Perm 区不要扩容，一开始就锁定资源。</li>
<li>使用 CMSPermGenSweepingEnabled、CMSClassUnloadingEnabled-这要求有动态类可以被回收，如果大量的类不是可回收的动态类，那么方案 1 才有用。</li>
</ol>
<h1 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h1><p>CMS 的垃圾收集器默认在新生代就使用 ParNew，ParNew 天然是个 STW 收集器。</p>
<p>ParNew 使用标记-复制算法。标记-复制算法可以分为三个阶段：</p>
<ul>
<li>标记阶段，即从GC Roots集合开始，标记活跃对象；</li>
<li>转移阶段，即把活跃对象复制到新的内存地址上；</li>
<li>重定位阶段，因为转移导致对象的地址发生了变化，在重定位阶段，所有指向对象旧地址的指针都要调整到对象新的地址上。</li>
</ul>
<p>CMS 是个并发收集器。其操作步骤包括：</p>
<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>再标记</li>
<li>并发收集</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/363">CMS 将在 Java 14 中被 removed 掉</a>。</p>
<p>ParallelGCThreads 可以和 ParNew，Parallel Scavenge 一起工作，却不能改变 CMS 的线程数。</p>
<p>Parallel Scavenge 与 G1都可以设置停顿时间目标（都是 MaxGCPauseMillis，不过 PS 是 young 区收集器，G1 是全区收集器，PS 有个 PS old，算是 parallel 化的 serial），CMS 却偏偏没有。</p>
<h1 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h1><p>老的垃圾收集器总是面临几个问题：</p>
<ul>
<li>所有针对老年代的操作必须扫描整个老年代空间；</li>
<li>年轻代和老年代是独立的连续的内存块，必须先决定年轻代和老年代在虚拟地址空间的位置。</li>
</ul>
<p>G1是一种服务端应用使用的垃圾收集器，目标是用在多核、大内存的机器上，它在大多数情况下可以实现指定的GC暂停时间（因为它引入了更好的停顿预测模型），同时还能保持较高的吞吐量。</p>
<p>G1的缺点是：停顿预测模型还不够智能-即使使用了 pre-write barrier 和 post-write barrier。 并发标记的准确度不够高，所以需要重标记，甚至依然有 concurrent mode 失败的场景。</p>
<p>G1 在发生垃圾回收的前后，各种 region 的配比会变化，比如：Eden: 3072.0K(194.0M)-&gt;0.0B(201.0M) 显示垃圾回收后，有 7mb 的 region 增加给了 eden 区。如果不指定 region，则 G1 会根据实际可用的机器内存大小来决定 region，尽量达到 2048 region。</p>
<p>这种调整 young 区、tenure 区的行为会在 <strong>mixedgc</strong> 或者<strong>冷启动</strong>的时候发生得很剧烈，会造成一波 stw 的小高潮，这在有高峰时段的服务上小心谨慎。</p>
<h2 id="G1-phases"><a href="#G1-phases" class="headerlink" title="G1 phases"></a>G1 phases</h2><p><img src="g1-gc-cycle.png" alt="g1-gc-cycle.png"><br>其中：</p>
<ul>
<li>蓝色 Young-only</li>
<li>黄色 标记过程的停顿</li>
<li>红色 Mixed gc 停顿</li>
</ul>
<h2 id="G1-region"><a href="#G1-region" class="headerlink" title="G1 region"></a>G1 region</h2><p><img src="g1-regions.jpg" alt="g1-regions.jpg"></p>
<p>关于 gc 日志可以参考<a target="_blank" rel="noopener" href="https://dzone.com/articles/understanding-g1-gc-log-format">《Understanding G1 GC Log Format》</a>。</p>
<p>在 jvm 里，minor gc 是一种 minor gc event。</p>
<h2 id="查看-gc-日志的命令"><a href="#查看-gc-日志的命令" class="headerlink" title="查看 gc 日志的命令"></a>查看 gc 日志的命令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -rn --color &quot;G1 Evacuation Pause&quot; gc.log.20210923 | grep &quot;2021-10-04T11:11&quot;</span><br></pre></td></tr></table></figure>

<h2 id="minor-gc-的日志"><a href="#minor-gc-的日志" class="headerlink" title="minor gc 的日志"></a>minor gc 的日志</h2><blockquote>
<p>发生在年轻代的GC算法，一般对象（除了巨型对象）都是在eden region中分配内存，当所有eden<br>region被耗尽无法申请内存时，就会触发一次young gc，这种触发机制和之前的young gc差不多，执行完一次young<br>gc，活跃对象会被拷贝到survivor region或者晋升到old<br>region中，空闲的region会被放入空闲列表中，等待下次被使用。</p>
</blockquote>
<p>ParallelTime 到 Eden 就是 PrintGCDetails 的结果。</p>
<p>一般 8 核的 cpu，就会产生 8 个<strong>并行 gc worker 线程</strong>。</p>
<p>从这个图我们也可以看出，如果让 g1 自己选择 region 里面新老分布的比例的话，（通常）young 会多小（在一个 4g 的堆上，可能只有 200m 的年轻代），g1 的年轻代往往会有一个自动扩容的过程。如果 gc 时间不到 10ms，real 都显示不出来。</p>
<h2 id="global-concurrent-marking-的日志"><a href="#global-concurrent-marking-的日志" class="headerlink" title="global concurrent marking 的日志"></a>global concurrent marking 的日志</h2><p>InitiatingHeapOccupancyPercent 到了是最容易触发触发并发收集的。</p>
<p>Percentage of the (entire) heap occupancy to start a concurrent GC cycle. GCs that trigger a concurrent GC cycle based on the occupancy of the entire heap and not just one of the generations, including G1, use this option. A value of 0 denotes ‘do constant GC cycles’. The default value is 45.</p>
<p>但实际上我们在实践中发现，8g 的堆，y 区到了 4g 的满状态，也只是触发 ygc，而不是 mixed gc。</p>
<p><img src="global-concurrent-marking.png" alt="global-concurrent-marking.png"></p>
<p>现实中的 Concurrent Cycles 往往会执行一轮又一轮，直到内存空间的比例降到足够低的水位为止。</p>
<p>搜索 GC pause 可以看到各种各样的 gc 停顿。要找混合垃圾回收直接搜“mixed GCs”或者“(G1 Evacuation Pause) (mixed)”。</p>
<p>实际上 mixed 的 phase 之间的顺序是：young -&gt; initial mark -&gt; concurrent mark 的其他阶段 + clean up -&gt; young -&gt; mixed gc。其中 initial mark 的时间最久，整体来讲也是 stw 的。concurrent clean up 的 stw 一般不会被 jmx 工具统计到，但它的时间非常长，而且混合了并发和 stw 的事件。</p>
<p>一般的 gc 日志的顺序是“[GC pause (G1 Evacuation Pause) (young)” -&gt; “concurrent-root-region-scan-start” -&gt; “Concurrent Cycles” -&gt; “ [GC pause (G1 Evacuation Pause) (young)” -&gt; “[G1Ergonomics (Mixed GCs) start mixed GCs” -&gt;“(G1 Evacuation Pause) (mixed)”（这一步会循环执行）。</p>
<p>每次 gc 开始时，Heap before GC invocations=15872 (full 0)，其中invocations=15872是自JVM启动以来，执行GC的次数。每一次 initial-mark，这个值就会加 1。</p>
<h2 id="可中断的-mixedgc"><a href="#可中断的-mixedgc" class="headerlink" title="可中断的 mixedgc"></a>可中断的 mixedgc</h2><blockquote>
<p>一旦收集器确定了 GC 回收集 并且 GC 回收、整理工作已经开始，这个过程是without stopping的，即 G1<br>收集器必须完成收集集合的所有区域中的所有活动对象之后才能停止；但是如果收集器选择过大的 GC<br>回收集，此时的STW时间会过长超出目标pause time。</p>
<p>这种情况在mixed collections时候比较明显。这个特性启动了一个机制，当选择了一个比较大的collection<br>set，Java12 中将把 GC 回收集（混合收集集合）拆分为mandatory（必需或强制）及optional两部分(<br>当完mandatory的部分，如果还有剩余时间则会去处理optional部分)来将mixed collections从without<br>stopping变为abortable，以更好满足指定pause time的目标。</p>
<p>其中必需处理的部分包括 G1 垃圾收集器不能递增处理的 GC 回收集的部分（如：年轻代），同时也可以包含老年代以提高处理效率。</p>
<p>将 GC 回收集拆分为必需和可选部分时，垃圾收集过程优先处理必需部分。同时，需要为可选 GC 回收集部分维护一些其他数据，这会产生轻微的<br>CPU 开销，但小于 1 ％的变化，同时在 G1 回收器处理 GC 回收集期间，本机内存使用率也可能会增加，使用上述情况只适用于包含可选<br>GC 回收部分的 GC 混合回收集合。</p>
</blockquote>
<p>参考：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/androidsuperman/p/11742876.html">《Java12新特性 – 可中断的 G1 Mixed GC》</a></li>
</ol>
<h2 id="full-gc"><a href="#full-gc" class="headerlink" title="full gc"></a>full gc</h2><p>Full GC (Allocation Failure) 是最常见的 fgc 的原因。</p>
<h2 id="常用的-jvm-配置"><a href="#常用的-jvm-配置" class="headerlink" title="常用的 jvm 配置"></a>常用的 jvm 配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#jvm arg</span></span><br><span class="line">-server -Dfile.encoding=UTF-8 -Dsun.jnu.encoding=UTF-8 -Djava.io.tmpdir=/tmp -Djava.net.preferIPv6Addresses=<span class="literal">false</span> -Duser.timezone=GMT+08</span><br><span class="line"></span><br><span class="line"><span class="comment"># jvm gc</span></span><br><span class="line">-XX:+AlwaysPreTouch -XX:CICompilerCount=4 -XX:ErrorFile=/var/company/logs/com.company.application/vmerr.log.20200928 -XX:G1HeapRegionSize=4194304 -XX:GCLogFileSize=10485760 -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDum      pPath=/var/company/logs/com.company.application/heaperr.log.20200928 -XX:InitialHeapSize=4294967296 -XX:InitiatingHeapOccupancyPercent=40 -XX:MaxGCPauseMillis=100 -XX:MaxHeapSize=4294967296 -XX:MaxMetaspaceSize=536870912 -XX:MetaspaceSize=536870912 -XX:NumberOfGCLogFiles=10 -XX:+PrintAdaptiveSizePolicy -XX:+PrintFlagsFinal -XX:+PrintGC -XX:+PrintGCApplicationS      toppedTime -XX:+PrintGCDateStamps -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintHeapAtGC -XX:+PrintStringTableStatistics       -XX:+PrintTenuringDistribution -XX:ThreadStackSize=512 -XX:+TieredCompilation -XX:-UseBiasedLocking -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseG1GC -XX:-UseGCLogFileRotation</span><br><span class="line"></span><br><span class="line"><span class="comment"># jvm heap</span></span><br><span class="line">-Xss512k -Xmx$(实际内存/2)m -Xms$(实际内存/2)m -XX:MetaspaceSize=$(实际内存/16)m -XX:MaxMetaspaceSize=$(实际内存/16)m -XX:+AlwaysPreTouch -XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一种能够把 avg ygc 控制在 10ms 到 20ms 之间，一分钟 avg 的 ygc count 的配置</span></span><br><span class="line">JVM_HEAP=<span class="string">&quot;-XX:NewRatio=1 -XX:SurvivorRatio=208 -XX:MaxTenuringThreshold=7&quot;</span></span><br><span class="line">JVM_SIZE=<span class="string">&quot;-Xms7G -Xmx7G &quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># JVM 的参数里的名词就是被除数</span></span><br><span class="line"><span class="comment"># NewRatio=1 old 区和 young 区的比例是1:1，常态是 2，也就是 old 是 young 的 2 倍。young 非常大，大量的对象可以进入 young 区而触发触发 ygc 的时机比较少。</span></span><br><span class="line"><span class="comment"># SurvivorRatio=208 eden 是 s2（to）的 208 倍。所以 eden 非常非常大。s 非常小，所以回收目标要么快速进入 s 区（因为 s 区很小），要么快速进入 old 区。</span></span><br><span class="line"><span class="comment"># MaxTenuringThreshold=7 对象停留在 s 区的时机非常小，小到很快就进入 old 区。</span></span><br><span class="line"><span class="comment"># old 区每次回收 3g 左右的堆，需要经过7次 mixed gc，每次 10ms-20ms。每轮 mixed gc 回收 old 区 200mb 到 400mb，每一次 ygc 会让 old 区增长 0.x MB。</span></span><br><span class="line"><span class="comment"># 总结：先扩大 young 区，然后扩大 eden 区，然后缩小 tenuring threshold。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">问题是为什么这样能够起作用呢？这个配置本身是按比例配置的，大致上是可伸缩的。</span><br><span class="line">只能认为尽量让 eden 区的 gc 时间延迟，而把不能回收进 s 区的对象扔到 old 区去。理论上 MaxTenuringThreshold 调得很高可能会让 JVM 表现得更好（前提是每次回收完 S 区并不显著增大，否则动态年龄计算也能够起到调节 MaxTenuringThreshold 的作用）。</span><br><span class="line"></span><br><span class="line">对于 young 区的调优的基本思路是：</span><br><span class="line">1. 尽量增大年轻大的大小和 eden 的比例，来降低 young 区的 gc 频次。</span><br><span class="line">2. 让稍微年龄大一点的对象提前进入 old 区，来避免 s 区的反复拷贝，让 s 区始终很小，这就看出来真正朝生夕死的对象都非常短命。这可以反推出来，我们真正合理的 MaxTenuringThreshold 应该是某几个不再变小的 threshold 之间。</span><br><span class="line"></span><br><span class="line">- age   1:   25047656 bytes,   25047656 total</span><br><span class="line">- age   2:     786792 bytes,   25834448 total</span><br><span class="line">- age   3:     615104 bytes,   26449552 total</span><br><span class="line">- age   4:     845128 bytes,   27294680 total</span><br><span class="line">- age   5:    5844016 bytes,   33138696 total</span><br><span class="line">- age   6:    1223224 bytes,   34361920 total</span><br><span class="line">- age   7:   24372296 bytes,   58734216 total</span><br><span class="line">- age   8:    3789440 bytes,   62523656 total</span><br><span class="line">- age   9:    6253976 bytes,   68777632 total</span><br><span class="line"></span><br><span class="line">- age   1:   24826808 bytes,   24826808 total</span><br><span class="line">- age   2:     688504 bytes,   25515312 total</span><br><span class="line">- age   3:     679288 bytes,   26194600 total</span><br><span class="line">- age   4:     603968 bytes,   26798568 total</span><br><span class="line">- age   5:     839352 bytes,   27637920 total</span><br><span class="line">- age   6:    5831024 bytes,   33468944 total</span><br><span class="line">- age   7:    1216568 bytes,   34685512 total</span><br><span class="line">- age   8:   24311896 bytes,   58997408 total</span><br><span class="line">- age   9:    3789440 bytes,   62786848 total</span><br><span class="line">- age  10:    6253976 bytes,   69040824 total</span><br><span class="line"></span><br><span class="line">注意看，age 9 和 age10 开始，某类对象就不再减少，而整体一直年龄递增，所以 age 设置为 9 也是一个可以尝试的思路。</span><br><span class="line"></span><br><span class="line">TODO：怎样做个实验来验证这里面的问题？</span><br></pre></td></tr></table></figure>

<p>另外：</p>
<ul>
<li>G1MixedGCLiveThresholdPercent：每个 region 里 live 对象到达多少的时候可以进入 CSet。</li>
<li>XX:G1MixedGCCountTarget=8 能够决定  mixed gc 的轮数。</li>
</ul>
<p>参考：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/161427950">《G1从入门到放弃》</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/54048685">《可能是最全面的G1学习笔记》</a></li>
<li>g1 的 gc 日志可以看<a target="_blank" rel="noopener" href="https://blogs.oracle.com/poonam/understanding-g1-gc-logs">《Understanding G1 GC Logs》</a>。</li>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/2016/09/23/g1.html">《Java Hotspot G1 GC的一些关键技术》</a></li>
</ol>
<h1 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a>ZGC</h1><p>zgc 是 java11 推出的垃圾收集器，在 java16 中做到了 max pause 1ms。它基本基于 Azul 的 pauseless gc 和 c4，做到了它们的早期方案，但不支持分代收集。zgc 在 allocation rate 高的时候的 tuning 手段就是加大堆。</p>
<blockquote>
<p>ZGC（The Z Garbage Collector）是JDK 11中推出的一款低延迟垃圾回收器，它的设计目标包括：</p>
<ul>
<li>停顿时间不超过10ms；</li>
<li>停顿时间不会随着堆的大小，或者活跃对象的大小而增加；</li>
<li>支持8MB~4TB级别的堆（未来支持16TB）。</li>
</ul>
<p>与CMS中的ParNew和G1类似，ZGC也采用标记-复制算法，不过ZGC对该算法做了重大改进：ZGC在标记、转移和重定位阶段几乎都是并发的，这是ZGC实现停顿时间小于10ms目标的最关键原因。</p>
</blockquote>
<p>![zgc 过程.png](zgc 过程.png)</p>
<blockquote>
<p>ZGC只有三个STW阶段：初始标记，再标记，初始转移。其中，初始标记和初始转移分别都只需要扫描所有GC Roots，其处理时间和GC<br>Roots的数量成正比，一般情况耗时非常短；再标记阶段STW时间很短，最多1ms，超过1ms则再次进入并发标记阶段。即，ZGC几乎所有暂停都只依赖于GC<br>Roots集合大小，停顿时间不会随着堆的大小或者活跃对象的大小而增加。与ZGC对比，G1的转移阶段完全STW的，且停顿时间随存活对象的大小增加而增加。</p>
<p>ZGC通过着色指针和读屏障技术，解决了转移过程中准确访问对象的问题，实现了并发转移。大致原理描述如下：并发转移中“并发”意味着GC线程在转移对象的过程中，应用线程也在不停地访问对象。假设对象发生转移，但对象地址未及时更新，那么应用线程可能访问到旧地址，从而造成错误。而在ZGC中，应用线程访问对象将触发“读屏障”，如果发现对象被移动了，那么“读屏障”会把读出来的指针更新到对象的新地址上，这样应用线程始终访问的都是对象的新地址。那么，JVM是如何判断对象被移动过呢？就是利用对象引用的地址，即着色指针。下面介绍着色指针和读屏障技术细节。</p>
</blockquote>
<h2 id="着色指针"><a href="#着色指针" class="headerlink" title="着色指针"></a>着色指针</h2><p>![zgc 的 64 位地址空间.png](zgc 的 64 位地址空间.png)</p>
<blockquote>
<p>其中，[0~4TB) 对应Java堆，[4TB ~ 8TB) 称为M0地址空间，[8TB ~ 12TB) 称为M1地址空间，[12TB ~<br>16TB) 预留未使用，[16TB ~ 20TB) 称为Remapped空间。</p>
<p>当应用程序创建对象时，首先在堆空间申请一个虚拟地址，但该虚拟地址并不会映射到真正的物理地址。ZGC同时会为该对象在M0、M1和Remapped地址空间分别申请一个虚拟地址，且这三个虚拟地址对应同一个物理地址，但这三个空间在同一时间有且只有一个空间有效。ZGC之所以设置三个虚拟地址空间，是因为它使用“空间换时间”思想，去降低GC停顿时间。“空间换时间”中的空间是虚拟空间，而不是真正的物理空间。后续章节将详细介绍这三个空间的切换过程。</p>
<p>与上述地址空间划分相对应，ZGC实际仅使用64位地址空间的第0<del>41位，而第42</del>45位存储元数据，第47~63位固定为0。</p>
</blockquote>
<p><img src="%E7%9D%80%E8%89%B2%E6%8C%87%E9%92%88.png" alt="着色指针.png"></p>
<blockquote>
<p>ZGC将对象存活信息存储在42~45位中，这与传统的垃圾回收并将对象存活信息放在对象头中完全不同。</p>
</blockquote>
<h2 id="读屏障"><a href="#读屏障" class="headerlink" title="读屏障"></a>读屏障</h2><blockquote>
<p>读屏障是JVM向应用代码插入一小段代码的技术。当应用线程从堆中读取对象引用时，就会执行这段代码。需要注意的是，仅“从堆中读取对象引用”才会触发这段代码。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object o = obj.FieldA   <span class="comment">// 从堆中读取引用，需要加入屏障</span></span><br><span class="line">&lt;Load barrier&gt;</span><br><span class="line">Object p = o  <span class="comment">// 无需加入屏障，因为不是从堆中读取引用</span></span><br><span class="line">o.dosomething() <span class="comment">// 无需加入屏障，因为不是从堆中读取引用</span></span><br><span class="line"><span class="keyword">int</span> i =  obj.FieldB  <span class="comment">//无需加入屏障，因为不是对象引用</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>ZGC中读屏障的代码作用：在对象标记和转移过程中，用于确定对象的引用地址是否满足条件，并作出相应动作。</p>
</blockquote>
<h2 id="ZGC并发处理演示"><a href="#ZGC并发处理演示" class="headerlink" title="ZGC并发处理演示"></a>ZGC并发处理演示</h2><blockquote>
<p>接下来详细介绍ZGC一次垃圾回收周期中地址视图的切换过程：</p>
<ul>
<li>初始化：ZGC初始化之后，整个内存空间的地址视图被设置为Remapped。程序正常运行，在内存中分配对象，满足一定条件后垃圾回收启动，此时进入标记阶段。</li>
<li>并发标记阶段：第一次进入标记阶段时视图为M0，如果对象被GC标记线程或者应用线程访问过，那么就将对象的地址视图从Remapped调整为M0。所以，在标记阶段结束之后，对象的地址要么是M0视图，要么是Remapped。如果对象的地址是M0视图，那么说明对象是活跃的；如果对象的地址是Remapped视图，说明对象是不活跃的。</li>
<li>并发转移阶段：标记结束后就进入转移阶段，此时地址视图再次被设置为Remapped。如果对象被GC转移线程或者应用线程访问过，那么就将对象的地址视图从M0调整为Remapped。</li>
</ul>
<p>其实，在标记阶段存在两个地址视图M0和M1，上面的过程显示只用了一个地址视图。之所以设计成两个，是为了区别前一次标记和当前标记。也即，第二次进入并发标记阶段后，地址视图调整为M1，而非M0。</p>
<p>着色指针和读屏障技术不仅应用在并发转移阶段，还应用在并发标记阶段：将对象设置为已标记，传统的垃圾回收器需要进行一次内存访问，并将对象存活信息放在对象头中；而在ZGC中，只需要设置指针地址的第42~45位即可，并且因为是寄存器访问，所以速度比访问内存更快。</p>
</blockquote>
<p>注意可能会有多轮并发标记。</p>
<p>![zgc 并发标记示范.png](zgc 并发标记示范.png)</p>
<p>这个图里的 0 和 1 属于同一个内存页面，因为 0 是活跃对象，所以 0 被转移出来，而 1 和整个页面都被回收了。</p>
<p>并发标记和并发转移是对称操作，从对象的稳定状态都应该是 remmaped 态。</p>
<h2 id="常用的-jvm-配置-1"><a href="#常用的-jvm-配置-1" class="headerlink" title="常用的 jvm 配置"></a>常用的 jvm 配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-Xms10G -Xmx10G </span><br><span class="line">-XX:ReservedCodeCacheSize=256m -XX:InitialCodeCacheSize=256m </span><br><span class="line">-XX:+UnlockExperimentalVMOptions -XX:+UseZGC </span><br><span class="line">-XX:ConcGCThreads=2 -XX:ParallelGCThreads=6 </span><br><span class="line">-XX:ZCollectionInterval=120 -XX:ZAllocationSpikeTolerance=5 </span><br><span class="line">-XX:+UnlockDiagnosticVMOptions -XX:-ZProactive </span><br><span class="line">-Xlog:safepoint,classhisto*=trace,age*,gc*=info:file=/opt/logs/logs/gc-%t.log:time,tid,tags:filecount=5,filesize=50m </span><br></pre></td></tr></table></figure>

<blockquote>
<p>-Xms -Xmx：堆的最大内存和最小内存，这里都设置为10G，程序的堆内存将保持10G不变。 -XX:ReservedCodeCacheSize -XX:InitialCodeCacheSize：设置CodeCache的大小， JIT编译的代码都放在CodeCache中，一般服务64m或128m就已经足够。我们的服务因为有一定特殊性，所以设置的较大，后面会详细介绍。<br>-XX:+UnlockExperimentalVMOptions -XX:+UseZGC：启用ZGC的配置。 -XX:ConcGCThreads：并发回收垃圾的线程。默认是总核数的12.5%，8核CPU默认是1。调大后GC变快，但会占用程序运行时的CPU资源，吞吐会受到影响。<br>-XX:ParallelGCThreads：STW阶段使用线程数，默认是总核数的60%。 -XX:ZCollectionInterval：ZGC发生的最小时间间隔，单位秒。 -XX:ZAllocationSpikeTolerance：ZGC触发自适应算法的修正系数，默认2，数值越大，越早的触发ZGC。 -XX:+UnlockDiagnosticVMOptions -XX:-ZProactive：是否启用主动回收，默认开启，这里的配置表示关闭。 -Xlog：设置GC日志中的内容、格式、位置以及每个日志的大小。</p>
</blockquote>
<h2 id="理解ZGC触发时机"><a href="#理解ZGC触发时机" class="headerlink" title="理解ZGC触发时机"></a>理解ZGC触发时机</h2><p>相比于CMS和G1的GC触发机制，ZGC的GC触发机制有很大不同。ZGC的核心特点是并发，GC过程中一直有新的对象产生。如何保证在GC完成之前，新产生的对象不会将堆占满，是ZGC参数调优的第一大目标。因为在ZGC中，当垃圾来不及回收将堆占满时，会导致正在运行的线程停顿，持续时间可能长达秒级之久。</p>
<p>ZGC有多种GC触发机制，总结如下：</p>
<ul>
<li>阻塞内存分配请求触发：当垃圾来不及回收，垃圾将堆占满时，会导致部分线程阻塞。我们应当避免出现这种触发方式。日志中关键字是“Allocation Stall”。</li>
<li>基于分配速率的自适应算法：最主要的GC触发方式，其算法原理可简单描述为”ZGC根据近期的对象分配速率以及GC时间，计算出当内存占用达到什么阈值时触发下一次GC”。自适应算法的详细理论可参考彭成寒《新一代垃圾回收器ZGC设计与实现》一书中的内容。通过ZAllocationSpikeTolerance参数控制阈值大小，该参数默认2，数值越大，越早的触发GC。我们通过调整此参数解决了一些问题。日志中关键字是“Allocation Rate”。</li>
<li>基于固定时间间隔：通过ZCollectionInterval控制，适合应对突增流量场景。流量平稳变化时，自适应算法可能在堆使用率达到95%以上才触发GC。流量突增时，自适应算法触发的时机可能会过晚，导致部分线程阻塞。我们通过调整此参数解决流量突增场景的问题，比如定时活动、秒杀等场景。日志中关键字是“Timer”。</li>
<li>主动触发规则：类似于固定间隔规则，但时间间隔不固定，是ZGC自行算出来的时机，我们的服务因为已经加了基于固定时间间隔的触发机制，所以通过-ZProactive参数将该功能关闭，以免GC频繁，影响服务可用性。 日志中关键字是“Proactive”。</li>
<li>预热规则：服务刚启动时出现，一般不需要关注。日志中关键字是“Warmup”。</li>
<li>外部触发：代码中显式调用System.gc()触发。日志中关键字是“System.gc()”。</li>
<li>元数据分配触发：元数据区不足时导致，一般不需要关注。 日志中关键字是“Metadata GC Threshold”。</li>
</ul>
<h2 id="理解ZGC日志"><a href="#理解ZGC日志" class="headerlink" title="理解ZGC日志"></a>理解ZGC日志</h2><blockquote>
<p>一次完整的GC过程，需要注意的点已在图中标出。</p>
</blockquote>
<p>![zgc 日志举例.png](zgc 日志举例.png)</p>
<blockquote>
<p>注意：该日志过滤了进入安全点的信息。正常情况，在一次GC过程中还穿插着进入安全点的操作。</p>
<p>GC日志中每一行都注明了GC过程中的信息，关键信息如下：</p>
<ul>
<li>Start：开始GC，并标明的GC触发的原因。上图中触发原因是自适应算法。</li>
<li>Phase-Pause Mark Start：初始标记，会STW。</li>
<li>Phase-Pause Mark End：再次标记，会STW。</li>
<li>Phase-Pause Relocate Start：初始转移，会STW。</li>
<li>Heap 信息：记录了GC过程中Mark、Relocate前后的堆大小变化状况。High和Low记录了其中的最大值和最小值，我们一般关注High中Used的值，如果达到100%，在GC过程中一定存在内存分配不足的情况，需要调整GC的触发时机，更早或者更快地进行GC。</li>
<li>GC 信息统计：可以定时的打印垃圾收集信息，观察10秒内、10分钟内、10个小时内，从启动到现在的所有统计信息。利用这些统计信息，可以排查定位一些异常点。</li>
</ul>
</blockquote>
<p>!(zgc-日志举例 2.png)[zgc-日志举例 2.png]</p>
<h2 id="理解-ZGC-停顿原因"><a href="#理解-ZGC-停顿原因" class="headerlink" title="理解 ZGC 停顿原因"></a>理解 ZGC 停顿原因</h2><ul>
<li>GC时，初始标记：日志中Pause Mark Start。</li>
<li>GC时，再标记：日志中Pause Mark End。</li>
<li>GC时，初始转移：日志中Pause Relocate Start。</li>
<li>内存分配阻塞：当内存不足时线程会阻塞等待GC完成，关键字是”Allocation Stall”。</li>
<li>安全点：所有线程进入到安全点后才能进行GC，ZGC定期进入安全点判断是否需要GC。先进入安全点的线程需要等待后进入安全点的线程直到所有线程挂起。</li>
<li>dump线程、内存：比如jstack、jmap命令。</li>
</ul>
<p>这 6 种 STW，在其他垃圾收集器里也是很常见的。</p>
<h1 id="Shenandoah"><a href="#Shenandoah" class="headerlink" title="Shenandoah"></a>Shenandoah</h1><p>RedHat 的分代收集器，只有 Openjdk 才有。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>[Garbage Collector.xmind](Garbage Collector.xmind)</p>
<p>![Garbage Collector.png](Garbage Collector.png)</p>
<p>关于 cms 和 g1 的深入讨论，参考<a target="_blank" rel="noopener" href="https://hllvm-group.iteye.com/group/topic/44381">这个帖子</a>。</p>
<h1 id="调优经验"><a href="#调优经验" class="headerlink" title="调优经验"></a>调优经验</h1><p>在现代系统中，系统进入峰值时，峰值效应明显，要针对 peak server workloads 做好准备。 通常 ygc 始终是全 stw 的，fullgc 也不可避免的有好几个 stw 阶段。</p>
<p>指定堆的大小是为了保证垃圾回收的可预测性，也能进而保证堆扩展（heap expansion）不出错-在混布（mixed deployment）时保障资源有界。</p>
<p>指定最大停顿时间则意味着我们要指定系统在 high probability（90%的情况下）应该达到的一个软实时目标。PS 和 G1 都支持这种调优策略，而且能够自动适应调整堆内部大小。PS 是吞吐量收集器，G1 是 regionalized, parallel-concurrent, incremental garbage collector。PS 和 G1 的低延迟垃圾收集器。cms 可以被认为是一个并发收集器，而 g1 的 ygc 和 mixedgc 可以被认为都是 stw 的- mixed gc 的并发标记阶段是可以并发执行的。</p>
<p>对于有并发阶段存在的垃圾收集器而言，InitiatingHeapOccupancyPercent（全堆）/CMSInitiatingOccupancyFraction（老年代，需配合 CMSInitiatingOccupancyOnly 使用，否则只生效一次 ）等阈值保证了系统可以提前触发回收，这样可以保证并发收集留有余地，不至于有并发模式失败。</p>
<p>如果配置了-XX:MetaspaceSize，那么触发FGC的阈值就是配置的值；MaxMetaspaceSize 指的是元空间最大的大小-如果不设置则为无限大。参考<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/b448c21d2e71">《JVM参数MetaspaceSize的误解》</a>。</p>
<p>gc 日志中的 Allocation Failure 可能代表 y 区内存分配失败，也可能代表 old 区内存分配失败。实际上，内存分配失败、回收后空间水位过高、经常越过高水位，都是持续发生 gc 的元凶，它们通常都由 gc 不友好、内存泄漏的代码导致。</p>
<p>ygc 有意想不到的直接晋升到 old 区的几种可能，所以 old 区通常要设计得比 y 区大：ygc 剩余垃圾大于 eden，触发担保机制；大对象；动态年龄判断。如果 old 区很稳定，可以证明应用的对象朝生夕死分布得很好。单纯的年龄阈值并不一定能够适应复杂的 ygc 的年龄分布，所以 MaxTenuringThreshold 会和 TargetSurvivorRatio 一起使用，如果 ygc 的结果超出了 desired_survivor_size，也会触发老年代晋升。</p>
<p>看待 gc 时间需要客观：ygc 的时间总是会造成 stw 的停顿。如果设定了很小的 gc 时间目标，则 jvm 可能很保守地制造小堆，进而在数据密集型应用上触发频繁的垃圾回收，进而是总的停顿时间变大。有时候稍微大的堆（在 8g 机器上使用 2-4g 的年轻代）或者稍微大的停顿时间目标 100 ms 可以解决我们的问题。否则，我们只能通过压测，不断调节年轻代的大小来解决我们的问题。</p>
<p>一般一个 mixed gc 一天才出现一次，算是比较健康的。但使用自适应策略导致冷启动和 mixed gc 以后堆布局的重建容易出现多轮回收的问题（多的时候会有 20 几轮 ygc 才能把 young 区的数量建设到比较稳定的状态），比较麻烦。当然，一般情况下，gc 对于 tp999、tp9999 的抬升效应并没有那么明显，有很多其他因素会导致我们的 rt 出现明显抬升。</p>
<p>垃圾调优一定要解决确定存在的问题-而不能解决不存在的问题。如果需要调优 cpu，则注意垃圾收集器、标记线程、回收线程和垃圾回收的频次。调优年轻代的时候是有代价的：更大的年轻代意味着更低的回收频率（这通常会优化次数相关的告警），但会带来更大的 ygc meantime，也意味着进入老年代的时间更缓慢，但老年代的大小会变小，可能又会导致老年代的 fgc（这又取决于老年代是不是稳定的）。</p>
<p>cms/g1 都使用了三色标记算法，白色（未被扫描）、灰色（field 未被扫描）、黑色（已全被扫描）三种对象里面，灰色对象和白色对象的引用交替增删，可能造成部分白色对象不被回收，这就是这类垃圾收集器的浮动垃圾的根源。</p>
<p>card 和 rset 本身都是帮助 gc 的过程工具，一个 point-out，一个 point-in。都是用空间换时间。g1 的停顿预测模型是以衰减标准偏差为理论基础。扫描 dirty_card 的时间，会占据预测停顿时间的一部分。</p>
<h1 id="C4（Continuous-Concurrently-Compacting-Collection）"><a href="#C4（Continuous-Concurrently-Compacting-Collection）" class="headerlink" title="C4（Continuous Concurrently Compacting Collection）"></a>C4（Continuous Concurrently Compacting Collection）</h1><p>待续</p>
<p>参考：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/2020/08/06/new-zgc-practice-in-meituan.html">《新一代垃圾回收器ZGC的探索与实践》</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903893906751501">《【译】深入理解G1的GC日志（一）》</a></li>
</ol>

                    </article>
                    


    <blockquote id="date-expire-notification" class="post-expired-notify">This article was last updated on <span id="date-expire-num"></span> days ago, and the information described in the article may have changed.</blockquote>
    <script>
    (function() {
        var dateUpdate = Date.parse("2022-01-30");
        var nowDate = new Date();
        var a = nowDate.getTime();
        var b = a - dateUpdate;
        var daysUpdateExpire = Math.floor(b/(24*3600*1000));
        if (daysUpdateExpire >= 120) {
            document.getElementById('date-expire-num').innerHTML = daysUpdateExpire;
        } else {
            document.getElementById('date-expire-notification').style.display = 'none';
        }
    })();
    </script>


<p class="post-footer-info mb-0 pt-0">Published at&nbsp;<time datetime="2020-09-27T08:12:22.000Z" itemprop="datePublished">2020-09-27</time>

    , Updated at&nbsp;<time datetime="2022-01-30T10:42:26.647Z" itemprop="dateModified">2022-01-30</time>

</p>
<p class="post-footer-info mb-0 pt-2">



<span class="post-tags-list mt-2">

<a class="post-tags-list-item" href="/tags/JVM/" rel="tag">#&nbsp;JVM</a>

<a class="post-tags-list-item" href="/tags/Java/" rel="tag">#&nbsp;Java</a>

</span>


</p>

                </div>
                <div class="post-nav px-2 bg-gray">
<ul class="pagination">
    <!-- Prev Nav -->
    
        <li class="page-item page-prev">
            <a href="/2020/10/04/%E4%BA%BF%E7%BA%A7%E8%AE%A2%E5%8D%95%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/" rel="prev">
                <div class="page-item-title"><i class="icon icon-back" aria-hidden="true"></i></div>
                <div class="page-item-subtitle">亿级订单架构设计</div>
            </a>
        </li>
    

    <!-- Next Nav -->
    
        <li class="page-item page-next">
            <a href="/2020/09/14/MySQL-%E7%9A%84%E9%85%8D%E7%BD%AE/" rel="next">
                <div class="page-item-title"><i class="icon icon-forward" aria-hidden="true"></i></div>
                <div class="page-item-subtitle">MySQL 的配置</div>
            </a>
        </li>
    
</ul>
</div>

                
                    <!-- # Comment # -->
                    
                
            </div>
        </div>
    </div>
</div>

            <!-- ### Footer ### -->
            <footer class="text-center">
    <!-- footer copyright -->
    
        <p class="footer-copyright mb-0">Copyright&nbsp;©&nbsp;<span id="copyright-year"></span>
            <a class="footer-copyright-a" href="http://magicliang.github.io">守株阁</a>
        </p>

    <!-- footer custom text -->
    <p class="footer-text mb-0">
    
    </p>
    <!-- footer develop info -->
    <p class="footer-develop mb-0">
        
    <!-- Busuanzi User Views -->
    <span id="busuanzi_container_site_uv" hidden>
        <span></span>
        <span id="busuanzi_value_site_uv"></span>
        <span>Viewers</span>
        
            <span>|</span>
        
    </span>




        
        Powered by&nbsp;<!--
         --><a href="https://hexo.io" target="_blank" class="footer-develop-a" rel="external nofollow noopener noreferrer">Hexo</a><span class="footer-develop-divider"></span>Theme&nbsp;-&nbsp;<!--
         --><a href="https://github.com/SukkaW/hexo-theme-suka" target="_blank" class="footer-develop-a" rel="external noopener">Suka</a>
    </p>
</footer>


        <!-- ### Import File ### -->
        <!-- ### Footer JS Import ### -->

<script>

    
window.lazyLoadOptions = {
    elements_selector: ".lazyload",
    threshold: 50
};
document.getElementById('copyright-year').textContent = new Date().getFullYear();
console.log('\n %c Suka Theme (hexo-theme-suka) | © SukkaW | Verision 1.3.3 %c https://github.com/SukkaW/hexo-theme-suka \n', 'color: #fff; background: #444; padding:5px 0;', 'background: #bbb; padding:5px 0;');

</script>

<script src="/lib/vanilla-lazyload/lazyload.min.js" async></script>
    <script src="https://cdn.jsdelivr.net/npm/busuanzi@2.3.0/bsz.pure.mini.js" async></script>


<!-- Offset -->




<!-- Comment -->


<!-- ### Custom Footer ### -->

    </body>

</html>