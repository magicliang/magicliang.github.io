<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>ThreadLocal 的设计模式 | 守株阁</title><meta name="author" content="magicliang"><meta name="copyright" content="magicliang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="ThreadLocal 是 Java 并发编程中实现**线程封闭（Thread Confinement）**的核心工具。本文将从原理到实践，系统性地讲解 ThreadLocal 的设计哲学、内部机制、使用模式以及跨线程传递方案。 原理篇：ThreadLocal 的内部机制 核心设计理念：为什么不用 Map&lt;Thread, Value&gt;？ 很多人初次设计线程本地存储时，会想到用一个全局的">
<meta property="og:type" content="article">
<meta property="og:title" content="ThreadLocal 的设计模式">
<meta property="og:url" content="https://magicliang.github.io/2020/04/01/ThreadLocal-%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.html">
<meta property="og:site_name" content="守株阁">
<meta property="og:description" content="ThreadLocal 是 Java 并发编程中实现**线程封闭（Thread Confinement）**的核心工具。本文将从原理到实践，系统性地讲解 ThreadLocal 的设计哲学、内部机制、使用模式以及跨线程传递方案。 原理篇：ThreadLocal 的内部机制 核心设计理念：为什么不用 Map&lt;Thread, Value&gt;？ 很多人初次设计线程本地存储时，会想到用一个全局的">
<meta property="og:locale">
<meta property="og:image" content="https://magicliang.github.io/img/wall-paper-35.jpg">
<meta property="article:published_time" content="2020-04-01T12:29:29.000Z">
<meta property="article:modified_time" content="2026-01-24T07:35:51.956Z">
<meta property="article:author" content="magicliang">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="并发编程">
<meta property="article:tag" content="设计模式">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://magicliang.github.io/img/wall-paper-35.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "ThreadLocal 的设计模式",
  "url": "https://magicliang.github.io/2020/04/01/ThreadLocal-%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/",
  "image": "https://magicliang.github.io/img/wall-paper-35.jpg",
  "datePublished": "2020-04-01T12:29:29.000Z",
  "dateModified": "2026-01-24T07:35:51.956Z",
  "author": [
    {
      "@type": "Person",
      "name": "magicliang",
      "url": "https://magicliang.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://magicliang.github.io/2020/04/01/ThreadLocal-%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: magicliang","link":"Link: ","source":"Source: 守株阁","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'ThreadLocal 的设计模式',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"><link rel="alternate" href="/atom.xml" title="守株阁" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      if ($loadingBox.classList.contains('loaded')) return
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()

  if (document.readyState === 'complete') {
    preloader.endLoading()
  } else {
    window.addEventListener('load', preloader.endLoading)
    document.addEventListener('DOMContentLoaded', preloader.endLoading)
    // Add timeout protection: force end after 7 seconds
    setTimeout(preloader.endLoading, 7000)
  }

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/wall-paper-35.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">守株阁</span></a><a class="nav-page-title" href="/"><span class="site-name">ThreadLocal 的设计模式</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">ThreadLocal 的设计模式</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2020-04-01T12:29:29.000Z" title="Created 2020-04-01 20:29:29">2020-04-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2026-01-24T07:35:51.956Z" title="Updated 2026-01-24 15:35:51">2026-01-24</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">16.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>72mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>ThreadLocal 是 Java 并发编程中实现**线程封闭（Thread Confinement）**的核心工具。本文将从原理到实践，系统性地讲解 ThreadLocal 的设计哲学、内部机制、使用模式以及跨线程传递方案。</p>
<h1>原理篇：ThreadLocal 的内部机制</h1>
<h2 id="核心设计理念：为什么不用-map-thread-value-？">核心设计理念：为什么不用 <code>Map&lt;Thread, Value&gt;</code>？</h2>
<p>很多人初次设计线程本地存储时，会想到用一个全局的 <code>Map&lt;Thread, Value&gt;</code> 来存储每个线程的数据。但这种设计有致命缺陷：Thread 对象会被 Map 强引用，导致线程无法被 JVM 回收，造成严重的内存泄漏。</p>
<p>ThreadLocal 采用了相反的设计：<strong>让 Thread 持有 Map，而不是让 Map 持有 Thread</strong>。每个 Thread 内部都有一个 ThreadLocalMap，用于存储该线程的所有线程本地变量。这样设计的好处是：</p>
<ul>
<li>线程销毁时，ThreadLocalMap 随之销毁，数据自动清理</li>
<li>ThreadLocal 对象可以被显式管理（如声明为静态变量）</li>
<li>线程内部的存储容器是隐式的，由线程自己管理</li>
</ul>
<h2 id="引用关系结构">引用关系结构</h2>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xl">T<span class="hljs-function"><span class="hljs-title">hread</span> -&gt;</span> T<span class="hljs-function"><span class="hljs-title">hreadLocalMap</span> -&gt;</span> Entry[]<br>                           ↓<br>Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt;<br>  - key: ThreadLocal 对象（弱引用）<br>  - value: 实际存储的值（强引用）<br></code></pre></td></tr></table></figure>
<p>一个 ThreadLocal 变量的&quot;副本&quot;实际上是分散存储在多个线程的 ThreadLocalMap 中的。每个线程的 ThreadLocalMap 中都有一个 Entry，以同一个 ThreadLocal 对象为 key，但 value 是各自独立的。</p>
<p><strong>静态变量场景的引用关系：</strong></p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">方法区静态变量 -&gt; 强引用 ThreadLocal 对象<br>ThreadLocalMap.Entry -&gt; 弱引用 ThreadLocal 对象<br></code></pre></td></tr></table></figure>
<h2 id="四大核心原则">四大核心原则</h2>
<h3 id="原则1：操作的本质">原则1：操作的本质</h3>
<p>当我们调用 <code>ThreadLocal.get()</code> 或 <code>ThreadLocal.set()</code> 时，实际上是在操作<strong>当前线程内部的 ThreadLocalMap</strong>。ThreadLocal 对象本身只是一个&quot;访问入口&quot;，真正的数据存储在各个线程的隐藏 Map 中。</p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;方法区&quot;
        TL[ThreadLocal 静态变量&lt;br/&gt;static ThreadLocal]
        style TL fill:#e1f5ff
    end
    
    subgraph &quot;Thread-1 内部&quot;
        T1[Thread-1]
        TLM1[ThreadLocalMap]
        E1[Entry]
        V1[value: data1]
        T1 --&gt;|强引用| TLM1
        TLM1 --&gt;|强引用| E1
        E1 -.-&gt;|key弱引用| TL
        E1 --&gt;|强引用| V1
    end
    
    subgraph &quot;Thread-2 内部&quot;
        T2[Thread-2]
        TLM2[ThreadLocalMap]
        E2[Entry]
        V2[value: data2]
        T2 --&gt;|强引用| TLM2
        TLM2 --&gt;|强引用| E2
        E2 -.-&gt;|key弱引用| TL
        E2 --&gt;|强引用| V2
    end
    
    TL -.-&gt;|&quot;get()/set() 操作&lt;br/&gt;实际访问当前线程的 Map&quot;| TLM1
    TL -.-&gt;|&quot;get()/set() 操作&lt;br/&gt;实际访问当前线程的 Map&quot;| TLM2</code></pre>
<h3 id="原则2：threadlocal-应该是-static-变量">原则2：ThreadLocal 应该是 static 变量</h3>
<p>ThreadLocal 应该声明为 static 变量，作为类级别的全局唯一实例。原因有三：</p>
<ol>
<li>
<p><strong>避免内存浪费</strong>：如果作为成员变量，每个对象实例都会创建新的 ThreadLocal，导致每个线程的 ThreadLocalMap 中会有多个 Entry，浪费内存且违背线程本地存储的设计初衷。<strong>我们的初衷是每个线程有一个变量的副本，而不是多个副本</strong>。</p>
</li>
<li>
<p><strong>防止对象无法回收</strong>：如果 ThreadLocal 是成员变量，开发者会习惯性地通过 <code>对象实例.threadLocal.get()</code> 来访问 ThreadLocal。这种使用方式会导致对象实例被外部持有引用，进而无法被 GC 回收。而如果 ThreadLocal 是 static 变量，访问方式是 <code>类.threadLocal.get()</code>，不会持有对象实例的引用，避免了对象级别的内存泄漏。</p>
</li>
<li>
<p><strong>Class 生命周期更长</strong>：相比之下，Class 对象通常不需要频繁回收，其生命周期与应用程序相当，因此 static 成员是可以接受的。static 声明确保全局只有一个 ThreadLocal 实例，每个线程的 Map 中只有一个对应的 Entry，既节省内存又避免了对象无法回收的问题。</p>
</li>
</ol>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;错误做法：ThreadLocal 作为成员变量&quot;
        direction TB
        
        subgraph &quot;对象实例1&quot;
            O1[MyService 实例1]
            TL1[ThreadLocal 实例1]
            O1 --&gt;|持有| TL1
            style O1 fill:#ffcdd2
            style TL1 fill:#ffcdd2
        end
        
        subgraph &quot;对象实例2&quot;
            O2[MyService 实例2]
            TL2[ThreadLocal 实例2]
            O2 --&gt;|持有| TL2
            style O2 fill:#ffcdd2
            style TL2 fill:#ffcdd2
        end
        
        subgraph &quot;对象实例3&quot;
            O3[MyService 实例3]
            TL3[ThreadLocal 实例3]
            O3 --&gt;|持有| TL3
            style O3 fill:#ffcdd2
            style TL3 fill:#ffcdd2
        end
        
        subgraph &quot;Thread-1 的 Map&quot;
            E1A[Entry: key=TL1]
            E1B[Entry: key=TL2]
            E1C[Entry: key=TL3]
            style E1A fill:#fff9c4
            style E1B fill:#fff9c4
            style E1C fill:#fff9c4
        end
        
        problem[&quot;问题：&lt;br/&gt;1. 每个对象实例都创建新的 ThreadLocal&lt;br/&gt;2. 线程的 Map 中会有多个 Entry&lt;br/&gt;3. 浪费内存，违背线程本地存储的设计初衷&quot;]
        style problem fill:#ffebee
    end
    
    subgraph &quot;正确做法：ThreadLocal 作为 static 变量&quot;
        direction TB
        
        subgraph &quot;类级别&quot;
            TLS[static ThreadLocal&lt;br/&gt;全局唯一实例]
            style TLS fill:#c8e6c9
        end
        
        subgraph &quot;Thread-1 的 Map&quot;
            E2[Entry: key=TLS&lt;br/&gt;唯一的 Entry]
            E2 -.-&gt;|key弱引用| TLS
            style E2 fill:#e8f5e9
        end
        
        subgraph &quot;Thread-2 的 Map&quot;
            E3[Entry: key=TLS&lt;br/&gt;唯一的 Entry]
            E3 -.-&gt;|key弱引用| TLS
            style E3 fill:#e8f5e9
        end
        
        benefit[&quot;优势：&lt;br/&gt;1. 全局只有一个 ThreadLocal 实例&lt;br/&gt;2. 每个线程的 Map 中只有一个对应的 Entry&lt;br/&gt;3. 节省内存，符合设计初衷&quot;]
        style benefit fill:#e8f5e9
    end</code></pre>
<h3 id="原则3：线程生命周期决定数据生命周期">原则3：线程生命周期决定数据生命周期</h3>
<p>即使我们不主动调用 <code>remove()</code>，当线程销毁时（如普通线程执行完毕），该线程的 ThreadLocalMap 也会随之销毁，所有 value 自动被回收。这就是为什么在非线程池场景下，ThreadLocal 的内存泄漏问题不那么严重。</p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;场景：普通线程执行完毕&quot;
        direction TB
        
        subgraph &quot;执行前&quot;
            T1A[Thread-1 运行中]
            TLM1A[ThreadLocalMap]
            E1A[Entry]
            V1A[value: data1]
            T1A --&gt;|强引用| TLM1A
            TLM1A --&gt;|强引用| E1A
            E1A --&gt;|强引用| V1A
            style T1A fill:#fff4e6
            style TLM1A fill:#f0f0f0
            style E1A fill:#e8f5e9
            style V1A fill:#c8e6c9
        end
        
        arrow1[&quot;线程执行完毕&quot;]
        style arrow1 fill:#ffebee
        
        subgraph &quot;执行后&quot;
            destroyed[&quot;Thread-1 被销毁&lt;br/&gt;ThreadLocalMap 被销毁&lt;br/&gt;Entry 被销毁&lt;br/&gt;value 被 GC 回收&quot;]
            style destroyed fill:#ffcdd2
        end
        
        执行前 --&gt; arrow1
        arrow1 --&gt; 执行后
    end</code></pre>
<h3 id="原则4：threadlocal-对象的生命周期影响所有线程">原则4：ThreadLocal 对象的生命周期影响所有线程</h3>
<p>如果我们将 ThreadLocal 静态变量置为 null（去除强引用），那么所有线程的 ThreadLocalMap 中对应的 Entry 的 key 都会失效（弱引用被回收）。即使线程什么都不做，只要后续有任何 get/set/remove 操作触发，这些 key 为 null 的 Entry 就会被自动清理，value 随之消失。</p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;场景：ThreadLocal 静态变量被置为 null&quot;
        direction TB
        
        subgraph &quot;置为 null 前&quot;
            TLA[ThreadLocal 静态变量]
            E1A[Thread-1 的 Entry]
            E2A[Thread-2 的 Entry]
            E3A[Thread-3 的 Entry]
            V1A[value: data1]
            V2A[value: data2]
            V3A[value: data3]
            E1A -.-&gt;|key弱引用| TLA
            E2A -.-&gt;|key弱引用| TLA
            E3A -.-&gt;|key弱引用| TLA
            E1A --&gt;|强引用| V1A
            E2A --&gt;|强引用| V2A
            E3A --&gt;|强引用| V3A
            style TLA fill:#e1f5ff
            style E1A fill:#e8f5e9
            style E2A fill:#e8f5e9
            style E3A fill:#e8f5e9
            style V1A fill:#c8e6c9
            style V2A fill:#c8e6c9
            style V3A fill:#c8e6c9
        end
        
        arrow2[&quot;ThreadLocal = null + GC&quot;]
        style arrow2 fill:#ffebee
        
        subgraph &quot;置为 null 后&quot;
            TLB[ThreadLocal 对象被 GC 回收]
            E1B[Thread-1 的 Entry&lt;br/&gt;key=null]
            E2B[Thread-2 的 Entry&lt;br/&gt;key=null]
            E3B[Thread-3 的 Entry&lt;br/&gt;key=null]
            V1B[value: data1&lt;br/&gt;待清理]
            V2B[value: data2&lt;br/&gt;待清理]
            V3B[value: data3&lt;br/&gt;待清理]
            E1B --&gt;|强引用| V1B
            E2B --&gt;|强引用| V2B
            E3B --&gt;|强引用| V3B
            style TLB fill:#ffcdd2
            style E1B fill:#fff9c4
            style E2B fill:#fff9c4
            style E3B fill:#fff9c4
            style V1B fill:#ffebee
            style V2B fill:#ffebee
            style V3B fill:#ffebee
        end
        
        arrow3[&quot;任意线程调用 get/set/remove&quot;]
        style arrow3 fill:#ffebee
        
        subgraph &quot;自动清理&quot;
            cleaned[&quot;expungeStaleEntry 触发&lt;br/&gt;key=null 的 Entry 被清理&lt;br/&gt;value 被 GC 回收&quot;]
            style cleaned fill:#c8e6c9
        end
        
        置为null前 --&gt; arrow2
        arrow2 --&gt; 置为null后
        置为null后 --&gt; arrow3
        arrow3 --&gt; 自动清理
    end</code></pre>
<h2 id="为什么-key-使用弱引用？">为什么 key 使用弱引用？</h2>
<p>因为线程内部的 ThreadLocalMap 是隐式容器，由线程自己管理。如果 key 使用强引用，那么只要线程存活（如线程池场景），ThreadLocal 对象就永远无法被回收。使用弱引用后，当 ThreadLocal 对象没有外部强引用时（如静态变量被置为 null），它可以被 GC 回收，Entry 的 key 变为 null，后续的 get/set/remove 操作会自动清理这些过期的 Entry。</p>
<blockquote>
<p><strong>弱引用的特性</strong>：在垃圾回收器线程扫描内存区域时，一旦发现只具有弱引用的对象，不管当前内存空间是否足够，都会回收它的内存。</p>
</blockquote>
<h2 id="stale-entry-的自动清理机制">Stale Entry 的自动清理机制</h2>
<p>当 ThreadLocal 对象失去强引用后，GC 会回收它，此时 Entry 中的弱引用 key 会变成 null。但 Entry 本身仍然占据 ThreadLocalMap 的槽位，value 也仍然被 Entry 强引用。这种 key 为 null 的 Entry 被称为 <strong>Stale Entry（过期条目）</strong>。</p>
<p>ThreadLocalMap 的 <code>get()</code>、<code>set()</code>、<code>remove()</code> 方法在执行过程中，会<strong>主动检测并清理</strong>这些 Stale Entry。这是通过调用 <code>expungeStaleEntry()</code> 方法实现的：</p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant App as 应用代码
    participant TL as ThreadLocal
    participant TLM as ThreadLocalMap
    participant Entry as Entry[]
    participant GC as GC
    
    Note over App,GC: 阶段1：正常使用
    App-&gt;&gt;TL: threadLocal.set(value)
    TL-&gt;&gt;TLM: set(this, value)
    TLM-&gt;&gt;Entry: table[i] = new Entry(key, value)
    Note over Entry: Entry.key = WeakRef(ThreadLocal)&lt;br/&gt;Entry.value = value（强引用）
    
    Note over App,GC: 阶段2：ThreadLocal 失去强引用
    App-&gt;&gt;App: threadLocal = null
    Note over TL: 只剩 Entry 的弱引用指向 ThreadLocal
    
    Note over App,GC: 阶段3：GC 回收 ThreadLocal
    GC-&gt;&gt;TL: 回收 ThreadLocal 对象
    Note over Entry: Entry.key.get() == null&lt;br/&gt;Entry.value 仍然存在（Stale Entry）
    
    Note over App,GC: 阶段4：后续操作触发清理
    App-&gt;&gt;TL: anotherThreadLocal.get()
    TL-&gt;&gt;TLM: getEntry(this)
    
    TLM-&gt;&gt;TLM: 遍历 table 寻找目标 Entry
    
    alt 遇到 Stale Entry (key == null)
        TLM-&gt;&gt;TLM: expungeStaleEntry(staleSlot)
        Note over TLM: 1. 将 Entry.value 置为 null&lt;br/&gt;2. 将 Entry 置为 null&lt;br/&gt;3. rehash 后续元素
        TLM-&gt;&gt;Entry: table[staleSlot] = null
        Note over Entry: value 失去引用，可被 GC 回收
    end
    
    TLM--&gt;&gt;TL: 返回目标 Entry 的 value
    TL--&gt;&gt;App: 返回 value</code></pre>
<p><strong>为什么 get/set/remove 能&quot;知道&quot; Entry 已过期？</strong></p>
<p>这是弱引用的核心特性：<code>WeakReference.get()</code> 方法会返回被引用的对象，但如果该对象已被 GC 回收，则返回 <code>null</code>。ThreadLocalMap 的 Entry 继承自 <code>WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</code>，因此：</p>
<ol>
<li>当 ThreadLocal 对象存活时：<code>entry.get()</code> 返回 ThreadLocal 对象。</li>
<li>当 ThreadLocal 对象被 GC 回收后：<code>entry.get()</code> 返回 <code>null</code>——这就是继承 WeakReference 的好处。</li>
</ol>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;Entry 状态判断&quot;
        CHECK[&quot;entry.get()&quot;]
        
        VALID[&quot;返回 ThreadLocal 对象&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Entry 有效&lt;br/&gt;正常读取/更新 value&quot;]
        
        STALE[&quot;返回 null&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Entry 过期（Stale）&lt;br/&gt;触发 expungeStaleEntry()&quot;]
        
        CHECK --&gt;|&quot;ThreadLocal 存活&quot;| VALID
        CHECK --&gt;|&quot;ThreadLocal 已被 GC&quot;| STALE
        
        style VALID fill:#c8e6c9
        style STALE fill:#ffcdd2
    end</code></pre>
<p><strong>清理的时机与局限性：</strong></p>
<table>
<thead>
<tr>
<th>操作</th>
<th>是否触发清理</th>
<th>清理范围</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>get()</code></td>
<td>是</td>
<td>遍历过程中遇到的 Stale Entry</td>
</tr>
<tr>
<td><code>set()</code></td>
<td>是</td>
<td>遍历过程中遇到的 Stale Entry + 可能触发全表扫描</td>
</tr>
<tr>
<td><code>remove()</code></td>
<td>是</td>
<td>遍历过程中遇到的 Stale Entry</td>
</tr>
<tr>
<td><strong>无任何操作</strong></td>
<td>否</td>
<td><strong>这就是泄漏发生的根本原因</strong></td>
</tr>
</tbody>
</table>
<p><strong>关键结论</strong>：自动清理机制是<strong>被动触发</strong>的，只有在调用 get/set/remove 时才会执行。如果线程长期存活（如线程池）且不再访问任何 ThreadLocal，那些 Stale Entry 将永远不会被清理，导致内存泄漏。</p>
<p><strong>关键源码解析（JDK 8）：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ThreadLocalMap.getEntry() 方法</span><br><span class="hljs-keyword">private</span> Entry <span class="hljs-title function_">getEntry</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="hljs-number">1</span>);<br>    <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> table[i];<br>    <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span> &amp;&amp; e.get() == key)  <span class="hljs-comment">// e.get() 获取弱引用指向的对象</span><br>        <span class="hljs-keyword">return</span> e;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> getEntryAfterMiss(key, i, e);  <span class="hljs-comment">// 触发清理逻辑</span><br>&#125;<br><br><span class="hljs-comment">// 核心清理方法</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">expungeStaleEntry</span><span class="hljs-params">(<span class="hljs-type">int</span> staleSlot)</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br><br>    <span class="hljs-comment">// 清理当前 Stale Entry</span><br>    tab[staleSlot].value = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 断开 value 的强引用</span><br>    tab[staleSlot] = <span class="hljs-literal">null</span>;        <span class="hljs-comment">// 断开 Entry 的引用</span><br>    size--;<br><br>    <span class="hljs-comment">// 继续向后扫描，清理更多 Stale Entry 并 rehash</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="threadlocal-核心方法调用链解析">ThreadLocal 核心方法调用链解析</h2>
<p>理解 ThreadLocal 的工作原理，关键在于理清各个方法之间的调用关系。下面我们从源码层面逐一分析。</p>
<h3 id="方法调用关系图">方法调用关系图</h3>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;ThreadLocal 外部 API&quot;
        SET[&quot;ThreadLocal.set(T value)&quot;]
        GET[&quot;ThreadLocal.get()&quot;]
        REMOVE[&quot;ThreadLocal.remove()&quot;]
    end
    
    subgraph &quot;ThreadLocal 内部方法&quot;
        GETMAP[&quot;getMap(Thread t)&quot;]
        CREATEMAP[&quot;createMap(Thread t, T firstValue)&quot;]
        SETINITIAL[&quot;setInitialValue()&quot;]
    end
    
    subgraph &quot;ThreadLocalMap 内部方法&quot;
        MAPSET[&quot;ThreadLocalMap.set(ThreadLocal key, Object value)&quot;]
        GETENTRY[&quot;ThreadLocalMap.getEntry(ThreadLocal key)&quot;]
        GETMISS[&quot;getEntryAfterMiss(ThreadLocal key, int i, Entry e)&quot;]
        MAPREMOVE[&quot;ThreadLocalMap.remove(ThreadLocal key)&quot;]
        EXPUNGE[&quot;expungeStaleEntry(int staleSlot)&quot;]
        REPLACE[&quot;replaceStaleEntry(...)&quot;]
        CLEAN[&quot;cleanSomeSlots(...)&quot;]
        MAPCONSTRUCTOR[&quot;ThreadLocalMap(ThreadLocal firstKey, Object firstValue)&quot;]
    end
    
    SET --&gt; GETMAP
    SET --&gt;|&quot;map != null&quot;| MAPSET
    SET --&gt;|&quot;map == null&quot;| CREATEMAP
    CREATEMAP --&gt; MAPCONSTRUCTOR
    
    GET --&gt; GETMAP
    GET --&gt;|&quot;map != null&quot;| GETENTRY
    GET --&gt;|&quot;map == null 或 entry == null&quot;| SETINITIAL
    GETENTRY --&gt;|&quot;hash 冲突&quot;| GETMISS
    GETMISS --&gt; EXPUNGE
    SETINITIAL --&gt; CREATEMAP
    SETINITIAL --&gt; MAPSET
    
    REMOVE --&gt; GETMAP
    REMOVE --&gt; MAPREMOVE
    MAPREMOVE --&gt; EXPUNGE
    
    MAPSET --&gt;|&quot;遇到 stale entry&quot;| REPLACE
    REPLACE --&gt; EXPUNGE
    MAPSET --&gt; CLEAN
    CLEAN --&gt; EXPUNGE
    
    style SET fill:#e1f5ff
    style GET fill:#e1f5ff
    style REMOVE fill:#e1f5ff
    style EXPUNGE fill:#ffcdd2</code></pre>
<h3 id="核心方法源码解析">核心方法源码解析</h3>
<h4 id="1-threadlocal-set-t-value-设置入口">1. ThreadLocal.set(T value) —— 设置入口</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br>    <span class="hljs-comment">// 1. 获取当前线程</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-comment">// 2. 获取当前线程的 ThreadLocalMap</span><br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)<br>        <span class="hljs-comment">// 3a. Map 已存在，直接设置</span><br>        map.set(<span class="hljs-built_in">this</span>, value);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-comment">// 3b. Map 不存在，创建并设置第一个值</span><br>        createMap(t, value);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>设计要点</strong>：<code>set()</code> 方法体现了<strong>懒加载</strong>思想——只有在首次调用 <code>set()</code> 时才创建 ThreadLocalMap。</p>
<h4 id="2-getmap-thread-t-获取线程的-map">2. getMap(Thread t) —— 获取线程的 Map</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadLocalMap <span class="hljs-title function_">getMap</span><span class="hljs-params">(Thread t)</span> &#123;<br>    <span class="hljs-keyword">return</span> t.threadLocals;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>设计要点</strong>：这个方法揭示了 ThreadLocal 的核心设计——<strong>Map 存储在 Thread 对象内部</strong>，而不是 ThreadLocal 对象内部。这是&quot;让 Thread 持有 Map，而不是让 Map 持有 Thread&quot;设计理念的直接体现。</p>
<h4 id="3-createmap-thread-t-t-firstvalue-创建-map">3. createMap(Thread t, T firstValue) —— 创建 Map</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> &#123;<br>    t.threadLocals = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalMap</span>(<span class="hljs-built_in">this</span>, firstValue);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>设计要点</strong>：创建 Map 时直接传入第一个键值对，避免了&quot;先创建空 Map，再插入&quot;的两步操作。</p>
<h4 id="4-threadlocalmap-构造函数">4. ThreadLocalMap 构造函数</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;<br>    <span class="hljs-comment">// 1. 初始化 Entry 数组，初始容量为 16</span><br>    table = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[INITIAL_CAPACITY];<br>    <span class="hljs-comment">// 2. 计算第一个 Entry 的位置（使用魔数 0x61c88647 保证哈希分布均匀）</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 3. 创建 Entry 并放入数组</span><br>    table[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(firstKey, firstValue);<br>    size = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 4. 设置扩容阈值（容量的 2/3）</span><br>    setThreshold(INITIAL_CAPACITY);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>设计要点</strong>：</p>
<ul>
<li>初始容量 16，与 HashMap 相同</li>
<li>使用 <code>0x61c88647</code>（黄金分割数）作为哈希增量，使 Entry 分布更均匀</li>
<li>扩容阈值为容量的 2/3，比 HashMap 的 0.75 更保守，减少哈希冲突</li>
</ul>
<h4 id="5-threadlocalmap-set-threadlocal-key-object-value-核心设置逻辑">5. ThreadLocalMap.set(ThreadLocal&lt;?&gt; key, Object value) —— 核心设置逻辑</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br>    <span class="hljs-comment">// 1. 计算初始位置</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (len - <span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// 2. 线性探测</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[i]; e != <span class="hljs-literal">null</span>; e = tab[i = nextIndex(i, len)]) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();  <span class="hljs-comment">// 获取弱引用指向的 ThreadLocal</span><br><br>        <span class="hljs-comment">// 2a. 找到相同的 key，更新 value</span><br>        <span class="hljs-keyword">if</span> (k == key) &#123;<br>            e.value = value;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 2b. 发现 Stale Entry（key 已被 GC），替换它</span><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>) &#123;<br>            replaceStaleEntry(key, value, i);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 3. 找到空槽位，创建新 Entry</span><br>    tab[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(key, value);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> ++size;<br>    <br>    <span class="hljs-comment">// 4. 尝试清理一些 Stale Entry，如果没清理掉且超过阈值则扩容</span><br>    <span class="hljs-keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)<br>        rehash();<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>设计要点</strong>：</p>
<ul>
<li>使用<strong>线性探测</strong>解决哈希冲突</li>
<li>在探测过程中<strong>顺便清理</strong> Stale Entry（<code>k == null</code> 的情况）</li>
<li><code>cleanSomeSlots()</code> 是启发式清理，不会扫描全表</li>
</ul>
<h4 id="6-threadlocal-get-获取入口">6. ThreadLocal.get() —— 获取入口</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 1. 尝试获取 Entry</span><br>        ThreadLocalMap.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> map.getEntry(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (T) e.value;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 2. Map 不存在或 Entry 不存在，初始化</span><br>    <span class="hljs-keyword">return</span> setInitialValue();<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="7-getentryaftermiss-threadlocal-key-int-i-entry-e-哈希冲突时的查找">7. getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) —— 哈希冲突时的查找</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Entry <span class="hljs-title function_">getEntryAfterMiss</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, <span class="hljs-type">int</span> i, Entry e)</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br><br>    <span class="hljs-comment">// 线性探测查找</span><br>    <span class="hljs-keyword">while</span> (e != <span class="hljs-literal">null</span>) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br>        <span class="hljs-keyword">if</span> (k == key)<br>            <span class="hljs-keyword">return</span> e;  <span class="hljs-comment">// 找到了</span><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>)<br>            expungeStaleEntry(i);  <span class="hljs-comment">// 顺便清理 Stale Entry</span><br>        <span class="hljs-keyword">else</span><br>            i = nextIndex(i, len);  <span class="hljs-comment">// 继续探测</span><br>        e = tab[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 没找到</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>设计要点</strong>：在查找过程中<strong>顺便清理</strong>遇到的 Stale Entry，这是&quot;惰性清理&quot;策略的体现。</p>
<h4 id="8-threadlocal-remove-和-threadlocalmap-remove-threadlocal-key">8. ThreadLocal.remove() 和 ThreadLocalMap.remove(ThreadLocal&lt;?&gt; key)</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ThreadLocal.remove()</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> getMap(Thread.currentThread());<br>    <span class="hljs-keyword">if</span> (m != <span class="hljs-literal">null</span>)<br>        m.remove(<span class="hljs-built_in">this</span>);<br>&#125;<br><br><span class="hljs-comment">// ThreadLocalMap.remove()</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key)</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (len - <span class="hljs-number">1</span>);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[i]; e != <span class="hljs-literal">null</span>; e = tab[i = nextIndex(i, len)]) &#123;<br>        <span class="hljs-keyword">if</span> (e.get() == key) &#123;<br>            e.clear();  <span class="hljs-comment">// 清除弱引用</span><br>            expungeStaleEntry(i);  <span class="hljs-comment">// 清理该位置并 rehash 后续元素</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="9-expungestaleentry-int-staleslot-核心清理方法">9. expungeStaleEntry(int staleSlot) —— 核心清理方法</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">expungeStaleEntry</span><span class="hljs-params">(<span class="hljs-type">int</span> staleSlot)</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br><br>    <span class="hljs-comment">// 1. 清理目标位置的 Stale Entry</span><br>    tab[staleSlot].value = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 断开 value 的强引用，使其可被 GC</span><br>    tab[staleSlot] = <span class="hljs-literal">null</span>;        <span class="hljs-comment">// 断开 Entry 的引用</span><br>    size--;<br><br>    <span class="hljs-comment">// 2. 继续向后扫描，直到遇到空槽位</span><br>    Entry e;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = nextIndex(staleSlot, len); (e = tab[i]) != <span class="hljs-literal">null</span>; i = nextIndex(i, len)) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 2a. 又发现一个 Stale Entry，清理它</span><br>            e.value = <span class="hljs-literal">null</span>;<br>            tab[i] = <span class="hljs-literal">null</span>;<br>            size--;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 2b. 有效 Entry，检查是否需要 rehash</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> k.threadLocalHashCode &amp; (len - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (h != i) &#123;<br>                <span class="hljs-comment">// 该 Entry 不在其理想位置，需要重新放置</span><br>                tab[i] = <span class="hljs-literal">null</span>;<br>                <span class="hljs-comment">// 找到一个空槽位放置</span><br>                <span class="hljs-keyword">while</span> (tab[h] != <span class="hljs-literal">null</span>)<br>                    h = nextIndex(h, len);<br>                tab[h] = e;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> i;  <span class="hljs-comment">// 返回扫描结束的位置</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>设计要点</strong>：</p>
<ul>
<li>参数 <code>staleSlot</code> 是<strong>已知的 Stale Entry 位置</strong></li>
<li>不仅清理目标位置，还会<strong>继续向后扫描</strong>清理更多 Stale Entry</li>
<li>对有效 Entry 进行 <strong>rehash</strong>，确保线性探测链不断裂</li>
<li>返回值是扫描结束的位置，供调用者使用</li>
</ul>
<h3 id="方法调用关系总结">方法调用关系总结</h3>
<table>
<thead>
<tr>
<th>外部 API</th>
<th>调用的内部方法</th>
<th>可能触发的清理方法</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>set(T)</code></td>
<td><code>getMap()</code> → <code>ThreadLocalMap.set()</code> 或 <code>createMap()</code></td>
<td><code>replaceStaleEntry()</code> → <code>expungeStaleEntry()</code><br/><code>cleanSomeSlots()</code> → <code>expungeStaleEntry()</code></td>
</tr>
<tr>
<td><code>get()</code></td>
<td><code>getMap()</code> → <code>getEntry()</code> → <code>getEntryAfterMiss()</code> 或 <code>setInitialValue()</code></td>
<td><code>expungeStaleEntry()</code></td>
</tr>
<tr>
<td><code>remove()</code></td>
<td><code>getMap()</code> → <code>ThreadLocalMap.remove()</code></td>
<td><code>expungeStaleEntry()</code></td>
</tr>
</tbody>
</table>
<p><strong>核心结论</strong>：<code>expungeStaleEntry()</code> 是所有清理操作的<strong>最终执行者</strong>，而 <code>get()</code>、<code>set()</code>、<code>remove()</code> 都会在执行过程中触发它，实现&quot;惰性清理&quot;。</p>
<h2 id="为什么-threadlocalmap-使用开放地址法而不是链表法？">为什么 ThreadLocalMap 使用开放地址法而不是链表法？</h2>
<p><code>HashMap</code> 使用&quot;数组 + 链表/红黑树&quot;的结构来处理哈希冲突，而 <code>ThreadLocalMap</code> 却选择了<strong>开放地址法（线性探测）</strong>。这个设计选择背后有深刻的考量：</p>
<table>
<thead>
<tr>
<th>对比维度</th>
<th>HashMap（链表法）</th>
<th>ThreadLocalMap（开放地址法）</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>冲突处理</strong></td>
<td>冲突的元素挂在同一个桶的链表上</td>
<td>冲突时向后探测下一个空槽位</td>
</tr>
<tr>
<td><strong>内存布局</strong></td>
<td>链表节点分散在堆中，缓存不友好</td>
<td>所有 Entry 在连续数组中，缓存友好</td>
</tr>
<tr>
<td><strong>空间开销</strong></td>
<td>每个节点需要额外的 next 指针</td>
<td>无额外指针开销</td>
</tr>
<tr>
<td><strong>删除操作</strong></td>
<td>简单的链表节点删除</td>
<td>需要 rehash 后续元素（复杂）</td>
</tr>
</tbody>
</table>
<p><strong>ThreadLocalMap 选择开放地址法的核心原因：</strong></p>
<ol>
<li>
<p><strong>Entry 数量通常很少</strong>：一个线程的 ThreadLocalMap 中通常只有几个到几十个 Entry（对应几个 ThreadLocal 变量），远少于 HashMap 的典型使用场景。在元素少的情况下，开放地址法的线性探测效率很高。</p>
</li>
<li>
<p><strong>弱引用清理的需要</strong>：ThreadLocalMap 的 key 是弱引用，需要在遍历过程中发现并清理 Stale Entry。开放地址法的线性探测天然支持这种&quot;顺便清理&quot;的模式——在查找目标 Entry 的过程中，可以顺便清理沿途遇到的 Stale Entry。</p>
</li>
<li>
<p><strong>缓存友好性</strong>：开放地址法将所有 Entry 存储在连续的数组中，CPU 缓存预取效果好。对于频繁访问的 ThreadLocal（如每次请求都要读取的上下文信息），缓存友好性带来的性能提升是显著的。</p>
</li>
</ol>
<h2 id="内存泄漏的发生机制">内存泄漏的发生机制</h2>
<p>ThreadLocal 的内存泄漏实际上是一个条件链，任何一个环节被破坏都可能导致泄漏：</p>
<ol>
<li><strong>ThreadLocal 对象被回收</strong>：当 ThreadLocal 对象没有强引用时（如静态变量被置为 null），它会被 GC 回收</li>
<li><strong>Entry 的 key 变为 null</strong>：ThreadLocalMap 中对应的 Entry 的 key（弱引用）失效</li>
<li><strong>value 仍被强引用</strong>：但 value 仍被 Entry 强引用，无法被回收（<strong>value 不是被 key 引用，而是被 Entry 引用</strong>）</li>
<li><strong>自动清理机制</strong>：后续的 get/set/remove 操作会触发 <code>expungeStaleEntry()</code>，清理 key 为 null 的 Entry</li>
<li><strong>泄漏发生</strong>：如果线程长期存活（如线程池）且不再调用 get/set/remove，这些 Entry 永远不会被清理</li>
</ol>
<p><strong>Value 泄漏的因果链</strong>：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ada">ThreadLocal 对象失去强引用 <br>    → <span class="hljs-keyword">Entry</span>.key (WeakReference) 被 GC 回收变成 null<br>    → 但 <span class="hljs-keyword">Entry</span> 本身还在 ThreadLocalMap 中（<span class="hljs-keyword">Entry</span> 泄漏/Stale <span class="hljs-keyword">Entry</span>）<br>    → <span class="hljs-keyword">Entry</span> 持有 value 的强引用<br>    → value 无法被回收（Value 泄漏）<br></code></pre></td></tr></table></figure>
<p><strong>结论</strong>：Value 泄漏是 Entry 泄漏的直接后果。更准确地说，是因为 <strong>Stale Entry 没有被及时清理</strong>——ThreadLocal 对象本身是可以被回收的（因为是弱引用），问题在于回收后遗留的 Stale Entry 没有被清理。</p>
<h1>实践篇：ThreadLocal 的使用模式</h1>
<h2 id="基础版本：静态工具类封装">基础版本：静态工具类封装</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 定义基础的 Context 类型</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerContext</span> &#123;<br>    <span class="hljs-keyword">private</span> String traceId;<br>    <span class="hljs-keyword">private</span> String userId;<br>    <span class="hljs-comment">// getters and setters</span><br>&#125;<br><br><span class="hljs-comment">// 为这个基础类型装载一个 ThreadLocal 容器，然后为这个容器准备一个静态工具类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ContextHolder</span> &#123;<br>    <span class="hljs-comment">// ThreadLocal 必须是 static 的</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;ServerContext&gt; SERVER_CONTEXT = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ServerContext <span class="hljs-title function_">getServerContext</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> SERVER_CONTEXT.get();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setServerContext</span><span class="hljs-params">(ServerContext context)</span> &#123;<br>        SERVER_CONTEXT.set(context);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> &#123;<br>        SERVER_CONTEXT.remove();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 一个更大的 context，来汇总各种容器工具类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BizContext</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCurrentServerContext</span><span class="hljs-params">(<span class="hljs-keyword">final</span> ServerContext context)</span> &#123;<br>        <span class="hljs-comment">// 注意这里把 null 拿来 clear，而不是直接 put 的逻辑</span><br>        <span class="hljs-keyword">if</span> (context == <span class="hljs-literal">null</span>) &#123;<br>            ContextHolder.clear();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ContextHolder.setServerContext(context);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="用-map-来取消第一层工具类的方案">用 Map 来取消第一层工具类的方案</h2>
<p>这种方案使用一个 Map 来存储多种类型的上下文，但<strong>Map 容易腐化</strong>，需要谨慎使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ContextFactory</span> &#123;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">ContextFactory</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 私有构造器</span><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 上下文持有器</span><br><span class="hljs-comment">     * 全局静态变量，保存真正的交易上下文。</span><br><span class="hljs-comment">     * withInitial 没有被重载过，必须赋值给 ThreadLocal 类型。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;Map&lt;String, Object&gt;&gt; CONTEXT_HOLDER = <br>        InheritableThreadLocal.withInitial(() -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="hljs-number">16</span>));<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> &#123;<br>        CONTEXT_HOLDER.remove();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;Map&lt;String, Object&gt;&gt; <span class="hljs-title function_">getContextHolder</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> CONTEXT_HOLDER;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TransactionContextFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ContextFactory</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">TransactionContextFactory</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">TRANSACTION_CONTEXT_KEY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;TransactionContext&quot;</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 静态工厂方法，获取交易上下文实例。</span><br><span class="hljs-comment">     * 因为线程封闭和线程隔离，这里无需加锁和 double check</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; TransactionContext&lt;T&gt; <span class="hljs-title function_">getTransactionContext</span><span class="hljs-params">()</span> &#123;<br>        Map&lt;String, Object&gt; realContextHolder = getContextHolder().get();<br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == realContextHolder) &#123;<br>            realContextHolder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="hljs-number">16</span>);<br>            getContextHolder().set(realContextHolder);<br>        &#125;<br>        <br>        TransactionContext&lt;T&gt; realContext;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">mapValue</span> <span class="hljs-operator">=</span> realContextHolder.get(TRANSACTION_CONTEXT_KEY);<br>        <span class="hljs-keyword">if</span> (mapValue <span class="hljs-keyword">instanceof</span> TransactionContext) &#123;<br>            realContext = (TransactionContext&lt;T&gt;) mapValue;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            realContext = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransactionContext</span>&lt;&gt;();<br>            realContextHolder.put(TRANSACTION_CONTEXT_KEY, realContext);<br>        &#125;<br>        <span class="hljs-keyword">return</span> realContext;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>对这个 Map 的加强版本——不可变 Map 模式</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String key, <span class="hljs-keyword">final</span> String value)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!useMap) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    Map&lt;String, String&gt; map = localMap.get();<br>    <span class="hljs-comment">// 每次修改都创建新的不可变 Map，保证线程安全</span><br>    map = map == <span class="hljs-literal">null</span> ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">1</span>) : <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(map);<br>    map.put(key, value);<br>    localMap.set(Collections.unmodifiableMap(map));<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="绑定容器到线程并保存上一个状态">绑定容器到线程并保存上一个状态</h2>
<p>这是 Spring 事务管理中使用的经典模式——<strong>栈式上下文管理</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bindToThread</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 保存当前的 TransactionInfo，以便事务完成后恢复</span><br>    <span class="hljs-built_in">this</span>.oldTransactionInfo = transactionInfoHolder.get();<br>    transactionInfoHolder.set(<span class="hljs-built_in">this</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">restoreThreadLocalStatus</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 使用栈来恢复旧的 TransactionInfo</span><br>    <span class="hljs-comment">// 如果没有旧的，则为 null</span><br>    transactionInfoHolder.set(<span class="hljs-built_in">this</span>.oldTransactionInfo);<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="threadlocal-变策略模式">ThreadLocal 变策略模式</h2>
<p>Spring Security 的 <code>SecurityContextHolder</code> 是一个经典的策略模式实现，支持三种存储策略：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 策略接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">SecurityContextHolderStrategy</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">clearContext</span><span class="hljs-params">()</span>;<br>    SecurityContext <span class="hljs-title function_">getContext</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setContext</span><span class="hljs-params">(SecurityContext context)</span>;<br>    SecurityContext <span class="hljs-title function_">createEmptyContext</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">// InheritableThreadLocal 策略实现</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InheritableThreadLocalSecurityContextHolderStrategy</span> <span class="hljs-keyword">implements</span><br>        <span class="hljs-title class_">SecurityContextHolderStrategy</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;SecurityContext&gt; contextHolder = <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">InheritableThreadLocal</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clearContext</span><span class="hljs-params">()</span> &#123;<br>        contextHolder.remove();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> SecurityContext <span class="hljs-title function_">getContext</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">SecurityContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> contextHolder.get();<br>        <span class="hljs-keyword">if</span> (ctx == <span class="hljs-literal">null</span>) &#123;<br>            ctx = createEmptyContext();<br>            contextHolder.set(ctx);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ctx;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setContext</span><span class="hljs-params">(SecurityContext context)</span> &#123;<br>        Assert.notNull(context, <span class="hljs-string">&quot;Only non-null SecurityContext instances are permitted&quot;</span>);<br>        contextHolder.set(context);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> SecurityContext <span class="hljs-title function_">createEmptyContext</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecurityContextImpl</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 策略持有者</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecurityContextHolder</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">MODE_THREADLOCAL</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;MODE_THREADLOCAL&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">MODE_INHERITABLETHREADLOCAL</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;MODE_INHERITABLETHREADLOCAL&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">MODE_GLOBAL</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;MODE_GLOBAL&quot;</span>;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">strategyName</span> <span class="hljs-operator">=</span> System.getProperty(<span class="hljs-string">&quot;spring.security.strategy&quot;</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SecurityContextHolderStrategy strategy;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        initialize();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initialize</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (!StringUtils.hasText(strategyName)) &#123;<br>            strategyName = MODE_THREADLOCAL;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (strategyName.equals(MODE_THREADLOCAL)) &#123;<br>            strategy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalSecurityContextHolderStrategy</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (strategyName.equals(MODE_INHERITABLETHREADLOCAL)) &#123;<br>            strategy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InheritableThreadLocalSecurityContextHolderStrategy</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (strategyName.equals(MODE_GLOBAL)) &#123;<br>            strategy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GlobalSecurityContextHolderStrategy</span>();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 尝试加载自定义策略</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                Class&lt;?&gt; clazz = Class.forName(strategyName);<br>                Constructor&lt;?&gt; customStrategy = clazz.getConstructor();<br>                strategy = (SecurityContextHolderStrategy) customStrategy.newInstance();<br>            &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>                ReflectionUtils.handleReflectionException(ex);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clearContext</span><span class="hljs-params">()</span> &#123;<br>        strategy.clearContext();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SecurityContext <span class="hljs-title function_">getContext</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> strategy.getContext();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setContext</span><span class="hljs-params">(SecurityContext context)</span> &#123;<br>        strategy.setContext(context);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="带名字的-threadlocal">带名字的 ThreadLocal</h2>
<p>Spring 提供的 <code>NamedThreadLocal</code>，便于调试和诊断：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NamedThreadLocal</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ThreadLocal</span>&lt;T&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NamedThreadLocal</span><span class="hljs-params">(String name)</span> &#123;<br>        Assert.hasText(name, <span class="hljs-string">&quot;Name must not be empty&quot;</span>);<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1>跨线程传递篇：InheritableThreadLocal 与 TransmittableThreadLocal</h1>
<h2 id="inheritablethreadlocal-的工作原理">InheritableThreadLocal 的工作原理</h2>
<h3 id="thread-类的双-map-设计">Thread 类的双 Map 设计</h3>
<p>Thread 类里面其实存在两个 ThreadLocalMap：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-comment">// 当前线程的 ThreadLocalMap，主要存储该线程自身的 ThreadLocal</span><br>    ThreadLocal.<span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">threadLocals</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-comment">// InheritableThreadLocal，自父线程继承而来的 ThreadLocalMap</span><br>    <span class="hljs-comment">// 主要用于父子线程间 ThreadLocal 变量的传递</span><br>    ThreadLocal.<span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">inheritableThreadLocals</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="inheritablethreadlocal-的极简实现">InheritableThreadLocal 的极简实现</h3>
<p>令人惊讶的是，<code>InheritableThreadLocal</code> 只有 <strong>3 个方法</strong>，却实现了完整的父子线程值传递功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InheritableThreadLocal</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ThreadLocal</span>&lt;T&gt; &#123;<br>    <br>    <span class="hljs-comment">// 1. 子线程继承时调用，可重写以修改继承的值</span><br>    <span class="hljs-keyword">protected</span> T <span class="hljs-title function_">childValue</span><span class="hljs-params">(T parentValue)</span> &#123;<br>        <span class="hljs-keyword">return</span> parentValue;  <span class="hljs-comment">// 默认直接返回父线程的值</span><br>    &#125;<br><br>    <span class="hljs-comment">// 2. 重写 getMap，返回 inheritableThreadLocals 而非 threadLocals</span><br>    ThreadLocalMap <span class="hljs-title function_">getMap</span><span class="hljs-params">(Thread t)</span> &#123;<br>        <span class="hljs-keyword">return</span> t.inheritableThreadLocals;<br>    &#125;<br><br>    <span class="hljs-comment">// 3. 重写 createMap，创建 inheritableThreadLocals 而非 threadLocals</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> &#123;<br>        t.inheritableThreadLocals = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalMap</span>(<span class="hljs-built_in">this</span>, firstValue);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>设计精妙之处</strong>：通过重写 <code>getMap()</code> 和 <code>createMap()</code> 两个方法，将所有 <code>InheritableThreadLocal</code> 的值存储在独立的 <code>inheritableThreadLocals</code> Map 中，与普通 <code>ThreadLocal</code> 完全隔离。这样在创建子线程时，只需复制 <code>inheritableThreadLocals</code>，而不影响 <code>threadLocals</code>。</p>
<h3 id="thread-init-方法逐行解析">Thread.init() 方法逐行解析</h3>
<p>线程的构造器里隐藏着继承的核心逻辑。下面是 <code>Thread.init()</code> 方法的<strong>逐行中文注释</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 初始化一个线程</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> g             线程组</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> target        要执行的 Runnable</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> name          线程名称</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> stackSize     栈大小（0 表示忽略）</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> acc           访问控制上下文</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> inheritThreadLocals 是否继承父线程的 InheritableThreadLocal</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(ThreadGroup g, Runnable target, String name,</span><br><span class="hljs-params">                  <span class="hljs-type">long</span> stackSize, AccessControlContext acc,</span><br><span class="hljs-params">                  <span class="hljs-type">boolean</span> inheritThreadLocals)</span> &#123;<br>    <br>    <span class="hljs-comment">// 1. 线程名不能为 null</span><br>    <span class="hljs-keyword">if</span> (name == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">&quot;name cannot be null&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <br>    <span class="hljs-comment">// 2. 获取当前线程作为&quot;父线程&quot;</span><br>    <span class="hljs-comment">//    关键：创建子线程的线程就是父线程</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> currentThread();<br>    <br>    <span class="hljs-comment">// 3. 安全管理器检查</span><br>    <span class="hljs-type">SecurityManager</span> <span class="hljs-variable">security</span> <span class="hljs-operator">=</span> System.getSecurityManager();<br>    <span class="hljs-keyword">if</span> (g == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 如果没有指定线程组，尝试从安全管理器获取</span><br>        <span class="hljs-keyword">if</span> (security != <span class="hljs-literal">null</span>) &#123;<br>            g = security.getThreadGroup();<br>        &#125;<br>        <span class="hljs-comment">// 如果还是没有，使用父线程的线程组</span><br>        <span class="hljs-keyword">if</span> (g == <span class="hljs-literal">null</span>) &#123;<br>            g = parent.getThreadGroup();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 4. 检查是否有权限访问该线程组</span><br>    g.checkAccess();<br>    <br>    <span class="hljs-comment">// 5. 检查是否有权限创建子类（如果是 Thread 的子类）</span><br>    <span class="hljs-keyword">if</span> (security != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (isCCLOverridden(getClass())) &#123;<br>            security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 6. 将线程添加到线程组（未启动状态）</span><br>    g.addUnstarted();<br>    <br>    <span class="hljs-comment">// 7. 设置线程组</span><br>    <span class="hljs-built_in">this</span>.group = g;<br>    <br>    <span class="hljs-comment">// 8. 继承父线程的 daemon 属性</span><br>    <span class="hljs-comment">//    如果父线程是守护线程，子线程也是守护线程</span><br>    <span class="hljs-built_in">this</span>.daemon = parent.isDaemon();<br>    <br>    <span class="hljs-comment">// 9. 继承父线程的优先级</span><br>    <span class="hljs-built_in">this</span>.priority = parent.getPriority();<br>    <br>    <span class="hljs-comment">// 10. 设置上下文类加载器</span><br>    <span class="hljs-keyword">if</span> (security == <span class="hljs-literal">null</span> || isCCLOverridden(parent.getClass())) &#123;<br>        <span class="hljs-built_in">this</span>.contextClassLoader = parent.getContextClassLoader();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">this</span>.contextClassLoader = parent.contextClassLoader;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 11. 设置访问控制上下文</span><br>    <span class="hljs-built_in">this</span>.inheritedAccessControlContext = <br>        acc != <span class="hljs-literal">null</span> ? acc : AccessController.getContext();<br>    <br>    <span class="hljs-comment">// 12. 设置要执行的 Runnable</span><br>    <span class="hljs-built_in">this</span>.target = target;<br>    <br>    <span class="hljs-comment">// 13. 应用优先级设置</span><br>    setPriority(priority);<br>    <br>    <span class="hljs-comment">// ========== 关键代码：InheritableThreadLocal 的继承 ==========</span><br>    <span class="hljs-comment">// 14. 如果允许继承且父线程有 inheritableThreadLocals</span><br>    <span class="hljs-keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 创建子线程的 inheritableThreadLocals，复制父线程的所有值</span><br>        <span class="hljs-built_in">this</span>.inheritableThreadLocals =<br>            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);<br>    &#125;<br>    <span class="hljs-comment">// ============================================================</span><br>    <br>    <span class="hljs-comment">// 15. 设置栈大小</span><br>    <span class="hljs-built_in">this</span>.stackSize = stackSize;<br>    <br>    <span class="hljs-comment">// 16. 分配线程 ID</span><br>    tid = nextThreadID();<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="继承流程图解">继承流程图解</h3>
<pre><code class="hljs mermaid">sequenceDiagram
    participant Main as 主线程
    participant Thread as Thread 类
    participant Child as 子线程
    participant ITL as InheritableThreadLocal
    
    Note over Main: 主线程设置 ITL 值
    Main-&gt;&gt;ITL: set(&quot;parent-value&quot;)
    ITL-&gt;&gt;Main: 存入 inheritableThreadLocals
    
    Note over Main,Child: 创建子线程
    Main-&gt;&gt;Thread: new Thread(runnable)
    Thread-&gt;&gt;Thread: init(..., inheritThreadLocals=true)
    
    Note over Thread: init() 方法执行
    Thread-&gt;&gt;Main: parent = currentThread()
    Thread-&gt;&gt;Main: 检查 parent.inheritableThreadLocals
    
    alt parent.inheritableThreadLocals != null
        Thread-&gt;&gt;Thread: createInheritedMap(parent.inheritableThreadLocals)
        Note over Thread: 遍历父线程的 Map&lt;br/&gt;对每个 Entry 调用 childValue()&lt;br/&gt;创建子线程的 Map
        Thread-&gt;&gt;Child: this.inheritableThreadLocals = 新 Map
    end
    
    Note over Child: 子线程启动后
    Child-&gt;&gt;ITL: get()
    ITL-&gt;&gt;Child: 从 inheritableThreadLocals 获取
    Child--&gt;&gt;Child: 返回 &quot;parent-value&quot;</code></pre>
<h3 id="thread-为-inheritablethreadlocal-的专门改造">Thread 为 InheritableThreadLocal 的专门改造</h3>
<p><strong>问题</strong>：Thread 类是否为 InheritableThreadLocal 专门改造过？</p>
<p><strong>答案</strong>：是的，Thread 类进行了以下专门改造：</p>
<ol>
<li><strong>新增字段</strong>：<code>inheritableThreadLocals</code> 字段专门用于存储可继承的 ThreadLocal 值</li>
<li><strong>init() 方法增强</strong>：添加了 <code>inheritThreadLocals</code> 参数和复制逻辑</li>
<li><strong>createInheritedMap() 方法</strong>：ThreadLocal 类中专门提供了创建继承 Map 的静态方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ThreadLocal.createInheritedMap() 源码</span><br><span class="hljs-keyword">static</span> ThreadLocalMap <span class="hljs-title function_">createInheritedMap</span><span class="hljs-params">(ThreadLocalMap parentMap)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalMap</span>(parentMap);<br>&#125;<br><br><span class="hljs-comment">// ThreadLocalMap 的私有构造函数，专门用于继承</span><br><span class="hljs-keyword">private</span> <span class="hljs-title function_">ThreadLocalMap</span><span class="hljs-params">(ThreadLocalMap parentMap)</span> &#123;<br>    Entry[] parentTable = parentMap.table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> parentTable.length;<br>    setThreshold(len);<br>    table = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[len];<br><br>    <span class="hljs-comment">// 遍历父线程的所有 Entry</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; len; j++) &#123;<br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> parentTable[j];<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();<br>            <span class="hljs-keyword">if</span> (key != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 调用 childValue() 获取子线程应该继承的值</span><br>                <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> key.childValue(e.value);<br>                <span class="hljs-type">Entry</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(key, value);<br>                <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (len - <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">while</span> (table[h] != <span class="hljs-literal">null</span>)<br>                    h = nextIndex(h, len);<br>                table[h] = c;<br>                size++;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="为什么需要两个-map？不能合并吗？">为什么需要两个 Map？不能合并吗？</h3>
<p><strong>问题</strong>：为什么 Thread 要有 <code>threadLocals</code> 和 <code>inheritableThreadLocals</code> 两个 Map，不能合并成一个吗？</p>
<p><strong>答案</strong>：不能合并，原因如下：</p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;如果只有一个 Map 的问题&quot;
        direction TB
        
        subgraph &quot;父线程&quot;
            P_TL1[&quot;ThreadLocal A = 敏感数据&quot;]
            P_TL2[&quot;ThreadLocal B = 普通数据&quot;]
            P_ITL[&quot;InheritableThreadLocal C = 需要传递的数据&quot;]
            style P_TL1 fill:#ffcdd2
            style P_TL2 fill:#fff9c4
            style P_ITL fill:#c8e6c9
        end
        
        arrow[&quot;创建子线程时&lt;br/&gt;如果只有一个 Map&lt;br/&gt;要么全部复制，要么全不复制&quot;]
        style arrow fill:#ffebee
        
        subgraph &quot;子线程&quot;
            C_TL1[&quot;ThreadLocal A = 敏感数据 (不应该继承)&quot;]
            C_TL2[&quot;ThreadLocal B = 普通数据 (不应该继承)&quot;]
            C_ITL[&quot;InheritableThreadLocal C = 需要传递的数据 (应该继承)&quot;]
            style C_TL1 fill:#ffcdd2
            style C_TL2 fill:#fff9c4
            style C_ITL fill:#c8e6c9
        end
    end</code></pre>
<p><strong>不能合并的四个核心原因</strong>：</p>
<table>
<thead>
<tr>
<th>原因</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1. 语义隔离</strong></td>
<td>普通 <code>ThreadLocal</code> 的设计初衷是<strong>线程隔离</strong>，不应该被子线程看到；<code>InheritableThreadLocal</code> 的设计初衷是<strong>父子传递</strong>。两者语义完全相反</td>
</tr>
<tr>
<td><strong>2. 安全性</strong></td>
<td>如果合并，敏感的 <code>ThreadLocal</code> 值（如数据库连接、事务状态）会意外被子线程继承，造成安全隐患</td>
</tr>
<tr>
<td><strong>3. 性能优化</strong></td>
<td>分开存储后，创建子线程时只需复制 <code>inheritableThreadLocals</code>，而不是全部 ThreadLocal 值，减少开销</td>
</tr>
<tr>
<td><strong>4. 选择性继承</strong></td>
<td>开发者可以明确选择哪些变量需要继承（使用 <code>InheritableThreadLocal</code>），哪些不需要（使用普通 <code>ThreadLocal</code>）</td>
</tr>
</tbody>
</table>
<p><strong>继承流程对比</strong>：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss">使用两个 Map（当前设计）：<br>父线程<br>  ├─ threadLocals (不继承) ────────────────&gt; 子线程 threadLocals (空)<br>  └─ inheritableThreadLocals (继承) ──复制──&gt; 子线程 inheritableThreadLocals<br><br>如果只有一个 Map（假设）：<br>父线程<br>  └─ threadLocals ──全部复制──&gt; 子线程 threadLocals<br>     ↑ 问题：无法区分哪些应该继承，哪些不应该<br></code></pre></td></tr></table></figure>
<h3 id="inheritablethreadlocal-的浅拷贝问题">InheritableThreadLocal 的浅拷贝问题</h3>
<p><code>InheritableThreadLocal</code> 在继承时存在<strong>浅拷贝问题</strong>。<code>childValue()</code> 方法默认直接返回父线程的值引用，而不是深拷贝：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// InheritableThreadLocal 的默认实现</span><br><span class="hljs-keyword">protected</span> T <span class="hljs-title function_">childValue</span><span class="hljs-params">(T parentValue)</span> &#123;<br>    <span class="hljs-keyword">return</span> parentValue;  <span class="hljs-comment">// 直接返回引用，不是深拷贝！</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>问题演示</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">InheritableThreadLocal&lt;List&lt;String&gt;&gt; context = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InheritableThreadLocal</span>&lt;&gt;();<br>List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-string">&quot;parent-item&quot;</span>);<br>context.set(list);<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    List&lt;String&gt; childList = context.get();<br>    childList.add(<span class="hljs-string">&quot;child-item&quot;</span>);  <span class="hljs-comment">// 修改子线程的 list</span><br>    System.out.println(<span class="hljs-string">&quot;子线程: &quot;</span> + childList);<br>&#125;).start();<br><br>Thread.sleep(<span class="hljs-number">100</span>);<br>System.out.println(<span class="hljs-string">&quot;父线程: &quot;</span> + context.get());<br><span class="hljs-comment">// 输出：</span><br><span class="hljs-comment">// 子线程: [parent-item, child-item]</span><br><span class="hljs-comment">// 父线程: [parent-item, child-item]  -- 父线程的值也被修改了</span><br></code></pre></td></tr></table></figure>
<p><strong>解决方案</strong>：重写 <code>childValue()</code> 方法实现深拷贝：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">InheritableThreadLocal&lt;List&lt;String&gt;&gt; context = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InheritableThreadLocal</span>&lt;&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> List&lt;String&gt; <span class="hljs-title function_">childValue</span><span class="hljs-params">(List&lt;String&gt; parentValue)</span> &#123;<br>        <span class="hljs-comment">// 深拷贝：创建新的 ArrayList</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(parentValue);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="inheritablethreadlocal-的局限性">InheritableThreadLocal 的局限性</h3>
<p><strong>InheritableThreadLocal 的局限性</strong>：它只在<strong>创建子线程时</strong>复制父线程的值。如果使用线程池，线程是复用的，不会每次都创建新线程，因此 InheritableThreadLocal 在线程池场景下<strong>无法正确传递上下文</strong>。</p>
<p><strong>这就是为什么需要 TransmittableThreadLocal</strong>——InheritableThreadLocal 对线程池极不友好，无法满足现代应用中大量使用线程池的场景。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 问题演示</span><br>InheritableThreadLocal&lt;String&gt; context = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InheritableThreadLocal</span>&lt;&gt;();<br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// 第一次提交</span><br>context.set(<span class="hljs-string">&quot;request-1&quot;</span>);<br>executor.submit(() -&gt; &#123;<br>    System.out.println(context.get()); <span class="hljs-comment">// 输出: request-1 (符合预期)</span><br>&#125;);<br><br><span class="hljs-comment">// 第二次提交（复用同一个线程）</span><br>context.set(<span class="hljs-string">&quot;request-2&quot;</span>);<br>executor.submit(() -&gt; &#123;<br>    System.out.println(context.get()); <span class="hljs-comment">// 输出: request-1 (错误，期望是 request-2)</span><br>&#125;);<br></code></pre></td></tr></table></figure>
<p><strong>原因</strong>：线程池中的线程在第一次执行任务时就已经创建完成，此时继承了 <code>request-1</code>。后续任务复用这个线程时，不会再触发 <code>Thread.init()</code> 中的继承逻辑。</p>
<h2 id="transmittablethreadlocal：线程池场景的解决方案">TransmittableThreadLocal：线程池场景的解决方案</h2>
<p>阿里巴巴开源的 <a target="_blank" rel="noopener" href="https://github.com/alibaba/transmittable-thread-local">TransmittableThreadLocal (TTL)</a> 解决了线程池场景下的上下文传递问题。</p>
<h3 id="核心挑战：不能修改-thread-类">核心挑战：不能修改 Thread 类</h3>
<p><code>InheritableThreadLocal</code> 之所以能实现父子线程传递，是因为 <strong>JDK 对 Thread 类进行了专门改造</strong>——添加了 <code>inheritableThreadLocals</code> 字段和 <code>init()</code> 方法中的复制逻辑。</p>
<p>但对于第三方库（如 TTL），<strong>无法修改 JDK 的 Thread 类</strong>。那么如何在不修改 Thread 的情况下，实现线程池场景的上下文传递呢？</p>
<h3 id="ttl-的巧妙解决方案：capture-replay-restore">TTL 的巧妙解决方案：Capture-Replay-Restore</h3>
<p>TTL 采用了一种完全不同的思路——<strong>在任务层面而非线程层面</strong>解决问题：</p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant Main as 主线程
    participant TTL as TransmittableThreadLocal
    participant Task as TtlRunnable
    participant Pool as 线程池
    participant Worker as 工作线程
    
    Note over Main: 阶段1：设置上下文
    Main-&gt;&gt;TTL: context.set(&quot;request-123&quot;)
    TTL-&gt;&gt;Main: 存入 inheritableThreadLocals
    
    Note over Main,Task: 阶段2：提交任务时捕获（Capture）
    Main-&gt;&gt;Task: TtlRunnable.get(runnable)
    Task-&gt;&gt;Task: capture() 捕获所有 TTL 值
    Note over Task: 创建快照：&#123;context: &quot;request-123&quot;&#125;
    Main-&gt;&gt;Pool: executor.submit(ttlRunnable)
    
    Note over Worker: 阶段3：执行前重放（Replay）
    Pool-&gt;&gt;Worker: 分配任务给工作线程
    Worker-&gt;&gt;Task: run()
    Task-&gt;&gt;Task: backup = replay(captured)
    Note over Task: 1. 备份工作线程当前的 TTL 值&lt;br/&gt;2. 将快照中的值设置到工作线程&lt;br/&gt;3. 清理不在快照中的 TTL 变量
    
    Note over Worker: 阶段4：执行任务
    Task-&gt;&gt;Worker: runnable.run()
    Worker-&gt;&gt;TTL: context.get()
    TTL--&gt;&gt;Worker: 返回 &quot;request-123&quot; (正确)
    
    Note over Worker: 阶段5：执行后恢复（Restore）
    Task-&gt;&gt;Task: restore(backup)
    Note over Task: 恢复工作线程原来的 TTL 值&lt;br/&gt;避免影响后续任务</code></pre>
<h3 id="核心实现原理">核心实现原理</h3>
<h4 id="1-holder-注册机制">1. holder 注册机制</h4>
<p>TTL 的关键创新是引入了一个<strong>全局注册表</strong>，记录所有 TTL 实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TransmittableThreadLocal</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InheritableThreadLocal</span>&lt;T&gt; &#123;<br>    <br>    <span class="hljs-comment">// 全局注册表：记录当前线程所有设置过值的 TTL 实例</span><br>    <span class="hljs-comment">// 使用 InheritableThreadLocal 存储，确保子线程也能继承这个注册表</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> InheritableThreadLocal&lt;WeakHashMap&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt;&gt; holder =<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">InheritableThreadLocal</span>&lt;WeakHashMap&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt;&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">protected</span> WeakHashMap&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt; initialValue() &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakHashMap</span>&lt;&gt;();<br>            &#125;<br>            <br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">protected</span> WeakHashMap&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt; childValue(<br>                    WeakHashMap&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt; parentValue) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakHashMap</span>&lt;&gt;(parentValue);<br>            &#125;<br>        &#125;;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br>        <span class="hljs-built_in">super</span>.set(value);<br>        <span class="hljs-keyword">if</span> (value != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 设置值时，将当前 TTL 实例注册到 holder</span><br>            holder.get().put(<span class="hljs-built_in">this</span>, <span class="hljs-literal">null</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            holder.get().remove(<span class="hljs-built_in">this</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>设计精妙之处</strong>：</p>
<ul>
<li>使用 <code>WeakHashMap</code> 避免内存泄漏</li>
<li><code>holder</code> 本身是 <code>InheritableThreadLocal</code>，确保子线程能继承注册表</li>
<li>每次 <code>set()</code> 时自动注册，<code>capture()</code> 时遍历注册表获取所有 TTL 值</li>
</ul>
<h4 id="2-拦截线程池的-execute-方法">2. 拦截线程池的 execute 方法</h4>
<p>TTL 解决线程池传递问题的核心是<strong>拦截线程池的 <code>execute()</code> 方法</strong>。无论是 <code>TtlExecutors</code> 包装还是 Java Agent，本质上都是在任务提交时进行拦截：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// TtlExecutors 的核心实现（简化版）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ExecutorServiceTtlWrapper</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ExecutorService</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ExecutorService executorService;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;<br>        <span class="hljs-comment">// 拦截 execute 方法，自动包装任务</span><br>        executorService.execute(TtlRunnable.get(command));<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span> &#123;<br>        <span class="hljs-comment">// 拦截 submit 方法，自动包装任务</span><br>        <span class="hljs-keyword">return</span> executorService.submit(TtlCallable.get(task));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Java Agent 的字节码增强</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// TtlAgent 在类加载时修改 ThreadPoolExecutor 的字节码</span><br><span class="hljs-comment">// 将 execute 方法的入口处插入以下逻辑：</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;<br>    <span class="hljs-comment">// 插入的代码：自动包装 Runnable</span><br>    command = TtlRunnable.get(command, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>    <span class="hljs-comment">// 原始的 execute 逻辑...</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="3-worker-线程的-threadlocalmap-store-restore">3. Worker 线程的 ThreadLocalMap Store/Restore</h4>
<p>TTL 最关键的设计是处理<strong>工作线程原有 ThreadLocalMap 的保存和恢复</strong>。这是防止数据污染的核心机制：</p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant Task as TtlRunnable
    participant Worker as 工作线程
    participant Map as ThreadLocalMap
    
    Note over Worker: 工作线程可能有自己的 TTL 值&lt;br/&gt;（来自之前执行的其他任务）
    
    Task-&gt;&gt;Worker: run() 开始执行
    
    rect rgb(255, 245, 238)
        Note over Task,Map: Store 阶段
        Task-&gt;&gt;Map: backup = 备份当前 ThreadLocalMap 中的 TTL 值
        Task-&gt;&gt;Map: 清理不在 captured 中的 TTL 变量
        Task-&gt;&gt;Map: 设置 captured 中的值到 ThreadLocalMap
    end
    
    Task-&gt;&gt;Task: 执行原始任务 runnable.run()
    
    rect rgb(232, 245, 233)
        Note over Task,Map: Restore 阶段
        Task-&gt;&gt;Map: 清理当前 ThreadLocalMap 中的 TTL 变量
        Task-&gt;&gt;Map: 从 backup 恢复原来的 TTL 值
    end
    
    Note over Worker: 工作线程恢复到执行任务前的状态&lt;br/&gt;不影响后续任务</code></pre>
<p><strong>Store/Restore 的源码实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// TtlRunnable.run() 的核心逻辑</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">captured</span> <span class="hljs-operator">=</span> capturedRef.get();<br>    <br>    <span class="hljs-comment">// ========== Store 阶段 ==========</span><br>    <span class="hljs-comment">// replay() 返回的是 backup（工作线程原有的值）</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">backup</span> <span class="hljs-operator">=</span> Transmitter.replay(captured);<br>    <br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 执行原始任务</span><br>        runnable.run();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// ========== Restore 阶段 ==========</span><br>        <span class="hljs-comment">// 恢复工作线程原有的 ThreadLocalMap 状态</span><br>        Transmitter.restore(backup);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>为什么需要 Store/Restore？</strong></p>
<table>
<thead>
<tr>
<th>场景</th>
<th>不做 Restore 的问题</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>任务 A 设置了 TTL 值</strong></td>
<td>任务 B 复用同一个工作线程时，会读到任务 A 的值</td>
</tr>
<tr>
<td><strong>工作线程有自己的 TTL 值</strong></td>
<td>任务执行后，工作线程原有的值被覆盖，影响后续逻辑</td>
</tr>
<tr>
<td><strong>任务执行中修改了 TTL 值</strong></td>
<td>修改会&quot;泄漏&quot;到后续任务，造成数据污染</td>
</tr>
</tbody>
</table>
<p><strong>Store/Restore 确保</strong>：</p>
<ol>
<li>任务执行时只能看到<strong>提交任务时</strong>父线程传递的值</li>
<li>任务执行完毕后，工作线程恢复到<strong>执行任务前</strong>的状态</li>
<li>任务之间完全隔离，互不影响</li>
</ol>
<h4 id="4-transmitter-工具类">4. Transmitter 工具类</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Transmitter</span> &#123;<br>    <br>    <span class="hljs-comment">// 捕获当前线程的所有 TTL 变量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">capture</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Snapshot</span>(captureTtlValues(), captureThreadLocalValues());<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> WeakHashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt; <span class="hljs-title function_">captureTtlValues</span><span class="hljs-params">()</span> &#123;<br>        WeakHashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt; ttl2Value = <br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakHashMap</span>&lt;&gt;();<br>        <span class="hljs-comment">// 遍历 holder 中所有注册的 TTL 实例</span><br>        <span class="hljs-keyword">for</span> (TransmittableThreadLocal&lt;Object&gt; threadLocal : holder.get().keySet()) &#123;<br>            <span class="hljs-comment">// 获取值的副本</span><br>            ttl2Value.put(threadLocal, threadLocal.copyValue());<br>        &#125;<br>        <span class="hljs-keyword">return</span> ttl2Value;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 重放捕获的值到当前线程</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">replay</span><span class="hljs-params">(Object captured)</span> &#123;<br>        <span class="hljs-type">Snapshot</span> <span class="hljs-variable">capturedSnapshot</span> <span class="hljs-operator">=</span> (Snapshot) captured;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Snapshot</span>(<br>            replayTtlValues(capturedSnapshot.ttl2Value),<br>            replayThreadLocalValues(capturedSnapshot.threadLocal2Value)<br>        );<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> WeakHashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt; <span class="hljs-title function_">replayTtlValues</span><span class="hljs-params">(</span><br><span class="hljs-params">            WeakHashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt; captured)</span> &#123;<br>        <br>        <span class="hljs-comment">// 1. 备份当前线程（工作线程）的 TTL 值</span><br>        WeakHashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt; backup = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakHashMap</span>&lt;&gt;();<br>        <br>        <span class="hljs-keyword">for</span> (Iterator&lt;TransmittableThreadLocal&lt;Object&gt;&gt; iterator = <br>             holder.get().keySet().iterator(); iterator.hasNext(); ) &#123;<br>            TransmittableThreadLocal&lt;Object&gt; threadLocal = iterator.next();<br>            <br>            <span class="hljs-comment">// 备份当前值</span><br>            backup.put(threadLocal, threadLocal.get());<br>            <br>            <span class="hljs-comment">// 2. 关键：清理不在 captured 中的 TTL 变量</span><br>            <span class="hljs-comment">//    防止线程复用导致的数据污染</span><br>            <span class="hljs-keyword">if</span> (!captured.containsKey(threadLocal)) &#123;<br>                iterator.remove();<br>                threadLocal.superRemove();<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 3. 将捕获的值设置到当前线程</span><br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt; entry : <br>             captured.entrySet()) &#123;<br>            entry.getKey().set(entry.getValue());<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> backup;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 恢复到重放前的状态</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">restore</span><span class="hljs-params">(Object backup)</span> &#123;<br>        <span class="hljs-type">Snapshot</span> <span class="hljs-variable">backupSnapshot</span> <span class="hljs-operator">=</span> (Snapshot) backup;<br>        restoreTtlValues(backupSnapshot.ttl2Value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="3-ttlrunnable-包装器">3. TtlRunnable 包装器</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TtlRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicReference&lt;Object&gt; capturedRef;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Runnable runnable;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> releaseTtlValueReferenceAfterRun;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">TtlRunnable</span><span class="hljs-params">(Runnable runnable, <span class="hljs-type">boolean</span> releaseTtlValueReferenceAfterRun)</span> &#123;<br>        <span class="hljs-comment">// 构造时捕获当前线程（父线程）的 TTL 变量</span><br>        <span class="hljs-built_in">this</span>.capturedRef = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;(capture());<br>        <span class="hljs-built_in">this</span>.runnable = runnable;<br>        <span class="hljs-built_in">this</span>.releaseTtlValueReferenceAfterRun = releaseTtlValueReferenceAfterRun;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">captured</span> <span class="hljs-operator">=</span> capturedRef.get();<br>        <span class="hljs-keyword">if</span> (captured == <span class="hljs-literal">null</span> || <br>            (releaseTtlValueReferenceAfterRun &amp;&amp; <br>             !capturedRef.compareAndSet(captured, <span class="hljs-literal">null</span>))) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;TTL value reference is released!&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 重放：将父线程捕获的值设置到当前线程（工作线程）</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">backup</span> <span class="hljs-operator">=</span> replay(captured);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 执行原始任务</span><br>            runnable.run();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 恢复：恢复工作线程的原始状态</span><br>            restore(backup);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> TtlRunnable <span class="hljs-title function_">get</span><span class="hljs-params">(Runnable runnable)</span> &#123;<br>        <span class="hljs-keyword">if</span> (runnable == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (runnable <span class="hljs-keyword">instanceof</span> TtlRunnable) <span class="hljs-keyword">return</span> (TtlRunnable) runnable;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TtlRunnable</span>(runnable, <span class="hljs-literal">false</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="为什么需要清理不在快照中的-ttl-变量？">为什么需要清理不在快照中的 TTL 变量？</h3>
<p>这是 TTL 设计中最精妙的部分。考虑以下场景：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">TransmittableThreadLocal&lt;String&gt; context = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransmittableThreadLocal</span>&lt;&gt;();<br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// 任务1：设置 TTL 值</span><br>context.set(<span class="hljs-string">&quot;task1-value&quot;</span>);<br>executor.submit(TtlRunnable.get(() -&gt; &#123;<br>    System.out.println(context.get()); <span class="hljs-comment">// 输出: task1-value</span><br>    context.set(<span class="hljs-string">&quot;modified-in-task1&quot;</span>);  <span class="hljs-comment">// 在任务中修改</span><br>&#125;));<br><br><span class="hljs-comment">// 任务2：没有设置 TTL 值</span><br><span class="hljs-comment">// 如果不清理，任务2 会读到任务1 修改的值！</span><br>executor.submit(TtlRunnable.get(() -&gt; &#123;<br>    System.out.println(context.get()); <span class="hljs-comment">// 期望: null，而不是 &quot;modified-in-task1&quot;</span><br>&#125;));<br></code></pre></td></tr></table></figure>
<p><strong>清理逻辑确保</strong>：任务执行时只能访问<strong>提交任务时</strong>父线程传递的值，而不是工作线程之前执行其他任务时遗留的值。</p>
<h3 id="三种使用方式对比">三种使用方式对比</h3>
<table>
<thead>
<tr>
<th>方式</th>
<th>侵入性</th>
<th>实现原理</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>TtlRunnable 包装</strong></td>
<td>高</td>
<td>手动包装每个任务</td>
<td>少量任务需要传递上下文</td>
</tr>
<tr>
<td><strong>TtlExecutors 包装</strong></td>
<td>中</td>
<td>装饰器模式包装线程池</td>
<td>特定线程池需要传递上下文</td>
</tr>
<tr>
<td><strong>Java Agent</strong></td>
<td>无</td>
<td>字节码增强，自动包装</td>
<td>全局透明传递，推荐生产使用</td>
</tr>
</tbody>
</table>
<p><strong>方式一：修饰 Runnable/Callable</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">TransmittableThreadLocal&lt;String&gt; context = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransmittableThreadLocal</span>&lt;&gt;();<br>context.set(<span class="hljs-string">&quot;value-set-in-parent&quot;</span>);<br><br><span class="hljs-comment">// 使用 TtlRunnable 包装</span><br><span class="hljs-type">Runnable</span> <span class="hljs-variable">ttlRunnable</span> <span class="hljs-operator">=</span> TtlRunnable.get(() -&gt; &#123;<br>    System.out.println(context.get()); <span class="hljs-comment">// 输出: value-set-in-parent</span><br>&#125;);<br><br>executorService.submit(ttlRunnable);<br></code></pre></td></tr></table></figure>
<p><strong>方式二：修饰线程池</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br><span class="hljs-comment">// 使用 TtlExecutors 包装线程池</span><br>executorService = TtlExecutors.getTtlExecutorService(executorService);<br><br><span class="hljs-comment">// 之后提交的任务自动具备 TTL 传递能力</span><br>executorService.submit(() -&gt; &#123;<br>    System.out.println(context.get());<br>&#125;);<br></code></pre></td></tr></table></figure>
<p><strong>方式三：Java Agent 方式（推荐）</strong></p>
<p>通过 Java Agent 在类加载时自动增强线程池，无需修改业务代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -javaagent:transmittable-thread-local-x.x.x.jar -jar your-app.jar<br></code></pre></td></tr></table></figure>
<p>Java Agent 的实现原理是在类加载时修改 <code>ThreadPoolExecutor</code>、<code>ScheduledThreadPoolExecutor</code>、<code>ForkJoinPool</code> 等类的字节码，自动将提交的 <code>Runnable</code>/<code>Callable</code> 包装为 TTL 版本。</p>
<h3 id="ttl-核心数据结构图">TTL 核心数据结构图</h3>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;TTL 核心数据结构&quot;
        direction TB
        
        subgraph Thread1[&quot;主线程 (提交任务)&quot;]
            T1_TLM[&quot;threadLocals&lt;br/&gt;(ThreadLocalMap)&quot;]
            T1_ITL[&quot;inheritableThreadLocals&lt;br/&gt;(ThreadLocalMap)&quot;]
            T1_HOLDER[&quot;holder.get()&lt;br/&gt;(WeakHashMap)&quot;]
            
            T1_TTL1[&quot;TTL1 → value1&quot;]
            T1_TTL2[&quot;TTL2 → value2&quot;]
            
            T1_TLM --&gt; T1_TTL1
            T1_TLM --&gt; T1_TTL2
            T1_HOLDER --&gt; |&quot;注册&quot;| T1_TTL1
            T1_HOLDER --&gt; |&quot;注册&quot;| T1_TTL2
        end
        
        subgraph Snapshot[&quot;捕获的快照 (Snapshot)&quot;]
            S_MAP[&quot;WeakHashMap&lt;br/&gt;TTL → Value 副本&quot;]
            S_TTL1[&quot;TTL1 → value1_copy&quot;]
            S_TTL2[&quot;TTL2 → value2_copy&quot;]
            S_MAP --&gt; S_TTL1
            S_MAP --&gt; S_TTL2
        end
        
        subgraph Thread2[&quot;工作线程 (执行任务)&quot;]
            T2_TLM[&quot;threadLocals&lt;br/&gt;(ThreadLocalMap)&quot;]
            T2_BACKUP[&quot;backup&lt;br/&gt;(原有值备份)&quot;]
            T2_OLD[&quot;TTL3 → old_value&quot;]
            T2_TLM --&gt; T2_OLD
        end
        
        T1_HOLDER --&gt;|&quot;capture()&quot;| Snapshot
        Snapshot --&gt;|&quot;replay()&quot;| T2_TLM
        T2_OLD --&gt;|&quot;备份到&quot;| T2_BACKUP
    end
    
    style T1_HOLDER fill:#e3f2fd
    style Snapshot fill:#fff3e0
    style T2_BACKUP fill:#e8f5e9</code></pre>
<h3 id="ttl-完整生命周期图">TTL 完整生命周期图</h3>
<pre><code class="hljs mermaid">flowchart TB
    subgraph Phase1[&quot;阶段1: 主线程设置值&quot;]
        P1_SET[&quot;context.set(&#x27;request-123&#x27;)&quot;]
        P1_TLM[&quot;存入 threadLocals&quot;]
        P1_REG[&quot;注册到 holder&quot;]
        P1_SET --&gt; P1_TLM
        P1_SET --&gt; P1_REG
    end
    
    subgraph Phase2[&quot;阶段2: 提交任务时捕获&quot;]
        P2_WRAP[&quot;TtlRunnable.get(runnable)&quot;]
        P2_CAP[&quot;Transmitter.capture()&quot;]
        P2_ITER[&quot;遍历 holder 中所有 TTL&quot;]
        P2_COPY[&quot;复制每个 TTL 的值&quot;]
        P2_SNAP[&quot;创建 Snapshot&quot;]
        P2_WRAP --&gt; P2_CAP
        P2_CAP --&gt; P2_ITER
        P2_ITER --&gt; P2_COPY
        P2_COPY --&gt; P2_SNAP
    end
    
    subgraph Phase3[&quot;阶段3: 工作线程执行前&quot;]
        P3_RUN[&quot;TtlRunnable.run()&quot;]
        P3_REPLAY[&quot;Transmitter.replay(captured)&quot;]
        P3_BACKUP[&quot;备份工作线程当前 TTL 值&quot;]
        P3_CLEAN[&quot;清理不在快照中的 TTL&quot;]
        P3_APPLY[&quot;应用快照中的值&quot;]
        P3_RUN --&gt; P3_REPLAY
        P3_REPLAY --&gt; P3_BACKUP
        P3_BACKUP --&gt; P3_CLEAN
        P3_CLEAN --&gt; P3_APPLY
    end
    
    subgraph Phase4[&quot;阶段4: 执行业务逻辑&quot;]
        P4_BIZ[&quot;runnable.run()&quot;]
        P4_GET[&quot;context.get()&quot;]
        P4_VAL[&quot;返回 &#x27;request-123&#x27; (正确)&quot;]
        P4_BIZ --&gt; P4_GET
        P4_GET --&gt; P4_VAL
    end
    
    subgraph Phase5[&quot;阶段5: 执行后恢复&quot;]
        P5_RESTORE[&quot;Transmitter.restore(backup)&quot;]
        P5_CLEAR[&quot;清理当前 TTL 值&quot;]
        P5_RECOVER[&quot;从 backup 恢复原有值&quot;]
        P5_DONE[&quot;工作线程状态恢复&quot;]
        P5_RESTORE --&gt; P5_CLEAR
        P5_CLEAR --&gt; P5_RECOVER
        P5_RECOVER --&gt; P5_DONE
    end
    
    Phase1 --&gt; Phase2
    Phase2 --&gt; Phase3
    Phase3 --&gt; Phase4
    Phase4 --&gt; Phase5
    
    style Phase1 fill:#e8f5e9
    style Phase2 fill:#fff3e0
    style Phase3 fill:#e3f2fd
    style Phase4 fill:#f3e5f5
    style Phase5 fill:#ffebee</code></pre>
<h3 id="ttl-多任务隔离机制图">TTL 多任务隔离机制图</h3>
<pre><code class="hljs mermaid">sequenceDiagram
    participant Main as 主线程
    participant Pool as 线程池
    participant W1 as Worker-1
    
    Note over Main,W1: 场景：两个任务复用同一个工作线程
    
    rect rgb(232, 245, 233)
        Note over Main: 任务1：设置 context = &quot;task1&quot;
        Main-&gt;&gt;Main: context.set(&quot;task1&quot;)
        Main-&gt;&gt;Pool: submit(TtlRunnable(task1))
        Note over Pool: 快照1: &#123;context: &quot;task1&quot;&#125;
    end
    
    rect rgb(255, 243, 224)
        Pool-&gt;&gt;W1: 分配任务1
        W1-&gt;&gt;W1: backup = replay(快照1)
        Note over W1: backup = &#123;&#125; (工作线程原本为空)
        W1-&gt;&gt;W1: 设置 context = &quot;task1&quot;
        W1-&gt;&gt;W1: 执行 task1
        W1-&gt;&gt;W1: context.set(&quot;modified&quot;) 任务中修改
        W1-&gt;&gt;W1: restore(backup)
        Note over W1: 清理 context，恢复为空
    end
    
    rect rgb(227, 242, 253)
        Note over Main: 任务2：设置 context = &quot;task2&quot;
        Main-&gt;&gt;Main: context.set(&quot;task2&quot;)
        Main-&gt;&gt;Pool: submit(TtlRunnable(task2))
        Note over Pool: 快照2: &#123;context: &quot;task2&quot;&#125;
    end
    
    rect rgb(243, 229, 245)
        Pool-&gt;&gt;W1: 分配任务2 (复用同一线程)
        W1-&gt;&gt;W1: backup = replay(快照2)
        Note over W1: backup = &#123;&#125; (已被恢复为空)
        W1-&gt;&gt;W1: 设置 context = &quot;task2&quot;
        W1-&gt;&gt;W1: 执行 task2
        W1-&gt;&gt;W1: context.get() 返回 &quot;task2&quot; (正确)
        Note over W1: 不会读到 &quot;modified&quot;！
        W1-&gt;&gt;W1: restore(backup)
    end</code></pre>
<h3 id="ttl-三种使用方式对比图">TTL 三种使用方式对比图</h3>
<pre><code class="hljs mermaid">flowchart LR
    subgraph Way1[&quot;方式1: 包装 Runnable&quot;]
        W1_CODE[&quot;TtlRunnable.get(runnable)&quot;]
        W1_PROS[&quot;优点: 精确控制&quot;]
        W1_CONS[&quot;缺点: 侵入性高&quot;]
        W1_CODE --&gt; W1_PROS
        W1_CODE --&gt; W1_CONS
    end
    
    subgraph Way2[&quot;方式2: 包装线程池&quot;]
        W2_CODE[&quot;TtlExecutors.getTtlExecutorService(executor)&quot;]
        W2_PROS[&quot;优点: 一次包装&quot;]
        W2_CONS[&quot;缺点: 需修改代码&quot;]
        W2_CODE --&gt; W2_PROS
        W2_CODE --&gt; W2_CONS
    end
    
    subgraph Way3[&quot;方式3: Java Agent&quot;]
        W3_CODE[&quot;-javaagent:ttl.jar&quot;]
        W3_PROS[&quot;优点: 零侵入&quot;]
        W3_CONS[&quot;缺点: 需要 JVM 参数&quot;]
        W3_CODE --&gt; W3_PROS
        W3_CODE --&gt; W3_CONS
    end
    
    Way1 --&gt;|&quot;更便捷&quot;| Way2
    Way2 --&gt;|&quot;更透明&quot;| Way3
    
    style Way1 fill:#ffebee
    style Way2 fill:#fff3e0
    style Way3 fill:#e8f5e9</code></pre>
<h3 id="holder-注册机制详解图">holder 注册机制详解图</h3>
<pre><code class="hljs mermaid">graph TB
    subgraph TTL_Instance[&quot;TTL 实例&quot;]
        TTL1[&quot;TTL1: traceId&quot;]
        TTL2[&quot;TTL2: userId&quot;]
        TTL3[&quot;TTL3: tenantId&quot;]
    end
    
    subgraph SetOps[&quot;set 操作&quot;]
        SET1[&quot;ttl1.set(trace-001)&quot;]
        SET2[&quot;ttl2.set(user-123)&quot;]
        SET3[&quot;ttl3.set(tenant-A)&quot;]
    end
    
    subgraph HolderMap[&quot;holder WeakHashMap&quot;]
        REG1[&quot;TTL1 -&gt; null&quot;]
        REG2[&quot;TTL2 -&gt; null&quot;]
        REG3[&quot;TTL3 -&gt; null&quot;]
    end
    
    subgraph CaptureFlow[&quot;capture 遍历&quot;]
        CAP1[&quot;遍历 holder.keySet&quot;]
        CAP2[&quot;对每个TTL调用get&quot;]
        CAP3[&quot;生成快照Map&quot;]
        CAP1 --&gt; CAP2
        CAP2 --&gt; CAP3
    end
    
    SET1 --&gt; TTL1
    SET1 --&gt; REG1
    SET2 --&gt; TTL2
    SET2 --&gt; REG2
    SET3 --&gt; TTL3
    SET3 --&gt; REG3
    
    HolderMap --&gt; CAP1
    
    style HolderMap fill:#e3f2fd
    style CaptureFlow fill:#fff3e0</code></pre>
<h3 id="inheritablethreadlocal-vs-transmittablethreadlocal">InheritableThreadLocal vs TransmittableThreadLocal</h3>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;InheritableThreadLocal（JDK 内置）&quot;
        direction TB
        ITL_HOW[&quot;实现方式：修改 Thread 类&quot;]
        ITL_WHEN[&quot;传递时机：创建子线程时&quot;]
        ITL_LIMIT[&quot;局限性：线程池场景失效&quot;]
        style ITL_LIMIT fill:#ffcdd2
    end
    
    subgraph &quot;TransmittableThreadLocal（阿里开源）&quot;
        direction TB
        TTL_HOW[&quot;实现方式：包装任务/线程池&quot;]
        TTL_WHEN[&quot;传递时机：提交任务时&quot;]
        TTL_ADVANTAGE[&quot;优势：完美支持线程池&quot;]
        style TTL_ADVANTAGE fill:#c8e6c9
    end
    
    subgraph &quot;设计对比&quot;
        ITL_DESIGN[&quot;Thread 持有 Map&lt;br/&gt;在 init() 中复制&quot;]
        TTL_DESIGN[&quot;holder 注册所有 TTL&lt;br/&gt;capture/replay/restore&quot;]
    end</code></pre>
<h3 id="适用场景">适用场景</h3>
<ol>
<li><strong>分布式追踪</strong>：TraceId、SpanId 的跨线程传递</li>
<li><strong>日志上下文</strong>：MDC（Mapped Diagnostic Context）的传递</li>
<li><strong>用户上下文</strong>：用户身份信息、租户信息的传递</li>
<li><strong>事务上下文</strong>：分布式事务的上下文传递</li>
</ol>
<h1>ThreadLocal 核心源码深度解析</h1>
<h2 id="threadlocal-set-源码详解">ThreadLocal.set() 源码详解</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置当前线程的线程局部变量的值</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 核心流程：</span><br><span class="hljs-comment"> * 1. 获取当前线程</span><br><span class="hljs-comment"> * 2. 获取当前线程的 ThreadLocalMap</span><br><span class="hljs-comment"> * 3. 如果 Map 存在，直接设置值</span><br><span class="hljs-comment"> * 4. 如果 Map 不存在，创建 Map 并设置初始值</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> value 要存储的值</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br>    <span class="hljs-comment">// 获取当前执行线程</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <br>    <span class="hljs-comment">// 获取当前线程的 ThreadLocalMap</span><br>    <span class="hljs-comment">// 注意：这里是获取线程的 threadLocals 字段，不是 inheritableThreadLocals</span><br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// Map 已存在，直接设置</span><br>        <span class="hljs-comment">// key 是当前 ThreadLocal 实例（this），value 是用户传入的值</span><br>        map.set(<span class="hljs-built_in">this</span>, value);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// Map 不存在，创建新的 ThreadLocalMap</span><br>        <span class="hljs-comment">// 并以当前 ThreadLocal 为 key，value 为值创建第一个 Entry</span><br>        createMap(t, value);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取线程的 ThreadLocalMap</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 设计要点：</span><br><span class="hljs-comment"> * - Thread 类有一个 threadLocals 字段，类型是 ThreadLocal.ThreadLocalMap</span><br><span class="hljs-comment"> * - 这个字段是包级私有的，只有 ThreadLocal 能访问</span><br><span class="hljs-comment"> * - 这就是&quot;Thread 持有 Map&quot;设计的体现</span><br><span class="hljs-comment"> */</span><br>ThreadLocalMap <span class="hljs-title function_">getMap</span><span class="hljs-params">(Thread t)</span> &#123;<br>    <span class="hljs-keyword">return</span> t.threadLocals;  <span class="hljs-comment">// 直接访问 Thread 的 threadLocals 字段</span><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 为线程创建 ThreadLocalMap</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 设计要点：</span><br><span class="hljs-comment"> * - 延迟初始化：只有第一次 set 时才创建 Map</span><br><span class="hljs-comment"> * - 节省内存：不使用 ThreadLocal 的线程不会有 Map</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> &#123;<br>    <span class="hljs-comment">// 创建新的 ThreadLocalMap，并设置到线程的 threadLocals 字段</span><br>    t.threadLocals = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalMap</span>(<span class="hljs-built_in">this</span>, firstValue);<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="threadlocal-get-源码详解">ThreadLocal.get() 源码详解</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取当前线程的线程局部变量的值</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 核心流程：</span><br><span class="hljs-comment"> * 1. 获取当前线程的 ThreadLocalMap</span><br><span class="hljs-comment"> * 2. 如果 Map 存在且包含当前 ThreadLocal 的 Entry，返回 value</span><br><span class="hljs-comment"> * 3. 否则调用 setInitialValue() 设置并返回初始值</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 当前线程的线程局部变量值</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 以当前 ThreadLocal 实例为 key 查找 Entry</span><br>        ThreadLocalMap.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> map.getEntry(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (T) e.value;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// Map 不存在或 Entry 不存在，设置初始值</span><br>    <span class="hljs-keyword">return</span> setInitialValue();<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置初始值的变体方法</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 设计要点：</span><br><span class="hljs-comment"> * - 与 set() 类似，但调用 initialValue() 获取初始值</span><br><span class="hljs-comment"> * - initialValue() 默认返回 null，可被子类重写</span><br><span class="hljs-comment"> * - 这是模板方法模式的应用</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> T <span class="hljs-title function_">setInitialValue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 调用 initialValue() 获取初始值（默认返回 null）</span><br>    <span class="hljs-type">T</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> initialValue();<br>    <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>        map.set(<span class="hljs-built_in">this</span>, value);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        createMap(t, value);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 如果是 TerminatingThreadLocal，注册到终止回调列表</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> <span class="hljs-keyword">instanceof</span> TerminatingThreadLocal) &#123;<br>        TerminatingThreadLocal.register((TerminatingThreadLocal&lt;?&gt;) <span class="hljs-built_in">this</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> value;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 返回此线程局部变量的初始值</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 设计要点：</span><br><span class="hljs-comment"> * - 这是一个受保护的方法，子类可以重写</span><br><span class="hljs-comment"> * - 默认返回 null</span><br><span class="hljs-comment"> * - 典型用法是使用 ThreadLocal.withInitial() 工厂方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> T <span class="hljs-title function_">initialValue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="threadlocalmap-set-源码详解">ThreadLocalMap.set() 源码详解</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ThreadLocalMap 的 set 方法</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 核心算法：开放地址法（线性探测）</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 流程：</span><br><span class="hljs-comment"> * 1. 计算 hash 槽位</span><br><span class="hljs-comment"> * 2. 线性探测找到合适的位置</span><br><span class="hljs-comment"> * 3. 处理三种情况：找到相同 key、找到 stale entry、找到空槽</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br>    <br>    <span class="hljs-comment">// 计算初始槽位：使用 ThreadLocal 的 threadLocalHashCode</span><br>    <span class="hljs-comment">// threadLocalHashCode 使用黄金分割数 0x61c88647 递增</span><br>    <span class="hljs-comment">// 这个魔数能让 hash 分布更均匀</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (len - <span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// 线性探测：从 i 开始向后查找</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[i]; e != <span class="hljs-literal">null</span>; e = tab[i = nextIndex(i, len)]) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();  <span class="hljs-comment">// 获取弱引用指向的 ThreadLocal</span><br><br>        <span class="hljs-comment">// 情况1：找到相同的 key，直接更新 value</span><br>        <span class="hljs-keyword">if</span> (k == key) &#123;<br>            e.value = value;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 情况2：key 为 null，说明是 Stale Entry</span><br>        <span class="hljs-comment">// 这是弱引用被 GC 回收后的状态</span><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 替换 stale entry，同时清理其他 stale entries</span><br>            replaceStaleEntry(key, value, i);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 情况3：key 不同且不为 null，继续探测下一个槽位</span><br>    &#125;<br><br>    <span class="hljs-comment">// 找到空槽，创建新 Entry</span><br>    tab[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(key, value);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> ++size;<br>    <br>    <span class="hljs-comment">// 尝试清理一些 stale entries</span><br>    <span class="hljs-comment">// 如果没有清理任何 entry 且 size 超过阈值，则扩容</span><br>    <span class="hljs-keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) &#123;<br>        rehash();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 计算下一个槽位索引（环形数组）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nextIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> len)</span> &#123;<br>    <span class="hljs-keyword">return</span> ((i + <span class="hljs-number">1</span> &lt; len) ? i + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="threadlocalmap-getentry-源码详解">ThreadLocalMap.getEntry() 源码详解</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 根据 ThreadLocal key 获取 Entry</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 设计要点：</span><br><span class="hljs-comment"> * - 快速路径：直接命中</span><br><span class="hljs-comment"> * - 慢速路径：线性探测 + 清理 stale entries</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> Entry <span class="hljs-title function_">getEntry</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key)</span> &#123;<br>    <span class="hljs-comment">// 计算槽位</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="hljs-number">1</span>);<br>    <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> table[i];<br>    <br>    <span class="hljs-comment">// 快速路径：直接命中</span><br>    <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span> &amp;&amp; e.get() == key) &#123;<br>        <span class="hljs-keyword">return</span> e;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 慢速路径：需要线性探测</span><br>        <span class="hljs-keyword">return</span> getEntryAfterMiss(key, i, e);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 未直接命中时的查找逻辑</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 设计要点：</span><br><span class="hljs-comment"> * - 线性探测查找目标 Entry</span><br><span class="hljs-comment"> * - 遇到 stale entry 时触发清理</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> Entry <span class="hljs-title function_">getEntryAfterMiss</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, <span class="hljs-type">int</span> i, Entry e)</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br><br>    <span class="hljs-keyword">while</span> (e != <span class="hljs-literal">null</span>) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br>        <br>        <span class="hljs-comment">// 找到目标</span><br>        <span class="hljs-keyword">if</span> (k == key) &#123;<br>            <span class="hljs-keyword">return</span> e;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 遇到 stale entry，触发清理</span><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>) &#123;<br>            expungeStaleEntry(i);  <span class="hljs-comment">// 清理 stale entry</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            i = nextIndex(i, len);  <span class="hljs-comment">// 继续探测</span><br>        &#125;<br>        <br>        e = tab[i];<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 未找到</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="expungestaleentry-核心清理逻辑">expungeStaleEntry() 核心清理逻辑</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 清理 stale entry 的核心方法</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 这是 ThreadLocalMap 自动清理机制的核心</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 流程：</span><br><span class="hljs-comment"> * 1. 清理指定位置的 stale entry</span><br><span class="hljs-comment"> * 2. 向后扫描，清理更多 stale entries</span><br><span class="hljs-comment"> * 3. 对非 stale entries 进行 rehash（重新定位）</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> staleSlot 已知的 stale entry 位置</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 扫描结束的位置（第一个 null 槽位）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">expungeStaleEntry</span><span class="hljs-params">(<span class="hljs-type">int</span> staleSlot)</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br><br>    <span class="hljs-comment">// ========== 步骤1：清理当前 stale entry ==========</span><br>    tab[staleSlot].value = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 断开 value 的强引用，使其可被 GC</span><br>    tab[staleSlot] = <span class="hljs-literal">null</span>;        <span class="hljs-comment">// 清空槽位</span><br>    size--;<br><br>    <span class="hljs-comment">// ========== 步骤2：向后扫描并处理 ==========</span><br>    Entry e;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = nextIndex(staleSlot, len); (e = tab[i]) != <span class="hljs-literal">null</span>; i = nextIndex(i, len)) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br>        <br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 又发现一个 stale entry，清理它</span><br>            e.value = <span class="hljs-literal">null</span>;<br>            tab[i] = <span class="hljs-literal">null</span>;<br>            size--;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 非 stale entry，需要 rehash</span><br>            <span class="hljs-comment">// 因为前面的槽位可能已经空出来了</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> k.threadLocalHashCode &amp; (len - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (h != i) &#123;<br>                <span class="hljs-comment">// 当前位置不是理想位置，需要重新定位</span><br>                tab[i] = <span class="hljs-literal">null</span>;<br>                <br>                <span class="hljs-comment">// 从理想位置开始，找到第一个空槽</span><br>                <span class="hljs-keyword">while</span> (tab[h] != <span class="hljs-literal">null</span>) &#123;<br>                    h = nextIndex(h, len);<br>                &#125;<br>                tab[h] = e;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> i;  <span class="hljs-comment">// 返回第一个 null 槽位的索引</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h1>基于 ThreadLocal 的设计模式框架实例</h1>
<h2 id="实例1：spring-的-requestcontextholder">实例1：Spring 的 RequestContextHolder</h2>
<p>Spring 框架使用 ThreadLocal 实现请求上下文的线程隔离：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Spring RequestContextHolder 源码解析</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 设计模式：Holder 模式 + 策略模式</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 核心思想：</span><br><span class="hljs-comment"> * - 使用 ThreadLocal 存储当前请求的 RequestAttributes</span><br><span class="hljs-comment"> * - 支持普通 ThreadLocal 和 InheritableThreadLocal 两种模式</span><br><span class="hljs-comment"> * - 提供静态方法访问当前请求上下文</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RequestContextHolder</span> &#123;<br>    <br>    <span class="hljs-comment">// 普通 ThreadLocal：不支持子线程继承</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;RequestAttributes&gt; requestAttributesHolder =<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">NamedThreadLocal</span>&lt;&gt;(<span class="hljs-string">&quot;Request attributes&quot;</span>);<br><br>    <span class="hljs-comment">// InheritableThreadLocal：支持子线程继承</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;RequestAttributes&gt; inheritableRequestAttributesHolder =<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">NamedInheritableThreadLocal</span>&lt;&gt;(<span class="hljs-string">&quot;Request context&quot;</span>);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 重置当前线程的 RequestAttributes</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resetRequestAttributes</span><span class="hljs-params">()</span> &#123;<br>        requestAttributesHolder.remove();<br>        inheritableRequestAttributesHolder.remove();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置当前线程的 RequestAttributes</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> attributes 请求属性</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> inheritable 是否可被子线程继承</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRequestAttributes</span><span class="hljs-params">(RequestAttributes attributes, </span><br><span class="hljs-params">                                            <span class="hljs-type">boolean</span> inheritable)</span> &#123;<br>        <span class="hljs-keyword">if</span> (attributes == <span class="hljs-literal">null</span>) &#123;<br>            resetRequestAttributes();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (inheritable) &#123;<br>                inheritableRequestAttributesHolder.set(attributes);<br>                requestAttributesHolder.remove();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                requestAttributesHolder.set(attributes);<br>                inheritableRequestAttributesHolder.remove();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取当前线程的 RequestAttributes</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RequestAttributes <span class="hljs-title function_">getRequestAttributes</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">RequestAttributes</span> <span class="hljs-variable">attributes</span> <span class="hljs-operator">=</span> requestAttributesHolder.get();<br>        <span class="hljs-keyword">if</span> (attributes == <span class="hljs-literal">null</span>) &#123;<br>            attributes = inheritableRequestAttributesHolder.get();<br>        &#125;<br>        <span class="hljs-keyword">return</span> attributes;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取当前请求（必须存在）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RequestAttributes <span class="hljs-title function_">currentRequestAttributes</span><span class="hljs-params">()</span> <br>            <span class="hljs-keyword">throws</span> IllegalStateException &#123;<br>        <span class="hljs-type">RequestAttributes</span> <span class="hljs-variable">attributes</span> <span class="hljs-operator">=</span> getRequestAttributes();<br>        <span class="hljs-keyword">if</span> (attributes == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<br>                <span class="hljs-string">&quot;No thread-bound request found: ...&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> attributes;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>使用示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在 Filter 或 Interceptor 中设置</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, </span><br><span class="hljs-params">                         HttpServletResponse response, </span><br><span class="hljs-params">                         Object handler)</span> &#123;<br>    RequestContextHolder.setRequestAttributes(<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletRequestAttributes</span>(request, response));<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 在业务代码中获取</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">businessMethod</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> ((ServletRequestAttributes) <br>        RequestContextHolder.currentRequestAttributes()).getRequest();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> request.getHeader(<span class="hljs-string">&quot;X-User-Id&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 在 Filter 或 Interceptor 中清理</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, </span><br><span class="hljs-params">                            HttpServletResponse response, </span><br><span class="hljs-params">                            Object handler, Exception ex)</span> &#123;<br>    RequestContextHolder.resetRequestAttributes();<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="实例2：slf4j-的-mdc-mapped-diagnostic-context">实例2：SLF4J 的 MDC（Mapped Diagnostic Context）</h2>
<p>SLF4J 的 MDC 使用 ThreadLocal 实现日志上下文的线程隔离：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * MDC 核心实现（基于 Logback）</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 设计模式：门面模式 + ThreadLocal</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 核心思想：</span><br><span class="hljs-comment"> * - 使用 ThreadLocal&lt;Map&lt;String, String&gt;&gt; 存储诊断上下文</span><br><span class="hljs-comment"> * - 日志输出时自动附加 MDC 中的信息</span><br><span class="hljs-comment"> * - 支持嵌套上下文（通过 Map 的 copy）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogbackMDCAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MDCAdapter</span> &#123;<br>    <br>    <span class="hljs-comment">// 使用 InheritableThreadLocal 存储 MDC Map</span><br>    <span class="hljs-comment">// 子线程可以继承父线程的 MDC 上下文</span><br>    <span class="hljs-keyword">final</span> ThreadLocal&lt;Map&lt;String, String&gt;&gt; copyOnInheritThreadLocal = <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">InheritableThreadLocal</span>&lt;Map&lt;String, String&gt;&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">protected</span> Map&lt;String, String&gt; <span class="hljs-title function_">childValue</span><span class="hljs-params">(</span><br><span class="hljs-params">                    Map&lt;String, String&gt; parentValue)</span> &#123;<br>                <span class="hljs-keyword">if</span> (parentValue == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                &#125;<br>                <span class="hljs-comment">// 深拷贝，避免父子线程共享同一个 Map</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(parentValue);<br>            &#125;<br>        &#125;;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置 MDC 键值对</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(String key, String val)</span> &#123;<br>        <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;key cannot be null&quot;</span>);<br>        &#125;<br>        Map&lt;String, String&gt; map = copyOnInheritThreadLocal.get();<br>        <span class="hljs-keyword">if</span> (map == <span class="hljs-literal">null</span>) &#123;<br>            map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>            copyOnInheritThreadLocal.set(map);<br>        &#125;<br>        map.put(key, val);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取 MDC 值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">get</span><span class="hljs-params">(String key)</span> &#123;<br>        Map&lt;String, String&gt; map = copyOnInheritThreadLocal.get();<br>        <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span> &amp;&amp; key != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> map.get(key);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 移除 MDC 键值对</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(String key)</span> &#123;<br>        Map&lt;String, String&gt; map = copyOnInheritThreadLocal.get();<br>        <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>            map.remove(key);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 清空 MDC</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> &#123;<br>        Map&lt;String, String&gt; map = copyOnInheritThreadLocal.get();<br>        <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>            map.clear();<br>            copyOnInheritThreadLocal.remove();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>使用示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在请求入口设置 TraceId</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TraceIdFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Filter</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest request, </span><br><span class="hljs-params">                         ServletResponse response, </span><br><span class="hljs-params">                         FilterChain chain)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">traceId</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString();<br>            MDC.put(<span class="hljs-string">&quot;traceId&quot;</span>, traceId);<br>            MDC.put(<span class="hljs-string">&quot;userId&quot;</span>, getUserId(request));<br>            <br>            chain.doFilter(request, response);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            MDC.clear();  <span class="hljs-comment">// 必须清理！</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// logback.xml 配置</span><br><span class="hljs-comment">// &lt;pattern&gt;%d&#123;HH:mm:ss&#125; [%X&#123;traceId&#125;] [%X&#123;userId&#125;] %-5level %logger - %msg%n&lt;/pattern&gt;</span><br><br><span class="hljs-comment">// 日志输出示例</span><br><span class="hljs-comment">// 14:30:25 [abc-123-def] [user001] INFO  c.e.UserService - 用户登录成功</span><br></code></pre></td></tr></table></figure>
<h2 id="实例3：mybatis-的-sqlsession-管理">实例3：MyBatis 的 SqlSession 管理</h2>
<p>MyBatis-Spring 使用 ThreadLocal 管理 SqlSession 的生命周期：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * SqlSessionHolder 和 TransactionSynchronizationManager</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 设计模式：资源绑定模式</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 核心思想：</span><br><span class="hljs-comment"> * - 将 SqlSession 绑定到当前线程</span><br><span class="hljs-comment"> * - 同一事务内复用同一个 SqlSession</span><br><span class="hljs-comment"> * - 事务结束时自动清理</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TransactionSynchronizationManager</span> &#123;<br>    <br>    <span class="hljs-comment">// 存储线程绑定的资源（如 SqlSession、Connection 等）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;Map&lt;Object, Object&gt;&gt; resources =<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">NamedThreadLocal</span>&lt;&gt;(<span class="hljs-string">&quot;Transactional resources&quot;</span>);<br><br>    <span class="hljs-comment">// 存储事务同步回调</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;Set&lt;TransactionSynchronization&gt;&gt; synchronizations =<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">NamedThreadLocal</span>&lt;&gt;(<span class="hljs-string">&quot;Transaction synchronizations&quot;</span>);<br><br>    <span class="hljs-comment">// 当前事务名称</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;String&gt; currentTransactionName =<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">NamedThreadLocal</span>&lt;&gt;(<span class="hljs-string">&quot;Current transaction name&quot;</span>);<br><br>    <span class="hljs-comment">// 当前事务是否只读</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;Boolean&gt; currentTransactionReadOnly =<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">NamedThreadLocal</span>&lt;&gt;(<span class="hljs-string">&quot;Current transaction read-only status&quot;</span>);<br><br>    <span class="hljs-comment">// 当前事务隔离级别</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;Integer&gt; currentTransactionIsolationLevel =<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">NamedThreadLocal</span>&lt;&gt;(<span class="hljs-string">&quot;Current transaction isolation level&quot;</span>);<br><br>    <span class="hljs-comment">// 是否有实际的事务激活</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;Boolean&gt; actualTransactionActive =<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">NamedThreadLocal</span>&lt;&gt;(<span class="hljs-string">&quot;Actual transaction active&quot;</span>);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 绑定资源到当前线程</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bindResource</span><span class="hljs-params">(Object key, Object value)</span> &#123;<br>        Map&lt;Object, Object&gt; map = resources.get();<br>        <span class="hljs-keyword">if</span> (map == <span class="hljs-literal">null</span>) &#123;<br>            map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>            resources.set(map);<br>        &#125;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> map.put(key, value);<br>        <span class="hljs-keyword">if</span> (oldValue != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<br>                <span class="hljs-string">&quot;Already value [&quot;</span> + oldValue + <span class="hljs-string">&quot;] for key [&quot;</span> + key + <span class="hljs-string">&quot;] bound to thread&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取绑定到当前线程的资源</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getResource</span><span class="hljs-params">(Object key)</span> &#123;<br>        Map&lt;Object, Object&gt; map = resources.get();<br>        <span class="hljs-keyword">if</span> (map == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> map.get(key);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 解绑资源</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unbindResource</span><span class="hljs-params">(Object key)</span> &#123;<br>        Map&lt;Object, Object&gt; map = resources.get();<br>        <span class="hljs-keyword">if</span> (map == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> map.remove(key);<br>        <span class="hljs-keyword">if</span> (map.isEmpty()) &#123;<br>            resources.remove();<br>        &#125;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="实例4：自定义租户上下文-多租户架构">实例4：自定义租户上下文（多租户架构）</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 多租户上下文管理器</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 设计模式：上下文对象模式 + ThreadLocal</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 适用场景：SaaS 多租户系统</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TenantContext</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;TenantInfo&gt; TENANT_HOLDER = <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br>    <br>    <span class="hljs-comment">// 使用 TTL 支持线程池场景</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> TransmittableThreadLocal&lt;TenantInfo&gt; TTL_TENANT_HOLDER = <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransmittableThreadLocal</span>&lt;&gt;();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 租户信息</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TenantInfo</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String tenantId;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String tenantName;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String dataSourceKey;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Object&gt; attributes;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">TenantInfo</span><span class="hljs-params">(String tenantId, String tenantName, String dataSourceKey)</span> &#123;<br>            <span class="hljs-built_in">this</span>.tenantId = tenantId;<br>            <span class="hljs-built_in">this</span>.tenantName = tenantName;<br>            <span class="hljs-built_in">this</span>.dataSourceKey = dataSourceKey;<br>            <span class="hljs-built_in">this</span>.attributes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        &#125;<br><br>        <span class="hljs-comment">// getters...</span><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getTenantId</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> tenantId; &#125;<br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getTenantName</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> tenantName; &#125;<br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getDataSourceKey</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> dataSourceKey; &#125;<br>        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getAttribute</span><span class="hljs-params">(String key)</span> &#123; <span class="hljs-keyword">return</span> attributes.get(key); &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAttribute</span><span class="hljs-params">(String key, Object value)</span> &#123; attributes.put(key, value); &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置当前租户（支持线程池）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTenant</span><span class="hljs-params">(TenantInfo tenant)</span> &#123;<br>        TTL_TENANT_HOLDER.set(tenant);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取当前租户</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> TenantInfo <span class="hljs-title function_">getTenant</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> TTL_TENANT_HOLDER.get();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取当前租户 ID</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getTenantId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">TenantInfo</span> <span class="hljs-variable">tenant</span> <span class="hljs-operator">=</span> getTenant();<br>        <span class="hljs-keyword">return</span> tenant != <span class="hljs-literal">null</span> ? tenant.getTenantId() : <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 清除租户上下文</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> &#123;<br>        TTL_TENANT_HOLDER.remove();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 在指定租户上下文中执行操作</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; T <span class="hljs-title function_">executeWithTenant</span><span class="hljs-params">(TenantInfo tenant, Supplier&lt;T&gt; action)</span> &#123;<br>        <span class="hljs-type">TenantInfo</span> <span class="hljs-variable">previous</span> <span class="hljs-operator">=</span> getTenant();<br>        <span class="hljs-keyword">try</span> &#123;<br>            setTenant(tenant);<br>            <span class="hljs-keyword">return</span> action.get();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (previous != <span class="hljs-literal">null</span>) &#123;<br>                setTenant(previous);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                clear();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 在指定租户上下文中执行操作（无返回值）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runWithTenant</span><span class="hljs-params">(TenantInfo tenant, Runnable action)</span> &#123;<br>        executeWithTenant(tenant, () -&gt; &#123;<br>            action.run();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 租户拦截器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TenantInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, </span><br><span class="hljs-params">                             HttpServletResponse response, </span><br><span class="hljs-params">                             Object handler)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">tenantId</span> <span class="hljs-operator">=</span> request.getHeader(<span class="hljs-string">&quot;X-Tenant-Id&quot;</span>);<br>        <span class="hljs-keyword">if</span> (tenantId != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">TenantInfo</span> <span class="hljs-variable">tenant</span> <span class="hljs-operator">=</span> loadTenantInfo(tenantId);<br>            TenantContext.setTenant(tenant);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, </span><br><span class="hljs-params">                                HttpServletResponse response, </span><br><span class="hljs-params">                                Object handler, Exception ex)</span> &#123;<br>        TenantContext.clear();  <span class="hljs-comment">// 必须清理！</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> TenantInfo <span class="hljs-title function_">loadTenantInfo</span><span class="hljs-params">(String tenantId)</span> &#123;<br>        <span class="hljs-comment">// 从缓存或数据库加载租户信息</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TenantInfo</span>(tenantId, <span class="hljs-string">&quot;租户名称&quot;</span>, <span class="hljs-string">&quot;ds_&quot;</span> + tenantId);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 动态数据源路由</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TenantDataSourceRouter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractRoutingDataSource</span> &#123;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">determineCurrentLookupKey</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 根据当前租户选择数据源</span><br>        <span class="hljs-keyword">return</span> TenantContext.getTenant() != <span class="hljs-literal">null</span> <br>            ? TenantContext.getTenant().getDataSourceKey() <br>            : <span class="hljs-string">&quot;default&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="实例5：安全上下文-类似-spring-security">实例5：安全上下文（类似 Spring Security）</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 安全上下文管理器</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 设计模式：策略模式 + ThreadLocal</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 参考 Spring Security 的 SecurityContextHolder 设计</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecurityContextHolder</span> &#123;<br>    <br>    <span class="hljs-comment">// 上下文存储策略</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">MODE_THREADLOCAL</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;MODE_THREADLOCAL&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">MODE_INHERITABLETHREADLOCAL</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;MODE_INHERITABLETHREADLOCAL&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">MODE_GLOBAL</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;MODE_GLOBAL&quot;</span>;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">strategyName</span> <span class="hljs-operator">=</span> MODE_THREADLOCAL;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SecurityContextHolderStrategy strategy;<br>    <br>    <span class="hljs-keyword">static</span> &#123;<br>        initialize();<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initialize</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">switch</span> (strategyName) &#123;<br>            <span class="hljs-keyword">case</span> MODE_THREADLOCAL:<br>                strategy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalSecurityContextHolderStrategy</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> MODE_INHERITABLETHREADLOCAL:<br>                strategy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InheritableThreadLocalSecurityContextHolderStrategy</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> MODE_GLOBAL:<br>                strategy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GlobalSecurityContextHolderStrategy</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Unknown strategy: &quot;</span> + strategyName);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setContext</span><span class="hljs-params">(SecurityContext context)</span> &#123;<br>        strategy.setContext(context);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SecurityContext <span class="hljs-title function_">getContext</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> strategy.getContext();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clearContext</span><span class="hljs-params">()</span> &#123;<br>        strategy.clearContext();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SecurityContext <span class="hljs-title function_">createEmptyContext</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> strategy.createEmptyContext();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 策略接口</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">SecurityContextHolderStrategy</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">clearContext</span><span class="hljs-params">()</span>;<br>    SecurityContext <span class="hljs-title function_">getContext</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setContext</span><span class="hljs-params">(SecurityContext context)</span>;<br>    SecurityContext <span class="hljs-title function_">createEmptyContext</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ThreadLocal 策略实现</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalSecurityContextHolderStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SecurityContextHolderStrategy</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;SecurityContext&gt; contextHolder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clearContext</span><span class="hljs-params">()</span> &#123;<br>        contextHolder.remove();<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> SecurityContext <span class="hljs-title function_">getContext</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">SecurityContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> contextHolder.get();<br>        <span class="hljs-keyword">if</span> (ctx == <span class="hljs-literal">null</span>) &#123;<br>            ctx = createEmptyContext();<br>            contextHolder.set(ctx);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ctx;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setContext</span><span class="hljs-params">(SecurityContext context)</span> &#123;<br>        <span class="hljs-keyword">if</span> (context == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Context cannot be null&quot;</span>);<br>        &#125;<br>        contextHolder.set(context);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> SecurityContext <span class="hljs-title function_">createEmptyContext</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecurityContextImpl</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * InheritableThreadLocal 策略实现</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">InheritableThreadLocalSecurityContextHolderStrategy</span> <br>        <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SecurityContextHolderStrategy</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;SecurityContext&gt; contextHolder = <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">InheritableThreadLocal</span>&lt;&gt;();<br>    <br>    <span class="hljs-comment">// 实现与 ThreadLocalSecurityContextHolderStrategy 类似...</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clearContext</span><span class="hljs-params">()</span> &#123;<br>        contextHolder.remove();<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> SecurityContext <span class="hljs-title function_">getContext</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">SecurityContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> contextHolder.get();<br>        <span class="hljs-keyword">if</span> (ctx == <span class="hljs-literal">null</span>) &#123;<br>            ctx = createEmptyContext();<br>            contextHolder.set(ctx);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ctx;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setContext</span><span class="hljs-params">(SecurityContext context)</span> &#123;<br>        contextHolder.set(context);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> SecurityContext <span class="hljs-title function_">createEmptyContext</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecurityContextImpl</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 安全上下文</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">SecurityContext</span> &#123;<br>    Authentication <span class="hljs-title function_">getAuthentication</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAuthentication</span><span class="hljs-params">(Authentication authentication)</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SecurityContextImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SecurityContext</span> &#123;<br>    <span class="hljs-keyword">private</span> Authentication authentication;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Authentication <span class="hljs-title function_">getAuthentication</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> authentication;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAuthentication</span><span class="hljs-params">(Authentication authentication)</span> &#123;<br>        <span class="hljs-built_in">this</span>.authentication = authentication;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Authentication</span> &#123;<br>    String <span class="hljs-title function_">getPrincipal</span><span class="hljs-params">()</span>;<br>    Collection&lt;String&gt; <span class="hljs-title function_">getAuthorities</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAuthenticated</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="设计模式总结">设计模式总结</h2>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;基于 ThreadLocal 的设计模式&quot;
        direction TB
        
        subgraph Pattern1[&quot;Holder 模式&quot;]
            H1[&quot;静态 ThreadLocal 变量&quot;]
            H2[&quot;静态 get/set/remove 方法&quot;]
            H3[&quot;示例: RequestContextHolder&quot;]
        end
        
        subgraph Pattern2[&quot;上下文对象模式&quot;]
            C1[&quot;封装多个相关属性&quot;]
            C2[&quot;提供便捷访问方法&quot;]
            C3[&quot;示例: TenantContext&quot;]
        end
        
        subgraph Pattern3[&quot;策略模式&quot;]
            S1[&quot;多种存储策略&quot;]
            S2[&quot;运行时可切换&quot;]
            S3[&quot;示例: SecurityContextHolder&quot;]
        end
        
        subgraph Pattern4[&quot;资源绑定模式&quot;]
            R1[&quot;绑定资源到线程&quot;]
            R2[&quot;事务内复用&quot;]
            R3[&quot;示例: TransactionSynchronizationManager&quot;]
        end
        
        subgraph Pattern5[&quot;诊断上下文模式&quot;]
            D1[&quot;键值对存储&quot;]
            D2[&quot;日志自动附加&quot;]
            D3[&quot;示例: MDC&quot;]
        end
    end
    
    style Pattern1 fill:#e3f2fd
    style Pattern2 fill:#e8f5e9
    style Pattern3 fill:#fff3e0
    style Pattern4 fill:#f3e5f5
    style Pattern5 fill:#ffebee</code></pre>
<h1>最佳实践</h1>
<h2 id="如何正确使用-threadlocal">如何正确使用 ThreadLocal</h2>
<p>ThreadLocal 最好的用法是做一个 <strong>request scope 的缓存</strong>——在请求开始时设置，请求结束时清理。在线程里长期复用 ThreadLocal 其实极度危险。</p>
<p><strong>正确的使用模式</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;SomeObject&gt; threadLocal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        threadLocal.set(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SomeObject</span>());<br>        <span class="hljs-comment">// 业务逻辑</span><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        threadLocal.remove(); <span class="hljs-comment">// 确保清理，避免内存泄漏</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>最佳实践清单</strong>：</p>
<ol>
<li><strong>手动清理</strong>：使用完 ThreadLocal 后立即调用 <code>remove()</code>，这是最可靠的方式</li>
<li><strong>声明为 static</strong>：ThreadLocal 变量应该声明为 static，避免每个对象实例都创建新的 ThreadLocal</li>
<li><strong>避免静态变量泄漏</strong>：谨慎管理 ThreadLocal 静态变量的生命周期</li>
<li><strong>线程池场景特别注意</strong>：在使用线程池时，线程不会被销毁，必须手动清理</li>
<li><strong>使用 try-finally</strong>：确保在 finally 块中调用 remove()，即使发生异常也能清理</li>
</ol>
<h2 id="weakhashmap-与-threadlocalmap-的设计对比">WeakHashMap 与 ThreadLocalMap 的设计对比</h2>
<p>WeakHashMap 和 ThreadLocalMap 有相似的设计理念——利用弱引用实现自动清理。</p>
<p>WeakHashMap 利用下一次操作来触发 clear，好像有一个后台线程来维护 Map 一样。这种&quot;惰性清理&quot;的设计模式在 ThreadLocalMap 中也有体现：只有在 get/set/remove 操作时才会触发 Stale Entry 的清理。</p>
<p>这种设计的优点是避免了额外的清理线程开销，缺点是如果长时间没有操作，过期数据不会被及时清理。</p>
<h1>总结</h1>
<p>ThreadLocal 是 Java 并发编程中实现线程封闭的核心工具，其设计体现了几个重要的工程智慧：</p>
<ol>
<li><strong>反转持有关系</strong>：让 Thread 持有 Map，而不是让 Map 持有 Thread，从根本上避免了线程无法回收的问题</li>
<li><strong>弱引用 + 惰性清理</strong>：通过弱引用 key 和惰性清理机制，在不影响性能的前提下尽可能避免内存泄漏</li>
<li><strong>开放地址法</strong>：针对 ThreadLocal 的使用特点（Entry 数量少、需要顺便清理 Stale Entry），选择了更合适的哈希冲突解决方案</li>
</ol>
<p>在实际使用中，要牢记：</p>
<ul>
<li>ThreadLocal 应该声明为 static</li>
<li>使用完毕后必须调用 remove()</li>
<li>线程池场景下考虑使用 TransmittableThreadLocal</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://magicliang.github.io">magicliang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://magicliang.github.io/2020/04/01/ThreadLocal-%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">https://magicliang.github.io/2020/04/01/ThreadLocal-%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a><a class="post-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a></div><div class="post-share"><div class="social-share" data-image="/img/wall-paper-35.jpg" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2017/10/23/%E6%98%82%E8%B4%B5%E7%9A%84%E5%BC%82%E5%B8%B8/" title="昂贵的异常"><img class="cover" src="/img/wall-paper-151.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-10-23</div><div class="info-item-2">昂贵的异常</div></div><div class="info-2"><div class="info-item-1">抛出问题   Joshua Bloch 在《Effective Java》的 Item 57 里明确地提到过，不要试图用 Exception 的跳转来代替正常的程序控制流。他列举了很多原因，但特别提到了抛出异常会使得整个程序运行变慢。抛出异常远比普通的 return , break 等操作对控制流、数据流的性能影响要大，它就只适合拿来作异常分支的控制语句，而不能拿来编写正常的逻辑。  Throwing exception is expensive.    这句话在 Java 的程序员世界里面已经成为老生常谈。却很少有人谈及，但到底抛出异常比正常的程序跳转返回慢在哪里，有多慢。“不要滥用异常”好像一个猴子定律，人们忘记了为什么不能这么做，却不明白为什么不能这么做。   这几天读了一位同事写的好文[《Java虚拟机是如何处理异常的》][2]，深入地分析了 JVM 对异常跳转的处理过程: JVM 会通过异常表的机制，优化异常抛出和正常返回之间的性能差异。仅从程序计数器的移动上来讲，抛出一个异常对栈帧的弹栈并不比直接返回更昂贵。写在前头的结论是：“try-catch语句块几乎不会影响程序...</div></div></div></a><a class="pagination-related" href="/2017/11/30/Java%E4%B8%AD%E7%9A%84%E5%B9%BD%E7%81%B5%E7%B1%BB%E5%9E%8B/" title="Java中的幽灵类型"><img class="cover" src="/img/wall-paper-71.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-11-30</div><div class="info-item-2">Java中的幽灵类型</div></div><div class="info-2"><div class="info-item-1">先上结论：幽灵类型（Phantom Type）顾名思义，就是幽灵般的类型，这种类型往往在运行时可以消失，因为在运行时没有任何作用，它们最大的特点就是没有任何实例（Java 的 Void 就是幽灵类型的例子）。是一种可以把有些运行时才能检测到的错误，在编译时检测出来的技巧。按照有些老外的观点，就是“Making Wrong Code Look Wrong”。在面向对象的编程语言之中，幽灵类型的实现，往往与状态模式较为接近，但比状态模式提供了更强的纠错功能。在Java 5 以后的版本里，程序员可以使用泛型。通过泛型的类型参数，Java 中也拥有了幽灵类型的能力。 上面的阐述是不是很难看懂？我也觉得拗口，让我们直接进入具体的例子。假设我们要写一个飞机控制程序，操作飞机起飞或者落地。这个程序有一个非常强的业务约束，就是必须保证飞机一开始必须出现在的地上，只有在地上的飞机可以起飞，只有起飞的飞机可以落地，那么我们应该怎样设计我们的程序（主要是类型关系），来保证这个约束必然成立呢？ 让我们先来定义一组状态接口: 123456789101112131415161718192021/** * F...</div></div></div></a><a class="pagination-related" href="/2018/01/04/%E4%B8%8D%E5%B8%B8%E8%A7%81%E7%9A%84-Java-%E9%9B%86%E5%90%88%E7%B1%BB%E7%9A%84%E7%94%A8%E6%B3%95/" title="不常见的 Java 集合类的用法"><img class="cover" src="/img/wall-paper-168.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-01-04</div><div class="info-item-2">不常见的 Java 集合类的用法</div></div><div class="info-2"><div class="info-item-1">Sorted 集合## Sorted集合 Navigable 集合 Navigable Priority集合 Priority Identity 集合## Identity SkipList 集合 跳表系列。 DelayQueue 延迟队列 </div></div></div></a><a class="pagination-related" href="/2018/05/29/JPA-%E7%9A%84-id-%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5/" title="JPA 的 id 生成策略"><img class="cover" src="/img/wall-paper-10.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-05-29</div><div class="info-item-2">JPA 的 id 生成策略</div></div><div class="info-2"><div class="info-item-1">JPA 有一个@GeneratedValue注解，有一个strategy attribute，如 @GeneratedValue(strategy = GenerationType.IDENTITY)。 常见的可选策略主要有IDENTITY和SEQUENCE。 GenerationType.IDENTITY 要求底层有一个 integer 或者 bigint 类型的自增列（ auto-incremented column)。自增列的赋值必须在插入操作之后发生，因为这个原因，Hibernate 无法进行各种优化（特别是 JDBC 的 batch 处理，一次 flush 操作会产生很多条insert 语句，分别执行）。如果事务回滚，自增列的值就会被丢弃。数据库在这个自增操作上有个高度优化的轻量级锁机制，性能非常棒。 MySQL 支持这种 id 生成策略， 使用 MySQL 应该尽量使用这个策略，即使它无法优化。 JPA 用它生成 id，会一条一条地插入新的 entity。 GenerationType.SEQUENCE 数据库有一个所谓的 sequence 对象，可以通过 selec...</div></div></div></a><a class="pagination-related" href="/2018/06/19/%E5%A6%82%E4%BD%95%E5%81%9A%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8B%E7%9A%84%E7%AD%94%E6%A1%88/" title="如何做性能测试的问题下的答案"><img class="cover" src="/img/wall-paper-56.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-06-19</div><div class="info-item-2">如何做性能测试的问题下的答案</div></div><div class="info-2"><div class="info-item-1">试着回答一下这个问题。 首先要划分系统类型：有状态还是无状态，业务系统还是存储系统。根据不同的业务场景，设立性能测试的目标：是要测 QPS，还是 TPS 还是 TPS，还是任何其他【性能】-从广义来讲，一个存储系统到底能够以多高的平均时延来管理大多的存储空间，可能也是性能的一种。 有了性能测试的目标，接下来就是拆解用例。如果把性能测试归为测试的话，测试就需要测试用例，测试用例只是用例的形式化表达。把用户的使用场景勾勒出来，把每一步拆解成的流程图或者时序图–我们已经得到了一个纸上的集成测试计划，只是没有跟性能挂上钩。 接下来就进入真正写测试用例的环节了。 我们的测试报告如果要涵盖足够立体的信息，则既要了解每一个环节/接口/API 的性能指标，又要了解整体的性能指标。 这个时候测试工具的覆盖面就很重要了。如果我们选择偏黑盒的测试工具，apache ab /JMeter，则我们的测试用例就要围绕着对外交互的 API写，也只能测到外围接口的性能。这样的测试用例写起来最简单，无需侵入任何内部代码中。 如果我们使用了 JMH 一类的工具，则可以自由编写对任何方法的测试用例。但需要对系统有非常...</div></div></div></a><a class="pagination-related" href="/2018/09/07/%E6%97%A5%E6%9C%9F%E4%B8%8E%E6%97%B6%E9%97%B4/" title="日期与时间"><img class="cover" src="/img/wall-paper-77.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-09-07</div><div class="info-item-2">日期与时间</div></div><div class="info-2"><div class="info-item-1">JSR 310 Java Date与Time API 新旧 API 的更迭 旧的 Java API 主要包括java.util.Date和java.util.Calendar 两个包的内容。这两个包的时间类型是可变的。如 Date 的实例可以通过 setYear 来产生变化。 JSR 310 中包括的日期类型主要有：  计算机时间：Instant，对应 java.util.Date，它代表了一个确定的时间点，即相对于标准Java纪元（1970年1月1日）的偏移量；但与java.util.Date类不同的是其精确到了纳秒级别。 人类时间：对应于人类自身的观念，比如LocalDate和LocalTime。他们代表了一般的时区概念，要么是日期（不包含时间），要么是时间（不包含日期），类似于java.sql的表示方式。此外，还有一个MonthDay，它可以存储某人的生日（不包含年份）。每个类都在内部存储正确的数据而不是像java.util.Date那样利用午夜12点来区分日期，利用1970-01-01来表示时间。这些类型的实例是 immutable 的，而且只能通过工厂方法创建。  时区...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">原理篇：ThreadLocal 的内部机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8-map-thread-value-%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">核心设计理念：为什么不用 Map&lt;Thread, Value&gt;？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E5%85%B3%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">引用关系结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%8E%9F%E5%88%99"><span class="toc-number">1.3.</span> <span class="toc-text">四大核心原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%88%991%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">1.3.1.</span> <span class="toc-text">原则1：操作的本质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%88%992%EF%BC%9Athreadlocal-%E5%BA%94%E8%AF%A5%E6%98%AF-static-%E5%8F%98%E9%87%8F"><span class="toc-number">1.3.2.</span> <span class="toc-text">原则2：ThreadLocal 应该是 static 变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%88%993%EF%BC%9A%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%86%B3%E5%AE%9A%E6%95%B0%E6%8D%AE%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.3.3.</span> <span class="toc-text">原则3：线程生命周期决定数据生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%88%994%EF%BC%9Athreadlocal-%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%BD%B1%E5%93%8D%E6%89%80%E6%9C%89%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.3.4.</span> <span class="toc-text">原则4：ThreadLocal 对象的生命周期影响所有线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-key-%E4%BD%BF%E7%94%A8%E5%BC%B1%E5%BC%95%E7%94%A8%EF%BC%9F"><span class="toc-number">1.4.</span> <span class="toc-text">为什么 key 使用弱引用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stale-entry-%E7%9A%84%E8%87%AA%E5%8A%A8%E6%B8%85%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">1.5.</span> <span class="toc-text">Stale Entry 的自动清理机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#threadlocal-%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E9%93%BE%E8%A7%A3%E6%9E%90"><span class="toc-number">1.6.</span> <span class="toc-text">ThreadLocal 核心方法调用链解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB%E5%9B%BE"><span class="toc-number">1.6.1.</span> <span class="toc-text">方法调用关系图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-number">1.6.2.</span> <span class="toc-text">核心方法源码解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-threadlocal-set-t-value-%E8%AE%BE%E7%BD%AE%E5%85%A5%E5%8F%A3"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">1. ThreadLocal.set(T value) —— 设置入口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-getmap-thread-t-%E8%8E%B7%E5%8F%96%E7%BA%BF%E7%A8%8B%E7%9A%84-map"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">2. getMap(Thread t) —— 获取线程的 Map</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-createmap-thread-t-t-firstvalue-%E5%88%9B%E5%BB%BA-map"><span class="toc-number">1.6.2.3.</span> <span class="toc-text">3. createMap(Thread t, T firstValue) —— 创建 Map</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-threadlocalmap-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.6.2.4.</span> <span class="toc-text">4. ThreadLocalMap 构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-threadlocalmap-set-threadlocal-key-object-value-%E6%A0%B8%E5%BF%83%E8%AE%BE%E7%BD%AE%E9%80%BB%E8%BE%91"><span class="toc-number">1.6.2.5.</span> <span class="toc-text">5. ThreadLocalMap.set(ThreadLocal&lt;?&gt; key, Object value) —— 核心设置逻辑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-threadlocal-get-%E8%8E%B7%E5%8F%96%E5%85%A5%E5%8F%A3"><span class="toc-number">1.6.2.6.</span> <span class="toc-text">6. ThreadLocal.get() —— 获取入口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-getentryaftermiss-threadlocal-key-int-i-entry-e-%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E6%97%B6%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="toc-number">1.6.2.7.</span> <span class="toc-text">7. getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) —— 哈希冲突时的查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-threadlocal-remove-%E5%92%8C-threadlocalmap-remove-threadlocal-key"><span class="toc-number">1.6.2.8.</span> <span class="toc-text">8. ThreadLocal.remove() 和 ThreadLocalMap.remove(ThreadLocal&lt;?&gt; key)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-expungestaleentry-int-staleslot-%E6%A0%B8%E5%BF%83%E6%B8%85%E7%90%86%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.2.9.</span> <span class="toc-text">9. expungeStaleEntry(int staleSlot) —— 核心清理方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB%E6%80%BB%E7%BB%93"><span class="toc-number">1.6.3.</span> <span class="toc-text">方法调用关系总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-threadlocalmap-%E4%BD%BF%E7%94%A8%E5%BC%80%E6%94%BE%E5%9C%B0%E5%9D%80%E6%B3%95%E8%80%8C%E4%B8%8D%E6%98%AF%E9%93%BE%E8%A1%A8%E6%B3%95%EF%BC%9F"><span class="toc-number">1.7.</span> <span class="toc-text">为什么 ThreadLocalMap 使用开放地址法而不是链表法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%8F%91%E7%94%9F%E6%9C%BA%E5%88%B6"><span class="toc-number">1.8.</span> <span class="toc-text">内存泄漏的发生机制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">实践篇：ThreadLocal 的使用模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%89%88%E6%9C%AC%EF%BC%9A%E9%9D%99%E6%80%81%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%B0%81%E8%A3%85"><span class="toc-number">2.1.</span> <span class="toc-text">基础版本：静态工具类封装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8-map-%E6%9D%A5%E5%8F%96%E6%B6%88%E7%AC%AC%E4%B8%80%E5%B1%82%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%9A%84%E6%96%B9%E6%A1%88"><span class="toc-number">2.2.</span> <span class="toc-text">用 Map 来取消第一层工具类的方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A%E5%AE%B9%E5%99%A8%E5%88%B0%E7%BA%BF%E7%A8%8B%E5%B9%B6%E4%BF%9D%E5%AD%98%E4%B8%8A%E4%B8%80%E4%B8%AA%E7%8A%B6%E6%80%81"><span class="toc-number">2.3.</span> <span class="toc-text">绑定容器到线程并保存上一个状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#threadlocal-%E5%8F%98%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.4.</span> <span class="toc-text">ThreadLocal 变策略模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%A6%E5%90%8D%E5%AD%97%E7%9A%84-threadlocal"><span class="toc-number">2.5.</span> <span class="toc-text">带名字的 ThreadLocal</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">跨线程传递篇：InheritableThreadLocal 与 TransmittableThreadLocal</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#inheritablethreadlocal-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">3.1.</span> <span class="toc-text">InheritableThreadLocal 的工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#thread-%E7%B1%BB%E7%9A%84%E5%8F%8C-map-%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.1.1.</span> <span class="toc-text">Thread 类的双 Map 设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#inheritablethreadlocal-%E7%9A%84%E6%9E%81%E7%AE%80%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.1.2.</span> <span class="toc-text">InheritableThreadLocal 的极简实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#thread-init-%E6%96%B9%E6%B3%95%E9%80%90%E8%A1%8C%E8%A7%A3%E6%9E%90"><span class="toc-number">3.1.3.</span> <span class="toc-text">Thread.init() 方法逐行解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%A7%A3"><span class="toc-number">3.1.4.</span> <span class="toc-text">继承流程图解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#thread-%E4%B8%BA-inheritablethreadlocal-%E7%9A%84%E4%B8%93%E9%97%A8%E6%94%B9%E9%80%A0"><span class="toc-number">3.1.5.</span> <span class="toc-text">Thread 为 InheritableThreadLocal 的专门改造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%A4%E4%B8%AA-map%EF%BC%9F%E4%B8%8D%E8%83%BD%E5%90%88%E5%B9%B6%E5%90%97%EF%BC%9F"><span class="toc-number">3.1.6.</span> <span class="toc-text">为什么需要两个 Map？不能合并吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#inheritablethreadlocal-%E7%9A%84%E6%B5%85%E6%8B%B7%E8%B4%9D%E9%97%AE%E9%A2%98"><span class="toc-number">3.1.7.</span> <span class="toc-text">InheritableThreadLocal 的浅拷贝问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#inheritablethreadlocal-%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-number">3.1.8.</span> <span class="toc-text">InheritableThreadLocal 的局限性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#transmittablethreadlocal%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%9C%BA%E6%99%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">3.2.</span> <span class="toc-text">TransmittableThreadLocal：线程池场景的解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%8C%91%E6%88%98%EF%BC%9A%E4%B8%8D%E8%83%BD%E4%BF%AE%E6%94%B9-thread-%E7%B1%BB"><span class="toc-number">3.2.1.</span> <span class="toc-text">核心挑战：不能修改 Thread 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ttl-%E7%9A%84%E5%B7%A7%E5%A6%99%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9Acapture-replay-restore"><span class="toc-number">3.2.2.</span> <span class="toc-text">TTL 的巧妙解决方案：Capture-Replay-Restore</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">3.2.3.</span> <span class="toc-text">核心实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-holder-%E6%B3%A8%E5%86%8C%E6%9C%BA%E5%88%B6"><span class="toc-number">3.2.3.1.</span> <span class="toc-text">1. holder 注册机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%8B%A6%E6%88%AA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84-execute-%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.3.2.</span> <span class="toc-text">2. 拦截线程池的 execute 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-worker-%E7%BA%BF%E7%A8%8B%E7%9A%84-threadlocalmap-store-restore"><span class="toc-number">3.2.3.3.</span> <span class="toc-text">3. Worker 线程的 ThreadLocalMap Store&#x2F;Restore</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-transmitter-%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">3.2.3.4.</span> <span class="toc-text">4. Transmitter 工具类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-ttlrunnable-%E5%8C%85%E8%A3%85%E5%99%A8"><span class="toc-number">3.2.3.5.</span> <span class="toc-text">3. TtlRunnable 包装器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%B8%85%E7%90%86%E4%B8%8D%E5%9C%A8%E5%BF%AB%E7%85%A7%E4%B8%AD%E7%9A%84-ttl-%E5%8F%98%E9%87%8F%EF%BC%9F"><span class="toc-number">3.2.4.</span> <span class="toc-text">为什么需要清理不在快照中的 TTL 变量？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94"><span class="toc-number">3.2.5.</span> <span class="toc-text">三种使用方式对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ttl-%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%BE"><span class="toc-number">3.2.6.</span> <span class="toc-text">TTL 核心数据结构图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ttl-%E5%AE%8C%E6%95%B4%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE"><span class="toc-number">3.2.7.</span> <span class="toc-text">TTL 完整生命周期图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ttl-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E9%9A%94%E7%A6%BB%E6%9C%BA%E5%88%B6%E5%9B%BE"><span class="toc-number">3.2.8.</span> <span class="toc-text">TTL 多任务隔离机制图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ttl-%E4%B8%89%E7%A7%8D%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94%E5%9B%BE"><span class="toc-number">3.2.9.</span> <span class="toc-text">TTL 三种使用方式对比图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#holder-%E6%B3%A8%E5%86%8C%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3%E5%9B%BE"><span class="toc-number">3.2.10.</span> <span class="toc-text">holder 注册机制详解图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#inheritablethreadlocal-vs-transmittablethreadlocal"><span class="toc-number">3.2.11.</span> <span class="toc-text">InheritableThreadLocal vs TransmittableThreadLocal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.2.12.</span> <span class="toc-text">适用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">ThreadLocal 核心源码深度解析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#threadlocal-set-%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3"><span class="toc-number">4.1.</span> <span class="toc-text">ThreadLocal.set() 源码详解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#threadlocal-get-%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3"><span class="toc-number">4.2.</span> <span class="toc-text">ThreadLocal.get() 源码详解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#threadlocalmap-set-%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3"><span class="toc-number">4.3.</span> <span class="toc-text">ThreadLocalMap.set() 源码详解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#threadlocalmap-getentry-%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3"><span class="toc-number">4.4.</span> <span class="toc-text">ThreadLocalMap.getEntry() 源码详解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#expungestaleentry-%E6%A0%B8%E5%BF%83%E6%B8%85%E7%90%86%E9%80%BB%E8%BE%91"><span class="toc-number">4.5.</span> <span class="toc-text">expungeStaleEntry() 核心清理逻辑</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">基于 ThreadLocal 的设计模式框架实例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B1%EF%BC%9Aspring-%E7%9A%84-requestcontextholder"><span class="toc-number">5.1.</span> <span class="toc-text">实例1：Spring 的 RequestContextHolder</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B2%EF%BC%9Aslf4j-%E7%9A%84-mdc-mapped-diagnostic-context"><span class="toc-number">5.2.</span> <span class="toc-text">实例2：SLF4J 的 MDC（Mapped Diagnostic Context）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B3%EF%BC%9Amybatis-%E7%9A%84-sqlsession-%E7%AE%A1%E7%90%86"><span class="toc-number">5.3.</span> <span class="toc-text">实例3：MyBatis 的 SqlSession 管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B4%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E7%A7%9F%E6%88%B7%E4%B8%8A%E4%B8%8B%E6%96%87-%E5%A4%9A%E7%A7%9F%E6%88%B7%E6%9E%B6%E6%9E%84"><span class="toc-number">5.4.</span> <span class="toc-text">实例4：自定义租户上下文（多租户架构）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B5%EF%BC%9A%E5%AE%89%E5%85%A8%E4%B8%8A%E4%B8%8B%E6%96%87-%E7%B1%BB%E4%BC%BC-spring-security"><span class="toc-number">5.5.</span> <span class="toc-text">实例5：安全上下文（类似 Spring Security）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93"><span class="toc-number">5.6.</span> <span class="toc-text">设计模式总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">最佳实践</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8-threadlocal"><span class="toc-number">6.1.</span> <span class="toc-text">如何正确使用 ThreadLocal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#weakhashmap-%E4%B8%8E-threadlocalmap-%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%AF%B9%E6%AF%94"><span class="toc-number">6.2.</span> <span class="toc-text">WeakHashMap 与 ThreadLocalMap 的设计对比</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">总结</span></a></li></ol></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2017 - 2026 By magicliang</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional and Simplified Chinese">簡</button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><script src="/js/tw_cn.js?v=5.5.2"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="/"></script></div></body></html>