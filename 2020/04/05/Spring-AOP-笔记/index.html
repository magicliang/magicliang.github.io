<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Spring AOP 笔记 | 守株阁</title><meta name="author" content="magicliang"><meta name="copyright" content="magicliang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="AOP 的基本概念 Aspect: A modularization of a concern that cuts across multiple classes. 方面，横跨多个类的模块化关注点。如果只是简单地横跨多个类，可以考虑使用继承 + 组合 + 设计模式。如果使用某种模式匹配来横跨多个类，才需要考虑使用 Aspect。 Join point: A point during the exe">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring AOP 笔记">
<meta property="og:url" content="https://magicliang.github.io/2020/04/05/Spring-AOP-%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="守株阁">
<meta property="og:description" content="AOP 的基本概念 Aspect: A modularization of a concern that cuts across multiple classes. 方面，横跨多个类的模块化关注点。如果只是简单地横跨多个类，可以考虑使用继承 + 组合 + 设计模式。如果使用某种模式匹配来横跨多个类，才需要考虑使用 Aspect。 Join point: A point during the exe">
<meta property="og:locale">
<meta property="og:image" content="https://magicliang.github.io/2020/04/05/Spring-AOP-%E7%AC%94%E8%AE%B0/spring-aop-proxy-creation.jpg">
<meta property="article:published_time" content="2020-04-05T04:17:29.000Z">
<meta property="article:modified_time" content="2026-01-24T07:32:06.874Z">
<meta property="article:author" content="magicliang">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Spring">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://magicliang.github.io/2020/04/05/Spring-AOP-%E7%AC%94%E8%AE%B0/spring-aop-proxy-creation.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Spring AOP 笔记",
  "url": "https://magicliang.github.io/2020/04/05/Spring-AOP-%E7%AC%94%E8%AE%B0/",
  "image": "https://magicliang.github.io/2020/04/05/Spring-AOP-%E7%AC%94%E8%AE%B0/spring-aop-proxy-creation.jpg",
  "datePublished": "2020-04-05T04:17:29.000Z",
  "dateModified": "2026-01-24T07:32:06.874Z",
  "author": [
    {
      "@type": "Person",
      "name": "magicliang",
      "url": "https://magicliang.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://magicliang.github.io/2020/04/05/Spring-AOP-%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: magicliang","link":"Link: ","source":"Source: 守株阁","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Spring AOP 笔记',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"><link rel="alternate" href="/atom.xml" title="守株阁" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      if ($loadingBox.classList.contains('loaded')) return
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()

  if (document.readyState === 'complete') {
    preloader.endLoading()
  } else {
    window.addEventListener('load', preloader.endLoading)
    document.addEventListener('DOMContentLoaded', preloader.endLoading)
    // Add timeout protection: force end after 7 seconds
    setTimeout(preloader.endLoading, 7000)
  }

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/2020/04/05/Spring-AOP-%E7%AC%94%E8%AE%B0/spring-aop-proxy-creation.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">守株阁</span></a><a class="nav-page-title" href="/"><span class="site-name">Spring AOP 笔记</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">Spring AOP 笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2020-04-05T04:17:29.000Z" title="Created 2020-04-05 12:17:29">2020-04-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2026-01-24T07:32:06.874Z" title="Updated 2026-01-24 15:32:06">2026-01-24</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">29.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>145mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1>AOP 的基本概念</h1>
<p>Aspect: A modularization of a concern that cuts across multiple classes. 方面，<strong>横跨多个类</strong>的模块化关注点。如果只是简单地横跨多个类，可以考虑使用继承 + 组合 + 设计模式。如果使用某种模式匹配来横跨多个类，才需要考虑使用 Aspect。</p>
<p>Join point: A point during the execution of a program, such as the execution of a method or the handling of an exception. In Spring AOP, a join point always represents a method execution. 结合点是我们最需要关注的东西，既包括了<strong>方法执行过程，也包含了异常处理过程</strong>。</p>
<p>Advice: Action taken by an aspect at a particular join point. 方面针对结合点采取的<strong>行动</strong>。对 Advice 而言，join point 经常是他们的参数（至少 Advice 对应的 Interceptor 里包装了这些参数）。</p>
<p>Pointcut: A predicate that matches join points. Advice is associated with a pointcut expression and runs at any join point matched by the pointcut (for example, the execution of a method with a certain name). The concept of join points as matched by pointcut expressions is central to AOP, and Spring uses the AspectJ pointcut expression language by default. 切点（英文是点切）实际上是对 Join point 进行判定的谓词。<strong>切点把 Join point 和 Advice 实际上结合起来了</strong>。默认的切点表达式来自于 AspectJ pointcut expression。</p>
<p>Advisor：Base interface holding AOP advice (action to take at a joinpoint) and a filter determining the applicability of the advice (such as a pointcut). This interface is not for use by Spring users, but to allow for commonality in support for different types of advice.<br>
Spring AOP is based around around advice delivered via method interception, compliant with the AOP Alliance interception API. The Advisor interface allows support for different types of advice, such as before and after advice, which need not be implemented using interception. Advisor 不是给 Spring 用户用的。它包含一个 advice，是 一个 advice 的容器 - 相应地，Aspect 是包含很多 advice 的容器，这是个 Spring 用户用的。</p>
<p>Introductions：Declaring additional methods or fields on behalf of a type. 类似混型（mixin），在不打开原有类型以改变原有类型的内容的前提下（类似 Ruby 的元编程或者 C# 的 partial class），为类型增加新的功能。</p>
<p>Target object: An object being advised by one or more aspects. Also referred to as the “advised object”. Since Spring AOP is implemented by using runtime proxies, this object is always a proxied object. 目标对象、建议对象，即原始对象。</p>
<p>AOP proxy: An object created by the AOP framework in order to implement the aspect contracts (advise method executions and so on). In the Spring Framework, an AOP proxy is a JDK dynamic proxy or a CGLIB proxy. Interceptor、Proxy，aspect contracts 的实现。</p>
<p>Weaving: linking aspects with other application types or objects to create an advised object. This can be done at compile time (using the AspectJ compiler, for example), load time, or at runtime. Spring AOP, like other pure Java AOP frameworks, performs weaving at runtime. 织入，即把方面和 advised object 联系起来的过程。可以在编译时（性能最好）、装载时（容易被忽略）和运行时（所有的 pure java AOP framework 的默认选项）执行。大多数情况下，Spring AOP 已经够用了。</p>
<p>可以看出 Spring 的设计里面是尽可能地在 IOC 的基础上提供强大的<code>auto-proxying</code>服务，所有的增强功能，都是在代理里实现的，已解决企业级开发中常见的问题，而不是提供强大而完备的 AOP 实现（尽管它已经很强大了）。</p>
<p>所有声明、配置（不管是注解还是 xml 配置）：aspect、advice、pointcut、advisor、自己实现的 Interceptor、其他 proxies 可以混合使用，即 Mixing Aspect Types。</p>
<h1>到底应该使用哪种代理呢？</h1>
<p>Spring 默认使用 Java 动态代理，任何接口实现都可以被代理。但这种代理只能拦截接口方法。最终产生的 object 是 Proxy 的 instance 且 Interface 的 implementation。</p>
<p>当一个对象没有实现一个接口的时候，Spring 会退而求其次，使用 cglib 代理。当然，我们也可以（实际上经常）<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#aop-proxying">强制使用 cglib 代理</a>。这种代理可以拦截一切可以覆写的方法（而不只是接口声明的方法）。最终产生的 object 是原类型的 subclass 的 instance。</p>
<p>It is perfectly possible to mix @AspectJ style aspects by using the auto-proxying support, schema-defined <a href="aop:aspect">aop:aspect</a> aspects, <a href="aop:advisor">aop:advisor</a> declared advisors, and even proxies and interceptors in other styles in the same configuration. All of these are implemented by using the same underlying support mechanism and can co-exist without any difficulty.</p>
<p>如果默认生成 JdkDynamicAopProxy，则以下的注入会出错：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 实际在 context 里出现的 proxy 是 Iface 类型的，在这里注入都注入不进去</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> IfaceImpl iface;<br></code></pre></td></tr></table></figure>
<h1>声明各种基础类型</h1>
<h2 id="激活-aspect-注解的方式">激活 @Aspect 注解的方式</h2>
<p>使用 @Aspect 注解的风格被称为 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#aop-ataspectj">@AspectJ style</a>。@AspectJ refers to a style of declaring aspects as regular Java classes annotated with annotations.</p>
<p>以下两种流程都能激活 @Aspect 注解的解析。注意，即使第二种方法使用 了 xml，也只是激活了对 @Aspect 注解的解析。真正的配置还是放在  @Aspect 里。</p>
<p>注意，这种注解本身的定义来自于 AspectJ 项目（<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/11446893/spring-aop-why-do-i-need-aspectjweaver">哪怕实际上是 Spring AOP 在起作用</a>），这也要求类路径里存在<code>aspectjweaver.jar</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableAspectJAutoProxy</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:aspectj-autoproxy</span>/&gt;</span><br></code></pre></td></tr></table></figure>
<h3 id="声明-aspect">声明 Aspect</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.xyz;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Aspect;<br><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NotVeryUsefulAspect</span> &#123;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myAspect&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.xyz.NotVeryUsefulAspect&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- configure properties of the aspect here --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>Aspect 可以是普通的 class，只是里面可以有 advice、pointcut 和 introduction。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 直接声明切点，方法签名都是 void，这个声明要要被引用，直接用名称 anyOldTransfer - 用一个方法来设计切点变量是一种设计思想</span><br><span class="hljs-meta">@Pointcut(&quot;execution(* transfer(..))&quot;)</span> <span class="hljs-comment">// the pointcut expression</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">anyOldTransfer</span><span class="hljs-params">()</span> &#123;&#125; <span class="hljs-comment">// the pointcut signature</span><br><br><span class="hljs-comment">// 切点里加上 advice</span><br><span class="hljs-meta">@Around(&quot;execution(public * package..*.*(..))&quot;)</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">around</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> <span class="hljs-keyword">throws</span> Throwable &#123;&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;anyDaoMethod&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;@target(org.springframework.stereotype.Repository)&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>Spring AOP （proxy-based）的切点里 this 总是指代理，而 target 指的是被代理对象；AOP （type-based）里都指代理和被代理对象。</p>
<p>Spring AOP 里的 join point 专指 method execution，其他 AOP 框架不只是拦截方法执行。</p>
<h3 id="详解-pointcut">详解 pointcut</h3>
<p>切点有自己的 PCD（pointcut designators ），来自于  pointcut expressions（主要来自于 AspectJ），完整的表达式语法见<a target="_blank" rel="noopener" href="https://www.eclipse.org/aspectj/doc/released/progguide/semantics-pointcuts.html">《Appendix B. Language Semantics》</a>和<a target="_blank" rel="noopener" href="https://www.eclipse.org/aspectj/doc/next/progguide/printable.html#quick-pointcuts">《quick-pointcuts》</a>：</p>
<ul>
<li>execution: For matching method execution join points. This is the primary pointcut designator to use when working with Spring AOP. 方法执行连接点，这是最常用的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Pointcut(&quot;execution(public String com.baeldung.pointcutadvice.dao.FooDao.findById(Long))&quot;)</span><br><span class="hljs-meta">@Pointcut(&quot;execution(* com.baeldung.pointcutadvice.dao.FooDao.*(..))&quot;)</span><br><br><span class="hljs-comment">// 它的语法是：</span><br>execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern)<br>                <span class="hljs-keyword">throws</span>-pattern?)<br></code></pre></td></tr></table></figure>
<ul>
<li>within: Limits matching to join points within certain types (the execution of a method declared <strong>within a matching type</strong> when using Spring AOP) 以只在特定类型里的方法执行作为切点。execution 的阉割版本。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Pointcut(&quot;within(com.baeldung.pointcutadvice.dao.FooDao)&quot;)</span><br><span class="hljs-meta">@Pointcut(&quot;within(com.baeldung..*)&quot;)</span><br></code></pre></td></tr></table></figure>
<ul>
<li>this: Limits matching to join points (the execution of methods when using Spring AOP) where the bean reference (Spring AOP proxy) is an instance of the given type.  这里的 this 是 proxy 的意思，限制 proxy - 当我们使用 JDK dynamic proxy 的时候，推荐使用这个 PCD（并不必然）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FooDao</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BarDao</span> &#123;<br>    ...<br>&#125;<br><br><span class="hljs-comment">// jdk dynamic proxy</span><br><span class="hljs-meta">@Pointcut(&quot;target(com.baeldung.pointcutadvice.dao.BarDao)&quot;)</span><br></code></pre></td></tr></table></figure>
<ul>
<li>target: Limits matching to join points (the execution of methods when using Spring AOP) where the target object (application object being proxied) is an instance of the given type. 限制目标类型。当我们使用 cglib proxy 的时候，推荐使用这个 PCD（并不必然）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// cglib proxy</span><br><span class="hljs-meta">@Pointcut(&quot;this(com.baeldung.pointcutadvice.dao.FooDao)&quot;)</span><br></code></pre></td></tr></table></figure>
<ul>
<li>args: Limits matching to join points (the execution of methods when using Spring AOP) where the arguments are instances of the given types. 限制参数。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Pointcut(&quot;execution(* *..find*(Long))&quot;)</span><br></code></pre></td></tr></table></figure>
<ul>
<li>@target: Limits matching to join points (the execution of methods when using Spring AOP) where the class of the executing object has an annotation of the given type. 限制 target 有特定注解。<strong>这种切点配合特定的类注解特别有用！但实践中它可能会遇到 RuntimeTestWalker 检测的奇怪问题，这时候要换 @within</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Pointcut(&quot;@target(org.springframework.stereotype.Repository)&quot;)</span><br></code></pre></td></tr></table></figure>
<ul>
<li>@args: Limits matching to join points (the execution of methods when using Spring AOP) where the runtime type of the actual arguments passed have annotations of the given types. 限制参数有特定注解。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//  Suppose that we want to trace all the methods accepting beans annotated with @Entity annotation:</span><br><span class="hljs-meta">@Pointcut(&quot;@args(com.baeldung.pointcutadvice.annotations.Entity)&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodsAcceptingEntities</span><span class="hljs-params">()</span> &#123;&#125;<br><br><span class="hljs-meta">@Before(&quot;methodsAcceptingEntities()&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">logMethodAcceptionEntityAnnotatedBean</span><span class="hljs-params">(JoinPoint jp)</span> &#123;<br>    logger.info(<span class="hljs-string">&quot;Accepting beans with @Entity annotation: &quot;</span> + jp.getArgs()[<span class="hljs-number">0</span>]);<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>@within: Limits matching to join points within types that have the given annotation (the execution of methods declared in types with the given annotation when using Spring AOP). 限制在类型有特定注解。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@Pointcut(&quot;@within(org.springframework.stereotype.Repository)&quot;)</span><br><br><span class="hljs-comment">// 等价于</span><br><br><span class="hljs-meta">@Pointcut(&quot;within(@org.springframework.stereotype.Repository *)&quot;)</span><br></code></pre></td></tr></table></figure>
<ul>
<li>@annotation: Limits matching to join points where the subject of the join point (the method being executed in Spring AOP) has the given annotation. 限制连接点方法有特定注解。<strong>这种切点配合特定的方法注解特别有用，但不能用在类注解上！</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Pointcut(&quot;@annotation(com.baeldung.pointcutadvice.annotations.Loggable)&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loggableMethods</span><span class="hljs-params">()</span> &#123;&#125;<br><br><span class="hljs-meta">@Before(&quot;loggableMethods()&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">logMethod</span><span class="hljs-params">(JoinPoint jp)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> jp.getSignature().getName();<br>    logger.info(<span class="hljs-string">&quot;Executing method: &quot;</span> + methodName);<br>&#125;<br><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Idempotent &#123;<br>    <span class="hljs-comment">// marker annotation</span><br>&#125;<br><br>&lt;aop:pointcut id=<span class="hljs-string">&quot;idempotentOperation&quot;</span><br>        expression=<span class="hljs-string">&quot;execution(* com.xyz.myapp.service.*.*(..)) and</span><br><span class="hljs-string">        @annotation(com.xyz.myapp.service.Idempotent)&quot;</span>/&gt;<br></code></pre></td></tr></table></figure>
<ul>
<li>bean 特定的 bean 名称/名称模式引用的，类似<code> BeanNameAutoProxyCreator</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Pointcut(&quot;bean(tradeService)&quot;)</span><br><span class="hljs-meta">@Pointcut(&quot;bean(*Service)&quot;)</span><br></code></pre></td></tr></table></figure>
<p>更多例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// anyPublicOperation matches if a method execution join point represents the execution of any public method.</span><br><br><span class="hljs-comment">// inTrading matches if a method execution is in the trading module.</span><br><span class="hljs-meta">@Pointcut(&quot;execution(public * *(..))&quot;)</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">anyPublicOperation</span><span class="hljs-params">()</span> &#123;&#125; <br><br><span class="hljs-comment">// tradingOperation matches if a method execution represents any public method in the trading module.</span><br><span class="hljs-meta">@Pointcut(&quot;within(com.xyz.someapp.trading..*)&quot;)</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inTrading</span><span class="hljs-params">()</span> &#123;&#125; <br><br><span class="hljs-meta">@Pointcut(&quot;anyPublicOperation() &amp;&amp; inTrading()&quot;)</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tradingOperation</span><span class="hljs-params">()</span> &#123;&#125; <br><br><span class="hljs-comment">// 按照系统架构进行切点的分类</span><br><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SystemArchitecture</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * A join point is in the web layer if the method is defined</span><br><span class="hljs-comment">     * in a type in the com.xyz.someapp.web package or any sub-package</span><br><span class="hljs-comment">     * under that.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Pointcut(&quot;within(com.xyz.someapp.web..*)&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inWebLayer</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * A join point is in the service layer if the method is defined</span><br><span class="hljs-comment">     * in a type in the com.xyz.someapp.service package or any sub-package</span><br><span class="hljs-comment">     * under that.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Pointcut(&quot;within(com.xyz.someapp.service..*)&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inServiceLayer</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * A join point is in the data access layer if the method is defined</span><br><span class="hljs-comment">     * in a type in the com.xyz.someapp.dao package or any sub-package</span><br><span class="hljs-comment">     * under that.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Pointcut(&quot;within(com.xyz.someapp.dao..*)&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inDataAccessLayer</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * A business service is the execution of any method defined on a service</span><br><span class="hljs-comment">     * interface. This definition assumes that interfaces are placed in the</span><br><span class="hljs-comment">     * &quot;service&quot; package, and that implementation types are in sub-packages.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * If you group service interfaces by functional area (for example,</span><br><span class="hljs-comment">     * in packages com.xyz.someapp.abc.service and com.xyz.someapp.def.service) then</span><br><span class="hljs-comment">     * the pointcut expression &quot;execution(* com.xyz.someapp..service.*.*(..))&quot;</span><br><span class="hljs-comment">     * could be used instead.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * Alternatively, you can write the expression using the &#x27;bean&#x27;</span><br><span class="hljs-comment">     * PCD, like so &quot;bean(*Service)&quot;. (This assumes that you have</span><br><span class="hljs-comment">     * named your Spring service beans in a consistent fashion.)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Pointcut(&quot;execution(* com.xyz.someapp..service.*.*(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">businessService</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * A data access operation is the execution of any method defined on a</span><br><span class="hljs-comment">     * dao interface. This definition assumes that interfaces are placed in the</span><br><span class="hljs-comment">     * &quot;dao&quot; package, and that implementation types are in sub-packages.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Pointcut(&quot;execution(* com.xyz.someapp.dao.*.*(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dataAccessOperation</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-comment">// The execution of any public method:</span><br>    execution(<span class="hljs-keyword">public</span> * *(..))<br>    <br>    <span class="hljs-comment">// The execution of any method with a name that begins with set:</span><br>    execution(* set*(..))<br>    <br>    <span class="hljs-comment">// The execution of any method defined by the AccountService interface:</span><br>    execution(* com.xyz.service.AccountService.*(..))<br>    <br>    <span class="hljs-comment">// The execution of any method defined in the service package:</span><br>    execution(* com.xyz.service.*.*(..))<br>    <br>    <span class="hljs-comment">// The execution of any method defined in the service package or one of its sub-packages:</span><br>    execution(* com.xyz.service..*.*(..))<br>    <br>    <span class="hljs-comment">// Any join point (method execution only in Spring AOP) within the service package:</span><br>    within(com.xyz.service.*)<br><br>    <span class="hljs-comment">// Any join point (method execution only in Spring AOP) within the service package or one of its sub-packages:</span><br>    within(com.xyz.service..*)<br>    <br>    <span class="hljs-comment">// Any join point (method execution only in Spring AOP) where the proxy implements the AccountService interface:</span><br>    <span class="hljs-built_in">this</span>(com.xyz.service.AccountService)<br>    <br>    <span class="hljs-comment">// Any join point (method execution only in Spring AOP) where the target object implements the AccountService interface:</span><br>    target(com.xyz.service.AccountService)<br>    <br>    <span class="hljs-comment">// Any join point (method execution only in Spring AOP) that takes a single parameter and where the argument passed at runtime is Serializable:</span><br>    args(java.io.Serializable)<br><br>    <span class="hljs-comment">// Any join point (method execution only in Spring AOP) where the target object has a @Transactional annotation:</span><br>    <span class="hljs-meta">@target(org.springframework.transaction.annotation.Transactional)</span><br>You can also use <span class="hljs-string">&#x27;@target&#x27;</span> in a binding form. See the Declaring Advice section <span class="hljs-keyword">for</span> how to make the annotation object available in the advice body.<br>Any join <span class="hljs-title function_">point</span> <span class="hljs-params">(method execution only in Spring AOP)</span> where the declared type of the target object has an <span class="hljs-meta">@Transactional</span> annotation:<br><br>    <span class="hljs-meta">@within(org.springframework.transaction.annotation.Transactional)</span><br>You can also use <span class="hljs-string">&#x27;@within&#x27;</span> in a binding form. See the Declaring Advice section <span class="hljs-keyword">for</span> how to make the annotation object available in the advice body.<br>Any join <span class="hljs-title function_">point</span> <span class="hljs-params">(method execution only in Spring AOP)</span> where the executing method has an <span class="hljs-meta">@Transactional</span> annotation:<br><br>    <span class="hljs-meta">@annotation(org.springframework.transaction.annotation.Transactional)</span><br>You can also use <span class="hljs-string">&#x27;@annotation&#x27;</span> in a binding form. See the Declaring Advice section <span class="hljs-keyword">for</span> how to make the annotation object available in the advice body.<br>Any join <span class="hljs-title function_">point</span> <span class="hljs-params">(method execution only in Spring AOP)</span> which takes a single parameter, and where the runtime type of the argument passed has the <span class="hljs-meta">@Classified</span> annotation:<br><br>    <span class="hljs-meta">@args(com.xyz.security.Classified)</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>切点表达式会在编译时被优化，被重写成 DNF 范式形式，并且会被重排序，以提升性能。</p>
<p>注意，可以混合使用任何地方定义的切点：<strong>Java config 里的 bean 可以引用 xml 里定义的切点；反过来也可以</strong>。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span></span><br><span class="hljs-tag">        <span class="hljs-attr">pointcut</span>=<span class="hljs-string">&quot;com.xyz.someapp.SystemArchitecture.businessService()&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;tx-advice&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;tx-advice&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:attributes</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tx:advice</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>切点表达式分为三类：</p>
<ul>
<li>
<p>Kinded designators select a particular kind of join point: execution, get, set, call, and handler.</p>
</li>
<li>
<p>Scoping designators select a group of join points of interest (probably of many kinds): within and withincode</p>
</li>
<li>
<p>Contextual designators match (and optionally bind) based on context: this, target, and @annotation</p>
</li>
</ul>
<p>好的切点应该使用两种以上的表达式，性能才好，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">within(com.bigboxco..*) &amp;&amp; execution(<span class="hljs-keyword">public</span> * *(..))<br></code></pre></td></tr></table></figure>
<p>其中 Combination 的内容见：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">! Pointcut  every <span class="hljs-keyword">join</span> <span class="hljs-type">point</span> <span class="hljs-keyword">not</span> picked <span class="hljs-keyword">out</span> <span class="hljs-keyword">by</span> Pointcut<br>Pointcut0 &amp;&amp; Pointcut1  <span class="hljs-keyword">each</span> <span class="hljs-keyword">join</span> <span class="hljs-type">point</span> picked <span class="hljs-keyword">out</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">both</span> Pointcut0 <span class="hljs-keyword">and</span> Pointcut1<br>Pointcut0 || Pointcut1  <span class="hljs-keyword">each</span> <span class="hljs-keyword">join</span> <span class="hljs-type">point</span> picked <span class="hljs-keyword">out</span> <span class="hljs-keyword">by</span> either Pointcut0 <span class="hljs-keyword">or</span> Pointcut1<br>( Pointcut )    <span class="hljs-keyword">each</span> <span class="hljs-keyword">join</span> <span class="hljs-type">point</span> picked <span class="hljs-keyword">out</span> <span class="hljs-keyword">by</span> Pointcut<br></code></pre></td></tr></table></figure>
<p>而不是 and 与 or。</p>
<p>一个复杂例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> String <span class="hljs-title function_">getMonitoredBeanPointCut</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;(@annotation(clues.aop.annotation.TelemetryMonitor) || within(com.magicliang..*) &quot;</span><br>            + <span class="hljs-string">&quot;|| within(pulsar..*) || within(abc.infra.monitor..*) || within(abc.api..*) || within (clues..*)&quot;</span><br>            + <span class="hljs-string">&quot; || within(producer..*) || within(bm..*) ||&quot;</span><br>            + <span class="hljs-string">&quot; within(cloud..*) || within(tmc..*) || within(zy..*)) &amp;&amp; !within(*Spring..*) &amp;&amp; &quot;</span><br>            + <span class="hljs-string">&quot; !within(clues.aop..*) &amp;&amp; !within(*..clues.system..*) &amp;&amp; !within(clues.services.wechat.work&quot;</span><br>            + <span class="hljs-string">&quot;.externalcontact.CallBackManager) &amp;&amp; !within(*..*Application..*) &amp;&amp; !execution(* *..run(..)) &amp;&amp;&quot;</span><br>            + <span class="hljs-string">&quot; !within(is(FinalType)) &amp;&amp; !within(com.magicliang.clues.web.filter.ControllerLogFilter)&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="详解-advice">详解 advice</h3>
<p><img src="aop%E7%9A%84advice%E7%9A%845%E7%A7%8D%E7%8E%AF%E7%BB%95%E6%96%B9%E5%BC%8F.png" alt="aop的advice的5种环绕方式"></p>
<h4 id="advice-的类型">advice 的类型</h4>
<p>Advice 可以分为：</p>
<ul>
<li>before 申请资源适合放在这里</li>
<li>After returning</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Aspect;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.AfterReturning;<br><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AfterReturningExample</span> &#123;<br>    <span class="hljs-meta">@AfterReturning(</span><br><span class="hljs-meta">        pointcut=&quot;com.xyz.myapp.SystemArchitecture.dataAccessOperation()&quot;,</span><br><span class="hljs-meta">        // 注意名字必须完全匹配形参</span><br><span class="hljs-meta">        returning=&quot;retVal&quot;)</span><br>            <span class="hljs-comment">// 使用返回值的 after 例子，注意这个 object 参数，这里不可能泛型化</span><br>        <span class="hljs-comment">// 这里如果限制返回值类型，后果自负，spring 本身是 fully typed 类型匹配的，有好处也有坏处</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAccessCheck</span><span class="hljs-params">(Object retVal)</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>After throwing（不怎么常见，但 Spring MVC 的 Controller Advice 就是这样实现的）。PCD 里是不包含对于 exception 的定位的，只能通过 PCD 里定位方法，然后使用这个 advice。这是 Spring 对异常处理的唯一设计。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AfterThrowingExample</span> &#123;<br><br>    <span class="hljs-meta">@AfterThrowing(</span><br><span class="hljs-meta">        pointcut=&quot;com.xyz.myapp.SystemArchitecture.dataAccessOperation()&quot;,</span><br><span class="hljs-meta">        // 注意名字必须完全匹配形参</span><br><span class="hljs-meta">        throwing=&quot;ex&quot;)</span><br>        <span class="hljs-comment">// 这里可以限制异常类型，后果自负</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doRecoveryActions</span><span class="hljs-params">(DataAccessException ex)</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>After (finally) advice = returning + throwing，隐式包含 finally。释放资源适合放在这里。</li>
<li>around（大部分的 advice 都可以这样用，因为它兼容 before、after（实际上囊括了上面所有的 advice）， 而且管控范围最广）适合申请资源、释放资源、权限管理、日志，它因为是栈封闭的，所以是在方法执行前后，线程安全地共享状态（ share state before and after a method execution in a thread-safe manner） - timer 的合理方式。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 注意，这里的参数名指的是 advice 里的参数名，而不是原始被拦截方法的参数名-也不适合理解原始参数名</span><br><br><span class="hljs-comment">// 使用命名参数的正统方式。被拦截的方法，必须至少有一个参数，且第一个参数要被转化为 Account 类型传递给 Advice。</span><br><span class="hljs-meta">@Before(&quot;com.xyz.myapp.SystemArchitecture.dataAccessOperation() &amp;&amp; args(account,..)&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">validateAccount</span><span class="hljs-params">(Account account)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 理解注解的正统方式</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-comment">// 注意严格限定注解的使用类型</span><br><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Auditable &#123;<br>    AuditCode <span class="hljs-title function_">value</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-meta">@Before(&quot;com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; @annotation(auditable)&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">audit</span><span class="hljs-params">(Auditable auditable)</span> &#123;<br>    <span class="hljs-type">AuditCode</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> auditable.value();<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 处理泛型</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Sample</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sampleGenericMethod</span><span class="hljs-params">(T param)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sampleGenericCollectionMethod</span><span class="hljs-params">(Collection&lt;T&gt; param)</span>;<br>&#125;<br><br><span class="hljs-comment">// 这里 MyType 就是 type parameter，实例化了 T</span><br><span class="hljs-meta">@Before(&quot;execution(* ..Sample+.sampleGenericMethod(*)) &amp;&amp; args(param)&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeSampleMethod</span><span class="hljs-params">(MyType param)</span> &#123;<br>    <span class="hljs-comment">// Advice implementation</span><br>&#125;<br><br><span class="hljs-comment">// Collection&lt;MyType&gt; 不会生效的。Collection&lt;?&gt;能够保证整个 Collection 里只有一个类型，这样我们只要 check 一个元素就能知道整个集合的 type。</span><br><span class="hljs-meta">@Before(&quot;execution(* ..Sample+.sampleGenericCollectionMethod(*)) &amp;&amp; args(param)&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeSampleMethod</span><span class="hljs-params">(Collection&lt;?&gt; param)</span> &#123;<br>    <span class="hljs-comment">// Advice implementation</span><br>&#125;<br><br><br><span class="hljs-comment">// 使用 argName 的 attribute 来指定实际的 advice 参数的名称和顺序</span><br><span class="hljs-meta">@Before(value=&quot;com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; target(bean) &amp;&amp; @annotation(auditable)&quot;,</span><br><span class="hljs-meta">        argNames=&quot;bean,auditable&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">audit</span><span class="hljs-params">(Object bean, Auditable auditable)</span> &#123;<br>    <span class="hljs-type">AuditCode</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> auditable.value();<br>    <span class="hljs-comment">// ... use code and bean</span><br>&#125;<br><br><span class="hljs-comment">// 如果要强行指定切点的类型，则只能使用 ProceedingJoinPoint，不能用 argNames</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AspectJAnnotationArgsBrowserAroundAdvice</span> &#123;<br><br>    <span class="hljs-meta">@Pointcut(&quot;execution(* com.lcifn.spring.aop.bean.ChromeBrowser.*(String,java.util.Date+,..))&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pointcut</span><span class="hljs-params">()</span>&#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-meta">@Around(value=&quot;pointcut()&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">aroundIntercept</span><span class="hljs-params">(ProceedingJoinPoint pjp)</span> <span class="hljs-keyword">throws</span> Throwable&#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">retVal</span> <span class="hljs-operator">=</span> pjp.proceed();<br>        <span class="hljs-keyword">return</span> retVal;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果要使用 args 和 argName 配合，则不能指定切点的类型。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 注意 pointcut 和 around 都可以指定参数名称，而且必须一一匹配，否则 Spring 会出错--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span> <span class="hljs-attr">proxy-target-class</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pointcut&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.lcifn.spring.aop.bean.*.*(..)) &amp;&amp; args(str,date,..)&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;advice&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:around</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;aroundIntercept&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;pointcut&quot;</span> <span class="hljs-attr">arg-names</span>=<span class="hljs-string">&quot;str,date&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><strong>通常意义上的 Advice 被建模为 interceptor（所以 Advice 的实现是一个方法，映射到 Spring 的内部不是一个方法，而是一个类型，因为一个MethodInterceptor 只有一个 invoke 点</strong>）。围绕着 Join point 串起来一系列 interceptor（aspect 对 advised object 可以多对一，但彼此之间并不能相互 advised）。</p>
<p>我们通常会使用 around，但 Spring 推荐尽量用 less powerful 的 advice 以避免出错。</p>
<h4 id="advice-的优先级">advice 的优先级</h4>
<p>有最高优先级的 advice 在 advice 嵌套的最外层，before 最先执行而 after 最后执行。</p>
<p>可以通过实现 org.springframework.core.Ordered 或者使用 Order 注解给 Aspect - advice 的优先级跟着 aspect 的优先级走。</p>
<h3 id="详解-introduction">详解 introduction</h3>
<p>对于 this proxy 而言，introduction 引入了混型（mixin）；而对于调用者而言，这个新的 proxy 实际上是个 adapter。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UsageTracking</span> &#123;<br>    <br>    <span class="hljs-comment">// 解耦设计 1：符合这个 pattern 的 target types expression（注意不是 bean 的 interface），都会被默认实现这个接口 UsageTracked，且带有一个默认实现 DefaultUsageTracked。</span><br>    <span class="hljs-meta">@DeclareParents(value=&quot;com.xzy.myapp.service.*+&quot;, defaultImpl=DefaultUsageTracked.class)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> UsageTracked mixin;<br><br>    <span class="hljs-comment">// 解耦设计 2：凡是 proxy 本身带有这个接口 usageTracked 实现，则进行调用。而且这里把 usageTracked 赋值成一个方法参数</span><br>    <span class="hljs-meta">@Before(&quot;com.xyz.myapp.SystemArchitecture.businessService() &amp;&amp; this(usageTracked)&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recordUsage</span><span class="hljs-params">(UsageTracked usageTracked)</span> &#123;<br>        usageTracked.incrementUseCount();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 解耦设计 3：直接用 context getBean</span><br><span class="hljs-type">UsageTracked</span> <span class="hljs-variable">usageTracked</span> <span class="hljs-operator">=</span> (UsageTracked) context.getBean(<span class="hljs-string">&quot;myService&quot;</span>);<br></code></pre></td></tr></table></figure>
<p>这个功能在 Spring 内部实际上非常悠久，在 2003 年开发的代码里，就留有 IntroductionAdvisor 的痕迹了。</p>
<h3 id="高级主题-aop-其他-初始化模型">高级主题 - AOP （其他）初始化模型</h3>
<p>缺省的情况下，全局只有一个单例 aspect， AOP 把它称作“singleton instantiation model”。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect(&quot;perthis(com.xyz.myapp.SystemArchitecture.businessService())&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAspect</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> someState;<br><br>    <span class="hljs-meta">@Before(com.xyz.myapp.SystemArchitecture.businessService())</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recordServiceUsage</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这样的设计允许某些局部状态被限定起来，不再是全局共享。现实中并不太实用 - TransactionInterceptor 本身管理复杂的事务和连接，它却是靠 threadlocal 实现的，并没有依靠多个拦截器。</p>
<h2 id="激活-schema-based-approach">激活 schema-based approach</h2>
<p>解析 xml 标签的模式，被 Spring 称为 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#aop-schema">schema-based approach</a> 。</p>
<p>这种解决方案的表达能力不如基于注解的表达能力强（<strong>有些切点表达式可以用注解表达，无法用 xml 表达</strong>，，比如 xml 可以表达 id pointcut，却无法表达由 named pointcut 组成的 composited pointcut）。</p>
<p>它基于<strong>新增加</strong>的 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#xsd-schemas-aop">aop schema</a>，需要使用的时候引入一个 schema：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">        // <span class="hljs-attr">一定要使用这个</span> <span class="hljs-attr">xmlns</span></span><br><span class="hljs-tag">        <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;</span></span><br><span class="hljs-string"><span class="hljs-tag">        http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">        http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- 可以存在多个 &lt;aop:config/&gt; --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 可以放 pointcut、aspect 和 advisor --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myAspect&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;aBean&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;businessService&quot;</span></span><br><span class="hljs-tag">                          <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.xyz.myapp.service.*.*(..))&quot;</span>/&gt;</span><br>            <span class="hljs-comment">&lt;!-- 这个类里有好几个 pointcut 表达式 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;businessService&quot;</span></span><br><span class="hljs-tag">                          <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;com.xyz.myapp.SystemArchitecture.businessService()&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myAspect&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;aBean&quot;</span>&gt;</span><br>                    <span class="hljs-comment">&lt;!-- 在标记语言里面慎用 &amp;&amp; --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;businessService&quot;</span></span><br><span class="hljs-tag">                  <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.xyz.myapp.service.*.*(..)) &amp;&amp; this(service)&quot;</span>/&gt;</span><br>            <span class="hljs-comment">&lt;!-- before advice pointcut 的 service 参数会赋给 monitor --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">aop:before</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;businessService&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;monitor&quot;</span>/&gt;</span><br>            <span class="hljs-comment">&lt;!-- 指定返回参数 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">aop:after-returning</span></span><br><span class="hljs-tag">                <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;dataAccessOperation&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">returning</span>=<span class="hljs-string">&quot;retVal&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;doAccessCheck&quot;</span>/&gt;</span><br><br>            <span class="hljs-comment">&lt;!-- 指定抛出异常 绑定参数 throwing=&quot;dataAccessEx&quot; --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">aop:after-throwing</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;dataAccessOperation&quot;</span></span><br><span class="hljs-tag">                        <span class="hljs-attr">throwing</span>=<span class="hljs-string">&quot;dataAccessEx&quot;</span></span><br><span class="hljs-tag">                        <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;doRecoveryActions&quot;</span>/&gt;</span><br><br>            <span class="hljs-comment">&lt;!-- 无参数的 after --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">aop:after</span></span><br><span class="hljs-tag">                <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;dataAccessOperation&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;doReleaseLock&quot;</span>/&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- introduction 的 xml 版本 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;usageTrackerAspect&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;usageTracking&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">aop:declare-parents</span></span><br><span class="hljs-tag">                <span class="hljs-attr">types-matching</span>=<span class="hljs-string">&quot;com.xzy.myapp.service.*+&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">implement-interface</span>=<span class="hljs-string">&quot;com.xyz.myapp.service.tracking.UsageTracked&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">default-impl</span>=<span class="hljs-string">&quot;com.xyz.myapp.service.tracking.DefaultUsageTracked&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">aop:before</span></span><br><span class="hljs-tag">                <span class="hljs-attr">pointcut</span>=<span class="hljs-string">&quot;com.xyz.myapp.SystemArchitecture.businessService() &amp;&amp;  this(usageTracked)&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;recordUsage&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;aBean&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>注意：<strong>这个<code>&lt;aop:config/&gt;</code>依赖于<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#aop-autoproxy">auto-proxying</a>机制，因而与<code>AutoProxyCreator</code>如<code>BeanNameAutoProxyCreator</code>是相互冲突的</strong>，所以两者不要混用，使用了<code>aop:config</code>类 xml 配置，<strong>则不要使用 BeanNameAutoProxyCreator 等 xml 配置，虽然后者也是一种 xml 配置</strong>-与 Mixing Aspect Types 的观点稍微有点冲突。换言之，<code>&lt;aop:config/&gt;</code>与<code>&lt;bean class=&quot;org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator&quot;&gt;</code>或者手动创建的<code>DefaultAdvisorAutoProxyCreator</code>互斥。从优先级来讲，恐怕<code>&lt;aop:config/&gt;</code> 更适合大多数场景。</p>
<p>何谓 auto-proxy？<code>Spring also lets us use “auto-proxy” bean definitions, which can automatically proxy selected bean definitions. This is built on Spring’s “bean post processor” infrastructure, which enables modification of any bean definition as the container loads.</code>大意是用一些 bean definition 的配置（比如 xml 里的配置），触发 BeanPostProcessor 来做 auto proxing。 所有的 BeanPostProcessor 都 not eligible for auto-proxying。<code>By auto-proxying, we mean that, if Spring determines that a bean is advised by one or more aspects, it automatically generates a proxy for that bean to intercept method invocations and ensures that advice is run as needed.</code></p>
<p>另外，被 @Aspect 注解标注的类，也是不会被代理的：<code>Advising aspects with other aspects? In Spring AOP, aspects themselves cannot be the targets of advice from other aspects. The @Aspect annotation on a class marks it as an aspect and, hence, excludes it from auto-proxying.</code></p>
<h3 id="advisor">Advisor</h3>
<p>Advisor 是 Spring 特定的概念，AspectJ 里没有。</p>
<p>Advisor 是一个自包含的 aspect，只包含一个 advice - 类似 Java8 引入的函数式接口，而且它本身是一个平凡的 bean（废话），必须实现以 Spring 的官定 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#aop-api-advice-types">advice interface</a>。advisor 适用于内部的 advice，普通的 advice 应该使用 aspect。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;businessService&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.xyz.myapp.service.*.*(..))&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!-- 事务 advisor 引用事务 advice --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span></span><br><span class="hljs-tag">        <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;businessService&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;tx-advice&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 事务 advice，注意，它的解析类是 TxAdviceBeanDefinitionParser，实际上它引出的 advice 是一个 TransactionInterceptor，是 MethodInterceptor 的一种。也就是 aop 的拦截器规范。--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;tx-advice&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:attributes</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tx:advice</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- cache definitions --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">cache:advice</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cacheAdvice&quot;</span> <span class="hljs-attr">cache-manager</span>=<span class="hljs-string">&quot;cacheManager&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">cache:caching</span> <span class="hljs-attr">cache</span>=<span class="hljs-string">&quot;books&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">cache:cacheable</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;findBook&quot;</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;#isbn&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">cache:cache-evict</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;loadBooks&quot;</span> <span class="hljs-attr">all-entries</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">cache:caching</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">cache:advice</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 缓存 advisor --&gt;</span><br><span class="hljs-comment">&lt;!-- apply the cacheable behaviour to all BookService interfaces --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;cacheAdvice&quot;</span> <span class="hljs-attr">pointcut</span>=<span class="hljs-string">&quot;execution(* x.y.BookService.*(..))&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h2 id="到底应该使用哪种-aop？">到底应该使用哪种 AOP？</h2>
<p>pure Spring AOP or AspectJ AOP</p>
<p>AspectJ 实际上包含了 compiler （编译时增强）和 weaver（LTW，需要引用 <code>-javaagent</code>），不如 Spring AOP 开箱即用。<br>
根据 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#aop-spring-or-aspectj">Spring 文档</a>：</p>
<ol>
<li>只做 container managed bean interception 可以只用 Spring AOP，否则考虑 AspectJ AOP（如某些领域对象，我想这里指的是 JPA 取出的 entity）。</li>
<li>如果只做 method interception，可以只用 Spring AOP，否则考虑 AspectJ AOP（如 field set 和 get）- <strong>这决定了实际上这种 aspect 的增强比 proxied-based 的方案强，self-invocation 依然可以被拦截</strong>。</li>
<li>当场景里需要大量使用 Aspect + 拥有 Eclipse AJDT 插件的时候，使用 AspectJ language syntax （code style）；否则使用 AspectJ 的注解（比如Aspect 很少）。</li>
</ol>
<h2 id="使用-xml-或是-aspectj-注解">使用 xml 或是 @AspectJ 注解</h2>
<ul>
<li>xml 的优点是：</li>
<li>它可以独立变化（不同的人对这一点持不同看法），所以比系统里的切面配置更清晰。</li>
<li>xml 的缺点是：</li>
<li>它违反 DRY 原则，造成了重复；</li>
<li>它表达能力有限：它只有 singleton instantiation model；它不能表达 composite pointcut；</li>
</ul>
<h2 id="问题大辨析">问题大辨析</h2>
<p>使用哪种 AOP 和使用哪种代理和使用 xml 还是注解进行代理，是<strong>三个问题</strong>：</p>
<p>但 AspectJ 提出了 Aspect 的概念，拦截逻辑会被装入 Aspect 里。这要求：首先我们在 Java 代码里显式地写入了 Aspect，其次我们的配置不管是使用 xml （<code>&lt;aop:aspectj-autoproxy/&gt;</code>）还是注解（这被专门狭义地称作 AspectJ Style，这种 sytle 特指使用了 annotation 的方案），激活了 AspectJ 风格的注解，我们就可以通过 Aspect 来声明待装配的 AOP 逻辑。</p>
<p>否则我们可能需要采用传统的方法-不管声明方法声明一个 MethodInterceptor，想办法把它注入 Spring 的 bean factory 管理的 bean 体系里（见下面的对应关系）。经典的 MethodInterceptor 是 aop 联盟提出的概念（还有第二种 MethodInterceptor，见下面的对应关系），与之相对的是 Java 原生的 InvocationHandler。</p>
<p>所有问题的对应关系：</p>
<ol>
<li>pure Spring AOP 对应的是 AspectJ AOP，前者只能通过多态实现 method interception，后者可以实现 private method interception、field interception。AOP 的 Aspect 还有一个额外的牛逼之处在于，它可以提供非运行时的代理，这个问题可以往下看。</li>
<li>JdkProxy 对应 CglibProxy，关键配置是<code>proxy-target-class</code>。不管使用 CglibProxy 还是 JdkProxy， 都是把拦截逻辑放在 Advisor/MethodInterceptor 组成的逻辑链条里的。</li>
<li>schema-based 指的是基于 xml 的配置，所有<code>&lt;aop:config proxy-target-class/&gt;</code> <code>&lt;aop:aspectj-autoproxy/&gt;</code>类型的配置，都是 schema-based 的方案。和是不是用 gglib、是不是 aspectJ auto-proxying 都无关。</li>
<li>普通的 proxy factory 的增强通过 addAdvice 来实现（advice 是一个抽象概念，底层可能是个 InvocationHandler（Jdk 原生概念），也可能是 MethodInterceptor），aspectJ 的 proxy factory 通过 addAspect 来实现增强。</li>
<li>Spring 里有两种 MethodInterceptor，一种 aop alliance 定义的类型，一种是 cglibCallback 的子类型。</li>
<li><code>aop:aspectj-autoproxy</code>、<code>proxy-target-class</code>、<code>expose-proxy</code>是三大配置。</li>
</ol>
<h1>代理机制</h1>
<h2 id="手动调用代理工厂">手动调用代理工厂</h2>
<p>提供 JdkDynamicAopProxy 和 cglib 的 proxy 之外的统一抽象。</p>
<p><img src="aop-proxy-call.png" alt="aop-proxy-call.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ProxyFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProxyFactory</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SimplePojo</span>());<br>        factory.addInterface(Pojo.class);<br>        factory.addAdvice(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RetryAdvice</span>());<br>        <br>        <span class="hljs-comment">// 即使指定了 proxy-target-class，此处也可以得到一个 interface 的 proxy</span><br>        <span class="hljs-type">Pojo</span> <span class="hljs-variable">pojo</span> <span class="hljs-operator">=</span> (Pojo) factory.getProxy();<br>        <span class="hljs-comment">// this is a method call on the proxy!</span><br>        pojo.foo();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>从外部调用 proxy，会调到 advice。self-invocation （大多数情况下）不会-因为，<code>Finally, it must be noted that AspectJ does not have this self-invocation issue because it is not a proxy-based AOP framework</code>，AspectJ 还是很强大的。但我们几乎不会用到 AspectJ 的 compiler 或者 weaver，所以我们熟知的都是 pure Spring AOP proxy，仍然满足“self-invocation 不会调到 advice”这一定律。</p>
<h2 id="如何在被代理的-bean-里调用-proxy">如何在被代理的 bean 里调用 proxy</h2>
<ol>
<li>要求暴露了代理，如<code>&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot; expose-proxy=&quot;true&quot;/&gt;</code>或者 <code>@EnableAspectJAutoProxy(exposeProxy=true)</code>或者<code>&lt;aop:config proxy-target-class=&quot;true&quot; expose-proxy=&quot;true&quot;&gt;</code>或者<code>        factory.setExposeProxy(true)</code>。</li>
<li>使用<code>AopContext</code>：<code>((Service) AopContext.currentProxy()).callMethodB();</code>这里的callMethodB 是一个需要被代理增强的方法。这样做是不好的，因为这个类感知到了它正在被 proxied，而且直接耦合 Spring API。</li>
</ol>
<p>它基于一段命名线程局部对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AopContext</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * ThreadLocal holder for AOP proxy associated with this thread.</span><br><span class="hljs-comment">     * Will contain &#123;<span class="hljs-doctag">@code</span> null&#125; unless the &quot;exposeProxy&quot; property on</span><br><span class="hljs-comment">     * the controlling proxy configuration has been set to &quot;true&quot;.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> ProxyConfig#setExposeProxy</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;Object&gt; currentProxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NamedThreadLocal</span>&lt;&gt;(<span class="hljs-string">&quot;Current AOP proxy&quot;</span>);<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">AopContext</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Try to return the current AOP proxy. This method is usable only if the</span><br><span class="hljs-comment">     * calling method has been invoked via AOP, and the AOP framework has been set</span><br><span class="hljs-comment">     * to expose proxies. Otherwise, this method will throw an IllegalStateException.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the current AOP proxy (never returns &#123;<span class="hljs-doctag">@code</span> null&#125;)</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IllegalStateException if the proxy cannot be found, because the</span><br><span class="hljs-comment">     * method was invoked outside an AOP invocation context, or because the</span><br><span class="hljs-comment">     * AOP framework has not been configured to expose the proxy</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">currentProxy</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IllegalStateException &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> currentProxy.get();<br>        <span class="hljs-keyword">if</span> (proxy == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<br>                    <span class="hljs-string">&quot;Cannot find current proxy: Set &#x27;exposeProxy&#x27; property on Advised to &#x27;true&#x27; to make it available.&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> proxy;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Make the given proxy available via the &#123;<span class="hljs-doctag">@code</span> currentProxy()&#125; method.</span><br><span class="hljs-comment">     * &lt;p&gt;Note that the caller should be careful to keep the old value as appropriate.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> proxy the proxy to expose (or &#123;<span class="hljs-doctag">@code</span> null&#125; to reset it)</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the old proxy, which may be &#123;<span class="hljs-doctag">@code</span> null&#125; if none was bound</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> #currentProxy()</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Nullable</span><br>    <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">setCurrentProxy</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Object proxy)</span> &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">old</span> <span class="hljs-operator">=</span> currentProxy.get();<br>        <span class="hljs-keyword">if</span> (proxy != <span class="hljs-literal">null</span>) &#123;<br>            currentProxy.set(proxy);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            currentProxy.remove();<br>        &#125;<br>        <span class="hljs-keyword">return</span> old;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="aspectj-代理的创建方法">@AspectJ 代理的创建方法</h2>
<p>注意，这里产生的还是 proxy，适用于注解 bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// create a factory that can generate a proxy for the given target object</span><br><span class="hljs-type">AspectJProxyFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AspectJProxyFactory</span>(targetObject);<br><br><span class="hljs-comment">// add an aspect, the class must be an @AspectJ aspect</span><br><span class="hljs-comment">// you can call this as many times as you need with different aspects</span><br><span class="hljs-comment">// 这里增强用的就是 Aspect 了</span><br>factory.addAspect(SecurityManager.class);<br><br><span class="hljs-comment">// you can also add existing aspect instances, the type of the object supplied must be an @AspectJ aspect</span><br>factory.addAspect(usageTracker);<br><br><span class="hljs-comment">// now get the proxy object...</span><br><span class="hljs-type">MyInterfaceType</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> factory.getProxy();<br></code></pre></td></tr></table></figure>
<h1>使用真正的 AspectJ</h1>
<p>AspectJ Style aop 仍然使用 Spring 内部的机制，只是使用了 Aspect 等 AspectJ 风格的注解，<strong>真正的 AspectJ</strong>指的是用 AspectJ 的类库里的基础设施形成 aop。</p>
<p>ApsectJ 提供一个 compiler 和一个 weaver，可以实现 compile-time weaving、Post-compile weaving 和 load-time weaving - 所以一共有三种织入 aspect 的方法，pure java framework（Java 动态代理 + cglib 代理）都是 runtime，AspectJ 则是更前置的语言特性。Spring 交付一个专门的库<code>spring-aspects.jar</code>来提供以上功能。</p>
<p>通常编译期的织入，由一个特定的 compiler 来实现。可以由 <a target="_blank" rel="noopener" href="https://www.eclipse.org/aspectj/doc/released/devguide/antTasks.html">ant tasks</a> 来实现，基于 ajc。对性能的影响。</p>
<p>load-time 的织入则依赖于 LTW 机制。对性能的影响比 pure java aop 小（<strong>和 Java agent 比如何？</strong>）。有一派观点认为，Jdk dynamic proxy 在调用的时候使用反射来调到 invocationHandler，所以性能比 cglib 基于 ASM 生成的子类要差。</p>
<h2 id="使用-aspectj-来进行领域对象的依赖注入-dependency-injection">使用 AspectJ 来进行领域对象的依赖注入（Dependency Injection）</h2>
<p>所谓的领域对象，指的是 new 出来的、orm 框架创建出来的-带有 id 的对象，符合 ddd 里对 domain entity 的定义。</p>
<p>但我们可以使用 AspectJ，让被 new 出来的对象，也被 config。在 Spring 里，有一类类型如果被标记为<code>@Configurable</code>的，Spring 就会改写它的行为，使他隐式地成为一个 bean。这种支持是用在“容器控制之外的对象”上的，实际上建立了一种 “AspectJ 控制的对象”。</p>
<p>AspectJ在类加载时，将AnnotationBeanConfigurerAspect切面将织入到（weaving）标注有@Configurable注解的类中。</p>
<p>AnnotationBeanConfigurerAspect将这些类和Spring IoC容器进行了关联，AnnotationBeanConfigurerAspect本身实现了BeanFactoryAware的接口。</p>
<p>实际上，大量的单元测试的 mock 对象，如果这种注入不生效，手动地注入 stub 和 skeleton 也是可以生效的。</p>
<p>AnnotationBeanConfigurerAspect 是一个单例切面，每一个类加载器拥有一个单例。</p>
<ul>
<li>如果在一个类加载器里定义了多个 Spring Context，要考虑清楚在哪个 Context 里配置 @EnableSpringConfigured bean，并放置 spring-aspects.jar。</li>
<li>如果一个父的 spring context 和多个子 spring context （特别是多个 servlet 容器场景下）共用一些基础 service，应该在父 context 里激活 @EnableSpringConfigured 配置，在它的类路径（WEB-INF/）里放置 spring-aspects.jar。</li>
</ul>
<p>一个例子：</p>
<ul>
<li>需要准备的 jar：</li>
<li>spring-core，spring-beans，spring-context，spring-instrument，spring-aspects，aspectjweaver。实际执行的的 LTW 是 spring-context 的<code>InstrumentationLoadTimeWeaver</code></li>
<li>在<code>@Configuration</code>上加上<code>@EnableLoadTimeWeaving</code>和<code>@EnableSpringConfigured</code></li>
<li>运行前（有可能要涉及改动<strong>launch script</strong>）加上-javaagent:/path/to/spring-instrument.jar这个 jvm 参数（如：-javaagent:/Users/magicliang/.m2/repository/org/springframework/spring-instrument/5.2.5.RELEASE/spring-instrument-5.2.5.RELEASE.jar）；理论上还可以加上 aspectjweaver.jar 的路径（例如：-Xset:weaveJavaxPackages=true -javaagent:/Users/magicliang/.m2/repository/org/aspectj/aspectjweaver/1.9.5/aspectjweaver-1.9.5.jar，-Xset 这段可以去掉），但实际上没有尝试成功 work 过。</li>
<li>要让 AnnotationBeanConfigurerAspect 被织入到特定 bean 里面，强行使特定的对象和 Spring 容器被关联起来。</li>
</ul>
<p>待确定用途的功能：</p>
<p>使用自定义的 aspect + 工厂方法 bean：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;profiler&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.xyz.profiler.Profiler&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;aspectOf&quot;</span>&gt;</span> <br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;profilingStrategy&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;jamonProfilingStrategy&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h2 id="上面的例子不成功-这个例子会成功">上面的例子不成功，这个例子会成功</h2>
<p>参考<a target="_blank" rel="noopener" href="https://github.com/dsyer/spring-boot-aspectj">《spring-boot-aspectj》</a></p>
<p>基础的配置：</p>
<p>resources/org/aspectj/aop.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">aspectj</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//AspectJ//DTD//EN&quot;</span> <span class="hljs-string">&quot;https://www.eclipse.org/aspectj/dtd/aspectj.dtd&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 这个文件只能放在类路径下的 META-INF 或者  org/aspectj 文件夹里--&gt;</span><br><span class="hljs-comment">&lt;!-- 放在 org/aspectj 文件夹里更好，因为 https://github.com/dsyer/spring-boot-aspectj --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aspectj</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">weaver</span> <span class="hljs-attr">options</span>=<span class="hljs-string">&quot;-verbose -showWeaveInfo&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- only weave classes in our application-specific packages --&gt;</span><br>        <span class="hljs-comment">&lt;!-- .. 代表子包 --&gt;</span><br>        <span class="hljs-comment">&lt;!-- 这里可以注释掉，aspect 也会生效 --&gt;</span><br><span class="hljs-comment">&lt;!--                &lt;include within=&quot;com.magicliang..*&quot;/&gt;--&gt;</span><br>        <span class="hljs-comment">&lt;!-- 绝大多数情况下，不需要打开这个注解，我们不需要 advised spring boot 自己的模块 --&gt;</span><br>        <span class="hljs-comment">&lt;!--        &lt;include within=&quot;org.springframework.boot..*&quot;/&gt;--&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">weaver</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aspects</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 这里不能注释，否则无法让切面生效 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aspect</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.magicliang.experiments.aspect.ProfilingAspect&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">aspects</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aspectj</span>&gt;</span><br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * project name: spring-experiments</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * description: 被织入的类</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 使用 javaagent 要改启动脚本。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 要给 jvm 加参数（也就 -javaagent 加在 java 命令后面），而不是 application 加参数（application 的 main class 本身也是 jvm 的一个参数，也就是参数不要加在 -jar abc.jar 后面）：</span><br><span class="hljs-comment"> * $HOME</span><br><span class="hljs-comment"> *  * -javaagent:$&#123;HOME&#125;/.m2/repository/org/aspectj/aspectjweaver/1.9.5/aspectjweaver-1.9.5.jar</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> magicliang</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * date: 2020-04-18 17:43</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-comment">// 这个注解不能放在 spring-managed bean 上，不然会导致对象被初始化两次</span><br><span class="hljs-comment">// 这个注解什么作用都不起，它会指示 AnnotationBeanConfigurerAspect 在 construction 前后把依赖注入进这个 bean。注解和切面会联系在一起</span><br><span class="hljs-comment">// preConstruction 一用上，就会导致注入在 construction 之前。value = &quot;user&quot;，以为着要寻找一个名为 user 的 bean definition</span><br><span class="hljs-comment">// @Configurable(autowire = Autowire.BY_NAME, dependencyCheck = true)</span><br><span class="hljs-meta">@Configurable</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> Dog dog;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">output</span><span class="hljs-params">()</span> &#123;<br>        foo();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> &#123;<br>        log.info(<span class="hljs-string">&quot;doggy is:&quot;</span> + dog.toString());<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>&#125;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> String name;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * project name: spring-experiments</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * description:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> magicliang</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * date: 2020-04-18 23:28</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-comment">// 这个注解可有可无</span><br><span class="hljs-comment">// @ConfigurationProperties(&quot;interceptor&quot;)</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProfilingAspect</span> &#123;<br><br>    <span class="hljs-meta">@Around(&quot;methodsToBeProfiled()&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">profile</span><span class="hljs-params">(ProceedingJoinPoint pjp)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-type">StopWatch</span> <span class="hljs-variable">sw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StopWatch</span>(getClass().getSimpleName());<br>        <span class="hljs-keyword">try</span> &#123;<br>            sw.start(pjp.getSignature().getName());<br>            <span class="hljs-keyword">return</span> pjp.proceed();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            sw.stop();<br>            log.info(<span class="hljs-string">&quot;time:&quot;</span> + sw.prettyPrint());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Pointcut(&quot;execution(public * com.magicliang..*.*(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodsToBeProfiled</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/res/v1&quot;)</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-comment">// 只有打开这个注解， @Configurable 注解才会生效</span><br><span class="hljs-meta">@EnableSpringConfigured</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AspectjLoadTimeWeaverApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(AspectjLoadTimeWeaverApplication.class, args);<br>    &#125;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/user&quot;)</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">getUser</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        user.output();<br>        <span class="hljs-keyword">return</span> user;<br>    &#125;<br><br>    <span class="hljs-comment">// 没什么卵用的 ConditionalOnClass</span><br>    <span class="hljs-comment">// @ConditionalOnClass(AnnotationBeanConfigurerAspect.class)</span><br>    <span class="hljs-meta">@Bean</span><br>    Dog <span class="hljs-title function_">dog</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Dog</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>        d.setId(<span class="hljs-number">1</span>);<br>        d.setName(<span class="hljs-string">&quot;dog&quot;</span>);<br>        <span class="hljs-keyword">return</span> d;<br>    &#125;<br><br>    <span class="hljs-comment">// 这个 bean 方法有的项目建议有，但其实没有也无所谓</span><br><span class="hljs-comment">//    @Bean</span><br><span class="hljs-comment">//    public ProfilingAspect interceptor() &#123;</span><br><span class="hljs-comment">//        // This will barf at runtime if the weaver isn&#x27;t working (probably a</span><br><span class="hljs-comment">//        // good thing)</span><br><span class="hljs-comment">//        return Aspects.aspectOf(ProfilingAspect.class);</span><br><span class="hljs-comment">//    &#125;</span><br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>启动的时候加上这个 vm args（暂时不要使用 spring-instrument.jar）： * -javaagent:${HOME}/.m2/repository/org/aspectj/aspectjweaver/1.9.5/aspectjweaver-1.9.5.jar</p>
<p>只要有这个 javaagent，@Configurable + @EnableSpringConfigured 的自动注入就会生效 - 这个注解强依赖于这个 jave agent。</p>
<p>而如果有了 aop.xml 的 aspect，怎样的 public 方法都可以被增强。</p>
<p>Spring Boot 提供的 @EnableLoadTimeWeaving 和 spring-instrument.jar <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/54749106/aspectj-ltw-weaving-not-working-with-spring-boot">理论上应该一起生效</a>，但不知道怎样搭配才能生效还不可知。</p>
<h2 id="compile-time-weaving">compile time weaving</h2>
<p>compile time weaving 需要给 maven 增加以下配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs xml">    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">pluginManagement</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>                    <span class="hljs-comment">&lt;!-- thin-jar 是相对于 fatjar 而言的，比较难用 --&gt;</span><br><span class="hljs-comment">&lt;!--                        &lt;dependency&gt;--&gt;</span><br><span class="hljs-comment">&lt;!--                            &lt;groupId&gt;org.springframework.boot.experimental&lt;/groupId&gt;--&gt;</span><br><span class="hljs-comment">&lt;!--                            &lt;artifactId&gt;spring-boot-thin-layout&lt;/artifactId&gt;--&gt;</span><br><span class="hljs-comment">&lt;!--                            &lt;version&gt;$&#123;thin-jar.version&#125;&lt;/version&gt;--&gt;</span><br><span class="hljs-comment">&lt;!--                        &lt;/dependency&gt;--&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectjweaver<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;aspectj.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">pluginManagement</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><br>            <span class="hljs-comment">&lt;!-- 使用 delombok 插件来使生成的代码无 lombok，让 aspectjc 的编译无寻找不到符号问题 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.16.16.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>generate-sources<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>delombok<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">addOutputDirectory</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">addOutputDirectory</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">sourceDirectory</span>&gt;</span>src/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">sourceDirectory</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.codehaus.mojo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectj-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>$&#123;java.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>$&#123;java.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">proc</span>&gt;</span>none<span class="hljs-tag">&lt;/<span class="hljs-name">proc</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">complianceLevel</span>&gt;</span>$&#123;java.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">complianceLevel</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">showWeaveInfo</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">showWeaveInfo</span>&gt;</span><br>                    <span class="hljs-comment">&lt;!-- 另一种解法 https://stackoverflow.com/questions/41910007/lombok-and-aspectj --&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectjtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;aspectj.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-deploy-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">skip</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">skip</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">pluginRepositories</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">pluginRepository</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>spring-snapshots<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Spring Snapshots<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://repo.spring.io/snapshot<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 打开快照 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">snapshots</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">enabled</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">enabled</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">snapshots</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">pluginRepository</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">pluginRepository</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>spring-milestones<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Spring Milestones<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://repo.spring.io/milestone<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">snapshots</span>&gt;</span><br>                <span class="hljs-comment">&lt;!-- 关闭快照 --&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">enabled</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">enabled</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">snapshots</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">pluginRepository</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">pluginRepositories</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>然后不用 javaagent 就能启动增强了。</p>
<p>但是 @Configurable 不生效，要生效，还是要加上 javaagent：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -javaagent:<span class="hljs-variable">$HOME</span>/.m2/repository/org/aspectj/aspectjweaver/1.8.13/aspectjweaver-1.8.13.jar -jar target/*.jar<br></code></pre></td></tr></table></figure>
<p>被编译增强的类，debug 起来非常困难，因为增加了很多代码。<br>
还是普通的 spring aop 就足够了。</p>
<h2 id="spring-允许每个类加载器有细颗粒的-ltw">Spring 允许每个类加载器有细颗粒的 LTW</h2>
<p>待研究这样做的用处是什么</p>
<h1>Spring 的 AOP API</h1>
<h2 id="切点相关-api">切点相关 API</h2>
<p>切点负责让 advices 指向特定的类和方法。</p>
<p>Spring 用切点 API，使得切点成为一个框架特性，而不是一个语言特性-语言特性需要编译器支持。</p>
<p>但是，大多数情况下，我们应该<strong>只使用一个切点表达式</strong>就足够了，不要直接使用切点 API。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Pointcut</span> &#123;<br>    <span class="hljs-comment">//  restrict the pointcut to a given set of target classes</span><br>    ClassFilter <span class="hljs-title function_">getClassFilter</span><span class="hljs-params">()</span>;<br><br>    MethodMatcher <span class="hljs-title function_">getMethodMatcher</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>切点的 api 还可以分为两个部分（用于 union 其他 method matcher）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ClassFilter</span> &#123;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">matches</span><span class="hljs-params">(Class clazz)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>ClassFilter 用于限制一个目标类的切点。</p>
<p>而 MethodMatcher 更重要：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MethodMatcher</span> &#123;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">matches</span><span class="hljs-params">(Method m, Class targetClass)</span>;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isRuntime</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">matches</span><span class="hljs-params">(Method m, Class targetClass, Object[] args)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>双参数的 matches(Method, Class) 方法可以确认一个目标类上的特定方法是否符合切点要求。这个求值可以在 AOP proxy 被创建时发生，而不是每一次方法调用时发生。它返回 true，则 isRuntime 返回 true，然后三参数的 matches 每次方法执行会被调用。</p>
<p>大多数 MethodMatcher 被实现为静态的，isRuntime 返回 false，则三参数的 matches 永不会被执行。这是被 Spring 鼓励的，这样 Spring 可以在 AOP proxy 被创建的时候，缓存 pointcut evaluation 的结果。</p>
<p>除此之外，并集和交集的 API 可以参考<code>org.springframework.aop.support.Pointcuts</code>和<code>ComposablePointcut</code>。</p>
<p>大多数情况下，使用一个静态切点（即只关注 target class 上的方法特征，而不关注真正的运行时 arguments）就最好了</p>
<h3 id="一些有用的切点实现">一些有用的切点实现</h3>
<p>使用切点作为 bean，然后关联 bean 和 advice。<br>
这样我们可以实现不写 Aspect，也实现 pointcut 和 advice 的结合，再进一步实现 target 和 advisor 在 ProxyFactory 里的结合。</p>
<p>一般的日志切面适合使用：</p>
<ol>
<li>正则表达式 Poincut</li>
<li>正则表达式 advisor</li>
<li>直接使用 Aspect</li>
</ol>
<h4 id="jdkregexpmethodpointcut">JdkRegexpMethodPointcut</h4>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span>    </span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>       </span><br><span class="hljs-tag">    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans </span></span><br><span class="hljs-string"><span class="hljs-tag">    http://www.springframework.org/schema/beans/spring-beans-2.0.xsd&quot;</span>&gt;</span><br> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;person&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;Person&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;loggerPerson&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;LoggerPerson&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pointcut&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.aop.support.JdkRegexpMethodPointcut&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;patterns&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>.*ay.*<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>.*ie<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br> <br> <span class="hljs-comment">&lt;!-- DefaultPointcutAdvisor 就是典型的 advice api + pointcut api --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;advisor&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.aop.support.DefaultPointcutAdvisor&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;pointcut&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;pointcut&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;advice&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;loggerPerson&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;ProxyFactoryBean&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;target&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;person&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;interceptorNames&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>advisor<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>这个 pointcut 本身代表着早期 Spring 的正则切点，后续完整的切点可以重点使用<code>AspectJExpressionPointcut()</code>。</p>
<h4 id="regexpmethodpointcutadvisor">RegexpMethodPointcutAdvisor</h4>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;settersAndAbsquatulateAdvisor&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.aop.support.RegexpMethodPointcutAdvisor&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;advice&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;beanNameOfAopAllianceInterceptor&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;patterns&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>.*set.*<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>.*absquatulate<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h4 id="controlflowpointcut">ControlFlowPointcut</h4>
<p><a target="_blank" rel="noopener" href="https://www.roseindia.net/tutorial/spring/spring3/aop/controlflowpointcut.html">Control Flow Pointcut</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> roseindia.net.coltrolFlowpointcut;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHi</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello Friend&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">package</span> roseindia.net.coltrolFlowpointcut;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-keyword">import</span> org.aopalliance.intercept.MethodInterceptor;<br><span class="hljs-keyword">import</span> org.springframework.aop.MethodBeforeAdvice;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestAdvice</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodBeforeAdvice</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">(Method method, Object[] boObjects, Object object)</span><br>            <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-comment">// TODO Auto-generated method stub</span><br>        System.out.println(<span class="hljs-string">&quot;Calling before &quot;</span> + method);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">package</span> roseindia.net.coltrolFlowpointcut;<br><br><span class="hljs-keyword">import</span> org.aopalliance.aop.Advice;<br><span class="hljs-keyword">import</span> org.springframework.aop.Advisor;<br><span class="hljs-keyword">import</span> org.springframework.aop.ClassFilter;<br><span class="hljs-keyword">import</span> org.springframework.aop.MethodMatcher;<br><span class="hljs-keyword">import</span> org.springframework.aop.Pointcut;<br><span class="hljs-keyword">import</span> org.springframework.aop.framework.ProxyFactory;<br><span class="hljs-keyword">import</span> org.springframework.aop.support.ControlFlowPointcut;<br><span class="hljs-keyword">import</span> org.springframework.aop.support.DefaultPointcutAdvisor;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestControlFlow</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">SimpleClass</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleClass</span>();<br>        <span class="hljs-type">Pointcut</span> <span class="hljs-variable">pointcut</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ControlFlowPointcut</span>(TestControlFlow.class,<br>                <span class="hljs-string">&quot;controlFlowTest&quot;</span>);<br>        <span class="hljs-type">Advice</span> <span class="hljs-variable">advice</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestAdvice</span>();<br>        <span class="hljs-type">ProxyFactory</span> <span class="hljs-variable">proxyFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProxyFactory</span>();<br><br>        <span class="hljs-type">Advisor</span> <span class="hljs-variable">advisor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultPointcutAdvisor</span>(pointcut, advice);<br>        proxyFactory.addAdvisor(advisor);<br>        proxyFactory.setTarget(target);<br>        <span class="hljs-type">SimpleClass</span> <span class="hljs-variable">simpleProxy</span> <span class="hljs-operator">=</span> (SimpleClass) proxyFactory.getProxy();<br>        System.out.println(<span class="hljs-string">&quot;Calling Normally&quot;</span>);<br>        simpleProxy.sayHi();<br>        System.out.println(<span class="hljs-string">&quot;Calling in ControlFlow&quot;</span>);<br>        controlFlowTest(simpleProxy);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">controlFlowTest</span><span class="hljs-params">(SimpleClass simpleClass)</span> &#123;<br>        simpleClass.sayHi();<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">package</span> roseindia.net.coltrolFlowpointcut;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainClaz</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">TestControlFlow</span> <span class="hljs-variable">testControlFlow</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestControlFlow</span>();<br>        testControlFlow.test();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="通用的静态切点父类">通用的静态切点父类</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestStaticPointcut</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">StaticMethodMatcherPointcut</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">matches</span><span class="hljs-params">(Method m, Class targetClass)</span> &#123;<br>        <span class="hljs-comment">// return true if custom criteria match</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="advice-相关-api">advice 相关 API</h2>
<p>Spring 的 advice 主要分为 per-class 和 per-instance 两类。 per-class 最常用（我们所有的 proxy 确实都是针对<strong>一类类型的</strong>），比如 transaction advisor； per-instance 通常用来作为 introduction 支持混型的基本技术，它会给 proxied object 增加状态。</p>
<p>尽量使用 alliance-compliant AOP advice 的拦截器（所以 spring 甚至自己定义了一个 alliancen 包），这样可以保证拦截器可以被其他 AOP 框架使用（如 google guice）。</p>
<p>interceptor 自己会产生一个 interceptor chain，这个 chain 是会被破坏的。</p>
<p>各种 advice、advisor 可以在一套 proxy 配置里生效。</p>
<h3 id="interception-around-advice">Interception Around Advice</h3>
<p>最常用的拦截器，能够完全控制方法的执行。在方法前后，完全环绕：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MethodInterceptor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Interceptor</span> &#123;<br><br>    Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(MethodInvocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DebugInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodInterceptor</span> &#123;<br><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(MethodInvocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(<span class="hljs-string">&quot;Before: invocation=[&quot;</span> + invocation + <span class="hljs-string">&quot;]&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">rval</span> <span class="hljs-operator">=</span> invocation.proceed();<br>        System.out.println(<span class="hljs-string">&quot;Invocation returned&quot;</span>);<br>        <span class="hljs-keyword">return</span> rval;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="before-advice">Before Advice</h3>
<p>只在方法前执行，所以不需要<code>MethodInvocation</code>，只要能够引用到 Method 即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MethodBeforeAdvice</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BeforeAdvice</span> &#123;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">(Method m, Object[] args, Object target)</span> <span class="hljs-keyword">throws</span> Throwable;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CountingBeforeAdvice</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodBeforeAdvice</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> count;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">(Method m, Object[] args, Object target)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        ++count;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCount</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>它如果挂了，方法执行就会挂掉。而且会抛出一个异常给 client 调用端-如果异常 match client 的异常，可以抛原始异常给 client，否则会抛出一个包装器。</p>
<p>这个 advice 可以配合切点使用。</p>
<h3 id="throws-advice">Throws Advice</h3>
<p>这是一个 tag interface，所以本身不包含任何的实际方法。但 Spring 又支持 typed advice，所以可以自由组织各种 advice 的实现方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 原始的 tag interface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ThrowsAdvice</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AfterAdvice</span> &#123;<br><br>&#125;<br><span class="hljs-comment">// 推荐的模式</span><br>afterThrowing([Method, args, target], subclassOfThrowable)<br><br><span class="hljs-comment">// 现实中的 advice</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RemoteThrowsAdvice</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ThrowsAdvice</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterThrowing</span><span class="hljs-params">(RemoteException ex)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-comment">// Do something with remote exception</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServletThrowsAdviceWithArguments</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ThrowsAdvice</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterThrowing</span><span class="hljs-params">(Method m, Object[] args, Object target, ServletException ex)</span> &#123;<br>        <span class="hljs-comment">// Do something with all arguments</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CombinedThrowsAdvice</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ThrowsAdvice</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterThrowing</span><span class="hljs-params">(RemoteException ex)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-comment">// Do something with remote exception</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterThrowing</span><span class="hljs-params">(Method m, Object[] args, Object target, ServletException ex)</span> &#123;<br>        <span class="hljs-comment">// Do something with all arguments</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个 advice 可以配合切点使用。</p>
<h3 id="after-returning-advice">After Returning Advice</h3>
<p>可以获取返回参数和抛出异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AfterReturningAdvice</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Advice</span> &#123;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterReturning</span><span class="hljs-params">(Object returnValue, Method m, Object[] args, Object target)</span><br>            <span class="hljs-keyword">throws</span> Throwable;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个 advice 可以配合切点使用。</p>
<h3 id="introduction-advice">Introduction Advice</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IntroductionInterceptor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">MethodInterceptor</span>, DynamicIntroductionAdvice &#123;&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockMixin</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">DelegatingIntroductionInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Lockable</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> locked;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.locked = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.locked = <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">locked</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.locked;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(MethodInvocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-keyword">if</span> (locked() &amp;&amp; invocation.getMethod().getName().indexOf(<span class="hljs-string">&quot;set&quot;</span>) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LockedException</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.invoke(invocation);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockMixinAdvisor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">DefaultIntroductionAdvisor</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LockMixinAdvisor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LockMixin</span>(), Lockable.class);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 接下来可以用 xml bean、 Advised.addAdvisor() 或者 auto proxy creators 来让这个 advisor 生效。</span><br></code></pre></td></tr></table></figure>
<p>这个 advice 不可以配合切点使用。</p>
<h2 id="proxyfactorybean">ProxyFactoryBean</h2>
<p><strong>一个 bean 引用一个 ProxyFactoryBean，其实不是引用它的 instance，而是在引用它的 getObject() 产生的对象</strong>（它的 getObject 接口是 convention over configuration 的典范，总是会被自动调用）。ProxyFactoryBean 有一个优点，因为由他搞出来的 advices 和 pointcuts 本身都是 IoC 容器管理的 bean。在大多数情况下，我们可以用 xml 配置相关 bean，但有些时候我们需要动态生成 bean，这时候就可以用到 ProxyFactoryBean 了。</p>
<p>Spring 框架里各种 EntityManagerFactory 都是各种 FactoryBean，factory bean 在 ioc 里再谈。</p>
<p>这个类型被 AbstractBeanFactory 使用（另一个被 BeanFactory 经常使用的扩展点是 BeanPostProcessor）。我们的系统中经常出现使用的扩展的其实不是 ProxyFactoryBean，而是 FactoryBean。它的用意是“（使用 xml）动态地给现存的 bean 增加切面”。</p>
<p>几个基础属性：</p>
<ul>
<li>proxyTargetClass: true，强制使用 CGLIB 代理。proxy-based vs interface-based（jdk-based proxy）。如果 interface-based 不可能正确生成，即使是这个值是 false，也会强制使用 CGLIB 代理。principle of least surprise。最好不要用 proxyTargetClass 和 optimize false 来转入 jdk-based proxy。因为生成 cglib proxy 的流程里还会回退到 jdk-based proxy，但 jdk-based proxy 的生成流程是不能回退到 cglib proxy 的。</li>
<li>optimize：可以对 CGLIB 代理施以激进优化。</li>
<li>frozen：是否允许变动配置（如增加 advice）。</li>
<li>exposeProxy：是否把代理放在线程（ThreadLocal）里，允许 AopContext.currentProxy() 生效。</li>
<li>proxyInterfaces：接口列表。如果什么都不提供，使用 CGLIB 代理，提供了，有可能使用 jdk 动态代理。</li>
<li>interceptorNames：拦截器、advice 列表。名字的顺序实际上决定了 interceptor chain 的生效顺序。这个列表本身不是 name-ref 的模式，是为了允许 prototype 模式生效。</li>
<li>singleton：是否单例，大部分的 FactoryBean 的实现的这个值都是 true。</li>
</ul>
<p>如果有可能，Spring 会顺着接口列表生成 JdkDynamicAopProxy；否则，会退而求其次生成 cglib proxy。Spring 是不能对 final class/待有 final 方法的抽象类生成 proxy 的，<strong>但可以针对 interface 生成一个 proxy，这显示子类模式的局限，基于接口的代理其实是对象适配器的一种</strong>。一个规避方法是<code>!within(is(FinalType)) &amp;&amp; execution(* doFilter(..))</code>。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;personTarget&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.mycompany.PersonImpl&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Tony&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;51&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myAdvisor&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.mycompany.MyAdvisor&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;someProperty&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Custom string property value&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;debugInterceptor&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.aop.interceptor.DebugInterceptor&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;person&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;proxyInterfaces&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mycompany.Person&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;target&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;personTarget&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;interceptorNames&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- You might be wondering why the list does not hold bean references. The reason for this is that, if the singleton property of the ProxyFactoryBean is set to false, it must be able to return independent proxy instances. If any of the advisors is itself a prototype, an independent instance would need to be returned, so it is necessary to be able to obtain an instance of the prototype from the factory. Holding a reference is not sufficient.</span><br><span class="hljs-comment"> --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>myAdvisor<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>debugInterceptor<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 注意，这里不再需要对 person 进行 getObject，getObject 已经被自动调用了，这里的这个 object 甚至可以是一个 String。</span><br><span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> (Person) factory.getBean(<span class="hljs-string">&quot;person&quot;</span>);<br></code></pre></td></tr></table></figure>
<p>我们也可以使用一个内部类声明，使全局的 bean 能够藏住一个不可被引用的被代理的 target，而且也无法从全局的其他地方被引用。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myAdvisor&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.mycompany.MyAdvisor&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;someProperty&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Custom string property value&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;debugInterceptor&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.aop.interceptor.DebugInterceptor&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;person&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;proxyInterfaces&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mycompany.Person&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- Use inner bean, not local reference to target --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;target&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.mycompany.PersonImpl&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Tony&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;51&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;interceptorNames&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>myAdvisor<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>debugInterceptor<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>interceptorNames 支持通配符模式：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;proxy&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;target&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;service&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;interceptorNames&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>global*<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;global_debug&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.aop.interceptor.DebugInterceptor&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;global_performance&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.aop.interceptor.PerformanceMonitorInterceptor&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 父代理工厂 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;txProxyTemplate&quot;</span> <span class="hljs-attr">abstract</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.transaction.interceptor.TransactionProxyFactoryBean&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;transactionManager&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;transactionAttributes&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">props</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;*&quot;</span>&gt;</span>PROPAGATION_REQUIRED<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">props</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 子代理工厂 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myService&quot;</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;txProxyTemplate&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;target&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.samples.MyServiceImpl&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 子代理工厂覆盖父配置 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mySpecialService&quot;</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;txProxyTemplate&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;target&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.samples.MySpecialServiceImpl&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;transactionAttributes&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">props</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;get*&quot;</span>&gt;</span>PROPAGATION_REQUIRED,readOnly<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;find*&quot;</span>&gt;</span>PROPAGATION_REQUIRED,readOnly<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;load*&quot;</span>&gt;</span>PROPAGATION_REQUIRED,readOnly<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;store*&quot;</span>&gt;</span>PROPAGATION_REQUIRED<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">props</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h2 id="程序化地创建-aop-代理的方法">程序化地创建 AOP 代理的方法</h2>
<p>使用 ProxyFactory（注意，不是 xml 使用的<code>ProxyFactoryBean</code>）；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ProxyFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProxyFactory</span>(myBusinessInterfaceImpl);<br>factory.addAdvice(myMethodInterceptor);<br>factory.addAdvisor(myAdvisor);<br><span class="hljs-type">MyBusinessInterface</span> <span class="hljs-variable">tb</span> <span class="hljs-operator">=</span> (MyBusinessInterface) factory.getProxy();<br></code></pre></td></tr></table></figure>
<p>所有的 proxy 都可以转化为<code>org.springframework.aop.framework.Advised</code>接口，其包含这些方法：</p>
<p>可以看出来 advice 和 advisor 的区别还是很大的：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml">Advisor[] getAdvisors();<br><br>void addAdvice(Advice advice) throws AopConfigException;<br><br>void addAdvice(int pos, Advice advice) throws AopConfigException;<br><br>void addAdvisor(Advisor advisor) throws AopConfigException;<br><br>void addAdvisor(int pos, Advisor advisor) throws AopConfigException;<br><br>int indexOf(Advisor advisor);<br><br>boolean removeAdvisor(Advisor advisor) throws AopConfigException;<br><br>void removeAdvisor(int index) throws AopConfigException;<br><br>boolean replaceAdvisor(Advisor a, Advisor b) throws AopConfigException;<br><br>boolean isFrozen();<br></code></pre></td></tr></table></figure>
<p>下面是一个例子，可以把 proxy 的 advisor 都取出来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Advised</span> <span class="hljs-variable">advised</span> <span class="hljs-operator">=</span> (Advised) myObject;<br>Advisor[] advisors = advised.getAdvisors();<br><span class="hljs-type">int</span> <span class="hljs-variable">oldAdvisorCount</span> <span class="hljs-operator">=</span> advisors.length;<br>System.out.println(oldAdvisorCount + <span class="hljs-string">&quot; advisors&quot;</span>);<br><br><span class="hljs-comment">// Add an advice like an interceptor without a pointcut</span><br><span class="hljs-comment">// Will match all proxied methods</span><br><span class="hljs-comment">// Can use for interceptors, before, after returning or throws advice</span><br>advised.addAdvice(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DebugInterceptor</span>());<br><br><span class="hljs-comment">// Add selective advice using a pointcut</span><br>advised.addAdvisor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultPointcutAdvisor</span>(mySpecialPointcut, myAdvice));<br><br>assertEquals(<span class="hljs-string">&quot;Added two advisors&quot;</span>, oldAdvisorCount + <span class="hljs-number">2</span>, advised.getAdvisors().length);<br></code></pre></td></tr></table></figure>
<p>注意，以上操作还是会受 frozen 的影响。</p>
<h2 id="使用自动代理设施-auto-proxying-facility">使用自动代理设施（auto-proxying facility）</h2>
<p>这种自动处理机制，很多系统都喜欢用。<br>
它的本质是对 bean definition 进行操作，使用 proxy 代理特定模式的 bean definition（targets eligible），依赖于 bean 后处理器的基础设施。</p>
<h3 id="beannameautoproxycreator">BeanNameAutoProxyCreator</h3>
<p>这是最常见的做法：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;beanNames&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdk*,onlyJdk&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;interceptorNames&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>myInterceptor<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>它对于 bean 名称的模式匹配，应该可以被 PCD 完全取代。<br>
它本身是一个 BeanPostProcessor，它会给每个 bean 专门生成一个 proxy。</p>
<h3 id="defaultadvisorautoproxycreator">DefaultAdvisorAutoProxyCreator</h3>
<p>这个东西会自动地把 advisor 和 target 关联起来，所有需要做的事情只是：</p>
<ul>
<li>声明一系列 advisor。</li>
<li>声明一个 DefaultAdvisorAutoProxyCreator。</li>
</ul>
<p>从这里看出来 advisor 和 advice、interceptor 的显著区别，advisor 天然就有 pointcut，可以自动被识别。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br>    <span class="hljs-comment">// 要创建代理的目标 Bean</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> UserService <span class="hljs-title function_">userService</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserServiceImpl</span>();<br>    &#125;<br>    <span class="hljs-comment">// 创建Advice</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Advice <span class="hljs-title function_">myMethodInterceptor</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyMethodInterceptor</span>();<br>    &#125;<br>    <span class="hljs-comment">// 使用 Advice 创建Advisor</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> NameMatchMethodPointcutAdvisor <span class="hljs-title function_">nameMatchMethodPointcutAdvisor</span><span class="hljs-params">()</span>&#123;<br>        NameMatchMethodPointcutAdvisor nameMatchMethodPointcutAdvisor=<span class="hljs-keyword">new</span> <span class="hljs-title class_">NameMatchMethodPointcutAdvisor</span>();<br>        nameMatchMethodPointcutAdvisor.setMappedName(<span class="hljs-string">&quot;pri*&quot;</span>);<br>        nameMatchMethodPointcutAdvisor.setAdvice(myMethodInterceptor());<br>        <span class="hljs-keyword">return</span> nameMatchMethodPointcutAdvisor;<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> DefaultAdvisorAutoProxyCreator <span class="hljs-title function_">defaultAdvisorAutoProxyCreator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultAdvisorAutoProxyCreator</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="targetsource-api">TargetSource API</h2>
<h3 id="可热替换-hot-swappable-的-target-source">可热替换（hot-swappable）的 target source</h3>
<p>Spring 提供一个 API，可以让代理暴露自己的目标源：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;initialTarget&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;mycompany.OldTarget&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;swapper&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.aop.target.HotSwappableTargetSource&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;initialTarget&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;swappable&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;targetSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;swapper&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 甚至这个接口还可以提供 swap target 的能力</span><br><span class="hljs-type">HotSwappableTargetSource</span> <span class="hljs-variable">swapper</span> <span class="hljs-operator">=</span> (HotSwappableTargetSource) beanFactory.getBean(<span class="hljs-string">&quot;swapper&quot;</span>);<br><span class="hljs-type">Object</span> <span class="hljs-variable">oldTarget</span> <span class="hljs-operator">=</span> swapper.swap(newTarget);<br></code></pre></td></tr></table></figure>
<h3 id="池化-target-source">池化 target source</h3>
<p>Spring 可以和各种 pooling api 配合使用，如以下的例子：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;businessObjectTarget&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.mycompany.MyBusinessObject&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;prototype&quot;</span>&gt;</span><br>    ... properties omitted<br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 依赖于 common-pools 2.3：org.apache.commons.pool2.ObjectPool --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;poolTargetSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.aop.target.CommonsPool2TargetSource&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;targetBeanName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;businessObjectTarget&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxSize&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;25&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;businessObject&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;targetSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;poolTargetSource&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;interceptorNames&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;myInterceptor&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>相关的关键类是：org.springframework.aop.target.AbstractPoolingTargetSource。</p>
<p>如果做了以下操作，可以把目标 bean 内部的 pool 配置读出来（比如对象池大小）：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;poolConfigAdvisor&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.beans.factory.config.MethodInvokingFactoryBean&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;targetObject&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;poolTargetSource&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;targetMethod&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;getPoolingConfigMixin&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">PoolingConfig</span> <span class="hljs-variable">conf</span> <span class="hljs-operator">=</span> (PoolingConfig) beanFactory.getBean(<span class="hljs-string">&quot;businessObject&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;Max pool size is &quot;</span> + conf.getMaxSize());<br></code></pre></td></tr></table></figure>
<p>能够被池化复用的对象，应该是无状态的对象，比如 EJB 对象，所以这个功能到底是不是真的有用，还要看业务场景。Spring 文档说无状态对象是线程安全的，只是把这个类型当做 transaction service 而已-如此说，prototype 和 singleton 又有什么区别。</p>
<h3 id="原型化-target-source">原型化 target source</h3>
<p>还有原型化的 target source api。原型化的 api 一般都很不好用，因为它意味着每次方法调用都会产生新对象。产生新对象的成本并不高，装配（wiring）依赖的成本会很高。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;prototypeTargetSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.aop.target.PrototypeTargetSource&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- prototype 的 bean--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;targetBeanName&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;businessObjectTarget&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>相当于 bean 还要被套在 TargetSource 里，所以 TargetSource 本质上只是一种 proxy 而已。</p>
<h3 id="threadlocal-target-source">ThreadLocal target source</h3>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;threadlocalTargetSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.aop.target.ThreadLocalTargetSource&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;targetBeanName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;businessObjectTarget&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>ThreadLocal 在多线程和多类加载器的场景下，会导致内存泄漏。</p>
<h3 id="定义新的-advice-类型">定义新的 Advice 类型</h3>
<p>Spring 的 AOP 框架本身是支持类型扩展的，自定义的扩展可以通过一套 SPI 机制进行扩展。见<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.2.5.RELEASE/javadoc-api/org/springframework/aop/framework/adapter/package-frame.html"><code>org.springframework.aop.framework.adapter</code></a>文档。</p>
<h1>总结一下 AOP 的初始化和使用方法</h1>
<p><a href="%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8AOP.xmind">如何正确使用AOP.xmind</a><br>
<img src="%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8AOP.png" alt="如何正确使用AOP.png"></p>
<p>基本结论，越使用自动机制，越要使用 aspect；越是使用内部机制，越是使用 advisor。</p>
<h1>一般的继承关系</h1>
<p><img src="spring-aop-package.png" alt="spring-aop-package"></p>
<p>spring-aop 模块的 jar 里包含 org.aopalliance 和 org.springframework.aop 这两个包。第一个包是 rod johnson 借 aopalliance 之名定义了如下抽象：</p>
<p><img src="aop-alliance-package.png" alt="aop-alliance-package"></p>
<p>然后第二个包引用第一个包的抽象，定义各种 Spring 内建的 Advice、Advisor（注意，这个概念是 Spring AOP 才有的）、Matcher、Pointcu、AopProxy、AopContext、AopProxyFactory。它还有一个专门的子包，专门处理 aspectj 相关问题。</p>
<p><img src="spring-core-package.png" alt="spring-core-package"></p>
<p>pring-core 模块的 jar 里，隐藏了另一个 MethodInterceptor，是为了 cglib proxy 的 callback 链准备的。</p>
<p>常见的 AOP 实现包括但不仅限于：</p>
<ul>
<li>AspectJ：源代码和字节码级别的编织器，需用使用 Aspect 语言</li>
<li>AspectWerkz：AOP框架，使用字节码动态编织器和 XML 配置</li>
<li>JBoss-AOP:基于拦截器和元数据的AOP框架，运行在JBoss应用服务器上</li>
<li>BCEL(Byte-Code Engineering Library):Java字节码操作类库</li>
<li>Javassist：Java字节码操作类库</li>
</ul>
<p><a href="spring-aop.vpp">spring-aop</a><br>
<img src="spring-aop-proxy-creation.jpg" alt="spring-aop-proxy-creation"></p>
<h2 id="解析-spring-aop-标签的流程">解析 spring aop 标签的流程</h2>
<p>我们常见的 xml 标签如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">xmlns:tx</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/tx&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans </span></span><br><span class="hljs-string"><span class="hljs-tag">                http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">                http://www.springframework.org/schema/context </span></span><br><span class="hljs-string"><span class="hljs-tag">                http://www.springframework.org/schema/context/spring-context-2.5.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">                http://www.springframework.org/schema/tx</span></span><br><span class="hljs-string"><span class="hljs-tag">                http://www.springframework.org/schema/tx/spring-tx-2.5.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">                http://www.springframework.org/schema/aop</span></span><br><span class="hljs-string"><span class="hljs-tag">                http://www.springframework.org/schema/aop/spring-aop-2.5.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.xh.spring.aop&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">context:include-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;annotation&quot;</span> </span><br><span class="hljs-tag">                 <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;org.aspectj.lang.annotation.Aspect&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!-- 强制使用 cglib proxy 的一种方法 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspectj-autoproxy</span> <span class="hljs-attr">proxy-target-class</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>在 jar 下存在一个路径可以配置类似 SPI 的加载路径<code>.m2/repository/org/springframework/spring-aop/5.2.3.RELEASE/spring-aop-5.2.3.RELEASE.jar!/META-INF/spring.handlers</code>。</p>
<p>其激活的<code>AopNamespaceHandler</code>，调用顺序为：AbstractApplicationContext.refresh（内层的 refresh 是最大、最全的方法，包括了 BeanFactory 的前置流程、装载流程和后置流程） -&gt; AbstractApplicationContext.invokeBeanFactoryPostProcessors -&gt; PostProcessorRegistrationDelegate.invokeBeanDefinitionRegistryPostProcessors（我们注解了 config 的类是这个方法的参数，比如 SpringApplication 类） -&gt; ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry -&gt; ConfigurationClassBeanDefinitionReader.loadBeanDefinitions（每一个 resource 对应一个 BeanDefinitionReader，比如一个 applicationContext.xml 作为总的 resource 抽象）-&gt; AopNamespaceHandler</p>
<p><img src="aop-parsing-1.jpg" alt="aop-parsing-1"><br>
<img src="aop-parsing-2.jpg" alt="aop-parsing-2"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 可以认为 Spring 的 schema-based 的解析都要靠 XXXNameSpaceHandler 来完成从 xml element 到 BeanDefinition 的配置流程</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AopNamespaceHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">NamespaceHandlerSupport</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Register the &#123;<span class="hljs-doctag">@link</span> BeanDefinitionParser BeanDefinitionParsers&#125; for the</span><br><span class="hljs-comment">     * &#x27;&#123;<span class="hljs-doctag">@code</span> config&#125;&#x27;, &#x27;&#123;<span class="hljs-doctag">@code</span> spring-configured&#125;&#x27;, &#x27;&#123;<span class="hljs-doctag">@code</span> aspectj-autoproxy&#125;&#x27;</span><br><span class="hljs-comment">     * and &#x27;&#123;<span class="hljs-doctag">@code</span> scoped-proxy&#125;&#x27; tags.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 注册搁置 BeanDefinitionParser，和 tag 联系起来，这里把 BeanDefinition 的初始化进一步交给一个抽象，这里的 parser 集合实际上是一个 map</span><br>        <span class="hljs-comment">// In 2.0 XSD as well as in 2.1 XSD.</span><br>        registerBeanDefinitionParser(<span class="hljs-string">&quot;config&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConfigBeanDefinitionParser</span>());<br>        registerBeanDefinitionParser(<span class="hljs-string">&quot;aspectj-autoproxy&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">AspectJAutoProxyBeanDefinitionParser</span>());<br>        registerBeanDefinitionDecorator(<span class="hljs-string">&quot;scoped-proxy&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScopedProxyBeanDefinitionDecorator</span>());<br><br>        <span class="hljs-comment">// Only in 2.0 XSD: moved to context namespace as of 2.1</span><br>        registerBeanDefinitionParser(<span class="hljs-string">&quot;spring-configured&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpringConfiguredBeanDefinitionParser</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果我们使用的 aop 配置是：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 强制使用 cglib proxy 的一种方法 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span> <span class="hljs-attr">proxy-target-class</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- other beans defined here... --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>则对应的 Parser 是<code>ConfigBeanDefinitionParser</code>，关键方法是 parse：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">public</span> BeanDefinition <span class="hljs-title function_">parse</span><span class="hljs-params">(Element element, ParserContext parserContext)</span> &#123;<br>    <span class="hljs-type">CompositeComponentDefinition</span> <span class="hljs-variable">compositeDef</span> <span class="hljs-operator">=</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompositeComponentDefinition</span>(element.getTagName(), parserContext.extractSource(element));<br>    parserContext.pushContainingComponent(compositeDef);<br>    <span class="hljs-comment">// 这个就是真正调用各种 proxyFactory 的地方</span><br>    configureAutoProxyCreator(parserContext, element);<br><br>    <span class="hljs-comment">// 通过 xml 生成三类对象看这里</span><br>    List&lt;Element&gt; childElts = DomUtils.getChildElements(element);<br>    <span class="hljs-keyword">for</span> (Element elt: childElts) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">localName</span> <span class="hljs-operator">=</span> parserContext.getDelegate().getLocalName(elt);<br>        <span class="hljs-keyword">if</span> (POINTCUT.equals(localName)) &#123;<br>            parsePointcut(elt, parserContext);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ADVISOR.equals(localName)) &#123;<br>            parseAdvisor(elt, parserContext);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ASPECT.equals(localName)) &#123;<br>            parseAspect(elt, parserContext);<br>        &#125;<br>    &#125;<br><br>    parserContext.popAndRegisterContainingComponent();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-comment">// 代理创建器是用这个方法：</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Configures the auto proxy creator needed to support the &#123;<span class="hljs-doctag">@link</span> BeanDefinition BeanDefinitions&#125;</span><br><span class="hljs-comment"> * created by the &#x27;&#123;<span class="hljs-doctag">@code</span> &lt;aop:config/&gt;&#125;&#x27; tag. Will force class proxying if the</span><br><span class="hljs-comment"> * &#x27;&#123;<span class="hljs-doctag">@code</span> proxy-target-class&#125;&#x27; attribute is set to &#x27;&#123;<span class="hljs-doctag">@code</span> true&#125;&#x27;.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> AopNamespaceUtils</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configureAutoProxyCreator</span><span class="hljs-params">(ParserContext parserContext, Element element)</span> &#123;<br>    <span class="hljs-comment">// </span><br>    AopNamespaceUtils.registerAspectJAutoProxyCreatorIfNecessary(parserContext, element);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerAspectJAutoProxyCreatorIfNecessary</span><span class="hljs-params">(</span><br><span class="hljs-params">        ParserContext parserContext, Element sourceElement)</span> &#123;<br>    <span class="hljs-comment">// 从 xml 元素转化为 BeanDefinition</span><br>    <span class="hljs-type">BeanDefinition</span> <span class="hljs-variable">beanDefinition</span> <span class="hljs-operator">=</span> AopConfigUtils.registerAspectJAutoProxyCreatorIfNecessary(<br>            parserContext.getRegistry(), parserContext.extractSource(sourceElement));<br>    useClassProxyingIfNecessary(parserContext.getRegistry(), sourceElement);<br>    registerComponentIfNecessary(beanDefinition, parserContext);<br>&#125;<br><br><span class="hljs-comment">// 在这里确认是否这个 bean 会 proxyTargetClass</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">useClassProxyingIfNecessary</span><span class="hljs-params">(BeanDefinitionRegistry registry, <span class="hljs-meta">@Nullable</span> Element sourceElement)</span> &#123;<br>    <span class="hljs-keyword">if</span> (sourceElement != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">proxyTargetClass</span> <span class="hljs-operator">=</span> Boolean.parseBoolean(sourceElement.getAttribute(PROXY_TARGET_CLASS_ATTRIBUTE));<br>        <span class="hljs-keyword">if</span> (proxyTargetClass) &#123;<br>            AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);<br>        &#125;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">exposeProxy</span> <span class="hljs-operator">=</span> Boolean.parseBoolean(sourceElement.getAttribute(EXPOSE_PROXY_ATTRIBUTE));<br>        <span class="hljs-keyword">if</span> (exposeProxy) &#123;<br>            AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// BeanDefinition 里靠 PropertyValues 来记载这些基本属性</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">forceAutoProxyCreatorToUseClassProxying</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> &#123;<br>    <span class="hljs-keyword">if</span> (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) &#123;<br>        <span class="hljs-type">BeanDefinition</span> <span class="hljs-variable">definition</span> <span class="hljs-operator">=</span> registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);<br>        definition.getPropertyValues().add(<span class="hljs-string">&quot;proxyTargetClass&quot;</span>, Boolean.TRUE);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">forceAutoProxyCreatorToExposeProxy</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> &#123;<br>    <span class="hljs-keyword">if</span> (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) &#123;<br>        <span class="hljs-type">BeanDefinition</span> <span class="hljs-variable">definition</span> <span class="hljs-operator">=</span> registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);<br>        definition.getPropertyValues().add(<span class="hljs-string">&quot;exposeProxy&quot;</span>, Boolean.TRUE);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parseAdvisor</span><span class="hljs-params">(Element advisorElement, ParserContext parserContext)</span> &#123;<br>    <span class="hljs-type">AbstractBeanDefinition</span> <span class="hljs-variable">advisorDef</span> <span class="hljs-operator">=</span> createAdvisorBeanDefinition(advisorElement, parserContext);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> advisorElement.getAttribute(ID);<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 如果 advice 有 id，就可以直接</span><br>        <span class="hljs-built_in">this</span>.parseState.push(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AdvisorEntry</span>(id));<br>        <span class="hljs-type">String</span> <span class="hljs-variable">advisorBeanName</span> <span class="hljs-operator">=</span> id;<br>        <span class="hljs-keyword">if</span> (StringUtils.hasText(advisorBeanName)) &#123;<br>            parserContext.getRegistry().registerBeanDefinition(advisorBeanName, advisorDef);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            advisorBeanName = parserContext.getReaderContext().registerWithGeneratedName(advisorDef);<br>        &#125;<br><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">pointcut</span> <span class="hljs-operator">=</span> parsePointcutProperty(advisorElement, parserContext);<br>        <span class="hljs-keyword">if</span> (pointcut <span class="hljs-keyword">instanceof</span> BeanDefinition) &#123;<br>            advisorDef.getPropertyValues().add(POINTCUT, pointcut);<br>            parserContext.registerComponent(<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">AdvisorComponentDefinition</span>(advisorBeanName, advisorDef, (BeanDefinition) pointcut));<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pointcut <span class="hljs-keyword">instanceof</span> String) &#123;<br>            advisorDef.getPropertyValues().add(POINTCUT, <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeBeanReference</span>((String) pointcut));<br>            parserContext.registerComponent(<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">AdvisorComponentDefinition</span>(advisorBeanName, advisorDef));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-built_in">this</span>.parseState.pop();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Create a &#123;<span class="hljs-doctag">@link</span> RootBeanDefinition&#125; for the advisor described in the supplied. Does &lt;strong&gt;not&lt;/strong&gt;</span><br><span class="hljs-comment"> * parse any associated &#x27;&#123;<span class="hljs-doctag">@code</span> pointcut&#125;&#x27; or &#x27;&#123;<span class="hljs-doctag">@code</span> pointcut-ref&#125;&#x27; attributes.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> AbstractBeanDefinition <span class="hljs-title function_">createAdvisorBeanDefinition</span><span class="hljs-params">(Element advisorElement, ParserContext parserContext)</span> &#123;<br>    <span class="hljs-type">RootBeanDefinition</span> <span class="hljs-variable">advisorDefinition</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RootBeanDefinition</span>(DefaultBeanFactoryPointcutAdvisor.class);<br>    advisorDefinition.setSource(parserContext.extractSource(advisorElement));<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">adviceRef</span> <span class="hljs-operator">=</span> advisorElement.getAttribute(ADVICE_REF);<br>    <span class="hljs-keyword">if</span> (!StringUtils.hasText(adviceRef)) &#123;<br>        parserContext.getReaderContext().error(<br>                <span class="hljs-string">&quot;&#x27;advice-ref&#x27; attribute contains empty value.&quot;</span>, advisorElement, <span class="hljs-built_in">this</span>.parseState.snapshot());<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        advisorDefinition.getPropertyValues().add(<br>                ADVICE_BEAN_NAME, <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeBeanNameReference</span>(adviceRef));<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (advisorElement.hasAttribute(ORDER_PROPERTY)) &#123;<br>        advisorDefinition.getPropertyValues().add(<br>                ORDER_PROPERTY, advisorElement.getAttribute(ORDER_PROPERTY));<br>    &#125;<br>    <span class="hljs-comment">// 经过这一步，我们得到了一个有很多 PropertyValues 的 BeanDefinition，既没有 bean，也还没有 proxy</span><br>    <span class="hljs-keyword">return</span> advisorDefinition;<br>&#125;<br><br><span class="hljs-comment">// 解析切点的过程</span><br><span class="hljs-keyword">private</span> Object <span class="hljs-title function_">parsePointcutProperty</span><span class="hljs-params">(Element element, ParserContext parserContext)</span> &#123;<br>    <span class="hljs-keyword">if</span> (element.hasAttribute(POINTCUT) &amp;&amp; element.hasAttribute(POINTCUT_REF)) &#123;<br>        parserContext.getReaderContext().error(<br>                <span class="hljs-string">&quot;Cannot define both &#x27;pointcut&#x27; and &#x27;pointcut-ref&#x27; on &lt;advisor&gt; tag.&quot;</span>,<br>                element, <span class="hljs-built_in">this</span>.parseState.snapshot());<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (element.hasAttribute(POINTCUT)) &#123;<br>        <span class="hljs-comment">// Create a pointcut for the anonymous pc and register it.</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">expression</span> <span class="hljs-operator">=</span> element.getAttribute(POINTCUT);<br>        <span class="hljs-type">AbstractBeanDefinition</span> <span class="hljs-variable">pointcutDefinition</span> <span class="hljs-operator">=</span> createPointcutDefinition(expression);<br>        pointcutDefinition.setSource(parserContext.extractSource(element));<br>        <span class="hljs-keyword">return</span> pointcutDefinition;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (element.hasAttribute(POINTCUT_REF)) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">pointcutRef</span> <span class="hljs-operator">=</span> element.getAttribute(POINTCUT_REF);<br>        <span class="hljs-keyword">if</span> (!StringUtils.hasText(pointcutRef)) &#123;<br>            parserContext.getReaderContext().error(<br>                    <span class="hljs-string">&quot;&#x27;pointcut-ref&#x27; attribute contains empty value.&quot;</span>, element, <span class="hljs-built_in">this</span>.parseState.snapshot());<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pointcutRef;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        parserContext.getReaderContext().error(<br>                <span class="hljs-string">&quot;Must define one of &#x27;pointcut&#x27; or &#x27;pointcut-ref&#x27; on &lt;advisor&gt; tag.&quot;</span>,<br>                element, <span class="hljs-built_in">this</span>.parseState.snapshot());<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">protected</span> AbstractBeanDefinition <span class="hljs-title function_">createPointcutDefinition</span><span class="hljs-params">(String expression)</span> &#123;<br>    <span class="hljs-comment">// 从这里可以看出默认的点切表达式虽然没有涉及 AspectJ</span><br>    <span class="hljs-type">RootBeanDefinition</span> <span class="hljs-variable">beanDefinition</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RootBeanDefinition</span>(AspectJExpressionPointcut.class);<br>    beanDefinition.setScope(BeanDefinition.SCOPE_PROTOTYPE);<br>    beanDefinition.setSynthetic(<span class="hljs-literal">true</span>);<br>    beanDefinition.getPropertyValues().add(EXPRESSION, expression);<br>    <span class="hljs-keyword">return</span> beanDefinition;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="parserContext%E7%9A%84%E5%86%85%E5%AD%98%E5%BF%AB%E7%85%A7.jpg" alt="parserContext的内存快照"></p>
<p>beandefinition 里的配置，会最终导致某个 AopProxyFactory 创建的 bean 产生差异。</p>
<p>除此之外，还有其他我们常见的 xml 配置，而且他们对 proxy creator 的影响是相互的、全局的（只要有一个指定 AspectJ，就会导致全局 AspectJ）：</p>
<blockquote>
<p>To be clear, using proxy-target-class=“true” on<br>
<code>&lt;tx:annotation-driven/&gt;</code>, <code>&lt;aop:aspectj-autoproxy/&gt;</code>, or <code>&lt;aop:config/&gt;</code><br>
elements forces the use of CGLIB proxies for all three of them.</p>
</blockquote>
<p>由 Spring 自己根据上下文，决定生成 还是 ，当然，这个行为实际上是受<code>proxy-target-class=&quot;true</code>这一属性控制的。引述官方文档如下：</p>
<blockquote>
<p>If the target object to be proxied implements at least one interface<br>
then a JDK dynamic proxy will be used. All of the interfaces<br>
implemented by the target type will be proxied. If the target object<br>
does not implement any interfaces then a CGLIB proxy will be created.<br>
如果要代理的目标对象实现至少一个接口，则将使用JDK动态代理。 目标类型实现的所有接口都将被代理。<br>
如果目标对象未实现任何接口，则将创建CGLIB代理。</p>
</blockquote>
<p>proxy-target-class 的语义，恰好与 JdkDynamicAopProxy 的 proxy targe interface 的语义对应过来。可以这样理解，JdkDynamicAopProxy 是代理一个类型上的接口的子类，而 proxy-target-class 则意味着 cglib 代理的是这个类型自己的子类，所以 cglib 代理也可以注入进目标类型为接口的 bean，而 JdkDynamicAopProxy 不能注入目标类型为具体子类型的 bean（比如 xxxImpl）。</p>
<p>我们可以不再显式地引入 cglib 相关的 jar，从 Spring 3.2 开始，cglib 相关的 jar 已经被自动打包进 spring-core.jar 里面了。</p>
<p>DefinitionParsing 做完以后，我们只是得到 Definition，还没有进入 Proxy 创建的流程，Proxy 实际上是这样创建的：</p>
<p>上面的 loadBeanDefinition 做完了以后，就要通过 finishBeanFactoryInitialization 进行 createBean 的操作了。</p>
<p>基本操作在 AbstractBeanFactory.getBean -&gt; doGetBean -&gt; getSingleton -&gt;  getObject -&gt; createBean。</p>
<p>但配置类有多余的一步，在 postProcessBeanFactory 里调用 enhanceConfigurationClasses，专门为 ConfigClass （通常是 SpringBoot 的 Application）生成一个 Enhancer 支持的增强代理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ConfigurationClassPostProcessor 里</span><br><span class="hljs-type">ConfigurationClassEnhancer</span> <span class="hljs-variable">enhancer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConfigurationClassEnhancer</span>();<br>    <span class="hljs-keyword">for</span> (Map.Entry&lt;String, AbstractBeanDefinition&gt; entry : configBeanDefs.entrySet()) &#123;<br>        <span class="hljs-type">AbstractBeanDefinition</span> <span class="hljs-variable">beanDef</span> <span class="hljs-operator">=</span> entry.getValue();<br>        <span class="hljs-comment">// If a @Configuration class gets proxied, always proxy the target class</span><br>        beanDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);<br>        <span class="hljs-comment">// Set enhanced subclass of the user-specified bean class</span><br>        Class&lt;?&gt; configClass = beanDef.getBeanClass();<br>        Class&lt;?&gt; enhancedClass = enhancer.enhance(configClass, <span class="hljs-built_in">this</span>.beanClassLoader);<br>        <span class="hljs-keyword">if</span> (configClass != enhancedClass) &#123;<br>            <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>                logger.trace(String.format(<span class="hljs-string">&quot;Replacing bean definition &#x27;%s&#x27; existing class &#x27;%s&#x27; with &quot;</span> +<br>                        <span class="hljs-string">&quot;enhanced class &#x27;%s&#x27;&quot;</span>, entry.getKey(), configClass.getName(), enhancedClass.getName()));<br>            &#125;<br>            beanDef.setBeanClass(enhancedClass);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>SpringApplication 的 createBean 完成以后，还有 applyBeanPostProcessorsAfterInitialization 的操作，由 AnnotationAwareAspectJAutoProxyCreator 作为一个后处理器。applyBeanPostProcessorsAfterInitialization 操作完，bean 就被 wrap 成了一个 proxy。</p>
<p>AbstractAutoProxyCreator 是一个 SmartInstantiationAwareBeanPostProcessor，也就是 InstantiationAwareBeanPostProcessor，也就是 BeanPostProcessor。它的后处理流程如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessAfterInitialization</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Object bean, String beanName)</span> &#123;<br>    <span class="hljs-keyword">if</span> (bean != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">cacheKey</span> <span class="hljs-operator">=</span> getCacheKey(bean.getClass(), beanName);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;<br>            <span class="hljs-keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> bean;<br>&#125;<br><br><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">wrapIfNecessary</span><span class="hljs-params">(Object bean, String beanName, Object cacheKey)</span> &#123;<br>    <span class="hljs-keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="hljs-built_in">this</span>.targetSourcedBeans.contains(beanName)) &#123;<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (Boolean.FALSE.equals(<span class="hljs-built_in">this</span>.advisedBeans.get(cacheKey))) &#123;<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;<br>        <span class="hljs-built_in">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br><br>    <span class="hljs-comment">// 这个方法底层会搜索所有潜在的advisor，包括 Spring 风格的 advisor 和 AspectJ 风格的 advisor</span><br>    <span class="hljs-comment">// Create proxy if we have advice.</span><br>    Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="hljs-literal">null</span>);<br>    <span class="hljs-comment">// 通常各种 configuration bean 在这里会被跳过</span><br>    <span class="hljs-keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;<br>        <span class="hljs-built_in">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);<br>        <span class="hljs-comment">// 第一个进来的bean 是第一个符合 advisor 表达式的 bean，下一步可以下钻</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> createProxy(<br>                bean.getClass(), beanName, specificInterceptors, <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingletonTargetSource</span>(bean));<br>        <span class="hljs-built_in">this</span>.proxyTypes.put(cacheKey, proxy.getClass());<br>        <span class="hljs-keyword">return</span> proxy;<br>    &#125;<br><br>    <span class="hljs-built_in">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);<br>    <span class="hljs-keyword">return</span> bean;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">protected</span> Object[] getAdvicesAndAdvisorsForBean(<br>        Class&lt;?&gt; beanClass, String beanName, <span class="hljs-meta">@Nullable</span> TargetSource targetSource) &#123;<br>    <span class="hljs-comment">// 所有的 advisor 会在这里出现</span><br>    List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName);<br>    <span class="hljs-keyword">if</span> (advisors.isEmpty()) &#123;<br>        <span class="hljs-keyword">return</span> DO_NOT_PROXY;<br>    &#125;<br>    <span class="hljs-keyword">return</span> advisors.toArray();<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 这是更早获取候选 advisor 的地方，比 DefaultAdvisorChainFactory 更早</span><br><span class="hljs-comment"> * Find all eligible Advisors for auto-proxying this class.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> beanClass the clazz to find advisors for</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> beanName the name of the currently proxied bean</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the empty List, not &#123;<span class="hljs-doctag">@code</span> null&#125;,</span><br><span class="hljs-comment"> * if there are no pointcuts or interceptors</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> #findCandidateAdvisors</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> #sortAdvisors</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> #extendAdvisors</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> List&lt;Advisor&gt; <span class="hljs-title function_">findEligibleAdvisors</span><span class="hljs-params">(Class&lt;?&gt; beanClass, String beanName)</span> &#123;       <br>    <span class="hljs-comment">// 找出所有的 advisor</span><br>    List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();<br>    <span class="hljs-comment">// 把所有的 advisor 的 poincut 里的 classMatcher 对目标的 beanClass 过一遍</span><br>    List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);<br>    extendAdvisors(eligibleAdvisors);<br>    <span class="hljs-keyword">if</span> (!eligibleAdvisors.isEmpty()) &#123;<br>        eligibleAdvisors = sortAdvisors(eligibleAdvisors);<br>    &#125;<br>    <span class="hljs-keyword">return</span> eligibleAdvisors;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> List&lt;Advisor&gt; <span class="hljs-title function_">findCandidateAdvisors</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 非 aspectJ 的 advisor 在这里被发现</span><br>    <span class="hljs-comment">// Add all the Spring advisors found according to superclass rules.</span><br>    List&lt;Advisor&gt; advisors = <span class="hljs-built_in">super</span>.findCandidateAdvisors();<br>    <span class="hljs-comment">// Build Advisors for all AspectJ aspects in the bean factory.</span><br>    <span class="hljs-comment">// aspectJ 的 advisor 在这里被发现，通常我们会得到 InstantiationModelAwarePointcutAdvisorImpl，下面会讲到</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.aspectJAdvisorsBuilder != <span class="hljs-literal">null</span>) &#123;<br>        advisors.addAll(<span class="hljs-built_in">this</span>.aspectJAdvisorsBuilder.buildAspectJAdvisors());<br>    &#125;<br>    <span class="hljs-keyword">return</span> advisors;<br>&#125;<br><br><span class="hljs-comment">// 底层通过这个方法确认一个 advisor 是否可以匹配 targetClass</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canApply</span><span class="hljs-params">(Advisor advisor, Class&lt;?&gt; targetClass, <span class="hljs-type">boolean</span> hasIntroductions)</span> &#123;<br>    <span class="hljs-keyword">if</span> (advisor <span class="hljs-keyword">instanceof</span> IntroductionAdvisor) &#123;<br>        <span class="hljs-keyword">return</span> ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (advisor <span class="hljs-keyword">instanceof</span> PointcutAdvisor) &#123;<br>        <span class="hljs-type">PointcutAdvisor</span> <span class="hljs-variable">pca</span> <span class="hljs-operator">=</span> (PointcutAdvisor) advisor;<br>        <span class="hljs-comment">// 匹配算法：这个匹配算法解决了切点表达式的匹配问题</span><br>        <span class="hljs-keyword">return</span> canApply(pca.getPointcut(), targetClass, hasIntroductions);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// It doesn&#x27;t have a pointcut so we assume it applies.</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 下钻的方法是：</span><br><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">createProxy</span><span class="hljs-params">(Class&lt;?&gt; beanClass, <span class="hljs-meta">@Nullable</span> String beanName,</span><br><span class="hljs-params">        <span class="hljs-meta">@Nullable</span> Object[] specificInterceptors, TargetSource targetSource)</span> &#123;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.beanFactory <span class="hljs-keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;<br>        AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) <span class="hljs-built_in">this</span>.beanFactory, beanName, beanClass);<br>    &#125;<br><br>    <span class="hljs-comment">// 因为这里是抽象自动代理创建器的主干代码，我们可以认为所有的 advisor 都使用 ProxyFactory，而不是 AspectJProxyFactory，只要我们能够把 aspect 里的 method 封装成一个个 advice 和平凡的 advisor，我们就可以使用平凡的 ProxyFactory 来构建 aop 代理</span><br>    <span class="hljs-type">ProxyFactory</span> <span class="hljs-variable">proxyFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProxyFactory</span>();<br>    <span class="hljs-comment">// 所有 proxyFactory 都可要拷贝自另一个 AdvisedSupport，作为 config 的依据</span><br>    proxyFactory.copyFrom(<span class="hljs-built_in">this</span>);<br><br>    <span class="hljs-keyword">if</span> (proxyFactory.isProxyTargetClass()) &#123;<br>        <span class="hljs-comment">// Explicit handling of JDK proxy targets (for introduction advice scenarios)</span><br>        <span class="hljs-keyword">if</span> (Proxy.isProxyClass(beanClass)) &#123;<br>            <span class="hljs-comment">// Must allow for introductions; can&#x27;t just set interfaces to the proxy&#x27;s interfaces only.</span><br>            <span class="hljs-keyword">for</span> (Class&lt;?&gt; ifc : beanClass.getInterfaces()) &#123;<br>                proxyFactory.addInterface(ifc);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// No proxyTargetClass flag enforced, let&#x27;s apply our default checks...</span><br>        <span class="hljs-keyword">if</span> (shouldProxyTargetClass(beanClass, beanName)) &#123;<br>            proxyFactory.setProxyTargetClass(<span class="hljs-literal">true</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            evaluateProxyInterfaces(beanClass, proxyFactory);<br>        &#125;<br>    &#125;<br><br>    Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);<br>    proxyFactory.addAdvisors(advisors);<br>    proxyFactory.setTargetSource(targetSource);<br>    customizeProxyFactory(proxyFactory);<br><br>    proxyFactory.setFrozen(<span class="hljs-built_in">this</span>.freezeProxy);<br>    <span class="hljs-comment">// AbstractAutoProxyCreator 会在这一步总是返回 true</span><br>    <span class="hljs-keyword">if</span> (advisorsPreFiltered()) &#123;<br>        proxyFactory.setPreFiltered(<span class="hljs-literal">true</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// Use original ClassLoader if bean class not locally loaded in overriding class loader</span><br>    <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> getProxyClassLoader();<br>    <span class="hljs-keyword">if</span> (classLoader <span class="hljs-keyword">instanceof</span> SmartClassLoader &amp;&amp; classLoader != beanClass.getClassLoader()) &#123;<br>        classLoader = ((SmartClassLoader) classLoader).getOriginalClassLoader();<br>    &#125;<br>    <span class="hljs-comment">// 到这一步就进入 proxy 体系了</span><br>    <span class="hljs-keyword">return</span> proxyFactory.getProxy(classLoader);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>注意，使用 AspectJ 风格注解 @Aspect 的切面的初始化流程是这样的：</p>
<ol>
<li>任意 bean 的后处理器里有 AnnotationAwareAspectJAutoProxyCreator（如 ProxyTransactionManagementConfiguration 的 bean 后处理器里就有，把AutoProxyCreator 放进 bean 后处理器列表里是 Spring 的常见做法）。</li>
<li>最终调用链进入 BeanFactoryAspectJAdvisorsBuilder：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Advisor&gt; <span class="hljs-title function_">buildAspectJAdvisors</span><span class="hljs-params">()</span> &#123;<br>        List&lt;String&gt; aspectNames = <span class="hljs-built_in">this</span>.aspectBeanNames;<br><br>        <span class="hljs-keyword">if</span> (aspectNames == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>                aspectNames = <span class="hljs-built_in">this</span>.aspectBeanNames;<br>                <span class="hljs-keyword">if</span> (aspectNames == <span class="hljs-literal">null</span>) &#123;<br>                    List&lt;Advisor&gt; advisors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>                    aspectNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>                    String[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(<br>                            <span class="hljs-built_in">this</span>.beanFactory, Object.class, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);<br>                    <span class="hljs-keyword">for</span> (String beanName : beanNames) &#123;<br>                        <span class="hljs-keyword">if</span> (!isEligibleBean(beanName)) &#123;<br>                            <span class="hljs-keyword">continue</span>;<br>                        &#125;<br>                        <span class="hljs-comment">// We must be careful not to instantiate beans eagerly as in this case they</span><br>                        <span class="hljs-comment">// would be cached by the Spring container but would not have been weaved.</span><br>                        Class&lt;?&gt; beanType = <span class="hljs-built_in">this</span>.beanFactory.getType(beanName, <span class="hljs-literal">false</span>);<br>                        <span class="hljs-keyword">if</span> (beanType == <span class="hljs-literal">null</span>) &#123;<br>                            <span class="hljs-keyword">continue</span>;<br>                        &#125;<br>                        <span class="hljs-comment">// 这里差不多把所有的 Spring Bean 都遍历过了，只挑选带有 aspect 注解的 bean 出来</span><br>                        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.advisorFactory.isAspect(beanType)) &#123;<br>                            aspectNames.add(beanName);<br>                            <span class="hljs-type">AspectMetadata</span> <span class="hljs-variable">amd</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AspectMetadata</span>(beanType, beanName);<br>                            <span class="hljs-keyword">if</span> (amd.getAjType().getPerClause().getKind() == PerClauseKind.SINGLETON) &#123;<br>                                <span class="hljs-comment">// 生成一个特定的 MetadataAwareAspectInstanceFactory</span><br>                                <span class="hljs-type">MetadataAwareAspectInstanceFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span><br>                                        <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanFactoryAspectInstanceFactory</span>(<span class="hljs-built_in">this</span>.beanFactory, beanName);<br>                                List&lt;Advisor&gt; classAdvisors = <span class="hljs-built_in">this</span>.advisorFactory.getAdvisors(factory);<br>                                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.beanFactory.isSingleton(beanName)) &#123;<br>                                    <span class="hljs-built_in">this</span>.advisorsCache.put(beanName, classAdvisors);<br>                                &#125;<br>                                <span class="hljs-keyword">else</span> &#123;<br>                                    <span class="hljs-built_in">this</span>.aspectFactoryCache.put(beanName, factory);<br>                                &#125;<br>                                advisors.addAll(classAdvisors);<br>                            &#125;<br>                            <span class="hljs-keyword">else</span> &#123;<br>                                <span class="hljs-comment">// Per target or per this.</span><br>                                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.beanFactory.isSingleton(beanName)) &#123;<br>                                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Bean with name &#x27;&quot;</span> + beanName +<br>                                            <span class="hljs-string">&quot;&#x27; is a singleton, but aspect instantiation model is not singleton&quot;</span>);<br>                                &#125;<br>                                <span class="hljs-type">MetadataAwareAspectInstanceFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span><br>                                        <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrototypeAspectInstanceFactory</span>(<span class="hljs-built_in">this</span>.beanFactory, beanName);<br>                                <span class="hljs-built_in">this</span>.aspectFactoryCache.put(beanName, factory);<br>                                advisors.addAll(<span class="hljs-built_in">this</span>.advisorFactory.getAdvisors(factory));<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-built_in">this</span>.aspectBeanNames = aspectNames;<br>                    <span class="hljs-keyword">return</span> advisors;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (aspectNames.isEmpty()) &#123;<br>            <span class="hljs-keyword">return</span> Collections.emptyList();<br>        &#125;<br>        List&lt;Advisor&gt; advisors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String aspectName : aspectNames) &#123;<br>            List&lt;Advisor&gt; cachedAdvisors = <span class="hljs-built_in">this</span>.advisorsCache.get(aspectName);<br>            <span class="hljs-keyword">if</span> (cachedAdvisors != <span class="hljs-literal">null</span>) &#123;<br>                advisors.addAll(cachedAdvisors);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">MetadataAwareAspectInstanceFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.aspectFactoryCache.get(aspectName);<br>                advisors.addAll(<span class="hljs-built_in">this</span>.advisorFactory.getAdvisors(factory));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> advisors;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 这里使用</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> List&lt;Advisor&gt; <span class="hljs-title function_">getAdvisors</span><span class="hljs-params">(MetadataAwareAspectInstanceFactory aspectInstanceFactory)</span> &#123;<br>        Class&lt;?&gt; aspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">aspectName</span> <span class="hljs-operator">=</span> aspectInstanceFactory.getAspectMetadata().getAspectName();<br>        validate(aspectClass);<br><br>        <span class="hljs-comment">// We need to wrap the MetadataAwareAspectInstanceFactory with a decorator</span><br>        <span class="hljs-comment">// so that it will only instantiate once.</span><br>        <span class="hljs-type">MetadataAwareAspectInstanceFactory</span> <span class="hljs-variable">lazySingletonAspectInstanceFactory</span> <span class="hljs-operator">=</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">LazySingletonAspectInstanceFactoryDecorator</span>(aspectInstanceFactory);<br><br>        List&lt;Advisor&gt; advisors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 在这里根据每个 method 生成一个 advisor</span><br>        <span class="hljs-keyword">for</span> (Method method : getAdvisorMethods(aspectClass)) &#123;<br>            <span class="hljs-comment">// Prior to Spring Framework 5.2.7, advisors.size() was supplied as the declarationOrderInAspect</span><br>            <span class="hljs-comment">// to getAdvisor(...) to represent the &quot;current position&quot; in the declared methods list.</span><br>            <span class="hljs-comment">// However, since Java 7 the &quot;current position&quot; is not valid since the JDK no longer</span><br>            <span class="hljs-comment">// returns declared methods in the order in which they are declared in the source code.</span><br>            <span class="hljs-comment">// Thus, we now hard code the declarationOrderInAspect to 0 for all advice methods</span><br>            <span class="hljs-comment">// discovered via reflection in order to support reliable advice ordering across JVM launches.</span><br>            <span class="hljs-comment">// Specifically, a value of 0 aligns with the default value used in</span><br>            <span class="hljs-comment">// AspectJPrecedenceComparator.getAspectDeclarationOrder(Advisor).</span><br>            <span class="hljs-comment">// 这一步是把方法包装成 advisor 的流程</span><br>            <span class="hljs-type">Advisor</span> <span class="hljs-variable">advisor</span> <span class="hljs-operator">=</span> getAdvisor(method, lazySingletonAspectInstanceFactory, <span class="hljs-number">0</span>, aspectName);<br>            <span class="hljs-keyword">if</span> (advisor != <span class="hljs-literal">null</span>) &#123;<br>                advisors.add(advisor);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// If it&#x27;s a per target aspect, emit the dummy instantiating aspect.</span><br>        <span class="hljs-keyword">if</span> (!advisors.isEmpty() &amp;&amp; lazySingletonAspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) &#123;<br>            <span class="hljs-type">Advisor</span> <span class="hljs-variable">instantiationAdvisor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SyntheticInstantiationAdvisor</span>(lazySingletonAspectInstanceFactory);<br>            advisors.add(<span class="hljs-number">0</span>, instantiationAdvisor);<br>        &#125;<br><br>        <span class="hljs-comment">// Find introduction fields.</span><br>        <span class="hljs-keyword">for</span> (Field field : aspectClass.getDeclaredFields()) &#123;<br>            <span class="hljs-type">Advisor</span> <span class="hljs-variable">advisor</span> <span class="hljs-operator">=</span> getDeclareParentsAdvisor(field);<br>            <span class="hljs-keyword">if</span> (advisor != <span class="hljs-literal">null</span>) &#123;<br>                advisors.add(advisor);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> advisors;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 这个方法做完，就会产生一个全局的 advisor，再调用进 findCandidateAdvisors 就能看见这个 advisor 了，List&lt;Advisor&gt; cachedAdvisors = this.advisorsCache.get(aspectName);</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-meta">@Nullable</span><br>    <span class="hljs-keyword">public</span> Advisor <span class="hljs-title function_">getAdvisor</span><span class="hljs-params">(Method candidateAdviceMethod, MetadataAwareAspectInstanceFactory aspectInstanceFactory,</span><br><span class="hljs-params">            <span class="hljs-type">int</span> declarationOrderInAspect, String aspectName)</span> &#123;<br><br>        validate(aspectInstanceFactory.getAspectMetadata().getAspectClass());<br><br>        <span class="hljs-type">AspectJExpressionPointcut</span> <span class="hljs-variable">expressionPointcut</span> <span class="hljs-operator">=</span> getPointcut(<br>                candidateAdviceMethod, aspectInstanceFactory.getAspectMetadata().getAspectClass());<br>        <span class="hljs-keyword">if</span> (expressionPointcut == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">// 在这一步把 method 封装成 advisor，这个 advisor 能够提供 pointcut 和 advice 就够了</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstantiationModelAwarePointcutAdvisorImpl</span>(expressionPointcut, candidateAdviceMethod,<br>                <span class="hljs-built_in">this</span>, aspectInstanceFactory, declarationOrderInAspect, aspectName);<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>所以把 aspect 的若干个方法包装成若干个 advisor，是一个个 getAdvicesAndAdvisorsForBean 的方法调用链里实现的。所有的切点和 advisor 的匹配发生在这个方法里。</p>
<h3 id="获取候选-bean">获取候选 bean</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Find all eligible Advisor beans in the current bean factory,</span><br><span class="hljs-comment"> * ignoring FactoryBeans and excluding beans that are currently in creation.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the list of &#123;<span class="hljs-doctag">@link</span> org.springframework.aop.Advisor&#125; beans</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> #isEligibleBean</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> List&lt;Advisor&gt; <span class="hljs-title function_">findAdvisorBeans</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// Determine list of advisor bean names, if not cached already.</span><br>    String[] advisorNames = <span class="hljs-built_in">this</span>.cachedAdvisorBeanNames;<br>    <span class="hljs-keyword">if</span> (advisorNames == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span><br>        <span class="hljs-comment">// uninitialized to let the auto-proxy creator apply to them!</span><br>        advisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(<br>                <span class="hljs-built_in">this</span>.beanFactory, Advisor.class, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);<br>        <span class="hljs-built_in">this</span>.cachedAdvisorBeanNames = advisorNames;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (advisorNames.length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-comment">// advisors 在这里做最初的逐个匹配，只要不是创建中，都会在列表中返回</span><br>    List&lt;Advisor&gt; advisors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (String name : advisorNames) &#123;<br>        <span class="hljs-keyword">if</span> (isEligibleBean(name)) &#123;<br>            <span class="hljs-comment">// 如果存在一个环形依赖，则此处会返回 true，这个 advisor 就被无声抛弃了！</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.beanFactory.isCurrentlyInCreation(name)) &#123;<br>                <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>                    logger.trace(<span class="hljs-string">&quot;Skipping currently created advisor &#x27;&quot;</span> + name + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    advisors.add(<span class="hljs-built_in">this</span>.beanFactory.getBean(name, Advisor.class));<br>                &#125;<br>                <span class="hljs-keyword">catch</span> (BeanCreationException ex) &#123;<br>                    <span class="hljs-type">Throwable</span> <span class="hljs-variable">rootCause</span> <span class="hljs-operator">=</span> ex.getMostSpecificCause();<br>                    <span class="hljs-keyword">if</span> (rootCause <span class="hljs-keyword">instanceof</span> BeanCurrentlyInCreationException) &#123;<br>                        <span class="hljs-type">BeanCreationException</span> <span class="hljs-variable">bce</span> <span class="hljs-operator">=</span> (BeanCreationException) rootCause;<br>                        <span class="hljs-type">String</span> <span class="hljs-variable">bceBeanName</span> <span class="hljs-operator">=</span> bce.getBeanName();<br>                        <span class="hljs-keyword">if</span> (bceBeanName != <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-built_in">this</span>.beanFactory.isCurrentlyInCreation(bceBeanName)) &#123;<br>                            <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>                                logger.trace(<span class="hljs-string">&quot;Skipping advisor &#x27;&quot;</span> + name +<br>                                        <span class="hljs-string">&quot;&#x27; with dependency on currently created bean: &quot;</span> + ex.getMessage());<br>                            &#125;<br>                            <span class="hljs-comment">// Ignore: indicates a reference back to the bean we&#x27;re trying to advise.</span><br>                            <span class="hljs-comment">// We want to find advisors other than the currently created bean itself.</span><br>                            <span class="hljs-keyword">continue</span>;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">throw</span> ex;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> advisors;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果一个 advisor 依赖于一个 bean，又拦截一个 bean，这个 bean 在初始化时就要决定这个 advisor 是不是要拦截这个 bean，于是 advisor 的状态就是 inCreation。Spring 会无声抛弃这种 advisor，导致无法对这个 bean 产生拦截效果。</p>
<p>解决方法有：</p>
<ol>
<li>在 advisor 依赖这个 bean 的时候使用 @Lazy。</li>
<li>在拦截里引入闭包，在闭包里通过 applicationContext.getBean 来取这个 service，而非直接通过注解声明 IOC</li>
</ol>
<h2 id="proxy-体系">proxy 体系</h2>
<p>代表单一方法的一等公民类型 Advice/Interceptor，他们是围绕 joinpoint/invocation 进行操作。</p>
<p>Advice（marker interface，不带有方法） -&gt; Interceptor（marker interface，不带有方法） -&gt; MethodInterceptor（带有一个很重要的<code>invoke(MethodInvocation invocation)</code>方法，注意，这里要使用 aop 联盟的方法拦截器，而不能使用 cglib 的方法拦截器。同一级的继承树上还有个 Advice，但 Advice 本身只能被 adapter 到 MethodInterceptor 才能进入 advisor 链了） -&gt; XXXInterceptor（比如 TransactionInterceptor，这个类虽然远在 spring-tx.jar 里，它仍然继承正统的 aop MethodInterceptor）。</p>
<p>对于每一个 bean 的 proxy 而言，interceptor 是有 interceptor chain 的。</p>
<p>我们从外部看到的两类 aopproxy，它们共同实现的标记接口实际上是 AopProxy。<br>
AopProxy 并不是真正的一个 proxy，它只是一个接收 config，返回一个真正 proxy 的地方，所以外部的 proxy 工厂调用它的模式都是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">getProxy</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> (T) createAopProxy().getProxy();<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>**注意 CglibAopProxy 内部定义了大量的 MethodInterceptor 的静态子类，这些子类并不并不是 org.aopalliance.intercept.MethodInterceptor 的子类。**org.aopalliance是个神奇的包，它可以在<code>aopalliance:aopalliance:1.0:jar</code> 里找到，也可以在<code>spring-aop-5.3.15.jar</code>里找到。这两者语义是一样的，但作者却不一样-可以被认为因为使用了同一个 java package，所以彼此兼容。</p>
<p>ProxyTransactionManagementConfiguration 和基础的切面类，如 SpringApplication 类总会初始化 AspectJAdvisor 两次。</p>
<p>如果使用 xml 来声明 aspect，其实只是换了一种语法声明 advice：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">                http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">                http://www.springframework.org/schema/aop</span></span><br><span class="hljs-string"><span class="hljs-tag">                http://www.springframework.org/schema/aop/spring-aop-2.5.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;logging&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.magicliang.transaction.sys.aop.advice.LoggingAdvice&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;profilingAspect&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.magicliang.transaction.sys.aop.aspect.ProfilingAspect&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;profilingPointcut&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;within(com.magicliang.transaction.sys..*)&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span></span><br><span class="hljs-tag">                <span class="hljs-attr">pointcut</span>=<span class="hljs-string">&quot;within(com.magicliang.transaction.sys..*)&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;logging&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!-- 下面这个标签和上面这个标签都会导致 parseAdvice --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;profilingAspect&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">aop:around</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;profile&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;profilingPointcut&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 强制使用 cglib proxy 的一种方法 --&gt;</span><br>    <span class="hljs-comment">&lt;!--    &lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h3 id="基本的-proxy-工厂">基本的 proxy 工厂</h3>
<h4 id="proxyfactory">ProxyFactory</h4>
<p>再看一个编程声明 ProxyFactory 的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyFactoryTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1.创建代理工厂</span><br>        <span class="hljs-type">ProxyFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProxyFactory</span>();<br>        <span class="hljs-comment">// 2.设置目标对象</span><br>        factory.setTarget(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChromeBrowser</span>());<br>        <span class="hljs-comment">// 3.设置代理实现接口</span><br>        factory.setInterfaces(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Browser.class&#125;);<br>        <span class="hljs-comment">// 4.添加前置增强</span><br>        factory.addAdvice(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BrowserBeforeAdvice</span>());<br>        <span class="hljs-comment">// 5.添加后置增强</span><br>        factory.addAdvice(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BrowserAfterReturningAdvice</span>());<br>        <span class="hljs-comment">// 6.获取代理对象</span><br>        <span class="hljs-type">Browser</span> <span class="hljs-variable">browser</span> <span class="hljs-operator">=</span> (Browser) factory.getProxy();<br>        <br>        browser.visitInternet();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol>
<li>
<p>ProxyFactory的构造函数是空方法</p>
</li>
<li>
<p>setTarget时，将target对象封装成TargetSource对象，而调用的setTargetSource是AdvisedSupport的方法。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTarget</span><span class="hljs-params">(Object target)</span> &#123;<br>   setTargetSource(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SingletonTargetSource</span>(target));<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTargetSource</span><span class="hljs-params">(TargetSource targetSource)</span> &#123;<br>   <span class="hljs-comment">// 初始化的时候哪怕得到一个空对象是也要注入</span><br>   <span class="hljs-built_in">this</span>.targetSource = (targetSource != <span class="hljs-literal">null</span> ? targetSource : EMPTY_TARGET_SOURCE);<br>&#125;<br></code></pre></td></tr></table></figure>
<ol start="3">
<li>setInterfaces，赋值的也是AdvisedSupport中的interfaces属性，但是是先清空再赋值。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Set the interfaces to be proxied.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setInterfaces</span><span class="hljs-params">(Class&lt;?&gt;... interfaces)</span> &#123;<br>   Assert.notNull(interfaces, <span class="hljs-string">&quot;Interfaces must not be null&quot;</span>);<br>   <span class="hljs-comment">// 这里的 clear 需要注意好</span><br>   <span class="hljs-built_in">this</span>.interfaces.clear();<br>   <span class="hljs-keyword">for</span> (Class&lt;?&gt; ifc : interfaces) &#123;<br>       addInterface(ifc);<br>   &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Add a new proxied interface.</span><br><span class="hljs-comment"> * [<span class="hljs-doctag">@param</span>] intf the additional interface to proxy</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterface</span><span class="hljs-params">(Class&lt;?&gt; intf)</span> &#123;<br>   Assert.notNull(intf, <span class="hljs-string">&quot;Interface must not be null&quot;</span>);<br>   <span class="hljs-keyword">if</span> (!intf.isInterface()) &#123;<br>       <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;[&quot;</span> + intf.getName() + <span class="hljs-string">&quot;] is not an interface&quot;</span>);<br>   &#125;<br>   <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.interfaces.contains(intf)) &#123;<br>       <span class="hljs-built_in">this</span>.interfaces.add(intf);<br>       adviceChanged();<br>   &#125;<br>&#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Propagate advice change event to all AdvisedSupportListeners.</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@see</span> AdvisedSupportListener#adviceChanged</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">adviceChanged</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-built_in">super</span>.adviceChanged();<br>       <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>           <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.active) &#123;<br>               <span class="hljs-keyword">for</span> (AdvisedSupportListener listener : <span class="hljs-built_in">this</span>.listeners) &#123;<br>                   listener.adviceChanged(<span class="hljs-built_in">this</span>);<br>               &#125;<br>           &#125;<br>       &#125;<br>   &#125;<br>   <br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * super 的 adviceChanged 是清理缓存</span><br><span class="hljs-comment">    * Invoked when advice has changed.</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">adviceChanged</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-built_in">this</span>.methodCache.clear();<br>   &#125;<br><br></code></pre></td></tr></table></figure>
<ol start="4">
<li>addAdvice方法则是直接调用AdvisedSupport，将Advice封装成Advisor然后添加到advisors集合中。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addAdvice</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, Advice advice)</span> <span class="hljs-keyword">throws</span> AopConfigException &#123;<br>    Assert.notNull(advice, <span class="hljs-string">&quot;Advice must not be null&quot;</span>);<br>    <span class="hljs-comment">// 引用增强单独处理</span><br>    <span class="hljs-keyword">if</span> (advice <span class="hljs-keyword">instanceof</span> IntroductionInfo) &#123;<br>        <span class="hljs-comment">// We don&#x27;t need an IntroductionAdvisor for this kind of introduction:</span><br>        <span class="hljs-comment">// It&#x27;s fully self-describing.</span><br>        addAdvisor(pos, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultIntroductionAdvisor</span>(advice, (IntroductionInfo) advice));<br>    &#125;<br>    <span class="hljs-comment">// DynamicIntroductionAdvice不能单独添加，必须作为IntroductionAdvisor的一部分</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (advice <span class="hljs-keyword">instanceof</span> DynamicIntroductionAdvice) &#123;<br>        <span class="hljs-comment">// We need an IntroductionAdvisor for this kind of introduction.</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AopConfigException</span>(<span class="hljs-string">&quot;DynamicIntroductionAdvice may only be added as part of IntroductionAdvisor&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        addAdvisor(pos, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultPointcutAdvisor</span>(advice));<br>    &#125;<br> &#125;<br><br><span class="hljs-comment">// 我们可以添加 advice，也可以添加 advisor</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addAdvisor</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, Advisor advisor)</span> <span class="hljs-keyword">throws</span> AopConfigException &#123;<br>    <span class="hljs-keyword">if</span> (advisor <span class="hljs-keyword">instanceof</span> IntroductionAdvisor) &#123;<br>        validateIntroductionAdvisor((IntroductionAdvisor) advisor);<br>    &#125;<br>    addAdvisorInternal(pos, advisor);<br> &#125;<br><br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addAdvisorInternal</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, Advisor advisor)</span> <span class="hljs-keyword">throws</span> AopConfigException &#123;<br>    Assert.notNull(advisor, <span class="hljs-string">&quot;Advisor must not be null&quot;</span>);<br>    <span class="hljs-comment">// frozen 的用意就在这里了</span><br>    <span class="hljs-keyword">if</span> (isFrozen()) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AopConfigException</span>(<span class="hljs-string">&quot;Cannot add advisor: Configuration is frozen.&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (pos &gt; <span class="hljs-built_in">this</span>.advisors.size()) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<br>                <span class="hljs-string">&quot;Illegal position &quot;</span> + pos + <span class="hljs-string">&quot; in advisor list with size &quot;</span> + <span class="hljs-built_in">this</span>.advisors.size());<br>    &#125;<br>    <span class="hljs-comment">// 添加到advisor集合，这里底层使用 list 的 add size 接口</span><br>    <span class="hljs-built_in">this</span>.advisors.add(pos, advisor);<br>    updateAdvisorArray();<br>    <span class="hljs-comment">// 这一步底层依赖于 active 和 listener 数组两类属性</span><br>    adviceChanged();<br> &#125;<br></code></pre></td></tr></table></figure>
<p>上述的Advice都被封装成 DefaultPointcutAdvisor，可以看下其构造函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">DefaultPointcutAdvisor</span><span class="hljs-params">(Advice advice)</span> &#123;<br>    <span class="hljs-built_in">this</span>(Pointcut.TRUE, advice);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Pointcut.TRUE表示支持任何切入点。</strong></p>
<ol start="5">
<li>创建代理</li>
<li>准备工作做完了，直接通过getProxy方法获取代理对象。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getProxy</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 在这个调用路径下所有的 proxy（而不是 bean），都是 AopProxy，没有其他 proxy，但这个签名是 Object，而不是 AopProxy 这个接口。这里的 getProxy() 调用的就是 JdkDynamicAopProxy</span><br>    <span class="hljs-keyword">return</span> createAopProxy().getProxy();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里的createAopProxy()返回的是 AopProxy 类型，方法是 final，并且加了锁操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">synchronized</span> AopProxy <span class="hljs-title function_">createAopProxy</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.active) &#123;<br>        <span class="hljs-comment">// 通常这一步才是让这个 ProxyCreatorSupport 被激活</span><br>        activate();<br>    &#125;<br>    <span class="hljs-keyword">return</span> getAopProxyFactory().createAopProxy(<span class="hljs-built_in">this</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Activate this proxy configuration.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> AdvisedSupportListener#activated</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">activate</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.active = <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 在创建索引之前，先激活所有的 listener</span><br>    <span class="hljs-keyword">for</span> (AdvisedSupportListener listener : <span class="hljs-built_in">this</span>.listeners) &#123;<br>        listener.activated(<span class="hljs-built_in">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>注意，生成 proxy 的方法显示，ProxyFactory 自己还委托 AopProxyFactory，生成了AopProxy 以后，还要再取一层 Proxy。</p>
<p>可以清晰地看出，ProxyFactory.getProxy() -&gt; createAopProxy().getProxy() -&gt;  AopProxyFactory.createAopProxy-&gt; AopProxy.getProxy() -&gt; Proxy 之间的结构。</p>
<h5 id="defaultaopproxyfactory">DefaultAopProxyFactory</h5>
<p>ProxyCreatorSupport 的构造过程决定缺省的 AopProxyFactory 是 DefaultAopProxyFactory。</p>
<p>这个工厂实际上是 ProxyFactory 的基类的成员 aopProxyFactory，它的 createAopProxy 是最关键的方法：</p>
<ol>
<li>把 ProxyFactory 作为 AdvisedSupport 这一 config 生成</li>
<li>选择 JdkDynamicAopProxy 还是 ObjenesisCglibAopProxy 作为构造器</li>
</ol>
<p>它的关键方法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 通常我们不直接使用 ProxyConfig，而使用它的子类 AdvisedSupport</span><br><span class="hljs-comment"> * 这个构造器代表了经典的耦合关系，AopProxy 靠 AdvisedSupport 持有真实对象，请求都委托给它。这也体现了 Spring 的设计思想，proxy 持有 interceptor，proxy 或者 interceptor 持有或者继承 xxxSupport。具体的实现能力由 xxxSupport 支持，但 xxxSupport 不会被直接使用，各种外部类型自己实现自己场景下的接入方法。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> AopProxy <span class="hljs-title function_">createAopProxy</span><span class="hljs-params">(AdvisedSupport config)</span> <span class="hljs-keyword">throws</span> AopConfigException &#123;<br>    <span class="hljs-comment">// optimize=true或proxyTargetClass=true或接口集合为空，或者指定了要代理目标类</span><br>    <span class="hljs-keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;<br>        <span class="hljs-comment">// 这里得到的是最底层类的 class，和任何 super class 无关</span><br>        Class&lt;?&gt; targetClass = config.getTargetClass();<br>        <span class="hljs-keyword">if</span> (targetClass == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AopConfigException</span>(<span class="hljs-string">&quot;TargetSource cannot determine target class: &quot;</span> +<br>                    <span class="hljs-string">&quot;Either an interface or a target is required for proxy creation.&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 目标 class 为接口时可能生成 JdkDynamicAopProxy</span><br>        <span class="hljs-keyword">if</span> (targetClass.isInterface()) &#123;<br>                <span class="hljs-comment">// 代理类是可以直接 new 出来的，即 AdvisedSupport 带进来的 target 是接口或者 proxy（比如带有 @Bean 注解的 configuration 工厂方法，或者 com.sun.proxy$Proxy1，会导致即使配置了 ProxyTargetClass，也会生成基于接口的的 proxy）</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JdkDynamicAopProxy</span>(config);<br>        &#125;<br>        <span class="hljs-comment">// 但绝大多数情况下，生成的是 ObjenesisCglibAopProxy</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjenesisCglibAopProxy</span>(config);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 默认情况下也可能进入这个构造器</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JdkDynamicAopProxy</span>(config);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="jdkdynamicaopproxy">JdkDynamicAopProxy</h3>
<p>JdkDynamicAopProxy 的关键代码是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 保存 advisorChainFactory（有缓存，能够生成或者获取缓存里的 interceptor 列表）、interfaces、advisors、最重要的 targetSource 和其他 proxy 配置</span><br><span class="hljs-comment">/** Config used to configure this proxy */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AdvisedSupport advised;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 构造器</span><br><span class="hljs-comment">     * Construct a new JdkDynamicAopProxy for the given AOP configuration.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> config the AOP configuration as AdvisedSupport object</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> AopConfigException if the config is invalid. We try to throw an informative</span><br><span class="hljs-comment">     * exception in this case, rather than let a mysterious failure happen later.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">JdkDynamicAopProxy</span><span class="hljs-params">(AdvisedSupport config)</span> <span class="hljs-keyword">throws</span> AopConfigException &#123;<br>        Assert.notNull(config, <span class="hljs-string">&quot;AdvisedSupport must not be null&quot;</span>);<br>        <span class="hljs-keyword">if</span> (config.getAdvisorCount() == <span class="hljs-number">0</span> &amp;&amp; config.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AopConfigException</span>(<span class="hljs-string">&quot;No advisors and no TargetSource specified&quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">this</span>.advised = config;<br>        <span class="hljs-comment">// 这个 JdkDynamicAopProxy 实例里会保存“完整的”被代理接口列表</span><br>        <span class="hljs-built_in">this</span>.proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(<span class="hljs-built_in">this</span>.advised, <span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">// 校验接口里是否定义了 equals 和 hashCode</span><br>        findDefinedEqualsAndHashCodeMethods(<span class="hljs-built_in">this</span>.proxiedInterfaces);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 这个类的构造器只是初始化另一个工厂，getProxy 才是生成 JDK 的 proxy 的地方</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getProxy</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 由工具类获取类加载器，这个 classLoader 通常是 Launcher$AppClassLoader@12006 这样的实例</span><br>        <span class="hljs-keyword">return</span> getProxy(ClassUtils.getDefaultClassLoader());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getProxy</span><span class="hljs-params">(ClassLoader classLoader)</span> &#123;<br>        <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>            <span class="hljs-comment">// targetSource 还是对 Target 的封装，但这里是不能看见 source 的，target 本身还可以通过 getTarget 做一个是否 static 的抽象（）</span><br>            logger.debug(<span class="hljs-string">&quot;Creating JDK dynamic proxy: target source is &quot;</span> + <span class="hljs-built_in">this</span>.advised.getTargetSource());<br>        &#125;<br>        <span class="hljs-comment">// 反向调用 Proxy 的工厂方法</span><br>        <span class="hljs-keyword">return</span> Proxy.newProxyInstance(classLoader, proxiedInterfaces, <span class="hljs-built_in">this</span>);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 它的 hashCode 是素数累加的</span><br>        <span class="hljs-keyword">return</span> JdkDynamicAopProxy.class.hashCode() * <span class="hljs-number">13</span> + <span class="hljs-built_in">this</span>.advised.getTargetSource().hashCode();<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>JdkDynamicAopProxy 是把自己当做一个 InvocationHandler 放进 proxy 里的，所以调用到了 invoke 这里：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在调试这个代码的时候，需要在 getProxy 之后，在外部调用到特定的接口的方法的时候才能进来</span><br><span class="hljs-comment"> * 注意，对代理对象即使是调用 toString、hashCode 都会进入这个 invoke。这就是 invoke 必须兼容、解决的问题</span><br><span class="hljs-comment"> * 经典的 InvocationHanlder 实现</span><br><span class="hljs-comment"> * Implementation of &#123;<span class="hljs-doctag">@code</span> InvocationHandler.invoke&#125;.</span><br><span class="hljs-comment"> * &lt;p&gt;Callers will see exactly the exception thrown by the target,</span><br><span class="hljs-comment"> * unless a hook method throws an exception.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>    MethodInvocation invocation;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">oldProxy</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">setProxyContext</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-type">TargetSource</span> <span class="hljs-variable">targetSource</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.advised.targetSource;<br>    Class&lt;?&gt; targetClass = <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 如果相关规范是求等，就求等</span><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123;<br>            <span class="hljs-comment">// The target does not implement the equals(Object) method itself.</span><br>            <span class="hljs-keyword">return</span> equals(args[<span class="hljs-number">0</span>]);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) &#123;<br>            <span class="hljs-comment">// 否则，求散列值</span><br>            <span class="hljs-comment">// The target does not implement the hashCode() method itself.</span><br>            <span class="hljs-keyword">return</span> hashCode();<br>        &#125;<br>         <span class="hljs-comment">// 如果方法的声明类型是包装器代理（这种代理拥有一个方法，可以返回最底层的“根（ultimate）被代理对象”），则调用唯一的方法的目的就是获取被代理对象，就试图获取被代理对象</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.getDeclaringClass() == DecoratingProxy.class) &#123;<br>            <span class="hljs-comment">// There is only getDecoratedClass() declared -&gt; dispatch to proxy config.</span><br>            <span class="hljs-keyword">return</span><br>            <span class="hljs-comment">// getDecoratedClass() 等价于这个调用，目的都是获取目标类</span><br>            AopProxyUtils.ultimateTargetClass(<span class="hljs-built_in">this</span>.advised);<br>        &#125;<br>        <span class="hljs-comment">// 如果调用的是 Advised 的派生接口，且本类的 advised作为 proxy config 是不透明的（反射走入拦截器的入口之一，比较少走入），直接对 advised 对象进行反射调用，也就是在这里不解析 interceptor 链条</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp;<br>                method.getDeclaringClass().isAssignableFrom(Advised.class)) &#123;<br>            <span class="hljs-comment">// 使用反射调用目标方法，这是一个直接反射调用的好例子，以后其他人可以不必自己写了</span><br>            <span class="hljs-comment">// Service invocations on ProxyConfig with the proxy config...</span><br>            <span class="hljs-keyword">return</span> AopUtils.invokeJoinpointUsingReflection(<span class="hljs-built_in">this</span>.advised, method, args);<br>        &#125;<br>        <span class="hljs-comment">// 进入主要流程，这里才是大多数情况下的主要流程</span><br>        Object retVal;<br>        <span class="hljs-comment">// 先设置当前的代理进入上下文</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.advised.exposeProxy) &#123;<br>            <span class="hljs-comment">// Make invocation available if necessary.，把当前的 proxy 绑定进线程上下文里，因为这个invoke 是带有 proxy 的，所以这时候的 proxy 就是最新的 proxy</span><br>            oldProxy = AopContext.setCurrentProxy(proxy);<br>            setProxyContext = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 获取目标，尽可能晚获取目标对象，减少对对象的拥有时间以优化对象池的性能</span><br>        <span class="hljs-comment">// May be null. Get as late as possible to minimize the time we &quot;own&quot; the target,</span><br>        <span class="hljs-comment">// in case it comes from a pool.</span><br>        target = targetSource.getTarget();<br>        <span class="hljs-keyword">if</span> (target != <span class="hljs-literal">null</span>) &#123;<br>            targetClass = target.getClass();<br>        &#125;<br>        <br>        <span class="hljs-comment">// 获取拦截器链。如果进入这个底层方法，可以看出在 Spring 底层，interceptor ==  advisor</span><br>        <span class="hljs-comment">// Get the interception chain for this method.</span><br>        List&lt;Object&gt; chain = <span class="hljs-built_in">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);<br>        <br>        <span class="hljs-comment">// 如果我们没有任何的增强，则我们可以直接调用目标方法，不用制造 MethodInvocation 以制造性能问题</span><br>        <span class="hljs-comment">// Check whether we have any advice. If we don&#x27;t, we can fallback on direct</span><br>        <span class="hljs-comment">// reflective invocation of the target, and avoid creating a MethodInvocation.</span><br>        <span class="hljs-keyword">if</span> (chain.isEmpty()) &#123;<br>            <span class="hljs-comment">// We can skip creating a MethodInvocation: just invoke the target directly</span><br>            <span class="hljs-comment">// Note that the final invoker must be an InvokerInterceptor so we know it does</span><br>            <span class="hljs-comment">// nothing but a reflective operation on the target, and no hot swapping or fancy proxying.</span><br>            <span class="hljs-comment">// 如果有 varargs 相关的场景，适配 args 的数组的最后一个元素为方法的目标类型</span><br>            Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);<br>            <span class="hljs-comment">// 使用反射调用目标方法</span><br>            retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 使用 interceptorchain，制造一个方法调用- 即 MethodInvocation</span><br>            <span class="hljs-comment">// We need to create a method invocation...</span><br>            invocation = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReflectiveMethodInvocation</span>(proxy, target, method, args, targetClass, chain);<br>            <span class="hljs-comment">// Proceed to the joinpoint through the interceptor chain.</span><br>            <span class="hljs-comment">// 对它进行调用，这就是大部分的 procced 和 interceptor 之间的入口，所以栈帧里面有大量的 ReflectiveMethodInvocation.proceed()嵌套，最外层才是 JdkDynamicAopProxy 的 invoke</span><br>            retVal = invocation.proceed();<br>        &#125;<br>        <br>        <span class="hljs-comment">// 如果返回值是当前 proxy，返回 this 作为额外处理。对流式调用特别有用</span><br>        <span class="hljs-comment">// Massage return value if necessary.</span><br>        Class&lt;?&gt; returnType = method.getReturnType();<br>        <span class="hljs-keyword">if</span> (retVal != <span class="hljs-literal">null</span> &amp;&amp; retVal == target &amp;&amp;<br>                returnType != Object.class &amp;&amp; returnType.isInstance(proxy) &amp;&amp;<br>                !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) &#123;<br>            <span class="hljs-comment">// Special case: it returned &quot;this&quot; and the return type of the method</span><br>            <span class="hljs-comment">// is type-compatible. Note that we can&#x27;t help if the target sets</span><br>            <span class="hljs-comment">// a reference to itself in another returned object.</span><br>            retVal = proxy;<br>        &#125;<br>        <span class="hljs-comment">// 如果返回值为空而方法不期待空，则抛出异常</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (retVal == <span class="hljs-literal">null</span> &amp;&amp; returnType != Void.TYPE &amp;&amp; returnType.isPrimitive()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AopInvocationException</span>(<br>                    <span class="hljs-string">&quot;Null return value from advice does not match primitive return type for: &quot;</span> + method);<br>        &#125;<br>        <span class="hljs-keyword">return</span> retVal;<br>    &#125;<br>    <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 确定 targetSource 是不是静态的（即每次都返回同一个对象）</span><br>        <span class="hljs-keyword">if</span> (target != <span class="hljs-literal">null</span> &amp;&amp; !targetSource.isStatic()) &#123;<br>            <span class="hljs-comment">// Must have come from TargetSource.</span><br>            <span class="hljs-comment">// 如果是则释放 target</span><br>            targetSource.releaseTarget(target);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (setProxyContext) &#123;<br>            <span class="hljs-comment">// Restore old proxy.</span><br>            <span class="hljs-comment">// 运用备忘录还原老的代理</span><br>            AopContext.setCurrentProxy(oldProxy);<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在调用 DefaultAdvisorChainFactory 之前，先用 method cache 来尝试获取 advisor 列表</span><br><span class="hljs-comment"> * Determine a list of &#123;<span class="hljs-doctag">@link</span> org.aopalliance.intercept.MethodInterceptor&#125; objects</span><br><span class="hljs-comment"> * for the given method, based on this configuration.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> method the proxied method</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> targetClass the target class</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> a List of MethodInterceptors (may also include InterceptorAndDynamicMethodMatchers)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> List&lt;Object&gt; <span class="hljs-title function_">getInterceptorsAndDynamicInterceptionAdvice</span><span class="hljs-params">(Method method, <span class="hljs-meta">@Nullable</span> Class&lt;?&gt; targetClass)</span> &#123;<br>    <span class="hljs-type">MethodCacheKey</span> <span class="hljs-variable">cacheKey</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MethodCacheKey</span>(method);<br>    List&lt;Object&gt; cached = <span class="hljs-built_in">this</span>.methodCache.get(cacheKey);<br>    <span class="hljs-keyword">if</span> (cached == <span class="hljs-literal">null</span>) &#123;<br>        cached = <span class="hljs-built_in">this</span>.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(<br>                <span class="hljs-built_in">this</span>, method, targetClass);<br>        <span class="hljs-built_in">this</span>.methodCache.put(cacheKey, cached);<br>    &#125;<br>    <span class="hljs-keyword">return</span> cached;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="defaultadvisorchainfactory">DefaultAdvisorChainFactory</h4>
<p>在第一个方法里，我们可以看到某个方法是否被切面的 pcd 匹配，进而产生拦截。但在 findEligibleAdvisors 之后。</p>
<p>可以在这个方法内部设置一个条件断点，然后设置条件：<code>method.getName().contains(&quot;getCsrfToken&quot;)</code>。然后在指定的 advisor 执行到了以后，进行调试，走进 match 分支里。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">/**</span><br><span class="hljs-comment">      * 通过遍历所有的Advisor切面，如果是 PointcutAdvisor，则提取出 Pointcut，</span><br><span class="hljs-comment">      * 然后匹配当前类和方法是否适用。另外通过 AdvisorAdapterRegistry 切面</span><br><span class="hljs-comment">      * 注册适配器将 Advisor 中的 Advice 都封装成 MethodInteceptor 以方便形成拦</span><br><span class="hljs-comment">      * 截器链。</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> List&lt;Object&gt; <span class="hljs-title function_">getInterceptorsAndDynamicInterceptionAdvice</span><span class="hljs-params">(</span><br><span class="hljs-params">            Advised config, Method method, Class&lt;?&gt; targetClass)</span> &#123;<br><br>        <span class="hljs-comment">// This is somewhat tricky... We have to process introductions first,</span><br>        <span class="hljs-comment">// but we need to preserve order in the ultimate list.</span><br>        <span class="hljs-type">AdvisorAdapterRegistry</span> <span class="hljs-variable">registry</span> <span class="hljs-operator">=</span> GlobalAdvisorAdapterRegistry.getInstance();<br>        Advisor[] advisors = config.getAdvisors();<br>        List&lt;Object&gt; interceptorList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(advisors.length);<br>        Class&lt;?&gt; actualClass = (targetClass != <span class="hljs-literal">null</span> ? targetClass : method.getDeclaringClass());<br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">hasIntroductions</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-keyword">for</span> (Advisor advisor : advisors) &#123;<br>            <span class="hljs-keyword">if</span> (advisor <span class="hljs-keyword">instanceof</span> PointcutAdvisor) &#123;<br>                <span class="hljs-comment">// Add it conditionally.</span><br>                <span class="hljs-type">PointcutAdvisor</span> <span class="hljs-variable">pointcutAdvisor</span> <span class="hljs-operator">=</span> (PointcutAdvisor) advisor;<br>                <span class="hljs-keyword">if</span> (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass)) &#123;<br>                    <span class="hljs-type">MethodMatcher</span> <span class="hljs-variable">mm</span> <span class="hljs-operator">=</span> pointcutAdvisor.getPointcut().getMethodMatcher();<br>                    <span class="hljs-type">boolean</span> match;<br>                    <span class="hljs-keyword">if</span> (mm <span class="hljs-keyword">instanceof</span> IntroductionAwareMethodMatcher) &#123;<br>                        <span class="hljs-keyword">if</span> (hasIntroductions == <span class="hljs-literal">null</span>) &#123;<br>                            hasIntroductions = hasMatchingIntroductions(advisors, actualClass);<br>                        &#125;<br>                        match = ((IntroductionAwareMethodMatcher) mm).matches(method, actualClass, hasIntroductions);<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> &#123;<br>                        match = mm.matches(method, actualClass);<br>                    &#125;<br>                    <br>                    <span class="hljs-comment">// 所有的 match 最后走到这里，把 interceptor 链取出来，也就是说此时 pointcut 已经无用了，前面的 match 过程已经用完 pointcut 了</span><br>                    <span class="hljs-keyword">if</span> (match) &#123;<br>                        MethodInterceptor[] interceptors = registry.getInterceptors(advisor);<br>                        <span class="hljs-keyword">if</span> (mm.isRuntime()) &#123;<br>                            <span class="hljs-comment">// Creating a new object instance in the getInterceptors() method</span><br>                            <span class="hljs-comment">// isn&#x27;t a problem as we normally cache created chains.</span><br>                            <span class="hljs-keyword">for</span> (MethodInterceptor interceptor : interceptors) &#123;<br>                                interceptorList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InterceptorAndDynamicMethodMatcher</span>(interceptor, mm));<br>                            &#125;<br>                        &#125;<br>                        <span class="hljs-keyword">else</span> &#123;<br>                            interceptorList.addAll(Arrays.asList(interceptors));<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (advisor <span class="hljs-keyword">instanceof</span> IntroductionAdvisor) &#123;<br>                <span class="hljs-type">IntroductionAdvisor</span> <span class="hljs-variable">ia</span> <span class="hljs-operator">=</span> (IntroductionAdvisor) advisor;<br>                <span class="hljs-keyword">if</span> (config.isPreFiltered() || ia.getClassFilter().matches(actualClass)) &#123;<br>                    Interceptor[] interceptors = registry.getInterceptors(advisor);<br>                    interceptorList.addAll(Arrays.asList(interceptors));<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                Interceptor[] interceptors = registry.getInterceptors(advisor);<br>                interceptorList.addAll(Arrays.asList(interceptors));<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> interceptorList;<br>    &#125;<br>    <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * registry.getInterceptors 是从 advisor 里取出默认 interceptor，这个地方最微妙了：这说明了一点很重要的设计思想，Spring 认为所有的原生 advice，应该被适配为 Interceptor</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> MethodInterceptor[] getInterceptors(Advisor advisor) <span class="hljs-keyword">throws</span> UnknownAdviceTypeException &#123;<br>        List&lt;MethodInterceptor&gt; interceptors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(<span class="hljs-number">3</span>);<br>        <span class="hljs-comment">// method 要 interceptor 化，其实是从 advisor 里把 advice 取出来的过程</span><br>        <span class="hljs-type">Advice</span> <span class="hljs-variable">advice</span> <span class="hljs-operator">=</span> advisor.getAdvice();<br>        <span class="hljs-comment">// 如果 advice 天然是 MethodInterceptor</span><br>        <span class="hljs-keyword">if</span> (advice <span class="hljs-keyword">instanceof</span> MethodInterceptor) &#123;<br>            <span class="hljs-comment">// 取出来要加入 list 中</span><br>            interceptors.add((MethodInterceptor) advice);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (AdvisorAdapter adapter : <span class="hljs-built_in">this</span>.adapters) &#123;<br>            <span class="hljs-comment">// 否则，用三种 adaptor 来转化 advisor 为 interceptor：MethodBeforeAdviceAdapter、AfterReturningAdviceAdapter、ThrowsAdviceAdapter，所以不用原始的 advice 也可以。所以 interceptor 可以转化为原始的 advice，但不是所有的 advice 都是 interceptor，有些古老的 advice 就只是 advice 而已</span><br>            <span class="hljs-keyword">if</span> (adapter.supportsAdvice(advice)) &#123;<br>                interceptors.add(adapter.getInterceptor(advisor));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (interceptors.isEmpty()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnknownAdviceTypeException</span>(advisor.getAdvice());<br>        &#125;<br>        <span class="hljs-keyword">return</span> interceptors.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MethodInterceptor</span>[<span class="hljs-number">0</span>]);<br>    &#125;<br>    <br><span class="hljs-comment">// 从 advice 转化为 interceptor 的方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AfterReturningAdviceAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AdvisorAdapter</span>, Serializable &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">supportsAdvice</span><span class="hljs-params">(Advice advice)</span> &#123;<br>        <span class="hljs-keyword">return</span> (advice <span class="hljs-keyword">instanceof</span> AfterReturningAdvice);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> MethodInterceptor <span class="hljs-title function_">getInterceptor</span><span class="hljs-params">(Advisor advisor)</span> &#123;<br>        <span class="hljs-type">AfterReturningAdvice</span> <span class="hljs-variable">advice</span> <span class="hljs-operator">=</span> (AfterReturningAdvice) advisor.getAdvice();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AfterReturningAdviceInterceptor</span>(advice);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="reflectivemethodinvocation">ReflectiveMethodInvocation</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 关键方法 1，构造器</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Construct a new ReflectiveMethodInvocation with the given arguments.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> proxy the proxy object that the invocation was made on</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> target the target object to invoke</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> method the method to invoke</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> arguments the arguments to invoke the method with</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> targetClass the target class, for MethodMatcher invocations</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> interceptorsAndDynamicMethodMatchers interceptors that should be applied,</span><br><span class="hljs-comment">     * along with any InterceptorAndDynamicMethodMatchers that need evaluation at runtime.</span><br><span class="hljs-comment">     * MethodMatchers included in this struct must already have been found to have matched</span><br><span class="hljs-comment">     * as far as was possibly statically. Passing an array might be about 10% faster,</span><br><span class="hljs-comment">     * but would complicate the code. And it would work only for static pointcuts.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">ReflectiveMethodInvocation</span><span class="hljs-params">(</span><br><span class="hljs-params">            Object proxy, <span class="hljs-meta">@Nullable</span> Object target, Method method, <span class="hljs-meta">@Nullable</span> Object[] arguments,</span><br><span class="hljs-params">            <span class="hljs-meta">@Nullable</span> Class&lt;?&gt; targetClass, List&lt;Object&gt; interceptorsAndDynamicMethodMatchers)</span> &#123;<br><br>        <span class="hljs-built_in">this</span>.proxy = proxy;<br>        <span class="hljs-built_in">this</span>.target = target;<br>        <span class="hljs-comment">// 在内层的 targetClass 已经毫无花巧，全然是 target 的 class 了</span><br>        <span class="hljs-built_in">this</span>.targetClass = targetClass;<br>        <span class="hljs-comment">// 这里实现了方法的桥接，这是 java5 才有的特性</span><br>        <span class="hljs-built_in">this</span>.method = BridgeMethodResolver.findBridgedMethod(method);<br>        <span class="hljs-comment">// 这里实现了参数的适配</span><br>        <span class="hljs-built_in">this</span>.arguments = AopProxyUtils.adaptArgumentsIfNecessary(method, arguments);<br>        <span class="hljs-built_in">this</span>.interceptorsAndDynamicMethodMatchers = interceptorsAndDynamicMethodMatchers;<br>    &#125;<br><span class="hljs-comment">// 关键方法 2：执行调用的流程</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-meta">@Nullable</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">proceed</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-comment">// 递归到尽头以后，真正的原始方法在这里进入</span><br>        <span class="hljs-comment">// We start with an index of -1 and increment early.</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.currentInterceptorIndex == <span class="hljs-built_in">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> invokeJoinpoint();<br>        &#125;<br>        <span class="hljs-comment">// 这个 invocation 是有状态的，按照顺序调用 advice</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">interceptorOrInterceptionAdvice</span> <span class="hljs-operator">=</span><br>                <span class="hljs-built_in">this</span>.interceptorsAndDynamicMethodMatchers.get(++<span class="hljs-built_in">this</span>.currentInterceptorIndex);<br>        <span class="hljs-keyword">if</span> (interceptorOrInterceptionAdvice <span class="hljs-keyword">instanceof</span> InterceptorAndDynamicMethodMatcher) &#123;<br>            <span class="hljs-comment">// Evaluate dynamic method matcher here: static part will already have</span><br>            <span class="hljs-comment">// been evaluated and found to match.</span><br>            <span class="hljs-type">InterceptorAndDynamicMethodMatcher</span> <span class="hljs-variable">dm</span> <span class="hljs-operator">=</span><br>                    (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;<br>            Class&lt;?&gt; targetClass = (<span class="hljs-built_in">this</span>.targetClass != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">this</span>.targetClass : <span class="hljs-built_in">this</span>.method.getDeclaringClass());<br>            <span class="hljs-keyword">if</span> (dm.methodMatcher.matches(<span class="hljs-built_in">this</span>.method, targetClass, <span class="hljs-built_in">this</span>.arguments)) &#123;<br>                <span class="hljs-keyword">return</span> dm.interceptor.invoke(<span class="hljs-built_in">this</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// Dynamic matching failed.</span><br>                <span class="hljs-comment">// Skip this interceptor and invoke the next in the chain.</span><br>                <span class="hljs-keyword">return</span> proceed();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 通常的 MethodInterceptor 会进入这里，注意，这里有一个很巧妙的设计，MethodInterceptor 的方法是 MethodInvocation，而 MethodInvocation 则可以调用 MethodInterceptor</span><br>            <span class="hljs-comment">// It&#x27;s an interceptor, so we just invoke it: The pointcut will have</span><br>            <span class="hljs-comment">// been evaluated statically before this object was constructed.</span><br>            <br>            <span class="hljs-comment">// Spring 的重要设计来了，MI 的 proceed 和 invokeJoinpoint 是无参的，但 interceptor 的 invoke 都有一个 MI 作为参数</span><br>            <span class="hljs-keyword">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(<span class="hljs-built_in">this</span>);<br>        &#125;<br>    &#125;<br>    <br><span class="hljs-comment">// 在 MethodInterceptor 内部实现了这样的逻辑</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-meta">@Nullable</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(MethodInvocation mi)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-comment">// 在这一步实现了对 MethodInvocation 的再调用，这就实现了一种交错的递归，而再调用的时候 mi 内部的状态 currentInterceptorIndex 已经变了。真正的调用链是由递归来实现的</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">retVal</span> <span class="hljs-operator">=</span> mi.proceed();<br>        <span class="hljs-built_in">this</span>.advice.afterReturning(retVal, mi.getMethod(), mi.getArguments(), mi.getThis());<br>        <span class="hljs-keyword">return</span> retVal;<br>    &#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Invoke the joinpoint using reflection.</span><br><span class="hljs-comment">     * Subclasses can override this to use custom invocation.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the return value of the joinpoint</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Throwable if invoking the joinpoint resulted in an exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Nullable</span><br>    <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">invokeJoinpoint</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-comment">// 它底层还是使用了这个反射方法，在 MI 内部，jointpoint 不是自己，而是自己的 target 了</span><br>        <span class="hljs-keyword">return</span> AopUtils.invokeJoinpointUsingReflection(<span class="hljs-built_in">this</span>.target, <span class="hljs-built_in">this</span>.method, <span class="hljs-built_in">this</span>.arguments);<br>    &#125;<br></code></pre></td></tr></table></figure>
<h3 id="aoputils">AopUtils</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AopUtils</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Check whether the given object is a JDK dynamic proxy or a CGLIB proxy.</span><br><span class="hljs-comment">     * &lt;p&gt;This method additionally checks if the given object is an instance</span><br><span class="hljs-comment">     * of &#123;<span class="hljs-doctag">@link</span> SpringProxy&#125;.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> object the object to check</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> #isJdkDynamicAopProxy</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> #isCglibProxy</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAopProxy</span><span class="hljs-params">(Object object)</span> &#123;<br>        <span class="hljs-keyword">return</span> (object <span class="hljs-keyword">instanceof</span> SpringProxy &amp;&amp;<br>                (Proxy.isProxyClass(object.getClass()) || ClassUtils.isCglibProxyClass(object.getClass())));<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Check whether the given object is a JDK dynamic proxy.</span><br><span class="hljs-comment">     * &lt;p&gt;This method goes beyond the implementation of</span><br><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@link</span> Proxy#isProxyClass(Class)&#125; by additionally checking if the</span><br><span class="hljs-comment">     * given object is an instance of &#123;<span class="hljs-doctag">@link</span> SpringProxy&#125;.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> object the object to check</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> java.lang.reflect.Proxy#isProxyClass</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isJdkDynamicAopProxy</span><span class="hljs-params">(Object object)</span> &#123;<br>        <span class="hljs-keyword">return</span> (object <span class="hljs-keyword">instanceof</span> SpringProxy &amp;&amp; Proxy.isProxyClass(object.getClass()));<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Check whether the given object is a CGLIB proxy.</span><br><span class="hljs-comment">     * &lt;p&gt;This method goes beyond the implementation of</span><br><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@link</span> ClassUtils#isCglibProxy(Object)&#125; by additionally checking if</span><br><span class="hljs-comment">     * the given object is an instance of &#123;<span class="hljs-doctag">@link</span> SpringProxy&#125;.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> object the object to check</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> ClassUtils#isCglibProxy(Object)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCglibProxy</span><span class="hljs-params">(Object object)</span> &#123;<br>        <span class="hljs-keyword">return</span> (object <span class="hljs-keyword">instanceof</span> SpringProxy &amp;&amp; ClassUtils.isCglibProxy(object));<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Determine the target class of the given bean instance which might be an AOP proxy.</span><br><span class="hljs-comment">     * &lt;p&gt;Returns the target class for an AOP proxy or the plain class otherwise.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> candidate the instance to check (might be an AOP proxy)</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the target class (or the plain class of the given object as fallback;</span><br><span class="hljs-comment">     * never &#123;<span class="hljs-doctag">@code</span> null&#125;)</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> org.springframework.aop.TargetClassAware#getTargetClass()</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> org.springframework.aop.framework.AopProxyUtils#ultimateTargetClass(Object)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Class&lt;?&gt; getTargetClass(Object candidate) &#123;<br>        Assert.notNull(candidate, <span class="hljs-string">&quot;Candidate object must not be null&quot;</span>);<br>        Class&lt;?&gt; result = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (candidate <span class="hljs-keyword">instanceof</span> TargetClassAware) &#123;<br>            result = ((TargetClassAware) candidate).getTargetClass();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (result == <span class="hljs-literal">null</span>) &#123;<br>            result = (isCglibProxy(candidate) ? candidate.getClass().getSuperclass() : candidate.getClass());<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Select an invocable method on the target type: either the given method itself</span><br><span class="hljs-comment">     * if actually exposed on the target type, or otherwise a corresponding method</span><br><span class="hljs-comment">     * on one of the target type&#x27;s interfaces or on the target type itself.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> method the method to check</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> targetType the target type to search methods on (typically an AOP proxy)</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> a corresponding invocable method on the target type</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IllegalStateException if the given method is not invocable on the given</span><br><span class="hljs-comment">     * target type (typically due to a proxy mismatch)</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span> 4.3</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> MethodIntrospector#selectInvocableMethod(Method, Class)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Method <span class="hljs-title function_">selectInvocableMethod</span><span class="hljs-params">(Method method, Class&lt;?&gt; targetType)</span> &#123;<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">methodToUse</span> <span class="hljs-operator">=</span> MethodIntrospector.selectInvocableMethod(method, targetType);<br>        <span class="hljs-keyword">if</span> (Modifier.isPrivate(methodToUse.getModifiers()) &amp;&amp; !Modifier.isStatic(methodToUse.getModifiers()) &amp;&amp;<br>                SpringProxy.class.isAssignableFrom(targetType)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(String.format(<br>                    <span class="hljs-string">&quot;Need to invoke method &#x27;%s&#x27; found on proxy for target class &#x27;%s&#x27; but cannot &quot;</span> +<br>                    <span class="hljs-string">&quot;be delegated to target bean. Switch its visibility to package or protected.&quot;</span>,<br>                    method.getName(), method.getDeclaringClass().getSimpleName()));<br>        &#125;<br>        <span class="hljs-keyword">return</span> methodToUse;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Determine whether the given method is an &quot;equals&quot; method.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> java.lang.Object#equals</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEqualsMethod</span><span class="hljs-params">(Method method)</span> &#123;<br>        <span class="hljs-keyword">return</span> ReflectionUtils.isEqualsMethod(method);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Determine whether the given method is a &quot;hashCode&quot; method.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> java.lang.Object#hashCode</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHashCodeMethod</span><span class="hljs-params">(Method method)</span> &#123;<br>        <span class="hljs-keyword">return</span> ReflectionUtils.isHashCodeMethod(method);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Determine whether the given method is a &quot;toString&quot; method.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> java.lang.Object#toString()</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isToStringMethod</span><span class="hljs-params">(Method method)</span> &#123;<br>        <span class="hljs-keyword">return</span> ReflectionUtils.isToStringMethod(method);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Determine whether the given method is a &quot;finalize&quot; method.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> java.lang.Object#finalize()</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFinalizeMethod</span><span class="hljs-params">(Method method)</span> &#123;<br>        <span class="hljs-keyword">return</span> (method != <span class="hljs-literal">null</span> &amp;&amp; method.getName().equals(<span class="hljs-string">&quot;finalize&quot;</span>) &amp;&amp;<br>                method.getParameterTypes().length == <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Given a method, which may come from an interface, and a target class used</span><br><span class="hljs-comment">     * in the current AOP invocation, find the corresponding target method if there</span><br><span class="hljs-comment">     * is one. E.g. the method may be &#123;<span class="hljs-doctag">@code</span> IFoo.bar()&#125; and the target class</span><br><span class="hljs-comment">     * may be &#123;<span class="hljs-doctag">@code</span> DefaultFoo&#125;. In this case, the method may be</span><br><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@code</span> DefaultFoo.bar()&#125;. This enables attributes on that method to be found.</span><br><span class="hljs-comment">     * &lt;p&gt;&lt;b&gt;<span class="hljs-doctag">NOTE:</span>&lt;/b&gt; In contrast to &#123;<span class="hljs-doctag">@link</span> org.springframework.util.ClassUtils#getMostSpecificMethod&#125;,</span><br><span class="hljs-comment">     * this method resolves Java 5 bridge methods in order to retrieve attributes</span><br><span class="hljs-comment">     * from the &lt;i&gt;original&lt;/i&gt; method definition.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> method the method to be invoked, which may come from an interface</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> targetClass the target class for the current invocation.</span><br><span class="hljs-comment">     * May be &#123;<span class="hljs-doctag">@code</span> null&#125; or may not even implement the method.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the specific target method, or the original method if the</span><br><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@code</span> targetClass&#125; doesn&#x27;t implement it or is &#123;<span class="hljs-doctag">@code</span> null&#125;</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> org.springframework.util.ClassUtils#getMostSpecificMethod</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Method <span class="hljs-title function_">getMostSpecificMethod</span><span class="hljs-params">(Method method, Class&lt;?&gt; targetClass)</span> &#123;<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">resolvedMethod</span> <span class="hljs-operator">=</span> ClassUtils.getMostSpecificMethod(method, targetClass);<br>        <span class="hljs-comment">// If we are dealing with method with generic parameters, find the original method.</span><br>        <span class="hljs-keyword">return</span> BridgeMethodResolver.findBridgedMethod(resolvedMethod);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Can the given pointcut apply at all on the given class?</span><br><span class="hljs-comment">     * &lt;p&gt;This is an important test as it can be used to optimize</span><br><span class="hljs-comment">     * out a pointcut for a class.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> pc the static or dynamic pointcut to check</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> targetClass the class to test</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> whether the pointcut can apply on any method</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canApply</span><span class="hljs-params">(Pointcut pc, Class&lt;?&gt; targetClass)</span> &#123;<br>        <span class="hljs-keyword">return</span> canApply(pc, targetClass, <span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Can the given pointcut apply at all on the given class?</span><br><span class="hljs-comment">     * &lt;p&gt;This is an important test as it can be used to optimize</span><br><span class="hljs-comment">     * out a pointcut for a class.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> pc the static or dynamic pointcut to check</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> targetClass the class to test</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> hasIntroductions whether or not the advisor chain</span><br><span class="hljs-comment">     * for this bean includes any introductions</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> whether the pointcut can apply on any method</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canApply</span><span class="hljs-params">(Pointcut pc, Class&lt;?&gt; targetClass, <span class="hljs-type">boolean</span> hasIntroductions)</span> &#123;<br>        Assert.notNull(pc, <span class="hljs-string">&quot;Pointcut must not be null&quot;</span>);<br>        <span class="hljs-keyword">if</span> (!pc.getClassFilter().matches(targetClass)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-type">MethodMatcher</span> <span class="hljs-variable">methodMatcher</span> <span class="hljs-operator">=</span> pc.getMethodMatcher();<br>        <span class="hljs-keyword">if</span> (methodMatcher == MethodMatcher.TRUE) &#123;<br>            <span class="hljs-comment">// No need to iterate the methods if we&#x27;re matching any method anyway...</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-type">IntroductionAwareMethodMatcher</span> <span class="hljs-variable">introductionAwareMethodMatcher</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (methodMatcher <span class="hljs-keyword">instanceof</span> IntroductionAwareMethodMatcher) &#123;<br>            introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher;<br>        &#125;<br><br>        Set&lt;Class&lt;?&gt;&gt; classes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;Class&lt;?&gt;&gt;(ClassUtils.getAllInterfacesForClassAsSet(targetClass));<br>        classes.add(targetClass);<br>        <span class="hljs-keyword">for</span> (Class&lt;?&gt; clazz : classes) &#123;<br>            Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz);<br>            <span class="hljs-keyword">for</span> (Method method : methods) &#123;<br>                <span class="hljs-keyword">if</span> ((introductionAwareMethodMatcher != <span class="hljs-literal">null</span> &amp;&amp;<br>                        introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions)) ||<br>                        methodMatcher.matches(method, targetClass)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Can the given advisor apply at all on the given class?</span><br><span class="hljs-comment">     * This is an important test as it can be used to optimize</span><br><span class="hljs-comment">     * out a advisor for a class.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> advisor the advisor to check</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> targetClass class we&#x27;re testing</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> whether the pointcut can apply on any method</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canApply</span><span class="hljs-params">(Advisor advisor, Class&lt;?&gt; targetClass)</span> &#123;<br>        <span class="hljs-keyword">return</span> canApply(advisor, targetClass, <span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Can the given advisor apply at all on the given class?</span><br><span class="hljs-comment">     * &lt;p&gt;This is an important test as it can be used to optimize out a advisor for a class.</span><br><span class="hljs-comment">     * This version also takes into account introductions (for IntroductionAwareMethodMatchers).</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> advisor the advisor to check</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> targetClass class we&#x27;re testing</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> hasIntroductions whether or not the advisor chain for this bean includes</span><br><span class="hljs-comment">     * any introductions</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> whether the pointcut can apply on any method</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canApply</span><span class="hljs-params">(Advisor advisor, Class&lt;?&gt; targetClass, <span class="hljs-type">boolean</span> hasIntroductions)</span> &#123;<br>        <span class="hljs-keyword">if</span> (advisor <span class="hljs-keyword">instanceof</span> IntroductionAdvisor) &#123;<br>            <span class="hljs-keyword">return</span> ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (advisor <span class="hljs-keyword">instanceof</span> PointcutAdvisor) &#123;<br>            <span class="hljs-type">PointcutAdvisor</span> <span class="hljs-variable">pca</span> <span class="hljs-operator">=</span> (PointcutAdvisor) advisor;<br>            <span class="hljs-keyword">return</span> canApply(pca.getPointcut(), targetClass, hasIntroductions);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// It doesn&#x27;t have a pointcut so we assume it applies.</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Determine the sublist of the &#123;<span class="hljs-doctag">@code</span> candidateAdvisors&#125; list</span><br><span class="hljs-comment">     * that is applicable to the given class.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> candidateAdvisors the Advisors to evaluate</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> clazz the target class</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> sublist of Advisors that can apply to an object of the given class</span><br><span class="hljs-comment">     * (may be the incoming List as-is)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Advisor&gt; <span class="hljs-title function_">findAdvisorsThatCanApply</span><span class="hljs-params">(List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; clazz)</span> &#123;<br>        <span class="hljs-keyword">if</span> (candidateAdvisors.isEmpty()) &#123;<br>            <span class="hljs-keyword">return</span> candidateAdvisors;<br>        &#125;<br>        List&lt;Advisor&gt; eligibleAdvisors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Advisor&gt;();<br>        <span class="hljs-keyword">for</span> (Advisor candidate : candidateAdvisors) &#123;<br>            <span class="hljs-keyword">if</span> (candidate <span class="hljs-keyword">instanceof</span> IntroductionAdvisor &amp;&amp; canApply(candidate, clazz)) &#123;<br>                eligibleAdvisors.add(candidate);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">hasIntroductions</span> <span class="hljs-operator">=</span> !eligibleAdvisors.isEmpty();<br>        <span class="hljs-keyword">for</span> (Advisor candidate : candidateAdvisors) &#123;<br>            <span class="hljs-keyword">if</span> (candidate <span class="hljs-keyword">instanceof</span> IntroductionAdvisor) &#123;<br>                <span class="hljs-comment">// already processed</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (canApply(candidate, clazz, hasIntroductions)) &#123;<br>                eligibleAdvisors.add(candidate);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> eligibleAdvisors;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Invoke the given target via reflection, as part of an AOP method invocation.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> target the target object</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> method the method to invoke</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args the arguments for the method</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the invocation result, if any</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Throwable if thrown by the target method</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> org.springframework.aop.AopInvocationException in case of a reflection error</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">invokeJoinpointUsingReflection</span><span class="hljs-params">(Object target, Method method, Object[] args)</span><br>            <span class="hljs-keyword">throws</span> Throwable &#123;<br><br>        <span class="hljs-comment">// Use reflection to invoke the method.</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            ReflectionUtils.makeAccessible(method);<br>            <span class="hljs-comment">// 这一步一般都没有办法 step into，必须依靠在真的方法内部设置真的断点或者 forceinto才能看到</span><br>            <span class="hljs-keyword">return</span> method.invoke(target, args);<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (InvocationTargetException ex) &#123;<br>            <span class="hljs-comment">// Invoked method threw a checked exception.</span><br>            <span class="hljs-comment">// We must rethrow it. The client won&#x27;t see the interceptor.</span><br>            <span class="hljs-keyword">throw</span> ex.getTargetException();<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (IllegalArgumentException ex) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AopInvocationException</span>(<span class="hljs-string">&quot;AOP configuration seems to be invalid: tried calling method [&quot;</span> +<br>                    method + <span class="hljs-string">&quot;] on target [&quot;</span> + target + <span class="hljs-string">&quot;]&quot;</span>, ex);<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (IllegalAccessException ex) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AopInvocationException</span>(<span class="hljs-string">&quot;Could not access method [&quot;</span> + method + <span class="hljs-string">&quot;]&quot;</span>, ex);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="aopproxyutils">AopProxyUtils</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AopProxyUtils</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Obtain the singleton target object behind the given proxy, if any.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> candidate the (potential) proxy to check</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the singleton target object managed in a &#123;<span class="hljs-doctag">@link</span> SingletonTargetSource&#125;,</span><br><span class="hljs-comment">     * or &#123;<span class="hljs-doctag">@code</span> null&#125; in any other case (not a proxy, not an existing singleton target)</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span> 4.3.8</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> Advised#getTargetSource()</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> SingletonTargetSource#getTarget()</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getSingletonTarget</span><span class="hljs-params">(Object candidate)</span> &#123;<br>        <span class="hljs-keyword">if</span> (candidate <span class="hljs-keyword">instanceof</span> Advised) &#123;<br>            <span class="hljs-type">TargetSource</span> <span class="hljs-variable">targetSource</span> <span class="hljs-operator">=</span> ((Advised) candidate).getTargetSource();<br>            <span class="hljs-keyword">if</span> (targetSource <span class="hljs-keyword">instanceof</span> SingletonTargetSource) &#123;<br>                <span class="hljs-keyword">return</span> ((SingletonTargetSource) targetSource).getTarget();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Determine the ultimate target class of the given bean instance, traversing</span><br><span class="hljs-comment">     * not only a top-level proxy but any number of nested proxies as well &amp;mdash;</span><br><span class="hljs-comment">     * as long as possible without side effects, that is, just for singleton targets.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> candidate the instance to check (might be an AOP proxy)</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the ultimate target class (or the plain class of the given</span><br><span class="hljs-comment">     * object as fallback; never &#123;<span class="hljs-doctag">@code</span> null&#125;)</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> org.springframework.aop.TargetClassAware#getTargetClass()</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> Advised#getTargetSource()</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Class&lt;?&gt; ultimateTargetClass(Object candidate) &#123;<br>        Assert.notNull(candidate, <span class="hljs-string">&quot;Candidate object must not be null&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> candidate;<br>        Class&lt;?&gt; result = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span> (current <span class="hljs-keyword">instanceof</span> TargetClassAware) &#123;<br>            result = ((TargetClassAware) current).getTargetClass();<br>            current = getSingletonTarget(current);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (result == <span class="hljs-literal">null</span>) &#123;<br>            result = (AopUtils.isCglibProxy(candidate) ? candidate.getClass().getSuperclass() : candidate.getClass());<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Determine the complete set of interfaces to proxy for the given AOP configuration.</span><br><span class="hljs-comment">     * &lt;p&gt;This will always add the &#123;<span class="hljs-doctag">@link</span> Advised&#125; interface unless the AdvisedSupport&#x27;s</span><br><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@link</span> AdvisedSupport#setOpaque &quot;opaque&quot;&#125; flag is on. Always adds the</span><br><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@link</span> org.springframework.aop.SpringProxy&#125; marker interface.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> advised the proxy config</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the complete set of interfaces to proxy</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> SpringProxy</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> Advised</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Class&lt;?&gt;[] completeProxiedInterfaces(AdvisedSupport advised) &#123;<br>        <span class="hljs-keyword">return</span> completeProxiedInterfaces(advised, <span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 补完全部的“”</span><br><span class="hljs-comment">     * Determine the complete set of interfaces to proxy for the given AOP configuration.</span><br><span class="hljs-comment">     * &lt;p&gt;This will always add the &#123;<span class="hljs-doctag">@link</span> Advised&#125; interface unless the AdvisedSupport&#x27;s</span><br><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@link</span> AdvisedSupport#setOpaque &quot;opaque&quot;&#125; flag is on. Always adds the</span><br><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@link</span> org.springframework.aop.SpringProxy&#125; marker interface.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> advised the proxy config</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> decoratingProxy whether to expose the &#123;<span class="hljs-doctag">@link</span> DecoratingProxy&#125; interface</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the complete set of interfaces to proxy</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span> 4.3</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> SpringProxy</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> Advised</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> DecoratingProxy</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> Class&lt;?&gt;[] completeProxiedInterfaces(AdvisedSupport advised, <span class="hljs-type">boolean</span> decoratingProxy) &#123;<br>        <span class="hljs-comment">// 如果在工厂生成的时候没有设置 interface（其实构造器里就已经有了），这里还有一个补完的机会</span><br>        Class&lt;?&gt;[] specifiedInterfaces = advised.getProxiedInterfaces();<br>        <span class="hljs-keyword">if</span> (specifiedInterfaces.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// No user-specified interfaces: check whether target class is an interface.</span><br>            Class&lt;?&gt; targetClass = advised.getTargetClass();<br>            <span class="hljs-keyword">if</span> (targetClass != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (targetClass.isInterface()) &#123;<br>                    advised.setInterfaces(targetClass);<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Proxy.isProxyClass(targetClass)) &#123;<br>                    advised.setInterfaces(targetClass.getInterfaces());<br>                &#125;<br>                specifiedInterfaces = advised.getProxiedInterfaces();<br>            &#125;<br>        &#125;<br>        List&lt;Class&lt;?&gt;&gt; proxiedInterfaces = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(specifiedInterfaces.length + <span class="hljs-number">3</span>);<br>        <span class="hljs-keyword">for</span> (Class&lt;?&gt; ifc : specifiedInterfaces) &#123;<br>            <span class="hljs-comment">// 针对 JDK 17 的增强</span><br>            <span class="hljs-comment">// Only non-sealed interfaces are actually eligible for JDK proxying (on JDK 17)</span><br>            <span class="hljs-keyword">if</span> (isSealedMethod == <span class="hljs-literal">null</span> || Boolean.FALSE.equals(ReflectionUtils.invokeMethod(isSealedMethod, ifc))) &#123;<br>                proxiedInterfaces.add(ifc);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果 advised 里有 SpringProxy 的子接口，则在被代理接口列表里加上 SpringProxy 这个类型</span><br>        <span class="hljs-keyword">if</span> (!advised.isInterfaceProxied(SpringProxy.class)) &#123;<br>            proxiedInterfaces.add(SpringProxy.class);<br>        &#125;<br>        <span class="hljs-comment">// 默认情况下会添加 Advised，除非 isOpaque 专门配置过</span><br>        <span class="hljs-keyword">if</span> (!advised.isOpaque() &amp;&amp; !advised.isInterfaceProxied(Advised.class)) &#123;<br>            proxiedInterfaces.add(Advised.class);<br>        &#125;<br>        <span class="hljs-comment">// </span><br>        <span class="hljs-keyword">if</span> (decoratingProxy &amp;&amp; !advised.isInterfaceProxied(DecoratingProxy.class)) &#123;<br>            proxiedInterfaces.add(DecoratingProxy.class);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ClassUtils.toClassArray(proxiedInterfaces);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Extract the user-specified interfaces that the given proxy implements,</span><br><span class="hljs-comment">     * i.e. all non-Advised interfaces that the proxy implements.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> proxy the proxy to analyze (usually a JDK dynamic proxy)</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> all user-specified interfaces that the proxy implements,</span><br><span class="hljs-comment">     * in the original order (never &#123;<span class="hljs-doctag">@code</span> null&#125; or empty)</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> Advised</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Class&lt;?&gt;[] proxiedUserInterfaces(Object proxy) &#123;<br>        Class&lt;?&gt;[] proxyInterfaces = proxy.getClass().getInterfaces();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">nonUserIfcCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (proxy <span class="hljs-keyword">instanceof</span> SpringProxy) &#123;<br>            nonUserIfcCount++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (proxy <span class="hljs-keyword">instanceof</span> Advised) &#123;<br>            nonUserIfcCount++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (proxy <span class="hljs-keyword">instanceof</span> DecoratingProxy) &#123;<br>            nonUserIfcCount++;<br>        &#125;<br>        Class&lt;?&gt;[] userInterfaces = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>&lt;?&gt;[proxyInterfaces.length - nonUserIfcCount];<br>        System.arraycopy(proxyInterfaces, <span class="hljs-number">0</span>, userInterfaces, <span class="hljs-number">0</span>, userInterfaces.length);<br>        Assert.notEmpty(userInterfaces, <span class="hljs-string">&quot;JDK proxy must implement one or more interfaces&quot;</span>);<br>        <span class="hljs-keyword">return</span> userInterfaces;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Check equality of the proxies behind the given AdvisedSupport objects.</span><br><span class="hljs-comment">     * Not the same as equality of the AdvisedSupport objects:</span><br><span class="hljs-comment">     * rather, equality of interfaces, advisors and target sources.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equalsInProxy</span><span class="hljs-params">(AdvisedSupport a, AdvisedSupport b)</span> &#123;<br>        <span class="hljs-keyword">return</span> (a == b ||<br>                (equalsProxiedInterfaces(a, b) &amp;&amp; equalsAdvisors(a, b) &amp;&amp; a.getTargetSource().equals(b.getTargetSource())));<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Check equality of the proxied interfaces behind the given AdvisedSupport objects.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equalsProxiedInterfaces</span><span class="hljs-params">(AdvisedSupport a, AdvisedSupport b)</span> &#123;<br>        <span class="hljs-keyword">return</span> Arrays.equals(a.getProxiedInterfaces(), b.getProxiedInterfaces());<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Check equality of the advisors behind the given AdvisedSupport objects.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equalsAdvisors</span><span class="hljs-params">(AdvisedSupport a, AdvisedSupport b)</span> &#123;<br>        <span class="hljs-keyword">return</span> Arrays.equals(a.getAdvisors(), b.getAdvisors());<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Adapt the given arguments to the target signature in the given method,</span><br><span class="hljs-comment">     * if necessary: in particular, if a given vararg argument array does not</span><br><span class="hljs-comment">     * match the array type of the declared vararg parameter in the method.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> method the target method</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> arguments the given arguments</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> a cloned argument array, or the original if no adaptation is needed</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span> 4.2.3</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> Object[] adaptArgumentsIfNecessary(Method method, Object... arguments) &#123;<br>        <span class="hljs-comment">// 校验数组的方法</span><br>        <span class="hljs-keyword">if</span> (method.isVarArgs() &amp;&amp; !ObjectUtils.isEmpty(arguments)) &#123;<br>            Class&lt;?&gt;[] paramTypes = method.getParameterTypes();<br>            <span class="hljs-keyword">if</span> (paramTypes.length == arguments.length) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">varargIndex</span> <span class="hljs-operator">=</span> paramTypes.length - <span class="hljs-number">1</span>;<br>                Class&lt;?&gt; varargType = paramTypes[varargIndex];<br>                <span class="hljs-keyword">if</span> (varargType.isArray()) &#123;<br>                    <span class="hljs-type">Object</span> <span class="hljs-variable">varargArray</span> <span class="hljs-operator">=</span> arguments[varargIndex];<br>                    <span class="hljs-comment">// 校验类型的两种方法</span><br>                    <span class="hljs-keyword">if</span> (varargArray <span class="hljs-keyword">instanceof</span> Object[] &amp;&amp; !varargType.isInstance(varargArray)) &#123;<br>                        Object[] newArguments = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[arguments.length];<br>                        <span class="hljs-comment">// 复制数组的标准方法</span><br>                        System.arraycopy(arguments, <span class="hljs-number">0</span>, newArguments, <span class="hljs-number">0</span>, varargIndex);<br>                        Class&lt;?&gt; targetElementType = varargType.getComponentType();<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">varargLength</span> <span class="hljs-operator">=</span> Array.getLength(varargArray);<br>                        <span class="hljs-comment">// 生成数组的方法</span><br>                        <span class="hljs-type">Object</span> <span class="hljs-variable">newVarargArray</span> <span class="hljs-operator">=</span> Array.newInstance(targetElementType, varargLength);<br>                        System.arraycopy(varargArray, <span class="hljs-number">0</span>, newVarargArray, <span class="hljs-number">0</span>, varargLength);<br>                        newArguments[varargIndex] = newVarargArray;<br>                        <span class="hljs-keyword">return</span> newArguments;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> arguments;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="classutils">ClassUtils</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 获取缺省类加载器</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ClassLoader <span class="hljs-title function_">getDefaultClassLoader</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">cl</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 首先还是取线程自己有的类加载器。</span><br>            cl = Thread.currentThread().getContextClassLoader();<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>            <span class="hljs-comment">// Cannot access thread context ClassLoader - falling back...</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (cl == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// No thread context class loader -&gt; use class loader of this class.</span><br>            <span class="hljs-comment">// 否则，获取本类的类加载器</span><br>            cl = ClassUtils.class.getClassLoader();<br>            <span class="hljs-keyword">if</span> (cl == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// getClassLoader() returning null indicates the bootstrap ClassLoader</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 获取当前的系统类加载器，这肯定就是 bootstrap ClassLoader 了，bootstrap不可能没有</span><br>                    cl = ClassLoader.getSystemClassLoader();<br>                &#125;<br>                <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>                    <span class="hljs-comment">// Cannot access system ClassLoader - oh well, maybe the caller can live with null...</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cl;<br>    &#125;<br></code></pre></td></tr></table></figure>
<h3 id="objenesiscglibaopproxy">ObjenesisCglibAopProxy</h3>
<p>ObjenesisCglibAopProxy 不需要依赖于构造器，在高版本（ 4.0 以后）Spring 上，是 CglibAopProxy 的替代品，而且不完全调用 super 的函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 如果使用编程式的 ProxyFactory，就会走进这个需要调用 super 的构造器里</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ObjenesisCglibAopProxy</span><span class="hljs-params">(AdvisedSupport config)</span> &#123;<br>        <span class="hljs-built_in">super</span>(config);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">createProxyClassAndInstance</span><span class="hljs-params">(Enhancer enhancer, Callback[] callbacks)</span> &#123;<br>        Class&lt;?&gt; proxyClass = enhancer.createClass();<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">proxyInstance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-keyword">if</span> (objenesis.isWorthTrying()) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                proxyInstance = objenesis.newInstance(proxyClass, enhancer.getUseCache());<br>            &#125;<br>            <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>                logger.debug(<span class="hljs-string">&quot;Unable to instantiate proxy using Objenesis, &quot;</span> +<br>                        <span class="hljs-string">&quot;falling back to regular proxy construction&quot;</span>, ex);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (proxyInstance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// Regular instantiation via default constructor...</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                Constructor&lt;?&gt; ctor = (<span class="hljs-built_in">this</span>.constructorArgs != <span class="hljs-literal">null</span> ?<br>                        proxyClass.getDeclaredConstructor(<span class="hljs-built_in">this</span>.constructorArgTypes) :<br>                        proxyClass.getDeclaredConstructor());<br>                ReflectionUtils.makeAccessible(ctor);<br>                proxyInstance = (<span class="hljs-built_in">this</span>.constructorArgs != <span class="hljs-literal">null</span> ?<br>                        ctor.newInstance(<span class="hljs-built_in">this</span>.constructorArgs) : ctor.newInstance());<br>            &#125;<br>            <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AopConfigException</span>(<span class="hljs-string">&quot;Unable to instantiate proxy using Objenesis, &quot;</span> +<br>                        <span class="hljs-string">&quot;and regular proxy instantiation via default constructor fails as well&quot;</span>, ex);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// callbacks 被绑定发生在这一步</span><br>        ((Factory) proxyInstance).setCallbacks(callbacks);<br>        <span class="hljs-keyword">return</span> proxyInstance;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="cglibaopproxy">CglibAopProxy</h3>
<p>CglibAopProxy 的构造器只是装入一个 config，但把它装入了一个 AdvisedDispatcher里。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">CglibAopProxy</span><span class="hljs-params">(AdvisedSupport config)</span> <span class="hljs-keyword">throws</span> AopConfigException &#123;<br>        Assert.notNull(config, <span class="hljs-string">&quot;AdvisedSupport must not be null&quot;</span>);<br>        <span class="hljs-keyword">if</span> (config.getAdvisorCount() == <span class="hljs-number">0</span> &amp;&amp; config.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AopConfigException</span>(<span class="hljs-string">&quot;No advisors and no TargetSource specified&quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">this</span>.advised = config;<br>        <span class="hljs-built_in">this</span>.advisedDispatcher = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AdvisedDispatcher</span>(<span class="hljs-built_in">this</span>.advised);<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>它的 enhancer 注册了很多的 Callback 方法，最重要的方法是 DynamicAdvisedInterceptor，它即是代理实际操作的回调类，回调方法为intercept。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><code class="hljs java"><br>    ClassUtils 里的一些有用的反射符号：<br>    <br>    <span class="hljs-comment">/** Suffix for array class names: &#123;<span class="hljs-doctag">@code</span> &quot;[]&quot;&#125;. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ARRAY_SUFFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;[]&quot;</span>;<br><br>    <span class="hljs-comment">/** Prefix for internal array class names: &#123;<span class="hljs-doctag">@code</span> &quot;[&quot;&#125;. */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">INTERNAL_ARRAY_PREFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;[&quot;</span>;<br><br>    <span class="hljs-comment">/** Prefix for internal non-primitive array class names: &#123;<span class="hljs-doctag">@code</span> &quot;[L&quot;&#125;. */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">NON_PRIMITIVE_ARRAY_PREFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;[L&quot;</span>;<br><br>    <span class="hljs-comment">/** A reusable empty class array constant. */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Class&lt;?&gt;[] EMPTY_CLASS_ARRAY = &#123;&#125;;<br><br>    <span class="hljs-comment">/** The package separator character: &#123;<span class="hljs-doctag">@code</span> &#x27;.&#x27;&#125;. */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span> <span class="hljs-variable">PACKAGE_SEPARATOR</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;.&#x27;</span>;<br><br>    <span class="hljs-comment">/** The path separator character: &#123;<span class="hljs-doctag">@code</span> &#x27;/&#x27;&#125;. */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span> <span class="hljs-variable">PATH_SEPARATOR</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;/&#x27;</span>;<br><br>    <span class="hljs-comment">/** The nested class separator character: &#123;<span class="hljs-doctag">@code</span> &#x27;$&#x27;&#125;. */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span> <span class="hljs-variable">NESTED_CLASS_SEPARATOR</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;$&#x27;</span>;<br><br>    <span class="hljs-comment">/** The CGLIB class separator: &#123;<span class="hljs-doctag">@code</span> &quot;$$&quot;&#125;. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">CGLIB_CLASS_SEPARATOR</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;$$&quot;</span>;<br><br>    <span class="hljs-comment">/** The &quot;.class&quot; file suffix. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">CLASS_FILE_SUFFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;.class&quot;</span>;<br>    <br>    <span class="hljs-comment">// 注意，多个 CglibAopProxy 验证过的 class 都会被放在这个成员里来</span><br>    <span class="hljs-comment">/** Keeps track of the Classes that we have validated for final methods. */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;Class&lt;?&gt;, Boolean&gt; validatedClasses = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakHashMap</span>&lt;&gt;();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getProxy</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> ClassLoader classLoader)</span> &#123;<br>        <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>            logger.trace(<span class="hljs-string">&quot;Creating CGLIB proxy: &quot;</span> + <span class="hljs-built_in">this</span>.advised.getTargetSource());<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            Class&lt;?&gt; rootClass = <span class="hljs-built_in">this</span>.advised.getTargetClass();<br>            Assert.state(rootClass != <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;Target class must be available for creating a CGLIB proxy&quot;</span>);<br><br>            Class&lt;?&gt; proxySuperClass = rootClass;<br>            <span class="hljs-comment">// 如果 advised 的目标依然是个 cglib 的类型，如A$$Foo，则把它的父类取出来，它的父类上的 interfaces 才是最需要关注的接口列表（因为代理类上的接口可能更多了）</span><br>            <span class="hljs-keyword">if</span> (rootClass.getName().contains(ClassUtils.CGLIB_CLASS_SEPARATOR)) &#123;<br>                proxySuperClass = rootClass.getSuperclass();<br>                Class&lt;?&gt;[] additionalInterfaces = rootClass.getInterfaces();<br>                <span class="hljs-keyword">for</span> (Class&lt;?&gt; additionalInterface : additionalInterfaces) &#123;<br>                    <span class="hljs-built_in">this</span>.advised.addInterface(additionalInterface);<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// Validate the class, writing log messages as necessary.</span><br>            <span class="hljs-comment">// 这一步大量依赖于 Modifier 这个方法的判定结果，会对 proxySuperClass 和它的父类做链式校验，确认有没有非可代理的方法的情况</span><br>            validateClassIfNecessary(proxySuperClass, classLoader);<br><br>            <span class="hljs-comment">// Configure CGLIB Enhancer...，这个 enhancer 是 Spring 自己内部定义的</span><br>            <span class="hljs-type">Enhancer</span> <span class="hljs-variable">enhancer</span> <span class="hljs-operator">=</span> createEnhancer();<br>            <span class="hljs-keyword">if</span> (classLoader != <span class="hljs-literal">null</span>) &#123;<br>                enhancer.setClassLoader(classLoader);<br>                <span class="hljs-keyword">if</span> (classLoader <span class="hljs-keyword">instanceof</span> SmartClassLoader &amp;&amp;<br>                        ((SmartClassLoader) classLoader).isClassReloadable(proxySuperClass)) &#123;<br>                    enhancer.setUseCache(<span class="hljs-literal">false</span>);<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 设置超类</span><br>            enhancer.setSuperclass(proxySuperClass);<br>            <span class="hljs-comment">// 设置接口列表，所以这个 proxy 本身也持有全部接口列表</span><br>            enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(<span class="hljs-built_in">this</span>.advised));<br>            <span class="hljs-comment">// 命名策略为实例</span><br>            enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);<br>            <span class="hljs-comment">// 这里的 GeneratorStrategy 要配合 Generator 用</span><br>            enhancer.setStrategy(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassLoaderAwareGeneratorStrategy</span>(classLoader));<br><br>            Callback[] callbacks = getCallbacks(rootClass);<br>            Class&lt;?&gt;[] types = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>&lt;?&gt;[callbacks.length];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; x &lt; types.length; x++) &#123;<br>                types[x] = callbacks[x].getClass();<br>            &#125;<br>            <span class="hljs-comment">// 配置一个回调过滤器，回调经过哪个 AOP 依赖于它的分派</span><br>            <span class="hljs-comment">// fixedInterceptorMap only populated at this point, after getCallbacks call above</span><br>            enhancer.setCallbackFilter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ProxyCallbackFilter</span>(<br>                    <span class="hljs-built_in">this</span>.advised.getConfigurationOnlyCopy(), <span class="hljs-built_in">this</span>.fixedInterceptorMap, <span class="hljs-built_in">this</span>.fixedInterceptorOffset));<br>            enhancer.setCallbackTypes(types);<br><br>            <span class="hljs-comment">// 各种 MethodInterceptor 实际上是 Callback 的扩展，此处把 MethodInterceptor 列表装成 callback 列表，拿来生成 enhancer 的代理</span><br>            <span class="hljs-comment">// Generate the proxy class and create a proxy instance.</span><br>            <span class="hljs-keyword">return</span> createProxyClassAndInstance(enhancer, callbacks);<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (CodeGenerationException | IllegalArgumentException ex) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AopConfigException</span>(<span class="hljs-string">&quot;Could not generate CGLIB subclass of &quot;</span> + <span class="hljs-built_in">this</span>.advised.getTargetClass() +<br>                    <span class="hljs-string">&quot;: Common causes of this problem include using a final class or a non-visible class&quot;</span>,<br>                    ex);<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>            <span class="hljs-comment">// TargetSource.getTarget() failed</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AopConfigException</span>(<span class="hljs-string">&quot;Unexpected AOP exception&quot;</span>, ex);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> Callback[] getCallbacks(Class&lt;?&gt; rootClass) <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// Parameters used for optimization choices...</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">exposeProxy</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.advised.isExposeProxy();<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isFrozen</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.advised.isFrozen();<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isStatic</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.advised.getTargetSource().isStatic();<br><br>        <span class="hljs-comment">// Choose an &quot;aop&quot; interceptor (used for AOP calls).这里和 JdkDynamicAopProxy 不一样，JdkDynamicAopProxy 里每个 interceptor 拥有一个 invoke 逻辑，构成链条，但 CglibAopProxy 的策略不一样，把整个 config 都放进 DynamicAdvisedInterceptor 里</span><br>        <span class="hljs-type">Callback</span> <span class="hljs-variable">aopInterceptor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DynamicAdvisedInterceptor</span>(<span class="hljs-built_in">this</span>.advised);<br><br>        <span class="hljs-comment">// Choose a &quot;straight to target&quot; interceptor. (used for calls that are</span><br>        <span class="hljs-comment">// unadvised but can return this). May be required to expose the proxy.</span><br>        <span class="hljs-comment">// 生成 targetInterceptor，这是一个取决于是否暴露代理和 isStatic 而生成的 UnadvisedInterceptor，也就是说，不经过 advice，而直接去调用 target 的 Interceptor</span><br>        Callback targetInterceptor;<br>        <span class="hljs-keyword">if</span> (exposeProxy) &#123;<br>            targetInterceptor = (isStatic ?<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">StaticUnadvisedExposedInterceptor</span>(<span class="hljs-built_in">this</span>.advised.getTargetSource().getTarget()) :<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">DynamicUnadvisedExposedInterceptor</span>(<span class="hljs-built_in">this</span>.advised.getTargetSource()));<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            targetInterceptor = (isStatic ?<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">StaticUnadvisedInterceptor</span>(<span class="hljs-built_in">this</span>.advised.getTargetSource().getTarget()) :<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">DynamicUnadvisedInterceptor</span>(<span class="hljs-built_in">this</span>.advised.getTargetSource()));<br>        &#125;<br>        <span class="hljs-comment">// 生成目标分配器</span><br>        <span class="hljs-comment">// Choose a &quot;direct to target&quot; dispatcher (used for</span><br>        <span class="hljs-comment">// unadvised calls to static targets that cannot return this).</span><br>        <span class="hljs-type">Callback</span> <span class="hljs-variable">targetDispatcher</span> <span class="hljs-operator">=</span> (isStatic ?<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">StaticDispatcher</span>(<span class="hljs-built_in">this</span>.advised.getTargetSource().getTarget()) : <span class="hljs-keyword">new</span> <span class="hljs-title class_">SerializableNoOp</span>());<br>        <br>        <span class="hljs-comment">// 全部的 interceptor 数组总共有 7 个对象，这里面每个拦截器都是 org.springframework.cglib.proxy.MethodInterceptor 的子类，第二个 MethodInterceptor 出现在这里</span><br>        <span class="hljs-comment">// 注意，这些类是 CglibAopProxy 的内部类</span><br>        Callback[] mainCallbacks = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Callback</span>[] &#123;<br>                aopInterceptor,  <span class="hljs-comment">// for normal advice</span><br>                targetInterceptor,  <span class="hljs-comment">// invoke target without considering advice, if optimized</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">SerializableNoOp</span>(),  <span class="hljs-comment">// no override for methods mapped to this</span><br>                targetDispatcher, <span class="hljs-built_in">this</span>.advisedDispatcher,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">EqualsInterceptor</span>(<span class="hljs-built_in">this</span>.advised),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashCodeInterceptor</span>(<span class="hljs-built_in">this</span>.advised)<br>        &#125;;<br><br>        Callback[] callbacks;<br>        <br>        <span class="hljs-comment">// 如果 target 是静态的（也就是 targetsource 每次都返回同一个），且 advice chain 是冻结的，我们可以做一些优化：制造一个固定 advice 链，调用它完了，直接调到那个链上</span><br>        <span class="hljs-comment">// If the target is a static one and the advice chain is frozen,</span><br>        <span class="hljs-comment">// then we can make some optimizations by sending the AOP calls</span><br>        <span class="hljs-comment">// direct to the target using the fixed chain for that method.</span><br>        <span class="hljs-keyword">if</span> (isStatic &amp;&amp; isFrozen) &#123;<br>            Method[] methods = rootClass.getMethods();<br>            Callback[] fixedCallbacks = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Callback</span>[methods.length];<br>            <span class="hljs-built_in">this</span>.fixedInterceptorMap = CollectionUtils.newHashMap(methods.length);<br><br>            <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> small memory optimization here (can skip creation for methods with no advice)</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; x &lt; methods.length; x++) &#123;<br>                <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> methods[x];<br>                <span class="hljs-comment">// 这里就看得出对一个方法取 advice 的方法的可复用性了，到处都可以用</span><br>                List&lt;Object&gt; chain = <span class="hljs-built_in">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, rootClass);<br>                fixedCallbacks[x] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FixedChainStaticTargetInterceptor</span>(<br>                        chain, <span class="hljs-built_in">this</span>.advised.getTargetSource().getTarget(), <span class="hljs-built_in">this</span>.advised.getTargetClass());<br>                <span class="hljs-comment">// 注意，这里仍然是 static 的</span><br>                <span class="hljs-built_in">this</span>.fixedInterceptorMap.put(method, x);<br>            &#125;<br>            <span class="hljs-comment">// 确定最终的 callbacks 数组</span><br>            <span class="hljs-comment">// Now copy both the callbacks from mainCallbacks</span><br>            <span class="hljs-comment">// and fixedCallbacks into the callbacks array.</span><br>            callbacks = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Callback</span>[mainCallbacks.length + fixedCallbacks.length];<br>            System.arraycopy(mainCallbacks, <span class="hljs-number">0</span>, callbacks, <span class="hljs-number">0</span>, mainCallbacks.length);<br>            System.arraycopy(fixedCallbacks, <span class="hljs-number">0</span>, callbacks, mainCallbacks.length, fixedCallbacks.length);<br>            <span class="hljs-built_in">this</span>.fixedInterceptorOffset = mainCallbacks.length;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 在这里返回不优化的 7 个 interceptor</span><br>            callbacks = mainCallbacks;<br>        &#125;<br>        <span class="hljs-keyword">return</span> callbacks;<br>    &#125;<br>    <br><br><span class="hljs-comment">// 把 callback 装进 enhencer，启动 enhancer，注意，这个方法在 ObjenesisCglibAopProxy 里是被复写的</span><br><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">createProxyClassAndInstance</span><span class="hljs-params">(Enhancer enhancer, Callback[] callbacks)</span> &#123;<br>        enhancer.setInterceptDuringConstruction(<span class="hljs-literal">false</span>);<br>        enhancer.setCallbacks(callbacks);<br>        <span class="hljs-keyword">return</span> (<span class="hljs-built_in">this</span>.constructorArgs != <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-built_in">this</span>.constructorArgTypes != <span class="hljs-literal">null</span> ?<br>                enhancer.create(<span class="hljs-built_in">this</span>.constructorArgTypes, <span class="hljs-built_in">this</span>.constructorArgs) :<br>                enhancer.create());<br>    &#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">createProxyClassAndInstance</span><span class="hljs-params">(Enhancer enhancer, Callback[] callbacks)</span> &#123;<br>    Class&lt;?&gt; proxyClass = enhancer.createClass();<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">proxyInstance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">if</span> (objenesis.isWorthTrying()) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            proxyInstance = objenesis.newInstance(proxyClass, enhancer.getUseCache());<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>            logger.debug(<span class="hljs-string">&quot;Unable to instantiate proxy using Objenesis, &quot;</span> +<br>                    <span class="hljs-string">&quot;falling back to regular proxy construction&quot;</span>, ex);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (proxyInstance == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// Regular instantiation via default constructor...</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            proxyInstance = (<span class="hljs-built_in">this</span>.constructorArgs != <span class="hljs-literal">null</span> ?<br>                    proxyClass.getConstructor(<span class="hljs-built_in">this</span>.constructorArgTypes).newInstance(<span class="hljs-built_in">this</span>.constructorArgs) :<br>                    proxyClass.newInstance());<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AopConfigException</span>(<span class="hljs-string">&quot;Unable to instantiate proxy using Objenesis, &quot;</span> +<br>                    <span class="hljs-string">&quot;and regular proxy instantiation via default constructor fails as well&quot;</span>, ex);<br>        &#125;<br>    &#125;<br><br>    ((Factory) proxyInstance).setCallbacks(callbacks);<br>    <span class="hljs-keyword">return</span> proxyInstance;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>JdkDynamicAopProxy 可以直接因为 InvocationHandler 在 Proxy 里的关系，进入调用栈，enhancer 生成的 proxy 子类 invoke 的调用要专门预先进入调试类 DynamicAdvisedInterceptor 才行，不能 step in，会有-1 栈帧的问题：</p>
<p><img src="-1%E7%9A%84%E6%A0%88%E5%B8%A7.png" alt="-1的栈帧"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">// methodProxy 是个被 cglib 封装进来的对象，它的构造我们管不了</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-meta">@Nullable</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">oldProxy</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">setProxyContext</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">TargetSource</span> <span class="hljs-variable">targetSource</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.advised.getTargetSource();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.advised.exposeProxy) &#123;<br>                <span class="hljs-comment">// Make invocation available if necessary.</span><br>                oldProxy = AopContext.setCurrentProxy(proxy);<br>                setProxyContext = <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-comment">// Get as late as possible to minimize the time we &quot;own&quot; the target, in case it comes from a pool...</span><br>            target = targetSource.getTarget();<br>            Class&lt;?&gt; targetClass = (target != <span class="hljs-literal">null</span> ? target.getClass() : <span class="hljs-literal">null</span>);<br>            <span class="hljs-comment">// 获取调用链</span><br>            List&lt;Object&gt; chain = <span class="hljs-built_in">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);<br>            Object retVal;<br>            <span class="hljs-comment">// Check whether we only have one InvokerInterceptor: that is,</span><br>            <span class="hljs-comment">// no real advice, but just reflective invocation of the target.</span><br>            <span class="hljs-keyword">if</span> (chain.isEmpty() &amp;&amp; CglibMethodInvocation.isMethodProxyCompatible(method)) &#123;<br>                <span class="hljs-comment">// We can skip creating a MethodInvocation: just invoke the target directly.</span><br>                <span class="hljs-comment">// Note that the final invoker must be an InvokerInterceptor, so we know</span><br>                <span class="hljs-comment">// it does nothing but a reflective operation on the target, and no hot</span><br>                <span class="hljs-comment">// swapping or fancy proxying.</span><br>                Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    retVal = methodProxy.invoke(target, argsToUse);<br>                &#125;<br>                <span class="hljs-keyword">catch</span> (CodeGenerationException ex) &#123;<br>                    CglibMethodInvocation.logFastClassGenerationFailure(method);<br>                    retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// We need to create a method invocation...</span><br>                <span class="hljs-comment">// 这是一个 ReflectiveMethodInvocation 的子类，它多了一个 MethodProxy 成员需要存储起来。Only use method proxy for public methods not derived from java.lang.Object。methodProxy 在 invokeJoinpoint() 里会有用，除此之外，所有的调用都同 ReflectiveMethodInvocation</span><br>                retVal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CglibMethodInvocation</span>(proxy, target, method, args, targetClass, chain, methodProxy).proceed();<br>            &#125;<br>            <span class="hljs-comment">// 这一步是这个 Callback 特有的</span><br>            retVal = processReturnType(proxy, target, method, retVal);<br>            <span class="hljs-keyword">return</span> retVal;<br>        &#125;<br>        <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 这两步也是 cglib 代理特有的</span><br>            <span class="hljs-keyword">if</span> (target != <span class="hljs-literal">null</span> &amp;&amp; !targetSource.isStatic()) &#123;<br>                targetSource.releaseTarget(target);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (setProxyContext) &#123;<br>                <span class="hljs-comment">// Restore old proxy.</span><br>                AopContext.setCurrentProxy(oldProxy);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 这段代码的意思是：</span><br><span class="hljs-comment"> *   一个方法的最后一个 vararg 是 A[]，实参是个 Object[]，把形参转化为 A[]数组以让调用成立，不过这里面有很多数组检查的方法实现得非常好</span><br><span class="hljs-comment"> * Adapt the given arguments to the target signature in the given method,</span><br><span class="hljs-comment"> * if necessary: in particular, if a given vararg argument array does not</span><br><span class="hljs-comment"> * match the array type of the declared vararg parameter in the method.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> method the target method</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> arguments the given arguments</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> a cloned argument array, or the original if no adaptation is needed</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 4.2.3</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> Object[] adaptArgumentsIfNecessary(Method method, <span class="hljs-meta">@Nullable</span> Object[] arguments) &#123;<br>    <span class="hljs-keyword">if</span> (ObjectUtils.isEmpty(arguments)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-keyword">if</span> (method.isVarArgs()) &#123;<br>        <span class="hljs-keyword">if</span> (method.getParameterCount() == arguments.length) &#123;<br>            Class&lt;?&gt;[] paramTypes = method.getParameterTypes();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">varargIndex</span> <span class="hljs-operator">=</span> paramTypes.length - <span class="hljs-number">1</span>;<br>            Class&lt;?&gt; varargType = paramTypes[varargIndex];<br>            <span class="hljs-keyword">if</span> (varargType.isArray()) &#123;<br>                <span class="hljs-type">Object</span> <span class="hljs-variable">varargArray</span> <span class="hljs-operator">=</span> arguments[varargIndex];<br>                <span class="hljs-comment">// Class.isInstance 是个 instanceOf 的动态调用版本</span><br>                <span class="hljs-keyword">if</span> (varargArray <span class="hljs-keyword">instanceof</span> Object[] &amp;&amp; !varargType.isInstance(varargArray)) &#123;<br>                    Object[] newArguments = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[arguments.length];<br>                    System.arraycopy(arguments, <span class="hljs-number">0</span>, newArguments, <span class="hljs-number">0</span>, varargIndex);<br>                    Class&lt;?&gt; targetElementType = varargType.getComponentType();<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">varargLength</span> <span class="hljs-operator">=</span> Array.getLength(varargArray);<br>                    <span class="hljs-type">Object</span> <span class="hljs-variable">newVarargArray</span> <span class="hljs-operator">=</span> Array.newInstance(targetElementType, varargLength);<br>                    System.arraycopy(varargArray, <span class="hljs-number">0</span>, newVarargArray, <span class="hljs-number">0</span>, varargLength);<br>                    newArguments[varargIndex] = newVarargArray;<br>                    <span class="hljs-keyword">return</span> newArguments;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arguments;<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 这个方法是 cglib 类型的代理特有的</span><br><span class="hljs-comment"> * Process a return value. Wraps a return of &#123;<span class="hljs-doctag">@code</span> this&#125; if necessary to be the</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@code</span> proxy&#125; and also verifies that &#123;<span class="hljs-doctag">@code</span> null&#125; is not returned as a primitive.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">processReturnType</span><span class="hljs-params">(</span><br><span class="hljs-params">        Object proxy, <span class="hljs-meta">@Nullable</span> Object target, Method method, <span class="hljs-meta">@Nullable</span> Object returnValue)</span> &#123;<br>    <span class="hljs-comment">// 如果要返回 target，只要这个方法的声明类型不是 RawTargetAccess 的类型，则返回 proxy，</span><br>    <span class="hljs-comment">// Massage return value if necessary</span><br>    <span class="hljs-keyword">if</span> (returnValue != <span class="hljs-literal">null</span> &amp;&amp; returnValue == target &amp;&amp;<br>            !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) &#123;<br>        <span class="hljs-comment">// Special case: it returned &quot;this&quot;. Note that we can&#x27;t help</span><br>        <span class="hljs-comment">// if the target sets a reference to itself in another returned object.</span><br>        returnValue = proxy;<br>    &#125;<br>    <span class="hljs-comment">// 原始类型里除了以外，不允许返回 null，否则抛出异常</span><br>    Class&lt;?&gt; returnType = method.getReturnType();<br>    <span class="hljs-keyword">if</span> (returnValue == <span class="hljs-literal">null</span> &amp;&amp; returnType != Void.TYPE &amp;&amp; returnType.isPrimitive()) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AopInvocationException</span>(<br>                <span class="hljs-string">&quot;Null return value from advice does not match primitive return type for: &quot;</span> + method);<br>    &#125;<br>    <span class="hljs-keyword">return</span> returnValue;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="methodinvocation">MethodInvocation</h2>
<p>proxy 方法里使用的方法调用抽象，可以 getMethod() 来获取方法。可以被认为是 joinpoint 的 getStaticPart() 的友元实现。</p>
<h2 id="joinpoint-设计">JoinPoint 设计</h2>
<p>Spring 自己的方法闭包执行点。</p>
<p>有了连接点，首先封装了 proxy，其他封装了 target，再次描述了方法的签名，最后封装了参数（这点特别重要，使得我们不需要直接使用 Object[]）。</p>
<p>连接点使用 PCD 的表达式，可以实现 data binding - 指定参数名称和类型。</p>
<h2 id="joinpoint">JoinPoint</h2>
<p>一般的 advice 的参数使用 JoinPoint。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">JoinPoint</span> &#123;  <br>   String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span>;         <span class="hljs-comment">// 连接点所在位置的相关信息  </span><br>   String <span class="hljs-title function_">toShortString</span><span class="hljs-params">()</span>;     <span class="hljs-comment">// 连接点所在位置的简短相关信息  </span><br>   String <span class="hljs-title function_">toLongString</span><span class="hljs-params">()</span>;     <span class="hljs-comment">// 连接点所在位置的全部相关信息  </span><br>   Object <span class="hljs-title function_">getThis</span><span class="hljs-params">()</span>;         <span class="hljs-comment">// 返回AOP代理对象，也就是com.sun.proxy.$Proxy18</span><br>   Object <span class="hljs-title function_">getTarget</span><span class="hljs-params">()</span>;       <span class="hljs-comment">// 返回目标对象，一般我们都需要它或者（也就是定义方法的接口或类，为什么会是接口呢？这主要是在目标对象本身是动态代理的情况下，例如Mapper。所以返回的是定义方法的对象如aoptest.daoimpl.GoodDaoImpl或com.b.base.BaseMapper&lt;T, E, PK&gt;）</span><br>   Object[] getArgs();       <span class="hljs-comment">// 返回被通知方法参数列表  </span><br>   Signature <span class="hljs-title function_">getSignature</span><span class="hljs-params">()</span>;  <span class="hljs-comment">// 返回当前连接点签名  其getName()方法返回方法的FQN，如void aoptest.dao.GoodDao.delete()或com.b.base.BaseMapper.insert(T)(需要注意的是，很多时候我们定义了子类继承父类的时候，我们希望拿到基于子类的FQN，这直接可拿不到，要依赖于AopUtils.getTargetClass(point.getTarget())获取原始代理对象，下面会详细讲解)</span><br>   SourceLocation <span class="hljs-title function_">getSourceLocation</span><span class="hljs-params">()</span>;<span class="hljs-comment">// 返回连接点方法所在类文件中的位置  </span><br>   String <span class="hljs-title function_">getKind</span><span class="hljs-params">()</span>;        <span class="hljs-comment">// 连接点类型  </span><br>   StaticPart <span class="hljs-title function_">getStaticPart</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 返回连接点静态部分  </span><br>  &#125;  <br></code></pre></td></tr></table></figure>
<h3 id="proceedingjoinpoint">ProceedingJoinPoint</h3>
<p>Around Advice 使用 ProceedingJoinPoint。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ProceedingJoinPoint</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">JoinPoint</span> &#123;<br>        <span class="hljs-comment">// 执行下一个 advice （从侧面看出 advice 是可以嵌套的）或者目标方法</span><br>       <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">proceed</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable;<br>       <span class="hljs-comment">// 使用数组参数来执行下一个 advice （从侧面看出 advice 是可以嵌套的）或者目标方法</span><br>       <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">proceed</span><span class="hljs-params">(Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable;  <br> &#125; <br></code></pre></td></tr></table></figure>
<p>ProceedingJoinPoint 的 proceed 可以被执行 0 次、1 次、无数次。</p>
<p>常见的例子就是缓存 API 在校验了 cache 了以后可以执行底层方法，也可以不执行底层方法。</p>
<p>如果按顺序绑定 ProceedingJoinPoint 的参数到 advice 方法上，可以先处理那个参数，再把参数回传去再 proceed 来代替之前被处理的参数。如下面的例子，find 方法的第一个参数是 accountHolderNamePattern，被处理以后就出现新 pattern 来调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Around(&quot;execution(List&lt;Account&gt; find*(..)) &amp;&amp; &quot; +</span><br><span class="hljs-meta">        &quot;com.xyz.myapp.SystemArchitecture.inDataAccessLayer() &amp;&amp; &quot; +</span><br><span class="hljs-meta">        &quot;args(accountHolderNamePattern)&quot;)</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">preProcessQueryPattern</span><span class="hljs-params">(ProceedingJoinPoint pjp,</span><br><span class="hljs-params">        String accountHolderNamePattern)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">newPattern</span> <span class="hljs-operator">=</span> preProcess(accountHolderNamePattern);<br>    <span class="hljs-keyword">return</span> pjp.proceed(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[] &#123;newPattern&#125;);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>参考：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://www.baeldung.com/spring-aop-pointcut-tutorial#3-this-and-target">《Introduction to Pointcut Expressions in Spring》</a></li>
<li><a target="_blank" rel="noopener" href="https://plentymore.github.io/2018/12/11/Spring-Configurable%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/">《Spring @Configurable基本用法》</a><br>
3.<a target="_blank" rel="noopener" href="https://my.oschina.net/u/2377110/blog/1507532">《Spring源码-AOP(三)-Spring AOP的四种实现》</a></li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://magicliang.github.io">magicliang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://magicliang.github.io/2020/04/05/Spring-AOP-%E7%AC%94%E8%AE%B0/">https://magicliang.github.io/2020/04/05/Spring-AOP-%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/Spring/">Spring</a></div><div class="post-share"><div class="social-share" data-image="/2020/04/05/Spring-AOP-%E7%AC%94%E8%AE%B0/spring-aop-proxy-creation.jpg" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2020/03/29/Java-%E6%B3%A8%E8%A7%A3%E5%92%8C%E9%85%8D%E7%BD%AE/" title="Java 注解和配置"><img class="cover" src="/img/wall-paper-45.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-03-29</div><div class="info-item-2">Java 注解和配置</div></div><div class="info-2"><div class="info-item-1">Java 的原生注解 meta annotation @Inherited @Inherited 是一个元注解（annotations applied to other annotations 注解其他注解的注解），也是一个标记注解，@Inherited阐述了某个被标注的类型是被继承的。 **@Inherited annotation类型是被标注过的class的子类所继承。类并不从它所实现的接口继承annotation，方法并不从它所重载的方法继承annotation。**其查找过程是：反射 API 会在查找 @Inherited 标注的注解的时候，自底向上往继承树上方查找。 12345678910111213141516171819202122@Inherited@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)public @interface MyAnnotation &#123;    String value() default &quot;Default Value&quot;;&#125;@MyA...</div></div></div></a><a class="pagination-related" href="/2020/04/20/Spring-%E6%A6%82%E8%A7%88/" title="Spring 概览"><img class="cover" src="/2020/04/20/Spring-%E6%A6%82%E8%A7%88/spring-framework-architecture.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-04-20</div><div class="info-item-2">Spring 概览</div></div><div class="info-2"><div class="info-item-1">Spring 起源于 2003 年，它作为 Java EE 平台规范的补充，而不是完全拥抱 specification。 Spring 可以指的是 entire family of projects。也可以单指 Spring Framework（换言之，Spring Framework 本身也只是 family 的一部分）。 Spring Framework 被模块化了，它的核心只包括 core container（主要解决依赖注入问题）。但是针对不同的应用架构，它提供不同的支持，包括 messaging、transactionl、persistence 和 web。这些模块原本命名为 “spring-core” 和 “spring-context”，在 Java 9 的 jigsaw 项目来临之时，也开始支持 module path，生成“自动模块名”清单项，并且定义语言级别的模块名，如&quot;spring.core&quot;、“spring.context”。 Spring 支持的 JSR 有：  Servlet API (JSR 340) WebSocket API ...</div></div></div></a><a class="pagination-related" href="/2020/07/19/Spring-IOC/" title="Spring IOC"><img class="cover" src="/2020/07/19/Spring-IOC/spring-ioc-hiarachy.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-19</div><div class="info-item-2">Spring IOC</div></div><div class="info-2"><div class="info-item-1">总体的类图 spring-Ioc     Bean 工厂提供 IOC 基本功能，Context 是全功能的 BeanFactory，是应用程序的全部上下文。 扩展点和生命周期钩子 Spring的扩展点.xmind    加载顺序：  获取工厂 准备工厂 后处理工厂 InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation，返回 object。 构造器 InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation，返回布尔值。 populateBean（注入 @Autowired，类内第一个方法），实际上调用的是 InstantiationAwareBeanPostProcessor.postProcessProperties InitializingBean:  各类 aware 方法注入 BeanPostProcessor.postProcessBeforeInitialization 的后处理器(@PostConsstruct) a...</div></div></div></a><a class="pagination-related" href="/2020/08/02/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88/" title="常见的服务器调用堆栈"><img class="cover" src="/img/wall-paper-38.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-02</div><div class="info-item-2">常见的服务器调用堆栈</div></div><div class="info-2"><div class="info-item-1">自顶向下调用 $是内部类的意思 $$是由 Lambda 生成的内部类的意思。当然 Spring 的 CGLIB 可以自己控制 naming pattern。 内部类生成的类名后往往带有一个数字，这个数字表示编译器生成这个内部类的顺序  Thread.run() ThreadPoolExecutor$Worker.run() ThreadPoolExecutor.runWorker() Netty.DefaultServerHandler.run() Netty.DefaultServerHandler.handleRequest() ThriftServerPublisher$MTProccessor.process() Thrift 接口$Processor.方法名() com.sun.proxy$Proxy 数字.方法名() XXXServiceImpl$$EnhancerBySpringCGLIB$$1fb0b39f.被拦截的方法 ThriftInvoker.invoker() RhinoLimiterFilter.filter() ThriftInvoker.invoke...</div></div></div></a><a class="pagination-related" href="/2020/07/19/Spring-%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93/" title="Spring 与数据库"><img class="cover" src="/2020/07/19/Spring-%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93/TransactionAspectSupport.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-19</div><div class="info-item-2">Spring 与数据库</div></div><div class="info-2"><div class="info-item-1">Java 执行事务的过程  1.获取连接 Connection con = DriverManager.getConnection() 2.开启事务con.setAutoCommit(true/false); 在 Spring 事务里（如 DataSourceTransactionManager 的 doBegin 方法）里，总是会显式地 con.setAutoCommit(false);（不然哪有事务可言）。 3.执行CRUD 4.提交事务/回滚事务 con.commit() / con.rollback(); 5.关闭连接 conn.close();  本文涉及到的类型的类图    Spring 的事务管理核心类型和流程 DataSource 不同的数据源诞生不同的 DataSource。默认的 TransactionManager 本身是期待一个名叫“datasource”的数据源的。 FactoryBean 不同的 DataSource 装入不同的 FactoryBean，比如 JPA 的 EntityManagerFactory。 PlatformTransaction...</div></div></div></a><a class="pagination-related" href="/2022/01/25/Spring-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%8B%A5%E5%B9%B2%E7%A7%8D%E5%B0%8F%E6%8A%80%E5%B7%A7/" title="Spring 数据库的若干种小技巧"><img class="cover" src="/img/wall-paper-10.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-25</div><div class="info-item-2">Spring 数据库的若干种小技巧</div></div><div class="info-2"><div class="info-item-1">常用命令 12345678910111213141516171819202122232425262728#  登录服务器mysql -u username -pdev -h hostname databaseName# 如何重命名一个 dbmysqldump emp &gt; emp.outmysql -e &quot;CREATE DATABASE employees;&quot;mysql employees &lt; emp.outmysql -e &quot;DROP DATABASE emp;&quot;# mysqldump 的用法mysqldump -u username -h hostname -ppassword databaseName &gt; /exportpath/dump.sql# 使用 brew 控制 mysqlbrew install mysqlbrew services restart mysql# 登录本机 root 用户mysql -uroot# 使用密码登录本机 root 用户mysql -uroot -p# 标准格式mysql -u US...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">AOP 的基本概念</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">到底应该使用哪种代理呢？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">声明各种基础类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BF%80%E6%B4%BB-aspect-%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">3.1.</span> <span class="toc-text">激活 @Aspect 注解的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E-aspect"><span class="toc-number">3.1.1.</span> <span class="toc-text">声明 Aspect</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%A6%E8%A7%A3-pointcut"><span class="toc-number">3.1.2.</span> <span class="toc-text">详解 pointcut</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%A6%E8%A7%A3-advice"><span class="toc-number">3.1.3.</span> <span class="toc-text">详解 advice</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#advice-%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.1.3.1.</span> <span class="toc-text">advice 的类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#advice-%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">3.1.3.2.</span> <span class="toc-text">advice 的优先级</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%A6%E8%A7%A3-introduction"><span class="toc-number">3.1.4.</span> <span class="toc-text">详解 introduction</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98-aop-%E5%85%B6%E4%BB%96-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.1.5.</span> <span class="toc-text">高级主题 - AOP （其他）初始化模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BF%80%E6%B4%BB-schema-based-approach"><span class="toc-number">3.2.</span> <span class="toc-text">激活 schema-based approach</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#advisor"><span class="toc-number">3.2.1.</span> <span class="toc-text">Advisor</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%B0%E5%BA%95%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8%E5%93%AA%E7%A7%8D-aop%EF%BC%9F"><span class="toc-number">3.3.</span> <span class="toc-text">到底应该使用哪种 AOP？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-xml-%E6%88%96%E6%98%AF-aspectj-%E6%B3%A8%E8%A7%A3"><span class="toc-number">3.4.</span> <span class="toc-text">使用 xml 或是 @AspectJ 注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%A4%A7%E8%BE%A8%E6%9E%90"><span class="toc-number">3.5.</span> <span class="toc-text">问题大辨析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">代理机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E8%B0%83%E7%94%A8%E4%BB%A3%E7%90%86%E5%B7%A5%E5%8E%82"><span class="toc-number">4.1.</span> <span class="toc-text">手动调用代理工厂</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8%E8%A2%AB%E4%BB%A3%E7%90%86%E7%9A%84-bean-%E9%87%8C%E8%B0%83%E7%94%A8-proxy"><span class="toc-number">4.2.</span> <span class="toc-text">如何在被代理的 bean 里调用 proxy</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#aspectj-%E4%BB%A3%E7%90%86%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E6%B3%95"><span class="toc-number">4.3.</span> <span class="toc-text">@AspectJ 代理的创建方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">使用真正的 AspectJ</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-aspectj-%E6%9D%A5%E8%BF%9B%E8%A1%8C%E9%A2%86%E5%9F%9F%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5-dependency-injection"><span class="toc-number">5.1.</span> <span class="toc-text">使用 AspectJ 来进行领域对象的依赖注入（Dependency Injection）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8A%E9%9D%A2%E7%9A%84%E4%BE%8B%E5%AD%90%E4%B8%8D%E6%88%90%E5%8A%9F-%E8%BF%99%E4%B8%AA%E4%BE%8B%E5%AD%90%E4%BC%9A%E6%88%90%E5%8A%9F"><span class="toc-number">5.2.</span> <span class="toc-text">上面的例子不成功，这个例子会成功</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#compile-time-weaving"><span class="toc-number">5.3.</span> <span class="toc-text">compile time weaving</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#spring-%E5%85%81%E8%AE%B8%E6%AF%8F%E4%B8%AA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%9C%89%E7%BB%86%E9%A2%97%E7%B2%92%E7%9A%84-ltw"><span class="toc-number">5.4.</span> <span class="toc-text">Spring 允许每个类加载器有细颗粒的 LTW</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">Spring 的 AOP API</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%87%E7%82%B9%E7%9B%B8%E5%85%B3-api"><span class="toc-number">6.1.</span> <span class="toc-text">切点相关 API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E5%88%87%E7%82%B9%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.1.1.</span> <span class="toc-text">一些有用的切点实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#jdkregexpmethodpointcut"><span class="toc-number">6.1.1.1.</span> <span class="toc-text">JdkRegexpMethodPointcut</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#regexpmethodpointcutadvisor"><span class="toc-number">6.1.1.2.</span> <span class="toc-text">RegexpMethodPointcutAdvisor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#controlflowpointcut"><span class="toc-number">6.1.1.3.</span> <span class="toc-text">ControlFlowPointcut</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E7%9A%84%E9%9D%99%E6%80%81%E5%88%87%E7%82%B9%E7%88%B6%E7%B1%BB"><span class="toc-number">6.1.1.4.</span> <span class="toc-text">通用的静态切点父类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#advice-%E7%9B%B8%E5%85%B3-api"><span class="toc-number">6.2.</span> <span class="toc-text">advice 相关 API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#interception-around-advice"><span class="toc-number">6.2.1.</span> <span class="toc-text">Interception Around Advice</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#before-advice"><span class="toc-number">6.2.2.</span> <span class="toc-text">Before Advice</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#throws-advice"><span class="toc-number">6.2.3.</span> <span class="toc-text">Throws Advice</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#after-returning-advice"><span class="toc-number">6.2.4.</span> <span class="toc-text">After Returning Advice</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#introduction-advice"><span class="toc-number">6.2.5.</span> <span class="toc-text">Introduction Advice</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#proxyfactorybean"><span class="toc-number">6.3.</span> <span class="toc-text">ProxyFactoryBean</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%8C%96%E5%9C%B0%E5%88%9B%E5%BB%BA-aop-%E4%BB%A3%E7%90%86%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">6.4.</span> <span class="toc-text">程序化地创建 AOP 代理的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%87%AA%E5%8A%A8%E4%BB%A3%E7%90%86%E8%AE%BE%E6%96%BD-auto-proxying-facility"><span class="toc-number">6.5.</span> <span class="toc-text">使用自动代理设施（auto-proxying facility）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#beannameautoproxycreator"><span class="toc-number">6.5.1.</span> <span class="toc-text">BeanNameAutoProxyCreator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#defaultadvisorautoproxycreator"><span class="toc-number">6.5.2.</span> <span class="toc-text">DefaultAdvisorAutoProxyCreator</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#targetsource-api"><span class="toc-number">6.6.</span> <span class="toc-text">TargetSource API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E7%83%AD%E6%9B%BF%E6%8D%A2-hot-swappable-%E7%9A%84-target-source"><span class="toc-number">6.6.1.</span> <span class="toc-text">可热替换（hot-swappable）的 target source</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%A0%E5%8C%96-target-source"><span class="toc-number">6.6.2.</span> <span class="toc-text">池化 target source</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E5%8C%96-target-source"><span class="toc-number">6.6.3.</span> <span class="toc-text">原型化 target source</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#threadlocal-target-source"><span class="toc-number">6.6.4.</span> <span class="toc-text">ThreadLocal target source</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%96%B0%E7%9A%84-advice-%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.6.5.</span> <span class="toc-text">定义新的 Advice 类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">总结一下 AOP 的初始化和使用方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">一般的继承关系</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90-spring-aop-%E6%A0%87%E7%AD%BE%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">8.1.</span> <span class="toc-text">解析 spring aop 标签的流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%80%99%E9%80%89-bean"><span class="toc-number">8.1.1.</span> <span class="toc-text">获取候选 bean</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#proxy-%E4%BD%93%E7%B3%BB"><span class="toc-number">8.2.</span> <span class="toc-text">proxy 体系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%9A%84-proxy-%E5%B7%A5%E5%8E%82"><span class="toc-number">8.2.1.</span> <span class="toc-text">基本的 proxy 工厂</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#proxyfactory"><span class="toc-number">8.2.1.1.</span> <span class="toc-text">ProxyFactory</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#defaultaopproxyfactory"><span class="toc-number">8.2.1.1.1.</span> <span class="toc-text">DefaultAopProxyFactory</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jdkdynamicaopproxy"><span class="toc-number">8.2.2.</span> <span class="toc-text">JdkDynamicAopProxy</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#defaultadvisorchainfactory"><span class="toc-number">8.2.2.1.</span> <span class="toc-text">DefaultAdvisorChainFactory</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reflectivemethodinvocation"><span class="toc-number">8.2.3.</span> <span class="toc-text">ReflectiveMethodInvocation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#aoputils"><span class="toc-number">8.2.4.</span> <span class="toc-text">AopUtils</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#aopproxyutils"><span class="toc-number">8.2.5.</span> <span class="toc-text">AopProxyUtils</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#classutils"><span class="toc-number">8.2.6.</span> <span class="toc-text">ClassUtils</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#objenesiscglibaopproxy"><span class="toc-number">8.2.7.</span> <span class="toc-text">ObjenesisCglibAopProxy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cglibaopproxy"><span class="toc-number">8.2.8.</span> <span class="toc-text">CglibAopProxy</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#methodinvocation"><span class="toc-number">8.3.</span> <span class="toc-text">MethodInvocation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#joinpoint-%E8%AE%BE%E8%AE%A1"><span class="toc-number">8.4.</span> <span class="toc-text">JoinPoint 设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#joinpoint"><span class="toc-number">8.5.</span> <span class="toc-text">JoinPoint</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#proceedingjoinpoint"><span class="toc-number">8.5.1.</span> <span class="toc-text">ProceedingJoinPoint</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2017 - 2026 By magicliang</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional and Simplified Chinese">簡</button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><script src="/js/tw_cn.js?v=5.5.2"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="/"></script></div></body></html>