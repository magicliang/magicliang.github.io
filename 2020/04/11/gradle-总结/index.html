<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>gradle 总结 | 守株阁</title><meta name="author" content="magicliang"><meta name="copyright" content="magicliang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="gradle.xmind    这里的 AIDL 是 Android Interface Definition Language 的意思。Dex 是 Dalvik executable format 的意思。  基本概念 gradle 是一个自动化构建工具（build automation，而不是像 maven 一样标榜自己是个 project management 工具），通过组织一系列 t">
<meta property="og:type" content="article">
<meta property="og:title" content="gradle 总结">
<meta property="og:url" content="https://magicliang.github.io/2020/04/11/gradle-%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="守株阁">
<meta property="og:description" content="gradle.xmind    这里的 AIDL 是 Android Interface Definition Language 的意思。Dex 是 Dalvik executable format 的意思。  基本概念 gradle 是一个自动化构建工具（build automation，而不是像 maven 一样标榜自己是个 project management 工具），通过组织一系列 t">
<meta property="og:locale">
<meta property="og:image" content="https://magicliang.github.io/2020/04/11/gradle-%E6%80%BB%E7%BB%93/Gradle_logo.png">
<meta property="article:published_time" content="2020-04-11T02:37:59.000Z">
<meta property="article:modified_time" content="2025-10-22T08:01:32.194Z">
<meta property="article:author" content="magicliang">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="gradle">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://magicliang.github.io/2020/04/11/gradle-%E6%80%BB%E7%BB%93/Gradle_logo.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "gradle 总结",
  "url": "https://magicliang.github.io/2020/04/11/gradle-%E6%80%BB%E7%BB%93/",
  "image": "https://magicliang.github.io/2020/04/11/gradle-%E6%80%BB%E7%BB%93/Gradle_logo.png",
  "datePublished": "2020-04-11T02:37:59.000Z",
  "dateModified": "2025-10-22T08:01:32.194Z",
  "author": [
    {
      "@type": "Person",
      "name": "magicliang",
      "url": "https://magicliang.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://magicliang.github.io/2020/04/11/gradle-%E6%80%BB%E7%BB%93/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: magicliang","link":"Link: ","source":"Source: 守株阁","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'gradle 总结',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="守株阁" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/2020/04/11/gradle-%E6%80%BB%E7%BB%93/Gradle_logo.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">守株阁</span></a><a class="nav-page-title" href="/"><span class="site-name">gradle 总结</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">gradle 总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2020-04-11T02:37:59.000Z" title="Created 2020-04-11 10:37:59">2020-04-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-10-22T08:01:32.194Z" title="Updated 2025-10-22 16:01:32">2025-10-22</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">9.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>40mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p><img src="author-gradle-2.png" alt="author-gradle-2"><br>
<img src="gradle-basic-flow.png" alt="gradle-basic-flow"><br>
<a href="gradle.xmind">gradle.xmind</a><br>
<img src="gradle.png" alt="gradle"></p>
<p><img src="gradle%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" alt="gradle流程图"><br>
<img src="android%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B.webp" alt="android打包流程"></p>
<p>这里的 AIDL 是 Android Interface Definition Language 的意思。Dex 是 Dalvik executable format 的意思。</p>
<p><img src="aapt2%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B.webp" alt="aapt2编译流程"></p>
<h1>基本概念</h1>
<p>gradle 是一个自动化构建工具（build automation，而不是像 maven 一样标榜自己是个 project management 工具），通过组织一系列 task 来最终完成自动化构建，<strong>所以 task 是 gradle 里最重要的概念之一</strong>， 以打包生成 apk 为例，整个过程要经过资源的处理，javac 编译，dex 打包，apk 打包，签名等等步骤，<strong>每个步骤就对应到 gradle 里的一个 task</strong>。因为这些 task 是 gradle 的生命周期里特有的，所以 gradle 的插件应该不能移植到其他构建工具里- maven 和 gradle 的插件不互通。</p>
<p>gradle 是事实上的 android/Kotlin 默认构建工具，<strong>虽然基于 JVM，但是可以用来构建其他语言</strong>。</p>
<p>每一个插件新增在 gradle 脚本里，都会带来新的 tasks。gradle 的 build 会触发很多的任务，包括但不限于构建和测试我们做构建完了以后通常会看到这样的文字：460 actionable tasks: 460 executed-因为很多任务针对不同的 module 和 source set 会重复执行，所以项目越大，actionable tasks 越多。我们常见的 build 文件夹是 gradle 会频繁使用的东西-构建的各种中间产出都在这里面。</p>
<p>gradle 可以使用 Groovy 或者 Kotlin DSL编写，这里我们涉及一个概念-DSL ，DSL 也就是 Domain Specific Language 的简称，<strong>相对应的是 GPL (General-Purpose Language)</strong>，比如 java 语言。与 GPL 相比起来，DSL 使用简单，定义比较简洁，比起配置文件，DSL 又可以实现语言逻辑-对 gradle 脚本来说，通过DSL实现了简洁的定义，又有充分的语言逻辑，以<code>android &#123;&#125;</code>为例，<strong>这本身是一个函数调用，参数是一个闭包，但是这种定义方式明显要简洁很多</strong>。</p>
<p>这类项目管理工具的基础是，如何使用声明式风格进行配置。所以它比 Maven 优秀的地方在于支持<code>easy to build by implementing conventions</code>。</p>
<p>core types：</p>
<ul>
<li>Project（build.gradle 实际上就是在描述这个类型对象的生成）</li>
<li>Task</li>
<li>Gradle</li>
<li>Settings</li>
<li>IncludedBuild</li>
<li>Script</li>
<li>SourceSet</li>
<li>SourceSetOutput</li>
<li>SourceDirectorySet</li>
<li>Configuration</li>
<li>ResolutionStrategy</li>
<li>ArtifactResolutionQuery</li>
<li>ComponentSelection</li>
<li>ComponentSelectionRules</li>
<li>DependencyAdder</li>
<li>ExtensionAware</li>
<li>ExtraPropertiesExtension</li>
<li>PluginDependenciesSpec</li>
<li>PluginDependencySpec</li>
<li>PluginManagementSpec</li>
<li>ResourceHandler</li>
<li>TextResourceFactory</li>
<li>InputChanges</li>
<li>Distribution</li>
</ul>
<h2 id="project-对象">Project 对象</h2>
<p>我们常见的属性其实是<strong>一个 Project 对象的实例</strong>，使用 groovy 进行配置更像是使用一种 DSL 进行设值。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs groovy">buildscript <span class="hljs-comment">// 配置脚本（build.gradle）的 classpath</span><br><br>allprojects <span class="hljs-comment">// 配置项目及其子项目</span><br>respositories <span class="hljs-comment">// 配置仓库地址，后面的依赖都会去这里配置的地址查找</span><br>dependencies <span class="hljs-comment">// 配置项目的依赖</span><br><br><br><span class="hljs-comment">// 一个Android Project工程的标准配置</span><br><br>buildscript &#123; <span class="hljs-comment">// 配置项目（build.gradle）的 classpath</span><br>    <span class="hljs-comment">// 每个 &#123;&#125; 圈定的闭包都是对一个单独的对象实例进行配置，配置的流程就是一行一行地调用方法</span><br>    <span class="hljs-comment">// 在这个块中定义的依赖项和仓库只对构建脚本本身可用，不会影响项目的依赖。通常用于添加 Gradle 插件依赖。</span><br>    repositories &#123;  <span class="hljs-comment">// 项目的仓库地址，会按顺序依次查找</span><br>        <span class="hljs-comment">// 这是一种调用法，寻找插件就在这里面寻找</span><br>        google()<br>        jcenter()<br>        mavenLocal()<br>    &#125;<br>    dependencies &#123; <span class="hljs-comment">// 项目的依赖</span><br>        <span class="hljs-comment">// 这是使用参数的调用法</span><br>        classpath <span class="hljs-string">&#x27;com.android.tools.build:gradle:4.2.1&#x27;</span><br>        classpath <span class="hljs-string">&#x27;com.xx.plugin:xxplugin:0.0.1&#x27;</span><br>        <span class="hljs-comment">// 把插件引入类路径以后，下方还需要/可以 apply plugin: &#x27;io.ebean&#x27;</span><br>        classpath <span class="hljs-string">&quot;io.ebean:ebean-gradle-plugin:12.2.3&quot;</span><br>    &#125;<br>    <br>&#125;<br><br>allprojects &#123; <span class="hljs-comment">// 子项目的配置</span><br>    repositories &#123;<br>        google()<br>        jcenter()<br>        mavenLocal()<br>        flatDir &#123;       <br>            dirs <span class="hljs-string">&quot;libs&quot;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里面的 buildscript 的 dependencies 是给 build.gradle 这个项目脚本构建中使用的。而我们常见的其他地方的 dependencies 是给项目打包/运行的时候项目自身用的。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">import</span> org.yaml.snakeyaml.Yaml<br><br>buildscript &#123;<br>    repositories &#123; <span class="hljs-comment">// Where to find the plugin or library</span><br>        maven &#123;<br>            url = uri(<span class="hljs-string">&quot;https://plugins.gradle.org/m2/&quot;</span>)<br>        &#125;<br>        mavenCentral()<br>    &#125;<br>    dependencies &#123;<br>        classpath <span class="hljs-string">&#x27;org.yaml:snakeyaml:1.19&#x27;</span> <span class="hljs-comment">// The library&#x27;s classpath dependency</span><br>        classpath <span class="hljs-string">&#x27;com.gradleup.shadow:shadow-gradle-plugin:8.3.4&#x27;</span> <span class="hljs-comment">// Plugin dependency for legacy plugin application</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Applies legacy Shadow plugin</span><br>apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;com.gradleup.shadow&#x27;</span><br><br><span class="hljs-comment">// Uses the library in the build script</span><br><span class="hljs-keyword">def</span> yamlContent = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        name: Project Name</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><span class="hljs-keyword">def</span> yaml = <span class="hljs-keyword">new</span> Yaml()<br><span class="hljs-keyword">def</span> data = yaml.load(yamlContent)<br></code></pre></td></tr></table></figure>
<p>在 idea 里，右侧的栏目列出的只有<strong>任务（插件看不见，被融入任务列表）+依赖</strong>。</p>
<p>gradle 能支持的仓库类型/风格有 remote（maven、ivy，可以用Nexus/Sonatype/JFrog）和 local（flatDir）。</p>
<h2 id="task">Task</h2>
<p>任务可以被分为：Application tasks、Build tasks、Documentation tasks、Other tasks。</p>
<h3 id="任务管理">任务管理</h3>
<p>A task represents some independent unit of work that a build performs, such as compiling classes, creating a JAR, generating Javadoc, or publishing archives to a repository.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./gradlew tasks<br></code></pre></td></tr></table></figure>
<h4 id="基本的任务创建形式">基本的任务创建形式</h4>
<p>最新版的做法：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs groovy">tasks.register(<span class="hljs-string">&quot;task1&quot;</span>) &#123;  <br>    println(<span class="hljs-string">&quot;REGISTER TASK1: This is executed during the configuration phase&quot;</span>)<br>&#125;<br><br>tasks.named(<span class="hljs-string">&quot;task1&quot;</span>) &#123;  <br>    println(<span class="hljs-string">&quot;NAMED TASK1: This is executed during the configuration phase&quot;</span>)<br>    doFirst &#123;<br>        println(<span class="hljs-string">&quot;NAMED TASK1 - doFirst: This is executed during the execution phase&quot;</span>)<br>    &#125;<br>    doLast &#123;<br>        println(<span class="hljs-string">&quot;NAMED TASK1 - doLast: This is executed during the execution phase&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>To create a custom task, you must subclass DefaultTask in Groovy DSL or DefaultTask in Kotlin DSL.要创建一个自定义任务，你必须在 Groovy DSL 中继承 DefaultTask 类，或者在 Kotlin DSL 中继承 DefaultTask 类。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// 以任务名创建：接受一个name参数</span><br><span class="hljs-keyword">def</span> task myTask = task(myTask)<br>myTask.doLast&#123;<br> println <span class="hljs-string">&quot;第一种创建Task方法，原型为Task task(String name) throws InvalidUserDataException&quot;</span><br>&#125;<br><br><span class="hljs-comment">// 以任务名+Map创建：Map参数用于对创建的task进行配置，可用配置（可选参数有）有 type、overwrite、dependsOn、action、description、group</span><br><span class="hljs-keyword">def</span> task myTask = task(myTask, <span class="hljs-attr">group:</span>BasePlugin.BUILD_GROUP)<br>myTask.doLast &#123;<br> println <span class="hljs-string">&quot;第二种创建Task方法，原型为Task task(String name,Map&lt;String,?&gt; args) throws InvalidUserDataException&quot;</span><br>&#125;<br><br><span class="hljs-comment">// 以任务名+闭包创建：常见形式</span><br>task myTask &#123;<br> doLast&#123;<br>   println <span class="hljs-string">&quot;第三种创建Task方法，原型为Task task(String name,Closure configureClosure)，第一个参数是 name，第二个参数是 configureClosure&quot;</span><br> &#125;<br>&#125;<br><br><span class="hljs-comment">// 多任务依赖，这里面 task1 和 task2 之间没有依赖关系</span><br>task task1&lt;&lt;&#123; <span class="hljs-comment">// 每个任务都使用了 &lt;&lt; 操作符，这是一种在旧版本 Gradle 中添加任务动作的方式。 (注意：&lt;&lt; 操作符在新版本的 Gradle 中已被弃用，现在推荐使用 doLast 方法)</span><br> println <span class="hljs-string">&#x27;hello&#x27;</span><br>&#125;<br>task task2&lt;&lt;&#123;<br> println <span class="hljs-string">&#x27;world&#x27;</span><br>&#125;<br><span class="hljs-comment">// 依赖单个任务</span><br>task task3(<span class="hljs-attr">dependsOn:</span>task1) &#123;<br> doLast&#123;<br>   println <span class="hljs-string">&#x27;one&#x27;</span><br> &#125;<br>&#125;<br><span class="hljs-comment">// 依赖多个任务</span><br>task task4 &#123;<br> dependsOn task1,task2<br> doLast&#123;<br>   println <span class="hljs-string">&#x27;two&#x27;</span><br> &#125;<br>&#125;<br><br><span class="hljs-comment">// 强制排序</span><br>taskB.shouldRunAfter(taskA) <span class="hljs-comment">// 表示taskB应该在taskA执行之后执行，有可能不会按预设执行</span><br>taskB.mustRunAfter(taskA) <span class="hljs-comment">// 表示taskB必须在taskA执行之后执行</span><br><br><span class="hljs-comment">// 分组&amp;描述：分组是对任务的分类，便于归类整理；描述是说明任务的作用；建议两个一起配置，便于快速了解任务的分类和用途。和上面的“以任务名+Map创建”本质上相同</span><br><span class="hljs-keyword">def</span> task myTask = task(myTask)<br>myTask .group = BasePlugin.BUILD_GROUP<br>myTask .description = <span class="hljs-string">&#x27;这是一个构建的引导任务&#x27;</span><br><br><span class="hljs-comment">// 启用&amp;禁用：enable属性可以启动和禁用任务，执行被禁用的任务输出提示该任务被跳过</span><br><span class="hljs-keyword">def</span> task myTask = task(myTask)<br>myTask.enable = <span class="hljs-literal">false</span> <span class="hljs-comment">//禁用任务</span><br></code></pre></td></tr></table></figure>
<p>执行分析：<strong>执行 Task 的时候实际上是执行其拥有的 actions List，它是 Task 对象实例的成员变量；在创建任务时Gradle会解析其中被 TaskAction 注解的方法作为其Task执行的 action，并添加到 actions List，其中 doFirst 和 doList 会被添加到 action List 第一位和最后一位</strong>。</p>
<p>每次构建（build）至少由一个 project 构成，一个 project  由一到多个 task 构成。每个 task 代表了构建过程当中的一个原子性操作，比如编译，打包，生成 javadoc，发布等等这些操作。</p>
<blockquote>
<p>project<br>
– task1 （Action1、Action2…）<br>
– task2 （Action1、Action2…）<br>
– …</p>
</blockquote>
<h4 id="通过任务把功能注册成插件">通过任务把功能注册成插件</h4>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// 伪代码</span><br>open <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProjectDependencyGraphGeneratorTask</span> : DefaultTask() &#123;<br>    <span class="hljs-meta">@TaskAction</span><br>    fun run() &#123;<br>        File(outputDirectory, projectGenerator.outputFileNameDot).writeText(graph.toString())<br><br>        val graphviz = Graphviz.fromGraph(graph)<br><br>        projectGenerator.outputFormats.forEach &#123;<br>            graphviz.render(it).toFile(File(outputDirectory, projectGenerator.outputFileName))<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 伪代码</span><br>open <span class="hljs-keyword">class</span> <span class="hljs-title class_">DependencyGraphGeneratorPlugin</span> : Plugin&lt;Project&gt; &#123;<br>  override fun apply(<span class="hljs-attr">project:</span> Project) &#123;<br>     project.tasks.register(projectGenerator.gradleTaskName, <span class="hljs-attr">ProjectDependencyGraphGeneratorTask:</span>:<span class="hljs-keyword">class</span>.java)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTask</span> : DefaultTask &#123;<br>    <span class="hljs-meta">@TaskAction</span><br>    fun doAction()&#123;<br>        println(<span class="hljs-string">&quot;my task run&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FastPlugin</span> : Plugin&lt;Project&gt; &#123;<br>    override fun apply(<span class="hljs-attr">project:</span> Project) &#123;<br>        println(<span class="hljs-string">&quot;apply my plugin&quot;</span>)<br>        project.tasks.register(<span class="hljs-string">&quot;mytask&quot;</span>, <span class="hljs-attr">MyTask:</span>:<span class="hljs-keyword">class</span>.java)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="定义任务的依赖关系">定义任务的依赖关系</h4>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs groovy">task putOnSocks &#123;<br>    doLast &#123;<br>        println <span class="hljs-string">&quot;Putting on Socks.&quot;</span><br>    &#125;<br>&#125;<br><br>task putOnShoes &#123;<br>    dependsOn <span class="hljs-string">&quot;putOnSocks&quot;</span><br>    doLast &#123;<br>        println <span class="hljs-string">&quot;Putting on Shoes.&quot;</span><br>    &#125;<br>&#125;<br><br>task eatBreakfast &#123;<br>    finalizedBy <span class="hljs-string">&quot;brushYourTeeth&quot;</span><br>    doLast&#123;<br>        println <span class="hljs-string">&quot;Om nom nom breakfast!&quot;</span><br>    &#125;<br>&#125;<br><br>task brushYourTeeth &#123;<br>    doLast &#123;<br>        println <span class="hljs-string">&quot;Brushie Brushie Brushie.&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="向任务注入对象">向任务注入对象</h4>
<p>可注入对象：</p>
<ul>
<li>ObjectFactory- 允许创建模型对象。</li>
<li>ProjectLayout- 提供对关键项目位置的访问权限。</li>
<li>BuildLayout- 提供对 Gradle 构建的重要位置的访问。</li>
<li>ProviderFactory- 创建Provider实例。</li>
<li>WorkerExecutor- 允许任务并行运行。</li>
<li>FileSystemOperations- 允许任务在文件系统上运行操作，例如删除文件、复制文件或同步目录。</li>
<li>ArchiveOperations- 允许任务对存档文件（例如 ZIP 或 TAR 文件）运行操作。</li>
<li>ExecOperations- 允许任务运行外部进程，并提供专门的运行外部java程序的支持。</li>
<li>ToolingModelBuilderRegistry- 允许插件注册 Gradle 工具 API 模型。</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs groovy">tasks.register(<span class="hljs-string">&quot;myObjectFactoryTask&quot;</span>) &#123;<br>    doLast &#123;<br>        <span class="hljs-keyword">def</span> objectFactory = project.objects<br>        <span class="hljs-keyword">def</span> myProperty = objectFactory.property(String)<br>        myProperty.set(<span class="hljs-string">&quot;Hello, Gradle!&quot;</span>)<br>        println myProperty.get()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DownloadExtension</span> &#123;<br>    <span class="hljs-comment">// A nested instance</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Resource resource;<br><br>    <span class="hljs-meta">@Inject</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DownloadExtension</span><span class="hljs-params">(ObjectFactory objectFactory)</span> &#123;<br>        <span class="hljs-comment">// Use an injected ObjectFactory to create a Resource object</span><br>        resource = objectFactory.newInstance(Resource.class);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Resource <span class="hljs-title function_">getResource</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> resource;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Resource</span> &#123;<br>    Property&lt;URI&gt; <span class="hljs-title function_">getUri</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="属性管理">属性管理</h2>
<p>Project、Task 和 SourceSet 都允许用户添加额外的自定义属性、并对自定义属性进行读取和设置。</p>
<ul>
<li>方式：通过ext属性，添加多个 ext 代码块</li>
<li>优点：相比局部变量有广泛的作用域，可以跨 Project、跨 Task 访问，只要能访问这些属性所属的对象即可</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// 给Project添加自定义属性</span><br>ext.age = <span class="hljs-number">18</span><br>ext &#123;<br> phone = <span class="hljs-number">13888888888</span><br> address = <span class="hljs-string">&#x27;Beijing&#x27;</span><br>&#125;<br><br><span class="hljs-comment">// 给Task添加自定义属性</span><br>task customProperty &#123; <br> ext.inner = <span class="hljs-string">&#x27;innnnnner&#x27;</span> <br> <br> doLast&#123;<br>   println project.hasProperty(<span class="hljs-string">&#x27;customProperty&#x27;</span>) <span class="hljs-comment">// true</span><br>   println project.hasProperty(<span class="hljs-string">&#x27;age&#x27;</span>) <span class="hljs-comment">// true</span><br>   println project.hasProperty(<span class="hljs-string">&#x27;inner&#x27;</span>)<span class="hljs-comment">// 返回fasle</span><br>   println <span class="hljs-string">&quot;$&#123;age&#125;&quot;</span><br>   println <span class="hljs-string">&quot;$&#123;phone&#125;&quot;</span><br>   println <span class="hljs-string">&quot;$&#123;inner&#125;&quot;</span><br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="惰性加载">惰性加载</h3>
<p><img src="prop-prov-1.png" alt="为什么要使用 property 而不使用原始类型"></p>
<p>Gradle 使用两个接口表示惰性属性：</p>
<ul>
<li>property - 表示可以查询和更改的值。属性可能是可变的，这意味着它同时具有get()方法和set()方法（类似C#）。</li>
<li>provider - 表示只能查询而不能更改的值。也叫Read-only Managed Properties (Providers)。</li>
</ul>
<h2 id="plugin">Plugin</h2>
<p>Plugins are the primary method to organize build logic and reuse build logic within a project.</p>
<p>Plugins are used to extend Gradle’s capability（功能） and optionally contribute tasks to a project.</p>
<p>plugin 里带有很多 tasks。一个 plugin 主要影响 source set 和 configuration，带来了属性（SourceSet就性质而言是一种 property，但文档把它称作 domain objects）、方法和任务。</p>
<ul>
<li>Java 插件
<ul>
<li>插件 ID: java</li>
<li>主要功能：
<ul>
<li>添加 Java 编译能力</li>
<li>提供标准的 Java 项目结构和任务（如 compileJava, test）</li>
<li>添加基本的依赖配置（如 implementation, testImplementation）</li>
</ul>
</li>
<li>适用场景：基本的 Java 项目，<strong>很多插件都扩展本插件，包括但不限于：Application、Java Library</strong></li>
</ul>
</li>
<li>Application 插件
<ul>
<li>插件 ID: application</li>
<li>主要功能：
<ul>
<li>包含 Java 插件的所有功能</li>
<li>添加运行和打包应用程序的能力</li>
<li>提供 run 任务来执行应用程序</li>
<li>可以创建可分发的 ZIP 和 TAR 包</li>
</ul>
</li>
<li>适用场景：需要作为独立应用程序运行的 Java 项目</li>
</ul>
</li>
<li>Java Library 插件
<ul>
<li>插件 ID: java-library</li>
<li>主要功能：
<ul>
<li>扩展了 Java 插件</li>
<li>引入 api 和 implementation 依赖配置的区别</li>
<li>更好地控制库的 API 暴露</li>
</ul>
</li>
<li>适用场景：开发供其他项目使用的 Java 库</li>
</ul>
</li>
<li>Spring Boot 插件
<ul>
<li>插件 ID: org.springframework.boot</li>
<li>主要功能：
<ul>
<li>提供 Spring Boot 特定的任务（如 bootRun）</li>
<li>能够创建可执行的 JAR 或 WAR 文件</li>
<li>管理 Spring Boot 依赖版本</li>
<li>提供 Spring Boot 的自动配置支持</li>
</ul>
</li>
<li>适用场景：Spring Boot 应用程序开发</li>
</ul>
</li>
<li>Spring Dependency Management 插件
<ul>
<li>插件 ID: io.spring.dependency-management</li>
<li>主要功能：
<ul>
<li>提供类似 Maven BOM（Bill of Materials）的依赖管理</li>
<li>允许在不指定版本的情况下导入依赖</li>
<li>可以与 Spring Boot 插件配合使用，也可以单独使用</li>
</ul>
</li>
<li>适用场景：需要统一管理依赖版本的项目，特别是 Spring 项目</li>
</ul>
</li>
<li>主要区别和使用场景：
<ul>
<li>基本 Java 项目：使用 java 插件。</li>
<li>可执行的 Java 应用：使用 application 插件。</li>
<li>Java 库开发：使用 java-library 插件。</li>
<li>Spring Boot 应用开发：使用 org.springframework.boot 插件，通常与 io.spring.dependency-management 插件一起使用。</li>
<li>需要精细控制依赖版本的项目：使用 io.spring.dependency-management 插件。</li>
</ul>
</li>
</ul>
<p>这些插件可以组合使用，例如：</p>
<ul>
<li>一个 Spring Boot 应用通常会同时使用 java、org.springframework.boot 和 io.spring.dependency-management 插件。</li>
<li>一个作为库开发的 Spring 项目可能会使用 java-library 和 io.spring.dependency-management 插件。</li>
</ul>
<p>大部分构建类的插件都是派生自 Base 插件，比如 java 插件，然后 The Java Library Plugin also integrates the above tasks into the standard Base Plugin lifecycle tasks，比如jar is attached to assemble，test is attached to check。</p>
<h3 id="分类">分类</h3>
<ol>
<li>Core plugins - Gradle develops and maintains a set of Core Plugins. Gradle Core plugins are a set of plugins that are included in the Gradle distribution itself. 核心插件不需要指定版本。</li>
<li>Community plugins - Gradle’s community shares plugins via the <a target="_blank" rel="noopener" href="http://plugins.gradle.org/?_gl=1*e6gbab*_gcl_au*MTgwODAzNzI5OS4xNzM1MDI5NjA3*_ga*MjEwNzg4ODc5Ni4xNzM1MDI5NjA3*_ga_7W7NC6YNPT*MTczNTI5NDg1OS43LjEuMTczNTI5ODAxOS41Ny4wLjA.">Gradle Plugin Portal</a>. Community plugins are plugins developed by the Gradle community, rather than being part of the core Gradle distribution. These plugins provide additional functionality that may be specific to certain use cases or technologies.</li>
<li>Local plugins/Custom plugins - Gradle enables users to create custom plugins using APIs.Custom or local plugins are developed and used within a specific project or organization. These plugins are not shared publicly and are tailored to the specific needs of the project or organization.</li>
</ol>
<p>Convention plugins are plugins used to share build logic between subprojects (modules). Users can wrap common logic in a convention plugin. For example, a code coverage plugin used as a convention plugin can survey code coverage for the entire project and not just a specific subproject.</p>
<blockquote>
<p>Gradle highly recommends the use of Convention plugins.</p>
</blockquote>
<p>所有的插件的定义都有这样一段<code>tasks.register</code>。</p>
<p>区分插件的标准是看是已经被编译成字节码（binary plugin），还是能看到源码（script plugin i）。A plugin often starts as a script plugin (because they are easy to write). Then, as the code becomes more valuable, it’s migrated to a binary plugin that can be easily tested and shared between multiple projects or organizations.二进制插件可以更高效共享和运行。</p>
<p>插件的使用总是分两步：</p>
<ol>
<li>resolve 解析：这是配置 repo 和 class path 的意义</li>
<li>apply：会调用<code>Plugin.apply(T)</code></li>
</ol>
<h3 id="声明">声明</h3>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs groovy">plugins &#123;<br>    id(<span class="hljs-string">&quot;org.barfuin.gradle.taskinfo&quot;</span>) version <span class="hljs-string">&quot;2.1.0&quot;</span><br>&#125;<br>allprojects &#123;<br>    apply(plugin = <span class="hljs-string">&quot;org.barfuin.gradle.taskinfo&quot;</span>)<br>    repositories &#123;<br>        mavenCentral()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果在顶层指定过版本，则在其他 method 里可以不指定版本了。</p>
<p>现代的 gradle有个特殊的目录和文件，对全部项目可以这样声明：</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-keyword">plugins</span> &#123;<br>    <span class="hljs-built_in">id</span> <span class="hljs-symbol">&#x27;java</span><span class="hljs-operator">-</span>gradle<span class="hljs-operator">-</span>plugin&#x27;<br>&#125;<br><br><span class="hljs-keyword">gradlePlugin</span> &#123;<br>    <span class="hljs-keyword">plugins</span> &#123;<br>        <span class="hljs-keyword">myPlugins</span> &#123;<br>            <span class="hljs-built_in">id</span> <span class="hljs-operator">=</span> <span class="hljs-symbol">&#x27;my</span><span class="hljs-operator">-</span>plugin&#x27;<br>            implementationClass <span class="hljs-operator">=</span> <span class="hljs-symbol">&#x27;my</span>.MyPlugin&#x27;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="插件仓库">插件仓库</h3>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs groovy">pluginManagement &#123;  <br>    plugins &#123;<br>    &#125;<br>    resolutionStrategy &#123;<br>    &#125;<br>    repositories &#123;<br>        gradlePluginPortal()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="java">java</h3>
<p><img src="javaPluginTasks.png" alt="javaPluginTasks"></p>
<p>这几幅图说明了 java 插件是如此重要！我们常见的构建任务都是这个插件带来的。</p>
<h4 id="sourceset">SourceSet</h4>
<p>Gradle’s Java support was the first to introduce a new concept for building <strong>source-based projects</strong>: source sets。</p>
<p><strong>源码集的概念是由 java 插件引入的，不是 gradle 自带的。</strong></p>
<p>source code and resources files 应该被 logically grouped together。每个 source set 要关注自己的 dependencies 和 classpath。</p>
<p>这个插件的假定 layout 是这样的：</p>
<ul>
<li>src/main/java
<ul>
<li><strong>Production Java source</strong>.</li>
</ul>
</li>
<li>src/main/resources
<ul>
<li>Production resources, such as XML and properties files.</li>
</ul>
</li>
<li>src/test/java
<ul>
<li>Test Java source.</li>
</ul>
</li>
<li>src/test/resources
<ul>
<li>Test resources.</li>
</ul>
</li>
<li>src/sourceSet/java
<ul>
<li>Java source for the source set named sourceSet.</li>
</ul>
</li>
<li>src/sourceSet/resources
<ul>
<li>Resources for the source set named sourceSet.</li>
</ul>
</li>
</ul>
<p>The Java plugin will compile whatever it finds, and handles anything which is missing.</p>
<p>You configure the project layout by configuring the appropriate source set.</p>
<p>我们常见的 main 和 test 是两个 java plugin 从 apache maven <strong>借来</strong>的 convention source set（所以它 maven-compatible）。按照 gradle 的观点，只要共享一个 complilation 和 runtime classpath，就可以把 test 配在同一个 source set 里。main 是用来存放 production source code，而 test 是用来存放测试 source code（默认是 unit test，不是 integration test、acceptance test）。这些 source 是 set 是用来保管 source code 的集合的，output 是它的附加属性。</p>
<p>比如上面的默认 source set 大致上等价于这样一段配置：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs groovy">sourceSets &#123;<br>    main &#123;<br>        java &#123;<br>            srcDirs = [<span class="hljs-string">&#x27;src/main/java&#x27;</span>]<br>        &#125;<br>        resources &#123;<br>            srcDirs = [<span class="hljs-string">&#x27;src/main/resources&#x27;</span>]<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>source set 要关注这三个问题：</p>
<ol>
<li>源代码和源代码的定位</li>
<li>编译的类路径-依赖来自于何处</li>
<li>classes 文件应该被输出到何处</li>
</ol>
<p><img src="java-sourcesets-compilation.png" alt="java-sourcesets-compilation"></p>
<p>这个图里面，configuration 是 property，白色的是一个编译任务（每个 sourceSet 有一个编译任务，名称叫 compileSourceSetJava），三个绿方块就是 source set 关注的三个问题。sourceSet 可以被替换为 main 和 test。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs groovy">plugins &#123;<br>    <span class="hljs-comment">// 源码集的概念是由插件引入的，不是 gradle 自带的</span><br>    id <span class="hljs-string">&#x27;java&#x27;</span><br>&#125;<br><br>repositories &#123;<br>    mavenCentral()<br>&#125;<br><br>dependencies &#123;<br>    <span class="hljs-comment">// 仅在编译时需要的依赖</span><br>    sourceSets.main.compileOnly <span class="hljs-string">&#x27;org.projectlombok:lombok:1.18.24&#x27;</span><br>    annotationProcessor <span class="hljs-string">&#x27;org.projectlombok:lombok:1.18.24&#x27;</span><br><br>    <span class="hljs-comment">// 编译时和运行时都需要的依赖</span><br>    sourceSets.main.implementation <span class="hljs-string">&#x27;org.springframework.boot:spring-boot-starter:2.7.4&#x27;</span><br>    sourceSets.main.implementation <span class="hljs-string">&#x27;org.springframework.boot:spring-boot-starter-aop:2.7.4&#x27;</span><br>    sourceSets.main.implementation <span class="hljs-string">&#x27;org.springframework.boot:spring-boot-starter-logging:2.7.4&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>Most language plugins, Java included, automatically create a source set called main, which is used for the project’s production code. This source set is special in that its name is not included in the names of the configurations and tasks, hence why you have just a compileJava task and compileOnly and implementation configurations rather than compileMainJava, mainCompileOnly and mainImplementation respectively.</p>
<p><img src="java-sourcesets-process-resources.png" alt="java-sourcesets-process-resources"></p>
<p>每个源码集都有一个专有的 processSourceSetResources (or processResources for the main source set)。</p>
<p>什么时候我们需要使用一个 custom source set？</p>
<p>当我们要形成特定的布局定义的时候：</p>
<ul>
<li>编译需要一个独特的类路径（unique classpath）</li>
<li>生成需要特殊处理的类，不同于 main 和 test</li>
</ul>
<p>如果有个三方的源代码需要加入源码集里，有个例子是：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs groovy">sourceSets &#123;<br>    main &#123;<br>        <span class="hljs-comment">// 等价于 java.srcDirs = [&#x27;src&#x27;]</span><br>        java &#123;<br>            <span class="hljs-comment">// 这里用第三方的源代码代替了原始的 src/main，如果要把新旧源码混合到一起最好使用数组形式 srcDirs</span><br>            srcDir <span class="hljs-string">&#x27;thirdParty/src/main/java&#x27;</span><br>        &#125;<br>        <span class="hljs-comment">//  manifest.srcFile &#x27;AndroidManifest.xml&#x27;</span><br>        <span class="hljs-comment">//  java.srcDirs = [&#x27;src&#x27;]</span><br>        <span class="hljs-comment">//  resources.srcDirs = [&#x27;src&#x27;]</span><br>        <span class="hljs-comment">//  aidl.srcDirs = [&#x27;src&#x27;]</span><br>        <span class="hljs-comment">//  renderscript.srcDirs = [&#x27;src&#x27;]</span><br>        <span class="hljs-comment">//  res.srcDirs = [&#x27;res&#x27;]</span><br>        <span class="hljs-comment">//   assets.srcDirs = [&#x27;assets&#x27;]</span><br>        <span class="hljs-comment">//  jniLibs.srcDirs = [&#x27;libs&#x27;]</span><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>srcDir 是个方法，调用方法的目的是 append，与之对应的 srcDirs 是个属性，<strong>调用属性的目的是 replace</strong>。这是 gradle 的一个设计惯例。<strong>是 method 还是 property 看赋值方式是看通过空格还是=赋值</strong>，也可以通过查看文档来了解。</p>
<h4 id="为集成测试准备的一些配置">为集成测试准备的一些配置</h4>
<p>参考<a target="_blank" rel="noopener" href="https://docs.gradle.org/current/userguide/java_testing.html#sec:configuring_java_integration_tests">setting up integration tests</a></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// Assembling a JAR for a source set</span><br>tasks.register(<span class="hljs-string">&#x27;intTestJar&#x27;</span>, Jar) &#123;<br>    <span class="hljs-comment">// 这种 sourceSet 的 output 在 java 对象实现里是一些 file collection</span><br>    from sourceSets.intTest.output<br>&#125;<br><br><span class="hljs-comment">// Generating the Javadoc for a source set</span><br>tasks.register(<span class="hljs-string">&#x27;intTestJavadoc&#x27;</span>, Javadoc) &#123;<br>    source sourceSets.intTest.allJava<br>    classpath = sourceSets.intTest.compileClasspath<br>&#125;<br><br><span class="hljs-comment">// 这是配置集成测试的方法之一</span><br><span class="hljs-comment">// Running tests in a source set</span><br>tasks.register(<span class="hljs-string">&#x27;intTest&#x27;</span>, Test) &#123;<br>    testClassesDirs = sourceSets.intTest.output.classesDirs<br>    classpath = sourceSets.intTest.runtimeClasspath<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="依赖配置-dependency-configuration-：">依赖配置（dependency configuration）：</h4>
<p><img src="java-main-configurations.png" alt="java-main-configurations"><br>
<img src="java-test-configurations.png" alt="java-test-configurations"></p>
<p>不同的 dependency 会在不同的 source set 的不同的 phase-compile、implementation、runtime 三重 scope 可见（The compile and runtime configurations have been removed with Gradle 7.0. Please refer to the <a target="_blank" rel="noopener" href="https://docs.gradle.org/current/userguide/upgrading_version_6.html#sec:configuration_removal">upgrade guide</a> how to migrate to implementation and api configurations.）。这是一个 visible 问题。</p>
<p>java plugin 还有一个 java extension，这个 java extension 有一个 java block 来配置，如：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy">java &#123;<br>    toolchain &#123;<br>        languageVersion = JavaLanguageVersion.of(<span class="hljs-number">17</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="java-library">java library</h3>
<p>对于 building 一个 java project 而言，最重要的插件是 java library 而不是 java。它会提供如下任务：</p>
<ul>
<li>A compileJava task that compiles all the Java source files under src/main/java</li>
<li>A compileTestJava task for source files under src/test/java</li>
<li>A test task that runs the tests from src/test/java</li>
<li>A jar task that packages the main compiled classes and resources from src/main/resources into a single JAR named <project>-<version>.jar</li>
<li>A javadoc task that generates Javadoc for the main classes</li>
</ul>
<p>管理 api exposed to consumer。</p>
<p>A library is a Java component meant to be consumed by other components. It’s a very common use case in multi-project builds, but also as soon as you have external dependencies.</p>
<p>在使用多模块和外部依赖的时候，管理 library 成了一个常见的用例。</p>
<p>java library 插件会让它的 consumer transitively 看到 api 依赖，但看不到 implementation 依赖。可以说 compile/implementation 是 gradle 自带的 dependency configuration，而 api 是 java library 带来的。</p>
<p>官方有个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// The following types can appear anywhere in the code</span><br><span class="hljs-comment">// but say nothing about API or implementation usage</span><br><span class="hljs-keyword">import</span> org.apache.commons.lang3.exception.ExceptionUtils;<br><span class="hljs-keyword">import</span> org.apache.http.HttpEntity;<br><span class="hljs-keyword">import</span> org.apache.http.HttpResponse;<br><span class="hljs-keyword">import</span> org.apache.http.HttpStatus;<br><span class="hljs-keyword">import</span> org.apache.http.client.HttpClient;<br><span class="hljs-keyword">import</span> org.apache.http.client.methods.HttpGet;<br><br><span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.UnsupportedEncodingException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpClientWrapper</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HttpClient client; <span class="hljs-comment">// private member: implementation details</span><br><br>    <span class="hljs-comment">// HttpClient is used as a parameter of a public method</span><br>    <span class="hljs-comment">// so &quot;leaks&quot; into the public API of this component</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">HttpClientWrapper</span><span class="hljs-params">(HttpClient client)</span> &#123;<br>        <span class="hljs-built_in">this</span>.client = client;<br>    &#125;<br><br>    <span class="hljs-comment">// public methods belongs to your API</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] doRawGet(String url) &#123;<br>        <span class="hljs-type">HttpGet</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpGet</span>(url);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">HttpEntity</span> <span class="hljs-variable">entity</span> <span class="hljs-operator">=</span> doGet(request);<br>            <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">baos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>            entity.writeTo(baos);<br>            <span class="hljs-keyword">return</span> baos.toByteArray();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            ExceptionUtils.rethrow(e); <span class="hljs-comment">// this dependency is internal only</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            request.releaseConnection();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// HttpGet and HttpEntity are used in a private method, so they don&#x27;t belong to the API</span><br>    <span class="hljs-keyword">private</span> HttpEntity <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpGet get)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">HttpResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> client.execute(get);<br>        <span class="hljs-keyword">if</span> (response.getStatusLine().getStatusCode() != HttpStatus.SC_OK) &#123;<br>            System.err.println(<span class="hljs-string">&quot;Method failed: &quot;</span> + response.getStatusLine());<br>        &#125;<br>        <span class="hljs-keyword">return</span> response.getEntity();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个模块要暴露的 api 仍然要暴露签名中的 httpclient 相关的类库给消费者，但不需要暴露内部的 ExceptionUtils 的应用。所以合理的 gradle 配置如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs groovy">dependencies &#123;<br>    api <span class="hljs-string">&#x27;org.apache.httpcomponents:httpclient:4.5.7&#x27;</span><br>    implementation <span class="hljs-string">&#x27;org.apache.commons:commons-lang3:3.5&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>在 Java 9 以后，只要使用一个<code>module-info.java</code>文件，就可以把一个 java 类库变成 java module，如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">src</span><br>└── <span class="hljs-selector-tag">main</span><br>    └── java<br>        └── module-info<span class="hljs-selector-class">.java</span><br></code></pre></td></tr></table></figure>
<p>其内容为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">module</span> org.gradle.sample &#123;<br>    <span class="hljs-keyword">requires</span> com.google.gson;          <span class="hljs-comment">// real module</span><br>    <span class="hljs-keyword">requires</span> org.apache.commons.lang3; <span class="hljs-comment">// automatic module</span><br>    <span class="hljs-comment">// commons-cli-1.4.jar is not a module and cannot be required</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个插件在两类 source set 视角下，进行 configuration set up 的 graph 如下：</p>
<p><img src="java-library-ignore-deprecated-main.png" alt="java-library-ignore-deprecated-main"><br>
<img src="java-library-ignore-deprecated-test.png" alt="java-library-ignore-deprecated-test"></p>
<h3 id="java-platform">java-platform</h3>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs groovy">plugins &#123;<br>    id <span class="hljs-string">&#x27;java-platform&#x27;</span><br>&#125;<br><br>dependencies &#123;<br>    <span class="hljs-comment">// 该dependencies块提供了一个constraints可用于帮助 Gradle 选择依赖项的特定版本的块，这是指定依赖的一种方法</span><br>    constraints &#123;<br>        api <span class="hljs-string">&#x27;org.springframework:spring-core:5.3.10&#x27;</span><br>        api <span class="hljs-string">&#x27;org.springframework:spring-context:5.3.10&#x27;</span><br>        runtime <span class="hljs-string">&#x27;org.slf4j:slf4j-api:1.7.32&#x27;</span><br>    &#125;<br>&#125;<br><br>dependencies &#123;<br>    implementation platform(project(<span class="hljs-string">&#x27;:platform&#x27;</span>))<br>    implementation <span class="hljs-string">&#x27;org.springframework:spring-core&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>maven 的 bom 必须这样在 gradle 里使用。</p>
<p><strong>依赖项约束的功能与依赖项类似，主要区别在于它们本身不会引入依赖项</strong>。相反，约束定义了版本要求，当依赖项通过其他方式引入项目时，这些要求会影响解析过程。</p>
<p>虽然默认情况下约束不是严格版本，但您可以根据需要指定严格版本约束。一旦包含依赖项，约束指定的版本就会参与冲突解决，就像将其声明为直接依赖项一样。</p>
<h2 id="日志">日志</h2>
<h3 id="级别">级别</h3>
<ul>
<li>ERROR (–quiet 或 -q)：仅显示错误信息。这个级别用于最简化的输出，只在构建失败时提供必要的错误信息。</li>
<li>WARNING：显示警告和错误信息。默认情况下，Gradle会在WARNING级别显示输出，提供有关潜在问题的警告信息。</li>
<li>LIFECYCLE：显示构建生命周期的主要事件，例如任务的开始和结束。这是Gradle的默认日志级别，适合大多数用户的日常使用。</li>
<li>INFO (–info)：显示详细的构建信息，包括任务执行的更多细节和配置信息。这个级别适用于需要了解构建过程更多细节的用户。</li>
<li>DEBUG (–debug)：显示非常详细的调试信息，包括内部状态和详细的执行过程。这个级别通常用于调试构建脚本或插件。</li>
<li>TRACE：显示最详细的日志信息，包括所有可能的内部操作和状态变化。这个级别通常用于开发Gradle本身或深入调试复杂问题。</li>
</ul>
<h1>依赖管理</h1>
<p>Dependency management is an automated technique for declaring and resolving <strong>external resources</strong> required by a project.</p>
<p>依赖管理要回答好三个问题：</p>
<ol>
<li>你需要什么依赖，名称和版本</li>
<li>你用来干什么：compilation 还是 running，这一点不易区分开来</li>
<li>在哪里找这个依赖</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs groovy">repositories &#123;<br>    <span class="hljs-comment">// 回答问题 3</span><br>    mavenCentral()<br>&#125;<br><br>dependencies &#123;<br>    <span class="hljs-comment">// 回答问题 1 和 2</span><br>    implementation <span class="hljs-string">&#x27;org.hibernate:hibernate-core:3.6.7.Final&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>Repository</li>
<li>Configuration：<code>implementation</code>是一种 configuration（所以 api 也是一种 configuration），a named collection of dependencies</li>
<li>Module coordinate：group name + artifact name + version</li>
</ul>
<h2 id="libs-versions-toml">libs.versions.toml</h2>
<p>目前这个方案被拿来当作 version catalog 用：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs groovy">[versions]<br>groovy = <span class="hljs-string">&quot;3.0.5&quot;</span><br>checkstyle = <span class="hljs-string">&quot;8.37&quot;</span><br><br>[libraries]<br>groovy-core = &#123; module = <span class="hljs-string">&quot;org.codehaus.groovy:groovy&quot;</span>, version.ref = <span class="hljs-string">&quot;groovy&quot;</span> &#125;<br>groovy-json = &#123; module = <span class="hljs-string">&quot;org.codehaus.groovy:groovy-json&quot;</span>, version.ref = <span class="hljs-string">&quot;groovy&quot;</span> &#125;<br>groovy-nio = &#123; module = <span class="hljs-string">&quot;org.codehaus.groovy:groovy-nio&quot;</span>, version.ref = <span class="hljs-string">&quot;groovy&quot;</span> &#125;<br>commons-lang3 = &#123; group = <span class="hljs-string">&quot;org.apache.commons&quot;</span>, name = <span class="hljs-string">&quot;commons-lang3&quot;</span>, version = &#123; strictly = <span class="hljs-string">&quot;[3.8, 4.0[&quot;</span>, prefer=<span class="hljs-string">&quot;3.9&quot;</span> &#125; &#125;<br><br>[bundles]<br><span class="hljs-comment">// 把上面的 artifact ref 过来，以后可以这样用：implementation bundles.groovy</span><br>groovy = [<span class="hljs-string">&quot;groovy-core&quot;</span>, <span class="hljs-string">&quot;groovy-json&quot;</span>, <span class="hljs-string">&quot;groovy-nio&quot;</span>]<br><br>[plugins]<br>versions = &#123; id = <span class="hljs-string">&quot;com.github.ben-manes.versions&quot;</span>, version = <span class="hljs-string">&quot;0.45.0&quot;</span> &#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy">plugins &#123;<br>    id <span class="hljs-string">&#x27;java-library&#x27;</span><br>    <span class="hljs-comment">// libs 是文件，plugins 是文件里的 plugins 段，versions 就是一个 ref</span><br>    alias(libs.plugins.versions)<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="configuration-分类">configuration 分类</h2>
<table>
<thead>
<tr>
<th>Configuration Name</th>
<th>Description</th>
<th>Used to:</th>
</tr>
</thead>
<tbody>
<tr>
<td>api</td>
<td>用于编译和运行时都需要的依赖，并包含在发布的 API 中。<br>Dependencies required for both compilation and runtime, and included in the published API.</td>
<td>Declare Dependencies</td>
</tr>
<tr>
<td>implementation</td>
<td>用于编译和运行时都需要的依赖。<br>Dependencies required for both compilation and runtime.</td>
<td>Declare Dependencies</td>
</tr>
<tr>
<td>compileOnly</td>
<td>仅在编译时需要的依赖，不包含在运行时或发布中。<br>Dependencies needed only for compilation, not included in runtime or publication.</td>
<td>Declare Dependencies</td>
</tr>
<tr>
<td>compileOnlyApi</td>
<td>仅在编译时需要的依赖，但包含在发布的 API 中。<br>Dependencies needed only for compilation, but included in the published API.</td>
<td>Declare Dependencies</td>
</tr>
<tr>
<td>runtimeOnly</td>
<td>仅在运行时需要的依赖，不包含在编译类路径中。<br>Dependencies needed only at runtime, not included in the compile classpath.</td>
<td>Declare Dependencies</td>
</tr>
<tr>
<td>testImplementation</td>
<td>用于编译和运行测试所需的依赖。<br>Dependencies required for compiling and running tests.</td>
<td>Declare Dependencies</td>
</tr>
<tr>
<td>testCompileOnly</td>
<td>仅用于测试编译的依赖。<br>Dependencies needed only for test compilation.</td>
<td>Declare Dependencies</td>
</tr>
<tr>
<td>testRuntimeOnly</td>
<td>仅用于运行测试的依赖。<br>Dependencies needed only for running tests.</td>
<td>Declare Dependencies</td>
</tr>
</tbody>
</table>
<p>implementation 才是最需要使用的configuration，因为大多数情况下我们除了专门的 sdk module，不需要 publish api。</p>
<p>本质上只有2种类路径 compileClassPath + runtimeClassPath：</p>
<ul>
<li>compileOnly、runtimeOnly、published api 可叠加。</li>
<li>implementation = compileOnly + runtimeOnly</li>
<li>api = implementation + published api</li>
</ul>
<p><img src="java-main-configurations.png" alt="java-main-configurations"></p>
<p>此外还有隐藏用法：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">dependencies</span> &#123;<br>    <span class="hljs-comment">// 添加编译时依赖</span><br>    compileClasspath <span class="hljs-string">&#x27;org.apache.commons:commons-lang3:3.10&#x27;</span><br>    <br>    <span class="hljs-comment">// 添加运行时依赖</span><br>    runtimeClasspath <span class="hljs-string">&#x27;com.google.guava:guava:28.2-jre&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">task</span> printRuntimeClasspath &#123;<br>    <span class="hljs-keyword">doLast</span> &#123;<br>        <span class="hljs-keyword">configurations</span>.runtimeClasspath.<span class="hljs-keyword">each</span> &#123; <span class="hljs-keyword">println</span> it &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="依赖约束和冲突解决-dependency-constraints-and-conflict-resolution">依赖约束和冲突解决 Dependency Constraints and Conflict Resolution</h2>
<ol>
<li>版本冲突：当两个或多个依赖项需要给定的模块但版本不同时。</li>
<li>功能冲突：当依赖图包含提供相同功能的多个工件时。</li>
</ol>
<ul>
<li>gradle 的做法：Gradle 会考虑所有请求的版本，<strong>无论它们出现在依赖关系图中的哪个位置</strong>。默认情况下，<strong>它会从这些版本中选择最高的版本</strong>。</li>
<li>maven 的做法：
<ul>
<li>默认规则：最近优先（Nearest Definition）
<ul>
<li>Maven 会选择依赖树中离项目最近的版本。</li>
<li>如果路径长度相同，则选择首先声明的版本。</li>
</ul>
</li>
<li>可传递性：
<ul>
<li>Maven 默认会传递所有依赖。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>冲突解决有这些方法：Resolution Rules、Dependency Substitution、Dynamic Versions（这是对构建最危险的，对产生 reproducible builds 造成危害）、Dependency Locking（ resolutionStrategy.activateDependencyLocking()）。最常用的是使用 configuration 的版本 force-没有使用 lock file。</p>
<h1>CLI 接口</h1>
<h2 id="常用命令">常用命令</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 修复某些 spring 的构建</span><br>gradle objenesisRepackJar<br>gradle cglibRepackJar<br><br><span class="hljs-comment"># 初始化项目</span><br>gradle init --<span class="hljs-built_in">type</span> java-application  --dsl groovy<br><br><span class="hljs-comment"># 基于 gradlew 构建，去掉 clean 更快</span><br>./gradlew clean build -x <span class="hljs-built_in">test</span> -x javadoc --console=verbose<br><br><span class="hljs-comment"># 只对某个模块进行构建，这样不用 cd 进文件夹里了</span><br>./gradlew :app:clean :app:build<br><br><span class="hljs-comment"># 列出 root project 依赖树，列出各种配置标题。每个标题（如 annotationProcessor, apiElements 等）代表一个 Gradle 配置。配置是依赖的容器，用于不同的目的。</span><br>./gradlew dependencies<br><br>allCodeCoverageReportClassDirectories - Supplies the class directories used to produce all aggregated JaCoCo coverage data reports<br>--- project : (*)<br><br>allCodeCoverageReportSourceDirectories - Supplies the <span class="hljs-built_in">source</span> directories used to produce all aggregated JaCoCo coverage data reports<br>--- project : (*)<br><br>annotationProcessor - Annotation processors and their dependencies <span class="hljs-keyword">for</span> <span class="hljs-built_in">source</span> <span class="hljs-built_in">set</span> <span class="hljs-string">&#x27;main&#x27;</span>.<br>No dependencies<br><br>apiElements - API elements <span class="hljs-keyword">for</span> main. (n)<br>No dependencies<br><br>archives - Configuration <span class="hljs-keyword">for</span> archive artifacts. (n)<br>No dependencies<br><br><span class="hljs-comment"># 列出模块依赖树-真正的依赖树要这样列出来才有意义，最好从头部 entrance sub project/module 进去</span><br>./gradlew :moduleName:dependencies<br><br><span class="hljs-comment"># 深度解析依赖树，后两个参数是必须的</span><br>./gradlew dependencyInsight --dependency opentelemetry-api-metrics<br><br><span class="hljs-comment"># 更重要的方法是使用 idea 的 analyzer</span><br><br><span class="hljs-comment"># 直接执行 task，build 是一个聚合（aggregate）task， 它触发一个依赖链，build -&gt; assemble -&gt; compileJava</span><br><span class="hljs-comment"># Executing Gradle on the command line conforms to the following structure:</span><br>gradle [taskName...] [--option-name...]<br><span class="hljs-comment"># Options are allowed before and after task names.</span><br>gradle [--option-name...] [taskName...]<br><span class="hljs-comment"># If multiple tasks are specified, you should separate them with a space.</span><br>gradle [taskName1 taskName2...] [--option-name...]<br><span class="hljs-comment">#  --dry-run 可以不执行任务，但是显示任务执行的顺序，对性能影响很小</span><br><br><span class="hljs-comment"># 把内置选项和任务选项区分开</span><br>gradle [--built-in-option-name...] -- [taskName...] [--task-option-name...]<br><br><span class="hljs-comment"># 通用输出 SKIPPED、NO-SOURCE</span><br><span class="hljs-comment"># 使用构建缓存，输出会带有 UP-TO-DATE、FROM-CACHE，所以增量编译是模块-任务级的</span><br>gradle [...] --build-cache<br><span class="hljs-comment"># 不使用缓存</span><br>gradle [...] --no-build-cache<br></code></pre></td></tr></table></figure>
<h1>构建管理</h1>
<h2 id="项目结构">项目结构</h2>
<h3 id="maven">Maven</h3>
<p>Maven 的项目结构通常是这样的（这个结构通常是随着 archetype 变化）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java">└───maven-project<br>    ├───pom.xml<br>    ├───README.txt<br>    ├───NOTICE.txt<br>    ├───LICENSE.txt<br>    └───src 一级文件夹除了 src 和 target 只允许一些隐藏的 .git 文件夹存在<br>        ├───main<br>        │   ├───java<br>        │   ├───resources<br>        │   ├───filters  contains files that inject values into configuration properties in the resources folder during the test phase<br>        │   └───webapp<br>        ├───test<br>        │   ├───java<br>        │   ├───resources<br>        │   └───filters<br>        ├───it failsafe 插件专门用 it 文件夹来承载<br>        ├───site<br>        └───assembly<br>    └───target<br>        └───classes com 文件夹和所有的 resources 下的文件<br>        └───dddsample-<span class="hljs-number">2.0</span>-SNAPSHOT.jar<br>        └───dddsample-<span class="hljs-number">2.0</span>-SNAPSHOT.jar.original<br>        └───generated-sources<br>            └───annotations<br>        └───generated-test-sources<br>            └───test-annotations<br>        └───maven-archiver<br>            └───pom.properties<br>        └───maven-status<br>        └───surefire-reports 每一个测试有一个 txt<br>        └───test-classes com 文件夹和所有的 resources 下的文件<br></code></pre></td></tr></table></figure>
<h3 id="spring-boot">Spring Boot</h3>
<p>Spring Boot 的构建 output 通常是这样的：</p>
<ul>
<li>out
<ul>
<li>production
<ul>
<li>classes</li>
<li>resources</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="gradle">Gradle</h3>
<p>gradle 的构建 output 通常是这样的：</p>
<ul>
<li>build
<ul>
<li>classes
<ul>
<li>java
<ul>
<li>main</li>
</ul>
</li>
</ul>
</li>
<li>docs</li>
<li>generated
<ul>
<li>sources
<ul>
<li>annotationProcessor
<ul>
<li>java
<ul>
<li>main</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>libs
<ul>
<li>project1.jar：这是一个完整 fatjar
<ul>
<li>BOOT-INF
<ul>
<li>classes：大致等同于一个解压过的 project1-plain.jar</li>
<li>lib：各种二方、三方的依赖 jar</li>
<li>classpath.idx：索引文件</li>
<li>layers.idx：索引文件</li>
</ul>
</li>
<li>META-INF
<ul>
<li>MANIFEST.MF</li>
</ul>
</li>
<li>org
<ul>
<li>springframework
<ul>
<li>boot
<ul>
<li>loader：launcher 和 archive 相关的功能</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>project1-javadoc.jar：这里只有 MANIFEST.MF，大小只有 B</li>
<li>project1-plain.jar：结构同 project1-sources 一样，只是 java 文件全部变成 class 文件了</li>
<li>project1-sources.jar
<ul>
<li>这个文件的结构是：
<ul>
<li>com java 源代码包</li>
<li>META-INF
<ul>
<li>MANIFEST.MF</li>
</ul>
</li>
<li>全部的 resources 文件：在进入 lib 以后，packaging 消除了 resources 和 java 文件夹的差别</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>resources
<ul>
<li>main：此处也按照 source set 进行分文件夹，也会 include 进测试 classpath  里</li>
</ul>
</li>
<li>tmp：这一层看起来是不同的 task 的中间结果
<ul>
<li>bootJar</li>
<li>compileJava</li>
<li>jar</li>
<li>javadoc</li>
<li>javadocJar</li>
<li>sourcesJar</li>
</ul>
</li>
<li>bootJarMainClassName：这个类型是 Spring Boot 特有的文件</li>
</ul>
</li>
</ul>
<h2 id="依赖解析">依赖解析</h2>
<p><img src="dep-man-basics-1.png" alt="dep-man-basics-1"></p>
<p>module = component = com.fasterxml.jackson.core:jackson-databind</p>
<p>所谓的图就是搞明白 direct dependencies (explicitly declared in the build script) and transitive dependencies (dependencies of the direct dependencies and other transitive dependencies)。</p>
<p>依赖图由以下节点组成：</p>
<ul>
<li>每个节点代表一个变体。</li>
<li>每个依赖项从一个组件中选择一个变体。</li>
</ul>
<p>这些图就是<code>./gradlew app:dependencies</code>的输出。<br>
强力的依赖解析可以使用<code>./gradlew :app:dependencyInsight --configuration runtimeClasspath --dependency com.fasterxml.jackson.core:jackson-databind:2.17.2</code>命令。</p>
<p>任意的 module 的metadata都包含两个variants，如：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">[</span><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;apiElements&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;runtimeElements&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;attributes&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;org.gradle.category&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;library&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;org.gradle.dependency.bundling&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;external&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;org.gradle.libraryelements&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;jar&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;org.gradle.usage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;java-runtime&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;dependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>      <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;group&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;com.fasterxml.jackson.core&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;module&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;jackson-annotations&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;requires&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2.17.2&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;group&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;com.fasterxml.jackson.core&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;module&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;jackson-core&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;requires&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2.17.2&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;group&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;com.fasterxml.jackson&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;module&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;jackson-bom&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;requires&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2.17.2&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;files&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>      <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;jackson-databind-2.17.2.jar&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure>
<p>Gradle 通常在编译时会选择apiElements，而在运行时会选择runtimeElements。因为apiElements 通常更小，只包含公共 API，这样可以加快编译速度。runtimeElements 包含完整实现，确保应用在运行时有所有需要的类和资源。<strong>似乎</strong>选用 api configuration 会把某个本 project 的依赖加入到本项目的 apiElements variants 里。</p>
<p>gradle 的 download step 就是找到这些 files 里的文件。而transform指的是如果文件不是 jar 而是 zip，可以从 zip 转成 jar。</p>
<h2 id="版本和范围">版本和范围</h2>
<ul>
<li>确保关键依赖使用特定版本（strictly）。</li>
<li>确保依赖不低于某个版本（require）。</li>
<li>优先选择某个版本以避免不必要的升级（prefer）。</li>
<li>排除已知有问题的版本（rejects）。</li>
</ul>
<p>默认的版本解析策略是基于最高版本策略（highest version strategy），<strong>即上面的一个都不选</strong>。</p>
<h2 id="性能优化">性能优化</h2>
<ol>
<li>并行构建-<strong>最好修改 properties</strong></li>
<li>启用各式缓存-局部缓存要单独配，局部的增量构建也是-<strong>最好修改 properties</strong></li>
<li>减少解析依赖的时间-优化仓库、使用版本-<strong>选择最好的镜像</strong></li>
<li>使用 scan 看构建图，查看慢速的部分-<strong>使用构建选项</strong></li>
</ol>
<h3 id="缓存的好处">缓存的好处</h3>
<ul>
<li>使用本地缓存加速开发人员构建</li>
<li>在 CI 构建之间共享结果</li>
<li>通过重复使用 CI 结果来加速开发人员的构建</li>
<li>将远程结果与本地缓存相结合</li>
<li>在开发人员之间共享成果</li>
</ul>
<h3 id="可缓存与不可缓存">可缓存与不可缓存</h3>
<p>默认情况下构建缓存是不打开的。–build-cache 和 properties 配置是两种使用构建缓存的方法。针对相同的输入，可能触发构建缓存。</p>
<p>:classes和:assemble是生命周期任务， 和:processResources 是:jar复制类任务，它们不可缓存，因为执行它们通常更快。</p>
<p>可缓存的任务有：</p>
<ul>
<li>Java toolchain: JavaCompile, Javadoc</li>
<li>Groovy toolchain: GroovyCompile, Groovydoc</li>
<li>Scala toolchain: ScalaCompile, org.gradle.language.scala.tasks.PlatformScalaCompile (removed), ScalaDoc</li>
<li>Native toolchain: CppCompile, CCompile, SwiftCompile</li>
<li>Testing: Test</li>
<li>Code quality tasks: Checkstyle, CodeNarc, Pmd</li>
<li>JaCoCo: JacocoReport</li>
<li>Other tasks: AntlrTask, ValidatePlugins, WriteProperties</li>
</ul>
<p>All other built-in tasks are currently not cacheable.</p>
<h3 id="自定义缓存">自定义缓存</h3>
<p>@CacheableTask 注解可以用来缓存那些耗时比较久的任务，比如自定义的 Javascript 任务。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs groovy">buildCache &#123;<br>    local &#123;<br>        directory = <span class="hljs-keyword">new</span> File(rootDir, <span class="hljs-string">&#x27;build-cache&#x27;</span>)<br>    &#125;<br>&#125;<br><br>buildCache &#123;<br>    remote(HttpBuildCache) &#123;<br>        <span class="hljs-comment">// When attempting to load an entry, a GET request is made to https://example.com:8123/cache/«cache-key». The response must have a 2xx status and the cache entry as the body, or a 404 Not Found status if the entry does not exist.</span><br>        url = <span class="hljs-string">&#x27;https://example.com:8123/cache/&#x27;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="配置缓存">配置缓存</h3>
<p>The configuration cache is a feature that significantly improves build performance by caching the result of the configuration phase and reusing this for subsequent builds.</p>
<h1>测试管理</h1>
<p>自带的 test source set 是为了单元测试用的。如果为了审美（aesthetics）和可管理 （manageability），就需要 separate one from another。</p>
<p>集成测试的存在通常意味着独立的 test task。</p>
<h2 id="配置一个集成测试">配置一个集成测试</h2>
<p>假设我们需要使用一个集成测试，需要首先为它准备一个 sourceSet</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs groovy">sourceSets &#123;<br>    <span class="hljs-comment">// 这里其实还需要配 src，这里重点只是这样做，这样做就是让 main 的 production 的 classes 产出全部成为这个 sourceSet 的 dependency</span><br>    intTest &#123;<br>        compileClasspath += sourceSets.main.output<br>        runtimeClasspath += sourceSets.main.output<br>    &#125;<br>&#125;<br><br>configurations &#123;<br>    <span class="hljs-comment">// 这是把 production 的依赖全部给与本源码集-需要理解的是，production code 的 classes 和它们自己的类路径依赖是不一样的</span><br>    intTestImplementation.extendsFrom implementation<br>    intTestRuntimeOnly.extendsFrom runtimeOnly<br>    <br>&#125;<br><br>dependencies &#123;<br>    <span class="hljs-comment">// 这是给本源码集增加测试环境下的特殊依赖</span><br>    intTestImplementation <span class="hljs-string">&#x27;org.junit.jupiter:junit-jupiter:5.7.1&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>有一个更极端的做法是<code>intTestImplementation.extendsFrom testImplementation</code>，这样单元测试的所有测试依赖也会成为集成测试的依赖。</p>
<p>然后再为它注册一个单独的任务</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs groovy">tasks.register(<span class="hljs-string">&#x27;integrationTest&#x27;</span>, Test) &#123;<br>    description = <span class="hljs-string">&#x27;Runs integration tests.&#x27;</span><br>    group = <span class="hljs-string">&#x27;verification&#x27;</span><br><br>    <span class="hljs-comment">// 把输出给单独的任务用</span><br>    testClassesDirs = sourceSets.intTest.output.classesDirs<br>    <span class="hljs-comment">// 把自己的 source code 的 runtime class path 当作任务的 class path</span><br>    classpath = sourceSets.intTest.runtimeClasspath<br>    <span class="hljs-comment">// 定义任务的依赖</span><br>    shouldRunAfter test<br><br>    useJUnitPlatform()<br><br>    testLogging &#123;<br>        events <span class="hljs-string">&quot;passed&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 这里让 check 又依赖于 integrationTest，等于 check -&gt; integrationTest -&gt; test</span><br>check.dependsOn integrationTest<br></code></pre></td></tr></table></figure>
<h1>Groovy 代码片段</h1>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs groovy">task printStringVar &lt;&lt; &#123;<br> <span class="hljs-keyword">def</span> name = <span class="hljs-string">&quot;张三”</span><br><span class="hljs-string"> println &#x27;单引号的变量计算:$&#123;name&#125;&#x27;</span><br><span class="hljs-string"> println &quot;</span>双引号的变量计算:$&#123;name&#125;<span class="hljs-string">&quot;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">// 运行./gradlew printStringVar输出结果：</span><br><span class="hljs-string">// 单引号的变量计算:$&#123;name&#125;</span><br><span class="hljs-string">// 双引号的变量计算:张三</span><br><span class="hljs-string"></span><br><span class="hljs-string">//List</span><br><span class="hljs-string">task printList&lt;&lt;&#123;</span><br><span class="hljs-string"> def numList = [1,2,3,4,5,6];//定义一个List</span><br><span class="hljs-string"> println numList[1]//输出第二个元素</span><br><span class="hljs-string"> println numList[-1]//输出最后一个元素</span><br><span class="hljs-string"> println numList[1..3]//输出第二个到第四个元素</span><br><span class="hljs-string"> numList.each&#123;</span><br><span class="hljs-string">   println it//输出每个元素</span><br><span class="hljs-string"> &#125;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">//Map</span><br><span class="hljs-string">task printlnMap&lt;&lt;&#123;</span><br><span class="hljs-string"> def map1 =[&#x27;width&#x27;:1024,&#x27;height&#x27;:768]//定义一个Map</span><br><span class="hljs-string"> println mapl[&#x27;width&#x27;]//输出width的值</span><br><span class="hljs-string"> println mapl.height//输出height的值</span><br><span class="hljs-string"> map1.each&#123;</span><br><span class="hljs-string">   println &quot;</span><span class="hljs-attr">Key:</span>$&#123;it.key&#125;,<span class="hljs-attr">Value:</span>$&#123;it.value&#125;<span class="hljs-string">&quot;//输出所有键值对</span><br><span class="hljs-string"> &#125;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">//以集合的each方法为例，接受的参数就是一个闭包</span><br><span class="hljs-string">numList.each(&#123;println it&#125;)</span><br><span class="hljs-string">//省略传参的括号，并调整格式，有以下常见形式</span><br><span class="hljs-string">numList.each&#123;</span><br><span class="hljs-string"> println it</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">// 不是一定要定义成员变量才能作为类属性被访问，用get/set方法也能当作类属性</span><br><span class="hljs-string">task helloJavaBean&lt;&lt;&#123;</span><br><span class="hljs-string"> Person p = new Person()</span><br><span class="hljs-string"> p.name = &quot;</span>张三<span class="hljs-string">&quot;</span><br><span class="hljs-string"> println &quot;</span>名字是: $&#123;p.name&#125;<span class="hljs-string">&quot;//输出类属性name，为张三</span><br><span class="hljs-string"> println &quot;</span>年龄是: $&#123;p.age&#125;<span class="hljs-string">&quot;//输出类属性age，为12</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">class Person&#123;</span><br><span class="hljs-string"> private String name</span><br><span class="hljs-string"> public int getAge()&#123;//省略return</span><br><span class="hljs-string">   12</span><br><span class="hljs-string"> &#125;</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure>
<h1>修复找不到 jar 的情况</h1>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 把每一个能够下下来的jar做一个本地安装</span><br> mvn install:install-file -Dfile=/Users/magicliang/.gradle/caches/modules-2/files-2.1/com.tc.rainbow/java-client/1.0.2-RELEASE/fbaa6826bb26cb2b89bc1261f549abb3c903709e/java-client-1.0.2-RELEASE.jar -DgroupId=com.tc.rainbow -DartifactId=java-client -Dversion=1.0.2-RELEASE -Dpackaging=jar<br><br><span class="hljs-comment"># 再做一个本地安装</span><br>./gradlew clean build -x <span class="hljs-built_in">test</span> -x javadoc --refresh-dependencies<br></code></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://magicliang.github.io">magicliang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://magicliang.github.io/2020/04/11/gradle-%E6%80%BB%E7%BB%93/">https://magicliang.github.io/2020/04/11/gradle-%E6%80%BB%E7%BB%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/gradle/">gradle</a></div><div class="post-share"><div class="social-share" data-image="/2020/04/11/gradle-%E6%80%BB%E7%BB%93/Gradle_logo.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2017/10/23/%E6%98%82%E8%B4%B5%E7%9A%84%E5%BC%82%E5%B8%B8/" title="昂贵的异常"><img class="cover" src="/img/wall-paper-5.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-10-23</div><div class="info-item-2">昂贵的异常</div></div><div class="info-2"><div class="info-item-1">抛出问题   Joshua Bloch 在《Effective Java》的 Item 57 里明确地提到过，不要试图用 Exception 的跳转来代替正常的程序控制流。他列举了很多原因，但特别提到了抛出异常会使得整个程序运行变慢。抛出异常远比普通的 return , break 等操作对控制流、数据流的性能影响要大，它就只适合拿来作异常分支的控制语句，而不能拿来编写正常的逻辑。  Throwing exception is expensive.    这句话在 Java 的程序员世界里面已经成为老生常谈。却很少有人谈及，但到底抛出异常比正常的程序跳转返回慢在哪里，有多慢。“不要滥用异常”好像一个猴子定律，人们忘记了为什么不能这么做，却不明白为什么不能这么做。   这几天读了一位同事写的好文[《Java虚拟机是如何处理异常的》][2]，深入地分析了 JVM 对异常跳转的处理过程: JVM 会通过异常表的机制，优化异常抛出和正常返回之间的性能差异。仅从程序计数器的移动上来讲，抛出一个异常对栈帧的弹栈并不比直接返回更昂贵。写在前头的结论是：“try-catch语句块几乎不会影响程序...</div></div></div></a><a class="pagination-related" href="/2017/11/10/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/" title="线程安全与锁优化"><img class="cover" src="/img/wall-paper-36.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-11-10</div><div class="info-item-2">线程安全与锁优化</div></div><div class="info-2"><div class="info-item-1">线程安全 什么是线程安全 “当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方法进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象就是线程安全的。” 相对的线程安全，可以分成五个等级： 线程安全的分类 不可变 不可变的数据，都是线程安全的。不可变的对象引用，加上所有field都是不可变的。如果有得选，尽量连方法都是final的。 绝对线程安全 Vector不是线程安全的。它也会出现并发修改时 Out of Range 的异常（注意，不是 ConcurrentModification 的异常）。 相对线程安全 需要保证对这个对象的单独操作是线程安全的，在调用的时候不需要加上额外的保障措施。对于特定顺序的连续操作，就需要额外的同步来保证调用的正确性了。 线程兼容 可以通过特殊手段做到线程安全的普通类，绝大部分类都属于相对线程安全的。 线程对立 线程对立，是不管调用端是否采取了同步措施，都无法在多线程环境中使用的代码。常见的线程对立的操作还有 suspend()，resume()， System....</div></div></div></a><a class="pagination-related" href="/2017/11/30/Java%E4%B8%AD%E7%9A%84%E5%B9%BD%E7%81%B5%E7%B1%BB%E5%9E%8B/" title="Java中的幽灵类型"><img class="cover" src="/img/wall-paper-54.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-11-30</div><div class="info-item-2">Java中的幽灵类型</div></div><div class="info-2"><div class="info-item-1">先上结论：幽灵类型（Phantom Type）顾名思义，就是幽灵般的类型，这种类型往往在运行时可以消失，因为在运行时没有任何作用，它们最大的特点就是没有任何实例（Java 的 Void 就是幽灵类型的例子）。是一种可以把有些运行时才能检测到的错误，在编译时检测出来的技巧。按照有些老外的观点，就是“Making Wrong Code Look Wrong”。在面向对象的编程语言之中，幽灵类型的实现，往往与状态模式较为接近，但比状态模式提供了更强的纠错功能。在Java 5 以后的版本里，程序员可以使用泛型。通过泛型的类型参数，Java 中也拥有了幽灵类型的能力。 上面的阐述是不是很难看懂？我也觉得拗口，让我们直接进入具体的例子。假设我们要写一个飞机控制程序，操作飞机起飞或者落地。这个程序有一个非常强的业务约束，就是必须保证飞机一开始必须出现在的地上，只有在地上的飞机可以起飞，只有起飞的飞机可以落地，那么我们应该怎样设计我们的程序（主要是类型关系），来保证这个约束必然成立呢？ 让我们先来定义一组状态接口: 123456789101112131415161718192021/** * F...</div></div></div></a><a class="pagination-related" href="/2018/01/04/%E4%B8%8D%E5%B8%B8%E8%A7%81%E7%9A%84-Java-%E9%9B%86%E5%90%88%E7%B1%BB%E7%9A%84%E7%94%A8%E6%B3%95/" title="不常见的 Java 集合类的用法"><img class="cover" src="/img/wall-paper-124.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-01-04</div><div class="info-item-2">不常见的 Java 集合类的用法</div></div><div class="info-2"><div class="info-item-1">Sorted 集合## Sorted集合 Navigable 集合 Navigable Priority集合 Priority Identity 集合## Identity SkipList 集合 跳表系列。 DelayQueue 延迟队列 </div></div></div></a><a class="pagination-related" href="/2018/05/29/JPA-%E7%9A%84-id-%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5/" title="JPA 的 id 生成策略"><img class="cover" src="/img/wall-paper-85.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-05-29</div><div class="info-item-2">JPA 的 id 生成策略</div></div><div class="info-2"><div class="info-item-1">JPA 有一个@GeneratedValue注解，有一个strategy attribute，如 @GeneratedValue(strategy = GenerationType.IDENTITY)。 常见的可选策略主要有IDENTITY和SEQUENCE。 GenerationType.IDENTITY 要求底层有一个 integer 或者 bigint 类型的自增列（ auto-incremented column)。自增列的赋值必须在插入操作之后发生，因为这个原因，Hibernate 无法进行各种优化（特别是 JDBC 的 batch 处理，一次 flush 操作会产生很多条insert 语句，分别执行）。如果事务回滚，自增列的值就会被丢弃。数据库在这个自增操作上有个高度优化的轻量级锁机制，性能非常棒。 MySQL 支持这种 id 生成策略， 使用 MySQL 应该尽量使用这个策略，即使它无法优化。 JPA 用它生成 id，会一条一条地插入新的 entity。 GenerationType.SEQUENCE 数据库有一个所谓的 sequence 对象，可以通过 selec...</div></div></div></a><a class="pagination-related" href="/2018/06/19/%E5%A6%82%E4%BD%95%E5%81%9A%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8B%E7%9A%84%E7%AD%94%E6%A1%88/" title="如何做性能测试的问题下的答案"><img class="cover" src="/img/wall-paper-145.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-06-19</div><div class="info-item-2">如何做性能测试的问题下的答案</div></div><div class="info-2"><div class="info-item-1">试着回答一下这个问题。 首先要划分系统类型：有状态还是无状态，业务系统还是存储系统。根据不同的业务场景，设立性能测试的目标：是要测 QPS，还是 TPS 还是 TPS，还是任何其他【性能】-从广义来讲，一个存储系统到底能够以多高的平均时延来管理大多的存储空间，可能也是性能的一种。 有了性能测试的目标，接下来就是拆解用例。如果把性能测试归为测试的话，测试就需要测试用例，测试用例只是用例的形式化表达。把用户的使用场景勾勒出来，把每一步拆解成的流程图或者时序图–我们已经得到了一个纸上的集成测试计划，只是没有跟性能挂上钩。 接下来就进入真正写测试用例的环节了。 我们的测试报告如果要涵盖足够立体的信息，则既要了解每一个环节/接口/API 的性能指标，又要了解整体的性能指标。 这个时候测试工具的覆盖面就很重要了。如果我们选择偏黑盒的测试工具，apache ab /JMeter，则我们的测试用例就要围绕着对外交互的 API写，也只能测到外围接口的性能。这样的测试用例写起来最简单，无需侵入任何内部代码中。 如果我们使用了 JMH 一类的工具，则可以自由编写对任何方法的测试用例。但需要对系统有非常...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#project-%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.1.</span> <span class="toc-text">Project 对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#task"><span class="toc-number">1.2.</span> <span class="toc-text">Task</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86"><span class="toc-number">1.2.1.</span> <span class="toc-text">任务管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%9A%84%E4%BB%BB%E5%8A%A1%E5%88%9B%E5%BB%BA%E5%BD%A2%E5%BC%8F"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">基本的任务创建形式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E4%BB%BB%E5%8A%A1%E6%8A%8A%E5%8A%9F%E8%83%BD%E6%B3%A8%E5%86%8C%E6%88%90%E6%8F%92%E4%BB%B6"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">通过任务把功能注册成插件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%BB%BB%E5%8A%A1%E7%9A%84%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">定义任务的依赖关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%91%E4%BB%BB%E5%8A%A1%E6%B3%A8%E5%85%A5%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">向任务注入对象</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E7%AE%A1%E7%90%86"><span class="toc-number">1.3.</span> <span class="toc-text">属性管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%83%B0%E6%80%A7%E5%8A%A0%E8%BD%BD"><span class="toc-number">1.3.1.</span> <span class="toc-text">惰性加载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#plugin"><span class="toc-number">1.4.</span> <span class="toc-text">Plugin</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-number">1.4.1.</span> <span class="toc-text">分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E"><span class="toc-number">1.4.2.</span> <span class="toc-text">声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E4%BB%B6%E4%BB%93%E5%BA%93"><span class="toc-number">1.4.3.</span> <span class="toc-text">插件仓库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java"><span class="toc-number">1.4.4.</span> <span class="toc-text">java</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sourceset"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">SourceSet</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95%E5%87%86%E5%A4%87%E7%9A%84%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">为集成测试准备的一些配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E9%85%8D%E7%BD%AE-dependency-configuration-%EF%BC%9A"><span class="toc-number">1.4.4.3.</span> <span class="toc-text">依赖配置（dependency configuration）：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java-library"><span class="toc-number">1.4.5.</span> <span class="toc-text">java library</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java-platform"><span class="toc-number">1.4.6.</span> <span class="toc-text">java-platform</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E5%BF%97"><span class="toc-number">1.5.</span> <span class="toc-text">日志</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A7%E5%88%AB"><span class="toc-number">1.5.1.</span> <span class="toc-text">级别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">依赖管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#libs-versions-toml"><span class="toc-number">2.1.</span> <span class="toc-text">libs.versions.toml</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#configuration-%E5%88%86%E7%B1%BB"><span class="toc-number">2.2.</span> <span class="toc-text">configuration 分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E7%BA%A6%E6%9D%9F%E5%92%8C%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3-dependency-constraints-and-conflict-resolution"><span class="toc-number">2.3.</span> <span class="toc-text">依赖约束和冲突解决 Dependency Constraints and Conflict Resolution</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">CLI 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">3.1.</span> <span class="toc-text">常用命令</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">构建管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84"><span class="toc-number">4.1.</span> <span class="toc-text">项目结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#maven"><span class="toc-number">4.1.1.</span> <span class="toc-text">Maven</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spring-boot"><span class="toc-number">4.1.2.</span> <span class="toc-text">Spring Boot</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gradle"><span class="toc-number">4.1.3.</span> <span class="toc-text">Gradle</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E8%A7%A3%E6%9E%90"><span class="toc-number">4.2.</span> <span class="toc-text">依赖解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%88%E6%9C%AC%E5%92%8C%E8%8C%83%E5%9B%B4"><span class="toc-number">4.3.</span> <span class="toc-text">版本和范围</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">4.4.</span> <span class="toc-text">性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">4.4.1.</span> <span class="toc-text">缓存的好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E7%BC%93%E5%AD%98%E4%B8%8E%E4%B8%8D%E5%8F%AF%E7%BC%93%E5%AD%98"><span class="toc-number">4.4.2.</span> <span class="toc-text">可缓存与不可缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BC%93%E5%AD%98"><span class="toc-number">4.4.3.</span> <span class="toc-text">自定义缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E7%BC%93%E5%AD%98"><span class="toc-number">4.4.4.</span> <span class="toc-text">配置缓存</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">测试管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E4%B8%80%E4%B8%AA%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95"><span class="toc-number">5.1.</span> <span class="toc-text">配置一个集成测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">Groovy 代码片段</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">修复找不到 jar 的情况</span></a></li></ol></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2017 - 2025 By magicliang</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional and Simplified Chinese">簡</button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>