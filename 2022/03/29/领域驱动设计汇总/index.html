<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>领域驱动设计汇总 | 守株阁</title><meta name="author" content="magicliang"><meta name="copyright" content="magicliang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="总结 DDD 主要是面向对象范式的高级应用。 分治、分层、抽象、演化是架构设计的4大原则。  分治是为了让复杂度变小，而且围绕单一的中心概念具有内聚，又通过边界区别彼此。在DDD中，在解决规模性问题，防止模型出现分裂-矛盾和重复的时候，使用战略设计：上下文（支持边界，天然为微服务服务，这里的上下文边界也是组织架构的边界，也强调团队管理）、精炼（围绕核心域的种种动作）、大型结构（分层在这里被强调）。">
<meta property="og:type" content="article">
<meta property="og:title" content="领域驱动设计汇总">
<meta property="og:url" content="https://magicliang.github.io/2022/03/29/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E6%B1%87%E6%80%BB/index.html">
<meta property="og:site_name" content="守株阁">
<meta property="og:description" content="总结 DDD 主要是面向对象范式的高级应用。 分治、分层、抽象、演化是架构设计的4大原则。  分治是为了让复杂度变小，而且围绕单一的中心概念具有内聚，又通过边界区别彼此。在DDD中，在解决规模性问题，防止模型出现分裂-矛盾和重复的时候，使用战略设计：上下文（支持边界，天然为微服务服务，这里的上下文边界也是组织架构的边界，也强调团队管理）、精炼（围绕核心域的种种动作）、大型结构（分层在这里被强调）。">
<meta property="og:locale">
<meta property="og:image" content="https://magicliang.github.io/2022/03/29/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%B9%82%E5%B9%82.gif">
<meta property="article:published_time" content="2022-03-29T07:49:06.000Z">
<meta property="article:modified_time" content="2025-10-22T08:01:32.693Z">
<meta property="article:author" content="magicliang">
<meta property="article:tag" content="DDD">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://magicliang.github.io/2022/03/29/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%B9%82%E5%B9%82.gif"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "领域驱动设计汇总",
  "url": "https://magicliang.github.io/2022/03/29/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E6%B1%87%E6%80%BB/",
  "image": "https://magicliang.github.io/2022/03/29/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%B9%82%E5%B9%82.gif",
  "datePublished": "2022-03-29T07:49:06.000Z",
  "dateModified": "2025-10-22T08:01:32.693Z",
  "author": [
    {
      "@type": "Person",
      "name": "magicliang",
      "url": "https://magicliang.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://magicliang.github.io/2022/03/29/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E6%B1%87%E6%80%BB/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: magicliang","link":"Link: ","source":"Source: 守株阁","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '领域驱动设计汇总',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="守株阁" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/2022/03/29/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%B9%82%E5%B9%82.gif);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">守株阁</span></a><a class="nav-page-title" href="/"><span class="site-name">领域驱动设计汇总</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">领域驱动设计汇总</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-03-29T07:49:06.000Z" title="Created 2022-03-29 15:49:06">2022-03-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-10-22T08:01:32.693Z" title="Updated 2025-10-22 16:01:32">2025-10-22</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">37.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>121mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1>总结</h1>
<p>DDD 主要是面向对象范式的高级应用。<br>
分治、分层、抽象、演化是架构设计的4大原则。</p>
<ul>
<li>分治是为了让复杂度变小，而且围绕单一的中心概念具有内聚，又通过边界区别彼此。在DDD中，在解决规模性问题，防止模型出现分裂-矛盾和重复的时候，使用战略设计：上下文（支持边界，天然为微服务服务，这里的上下文边界也是组织架构的边界，也强调团队管理）、精炼（围绕核心域的种种动作）、大型结构（分层在这里被强调）。战术设计则是围绕各种职责类型，强调程序的构造块。</li>
<li>分层 主要依赖于大型结构和模型驱动设计提到的 flexible layered architecture。</li>
<li>抽象意味着永远留有余地，核心越薄越好，这也是精炼要求的。</li>
<li>演化在这里则体现为，允许系统设计不断通过重构来精化模型。</li>
</ul>
<p>在 DDD 的原书里面，为了防止模型出问题，才逐渐引入战略设计。<br>
但别的 DDD 书籍里面，作者们都主张直接从战略设计入手。</p>
<h1>DDD 官网</h1>
<p><img src="%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E5%AE%9E%E8%B7%B5%E6%9E%B6%E6%9E%84%E5%9B%BE1.jpeg" alt="领域驱动设计实践架构图1"><br>
<img src="ExplicitArchitecture.png" alt="ExplicitArchitecture"></p>
<p><strong>真实的架构是由项目需求驱动出来的</strong>。</p>
<ol>
<li>左半段最外层叫 interface 层；右半段最外层叫 infra 层。左半段的 bus 是 command query bus，右半段的 bus 叫 event bus。</li>
<li>Ports 有
<ol>
<li>Queries</li>
<li>CQBus、EBus</li>
<li>Notification：
<ol>
<li>SMS adapter</li>
<li>Email adapter</li>
</ol>
</li>
<li>Search</li>
<li>Persistence</li>
<li>Services</li>
<li>Commands</li>
</ol>
</li>
<li>外围的 Controller 有：
<ol>
<li>Admin GUI Views &amp; Controllers</li>
<li>API Controllers</li>
<li>Consumer GUI Views &amp; Controllers</li>
<li>Console Commands</li>
</ol>
</li>
<li>C/Q 有自己的 Handler，Event 有自己是 listener。</li>
<li>Application Layer 就是有 App Services。</li>
<li>Domain Layer 有两层：
<ol>
<li>Domain Service 分离出来</li>
<li>Domain Model 层：在实现时“一个模型”指的是“一个类型”：Entity、Value Object、Aggregate。</li>
</ol>
</li>
<li>按照象限划分，从 handler/listener 开始，一直切分到底的组件化。</li>
</ol>
<h1>链接汇总</h1>
<ol>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/BcJWmmT2sLDwzEl_EGUNug">DDD as Code：如何用代码诠释领域驱动设计？</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/FvZI35aUqaoETUdWYaqPmg">对内 DDD 对外 API 之—对外 API 的设计理念</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/w1zqhWGuDPsCayiOgfxk6w">DDD系列第四讲：领域层设计规范</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/LF7rDQd3a_TS_u3cze6XdA">业务中台构建策略：划分子域、上下文、事件风暴、需求结构化和能力可配置</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/ps3F9pfJnJIHGos8l2DXVA">学而思网校直播课堂架构演进之路</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/c15FdDyBPIKzlTDbvtxvBA">万字长文，结合电商支付业务一文搞懂DDD</a></li>
<li><a target="_blank" rel="noopener" href="http://www.fanyilun.me/2018/04/08/%E8%B0%88%E8%B0%88%E9%A2%86%E5%9F%9F%E5%BB%BA%E6%A8%A1/">谈谈领域建模</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/PD5uEWZkgaR2HbybFmhwLQ">使用 DDD 指导微服务拆分的逻辑</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/JlIHUTRwpJMyenDb_LhOeg">欧创新：深度解析DDD中台和微服务设计</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/YL_NRiEKgR-D3_yx3FARbg">领域驱动设计(DDD)实践之路(四)：领域驱动在微服务设计中的应用</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/OOK_1bCIznF2dD-ikDeUKA">两个字搞定DDD（领域驱动设计），DDD脱水版（一）修订版</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/w6Ct0lzriXTPTh5FMfuCBg">基于 DDD 思想的酒店报价重构实践</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/PFgkIeBbas6Ol4fUoYNqkg">携程技术：国内酒店交易DDD应用与实践——代码篇</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Sm46-IHd658OuLaD13l-5w">DDD在经销商的应用</a></li>
</ol>
<h1>设计拆解</h1>
<p><img src="%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E5%AF%BC%E5%9B%BE.jpeg" alt="领域驱动设计导图"><br>
<img src="DDD.png" alt="DDD"><br>
<a href="DDD.xmind">DDD.xmind</a><br>
<img src="%E4%BB%8E%E4%B8%89%E4%B8%AA%E5%B1%82%E9%9D%A2%E6%9D%A5%E5%AE%9E%E6%96%BDddd.jpeg" alt="从三个层面来实施ddd"></p>
<h1>核心概念解释</h1>
<ul>
<li><strong>限界上下文</strong>：领域概念得以确立，不存在二义性的一个界定范围。是对职责实现的划分，是对动态业务流程的静态划分。</li>
<li>领域划分：
<ul>
<li><strong>核心域</strong>：企业内部赖以成功的竞争优势来源，通常意味着聚焦关注，自身开发。核心域要稳定，要清晰。</li>
<li>通用域：通用子域可以被独立为第三方服务，使用范围非常广。</li>
<li>支撑域：支撑子域是自建服务或企业系统里面，非核心域的次要部分，它是在确立了核心域以后才得以确立的。</li>
</ul>
</li>
<li>聚合：高度相关的一组对象的边界，必须从根部遍历。</li>
</ul>
<h1>DDD 原书</h1>
<ul>
<li>原书的两大核心主线：
<ul>
<li><strong>通用语</strong>：跨越团队职能，无需翻译</li>
<li><strong>模型驱动设计</strong>：在原书里指的是分析设计和实现绑定在一起的实践方法</li>
</ul>
</li>
<li>原书五大板块：
<ul>
<li>柔性设计</li>
<li>战术设计</li>
<li>精炼</li>
<li>大型结构</li>
<li>上下文</li>
</ul>
</li>
</ul>
<p><img src="%E6%9F%94%E6%80%A7%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%9E%84%E9%80%A0%E5%9D%97.jpeg" alt="柔性设计与构造块"><br>
<img src="%E6%88%98%E7%95%A5%E8%AE%BE%E8%AE%A1.jpeg" alt="战略设计"></p>
<p>这本书讲的一个简单真理是：建模即设计，设计即建模（modeling as design, design is modeling）。</p>
<p>设计是不可回避的，在高度复杂业务的背景下设计者必须懂得控制复杂度。很多人都声称“懂领域”，但并不真的懂领域的实质结构，而只是懂领域的表面。domain logic 是杂乱无章的，只有有真切的联系的模型，即 domain model，可以被称为实质结构。懂得实质结构要求我们真的懂得领域模型，而这些模型是建模而来的。建模并不能只通过简单的头脑风暴，还需要运用一些建模技术。概念建模-模型推导是这本书大量介绍的技术的实质。缺乏这些技术，无法产生实质上有意义的模型。</p>
<p>有意义的模型是正是很多人渴望的“所见即所得”的东西，既可以拿来在白板上与领域专家讨论，也可以拿来。领域模型是一种通用语言，可以成为连接不同角色的纽带。</p>
<p>这些技术非常庞杂，所以作者建立了一套体系，使用一系列的词汇来解释建模所需要采取的设计活动。</p>
<p>本书认为好的领域模型并不是“建模-实现”的产物，而是实现后才被发现的真正的好东西。从我个人的经验来看，模型真正动起来以后，他们之间的依赖和互动关系才能从高深莫测的静态迷雾中显露出来，我们这时候才能得到 better models。</p>
<p>很多大师都经历过失败，但只在书中讲自己无所不能的一面，这让这个理论并不真实。从失败中学习可能更重要。</p>
<p>按照作者的观点（《软件方法》里也有这一观点）：满足组织的需求是能够<strong>处理好核心复杂问题</strong>，而且<strong>能够持续演进</strong>，这才是好的软件。</p>
<p>作者在前言里举了几个例子，很多交易系统最初设计时非常简单，并不严格采用领域逻辑设计方法，注重对通用语的收集。于是，第二版本非常难产。相反，持续被精化的领域模型是持续演进架构中能够被持续扩展的基础，这件事可能越来越容易而不是越来越难。还有，如果开发人员不能把不断迭代的业务分析整合进代码中，系统构建还是会失败。</p>
<p>本书阐明了两个前提：</p>
<ol>
<li>软件焦点是领域和领域逻辑，</li>
<li>复杂的领域设计应该基于模型。</li>
</ol>
<p>领域驱动设计是一个设计方法论，但确实有必要依托于过程假设。本书基于两个过程假设：</p>
<ol>
<li>基于某种迭代式开发：主要是敏捷流程。这为架构演进打下基础。</li>
<li>迭代式开发中开发人员和领域专家要有密切的互动：领域驱动设计的实质是吸收知识，产生一个反映深层次知识聚焦关键概念的模型。</li>
</ol>
<p>本书作者认为，极限编程的核心思想是：人们可以通过重构来改进设计，而且可以迅速重构。</p>
<p>在本文中出现的系统业务域：发票、贷款、货运、库存管理和保险。</p>
<h2 id="第一部分-运用领域模型">第一部分 运用领域模型</h2>
<p>开发复杂系统需要用到的知识令人望而生畏。而模型是解决大脑超载问题的工具。<strong>模型并不仅仅是图，而经过选择和设计产生的抽象</strong>。所以领域模型并不一定<strong>符合现实</strong>，比如现实之中并没有时间和事件，但领域模型里就可以有。</p>
<p>模型在 DDD 中有如下作用：</p>
<ol>
<li>模型和设计的核心相互影响。我们可以基于模型来解释代码，也可以基于模型来解释产品。</li>
<li>模型是团队所有成员使用的通用语言的中枢。模型可以拿来和领域专家进行沟通。</li>
<li>模型是浓缩的知识。</li>
</ol>
<p>软件的核心是解决领域相关问题的能力。但大部分人都不愿意直面解决这些问题所需要的领域知识，转而去做一些“提高技术能力”、“框架性”的工作。这是本书一再谈到的，高级开发人员的一种通病。</p>
<h3 id="消化知识">消化知识</h3>
<p>在作者举的 PCB 电路设计的例子里，他和领域专家反复确定模型的细节，经过对信息的寻找与扬弃，增加了一些有用的信息而去掉了另一些有用的信息。到后来整个团队可以无需翻译就使用领域模型来交谈。</p>
<p>而在没有交谈流程的瀑布式设计流程里，设计是由单向流动的专家-分析者-开发者的流程驱动的，缺乏反馈而很容易失败。好的领域模型可以反馈<strong>领域专家的思考方式</strong>（这要求这个模型是严谨的），这恐怕是<strong>业务的实质</strong>。</p>
<p>在拥有领域专家的团队里，开发人员对领域的精通程度达到足以与领域专家流畅沟通即可；在没有领域专家的团队里，开发人员有时候要自己成为领域专家。</p>
<p>领域专家思考问题的模式可能是高度复杂的，但消化这些知识是澄清复杂概念的过程：我们可能习惯于寻找名词，但业务活动和规则也是需要我们仔细思考的领域核心概念（仔细想一想，一个领域的核心概念到底有多少种？）。</p>
<p>在本章中出现的第二个例子里，作者带来了如下的洞察：</p>
<ul>
<li>在动宾结构中可能夹杂着一种复杂的规则，这个规则如果设计为一个模型，则成为一个可以被展示的工件（artifact、stereotype、architype or something），这对于把关键的概念搞清楚是有益的。对我的启示：所有的动宾动作里都可能藏着两类模型，一类是事件动作，一类是规则。规则是元模型。</li>
</ul>
<p><img src="%E8%B6%85%E5%AE%9A%E7%AD%96%E7%95%A5.png" alt="超定策略-在这本书里，所有的模型就是最简单的方形框"></p>
<ul>
<li>领域专家们帮助研发团队们纠正了一个认知错误，航运不是“集装箱在各个地点之间运输”，而是“运货责任在各个实体之间的传递”。第一种设计几乎是所有开发者都会产生的第一种认知：具体标的物品模型的转移是易于察觉的，但业务也涉及一些权证所有权的转移，这在金融系统里是又是必须要被透彻理解的，<strong>第二种转移是深层模型</strong>。</li>
</ul>
<h3 id="交流与语言的使用">交流与语言的使用</h3>
<p>这是核心章节之一。</p>
<p>领域模型是通用语的核心。是一组概念反映了领域深层含义关系和术语。</p>
<p>领域专家通常有自己的沟通风格。而开发人员也有一套自己的模型表达工具-比如 UML 图。这两套沟通体系本来并不是互通的。<strong>但只要想办法构建通用语，则我们可以去除翻译</strong>。</p>
<p>通用语（UBIQUITOUS LANGUAGE）包括：类、主要操作、模型中已经明确的规则和高级组织规则。通用语更像是我们在《代码大全》和敏捷编程里经常提到的隐喻（metaphor），和隐喻相同的地方是，它们可以扼要地传播知识，但和隐喻不同，它指的是更庞大的<strong>语义体系</strong>。</p>
<p>只有通过大量地使用通用语，让沟通变得<strong>流畅才罢休</strong>。作者举了学习西班牙语和生意人发明混合语言的例子，说明坚持使用一种语言最终会让这门语言变得流利。</p>
<p>作者举了两个例子，一个例子使用“最小化的领域抽象”，另一个例子使用“领域模型”。第一个例子用户在谈业务功能的时候，开发者在谈工作机理，交谈中遇到很多混淆的节点，需要专门澄清。而第二个例子里，大家就只谈大家知道的名词和动作。</p>
<p>把模型作为通用语的支柱，意味<strong>着如果语言发生变动，模型必须发生变动</strong>，新增词汇应该新增模型，而修改语义应该重构模型（包括属性和方法），然后要改变图、表和代码的表述。</p>
<p>很多人讨论通用语流于空谈是因为“做不到一个团队一套语言”，这一定程度上是因为开发人员假设“领域专家并不不是抽象思考的专家，所以不一定能够理解抽象模型”。模型如果有问题，则领域专家一定能够发现，如果<strong>领域专家不理解模型，则模型必定有大问题</strong>。在大家使用的多套语言里，通用语至少是一个公分母，大家不会在使用<strong>同一个词汇的时候指代不同含义</strong>。</p>
<p>作者一再强调，模型不是图，图只是用来可视化模型的东西，代码是用来表达模型细节的地方。<strong>模型本质上是概念</strong>。很多时候，我们有了几幅“领域图”、“限界上下文”的图，真的是一种病。作者平时更多地使用文字来表达领域模型（非常反很多人的工作习惯），而使用图表来做补充说明。这是 six pager 的思路，而不是 ppt 的思路。</p>
<p>作者指出：</p>
<ol>
<li>文档应作为代码和口头交流的补充。因为代码已经是程序行为的精确说明了，所以文档不要再表达重复的信息了，浪费时间。</li>
<li>文档应该保持更新。</li>
</ol>
<p>1 和 2 简介强迫我们让文档保持在最小化的状态，没有任何文档是多余的。</p>
<p>作者探讨了 XP 社区的一个关键问题：他们只依赖于代码而不依赖于文档，这要求代码<strong>表现的逻辑清晰有力</strong>。这要求有一种统一的高表达性编程风格-如声明式编程。编程模型如果不具备这些特点，则编程风格可能是过程式的。</p>
<p>作者最后讲了“解释性模型”（即非严格 UML 图），这种图为模型提供了一种松散的上下文，对于澄清模型非常有帮助。</p>
<p><img src="%E8%88%AA%E8%BF%90%E7%BA%BF%E8%B7%AF%E7%9A%84%E8%A7%A3%E9%87%8A%E6%80%A7%E6%A8%A1%E5%9E%8B.jpeg" alt="航运线路的解释性模型"></p>
<h3 id="绑定模型和实现">绑定模型和实现</h3>
<p>这是核心章节之一。</p>
<p>作者首先又举了两个失败项目的例子，指出一个软件开发项目中的通病：深度探讨得出的模型，也可能是纸上谈兵的模型，无法指导设计，然后团队要维护两套概念：模型与实现。有些项目做得更差，只有一个又一个的功能的堆积，缺乏从模型出发的顶层设计。脱离了领域模型的设计，是无法合理利用面向对象的范式的。</p>
<p>作者开始讲了一个经典的例子：中世纪的星盘是天体模型的机械实现。可见能够正确使用面向对象范式，可以得到正确的实现。</p>
<p>设计和模型分离的项目里，模型和设计不同会导致程序设计的正确性无法得到保证，所以才有本章讨论的主题：要绑定模型和实现（设计是实现的一部分）。当然，<strong>模型和设计始终是两个不同的概念</strong>（这是本章节最重要的一个假设之一）。</p>
<p>传统的设计把分析和设计分离开来。分析模型仅仅是理解工具，设计和分析模型之间只存在松散的对应关系。真正的设计是一种“重新开始的过程”，会丢弃很多嵌入模型中的领域知识。</p>
<p>领域模型的发掘总是会带来层出不穷的问题，所以如果维护两套知识体系只会让它们无法相互指导彼此。所以，模型驱动开发（model-driven-design）提倡，满足两种目的：<strong>既遵循分析的要求，也使用设计的原则（所以模型并不只是简单对现实名词的提取）</strong>。模型和设计的关系需要由明确的对应，这种对应需要<strong>范式的支持</strong>，比如面向对象的编程。</p>
<p><img src="%E6%A8%A1%E5%9E%8B-%E8%8C%83%E5%BC%8F-%E8%AE%BE%E8%AE%A1.png" alt="模型-范式-设计"></p>
<p>逻辑范式和 OO 范式可以拿来处理领域建模问题，过程范式不可以。在逻辑范式的视角下，模型是一组逻辑规则和这些规则所操作的事实。标准模型一定要注意，不要忽略规则，配有规则的模型更准确地把核心问题把握住了。</p>
<p>作者接下来举了浏览器的例子：用户模型和设计/实现模型不统一，也会增加不同角色的人的学习成本。所以尽可能实现模型的统一还有提高用户体验的价值。</p>
<p>作者在结尾强调：</p>
<ol>
<li><strong>不能让分工阻断建模和和开发者之间的信息传递</strong>，这是模型和实现不能绑定的根因。很多团队内部</li>
<li>所有开发者必须<strong>学会使用代码表达模型</strong>。</li>
</ol>
<p>能够做到绑定模型和实现，才是正宗的 model-driven-design，否则技术负责人还在使用“分析和设计使用两套概念”的这一传统方式。</p>
<h2 id="第二部分-模型驱动设计的构造块">第二部分 模型驱动设计的构造块</h2>
<p>面向对象设计有一些总的，流行的基本纲领：</p>
<ol>
<li>职责驱动设计：我们经常讲，职责要明确，边界才能清晰。</li>
<li>基于契约编程。</li>
</ol>
<p>我们最常见的这幅图，讲的就是本部分的主题-模型驱动设计的构造块。每个构造块是一种标准模式。</p>
<p><img src="%E6%A8%A1%E5%9E%8B%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E6%A0%87%E5%87%86%E6%A8%A1%E5%BC%8F%E5%AF%BC%E8%88%AA%E5%9B%BE.jpeg" alt="模型驱动开发标准模式导航图"></p>
<p>这幅图告诉我们，模型驱动设计的子概念，<strong>构成了一套模式语言</strong>。原始的版本的图里是没有 domain event 的，在很多书籍里认为 event 不是 entity，但实际上在实现里它通常也是一种不易察觉的 entity，经常需要被存储起来，做事件溯源。</p>
<p>这个图还告诉我们一件事：factory 和 repo 是很相似的，前者强调 encapsulate with，后者强调 access with。</p>
<h3 id="分离领域">分离领域</h3>
<p>本章讲了领域概念出乎意料地重要，所以需要和软件技术概念分离开来。必须使用 layered architecture 这一模式。在当代的分层架构的语境里，分层架构特指能把领域层单独区别设计的架构。</p>
<p>不能够单独隔离和维护领域层的一般原因是：<strong>图快</strong>，为了快速完成开发工作。把分散的核心逻辑散步在非核心层外，就导致维护这些逻辑<strong>要大量使用筛查技巧</strong>。我们在蚂蚁的实践经验告诉我们，没有一个架构上的单独的领域层，领域逻辑是不会稳定的。</p>
<p><img src="%E4%B8%A4%E7%A7%8D%E5%88%86%E5%B1%82%E7%9A%84%E5%AF%B9%E6%AF%94.jpeg" alt="两种分层的对比"></p>
<p>分层本质上是一种 metaphore，被广泛接受的三层架构已经成为标准层。四层架构如下：</p>
<ol>
<li>界面层：展示</li>
<li>应用层：简单、协调、编排、任务进度、无状态。</li>
<li>领域层：<strong>业务状态</strong>。拥有规则，对领域活动进行起码的组织。表达业务概念。状态和生命周期的流转主要隐藏在这一层。这样内聚实现得很好，领域聚焦主要看这一层内聚是不是实现得好。</li>
<li>基础设施层：技术细节</li>
</ol>
<p>层次也不是很多，但严格强调单向向下依赖（实际上跨层依赖的情况在这幅图里还是有的，这里要强调的是“可以穿透，不可逆向”），高内聚，低耦合。</p>
<p>在作者举的银行转账系统的例子里，应用层的对象使用的是service，而领域层使用的则是 entity。</p>
<p>作者历数了分层架构的历史终出现的模式，既包括来自 smalltalk 的 mvc、application controller、model view separation 模式，然后回到四层架构：</p>
<p>四层架构里的 infrasctrure layer 是以类似 MailService 的形式提供服务的，但在分层框架上要实现对这一层服务的<strong>松散连接</strong>。Application 和 Domain 可以直接调用它，它也可以作为抽象基类为 Domain层的领域对象提供能力。这才是这幅图里的继承三角形出现的真意：</p>
<p><img src="%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84%E6%A1%86%E6%9E%B6.png" alt="分层架构框架"></p>
<p>这幅图里还有一个继承，是从界面层指向 infrasctructure 层的。这证明 infrasctructure 是洋葱外圈层的基础。</p>
<p>整个分层框架，都是围绕“<strong>如何实现松散连接</strong>”来探讨的。尽管子类在上层有违常理，但哪个类反应了更多的领域知识是很重要的。框架让开发人员要能“解决复杂技术问题”，“集中精力表达模型”。</p>
<p>我们经常选的框架其实是架构框架，比如 JavaEE Framework 时代的框架都是架构框架。作者举了一个例子，为了让架构框架实现并且用它很好地表达领域模型，可以抛弃框架中的一些功能，例如 entity bean 只会被拿来实现一些大型对象，而领域对象的业务逻辑却可以实现为 pojo。</p>
<p><strong>领域驱动设计只需要一个特定的层，就可以表达表达业务逻辑的概念。</strong></p>
<p>模型驱动开发标准模式导航图里的 SMART UI 在本章出现了：把功能实现为一个个散布在界面层的功能组件，直接与共享的数据库通信。这在复杂项目里是反模式，但在简单项目里是正确的模式。这也是我们谈到的 JSP 1.0 时代很多项目的做法。作者把 SMART UI 视为复杂业务的 anti-pattern，干脆直接与 model-driven-design 互斥。</p>
<p>一旦使用了 SMART UI，团队在接下来的开发工作里就很难摆脱其桎梏。所以作者倡导，<strong>在大型项目的早期阶段，就使用模型驱动开发，分离出独立的领域层</strong>。</p>
<p>领域模型在设计时可以以概念为主，图形和表格为辅，如上面作者提到的，在他的设计里大量使用文字描述领域模型，即使是类图也很少出现。但在实现是，承载领域逻辑的主要是类，但也可以是事务脚本。作者认为，只要实现了“能让领域层和其他层松散耦合”的设计，那么它也可以实现领域驱动设计。</p>
<h3 id="软件中所表示的模型">软件中所表示的模型</h3>
<p>上一章讲到，模型必须兼顾分析和设计，这就必然要面临一些折中问题。</p>
<h4 id="关联">关联</h4>
<p>第一个要解决的问题是关联问题。作者认为，模型中的可遍历的关联，必然会反映在软件实现上。所以处理关联是设计模型必须讨论的问题，要遵循以下原则：</p>
<ol>
<li>规定一个遍历方向。所有的线，预期是无箭头线，不如单箭头线。双向依赖不如单向依赖。</li>
<li>添加一个限定符，以便有效地减少多重关联。比如美国总统和美国之间的关联加上period作为限定词。</li>
<li>消除不必要的关联。比如某个经纪账户本来可以查询所有股票，后面简化成只和某只股票联系起来。</li>
</ol>
<h4 id="模式-entity-又称-reference-object">模式 Entity（又称 Reference Object）</h4>
<p>领域对象模式其一。</p>
<p><strong>由连续性和标识定义的是实体</strong>。同一个对象在多个实现、系统和现实世界之间的映射，必须使用统一的标识，而属性是可变的，不必完全匹配的。A Thread of Identity 保证了变更的连续性。</p>
<p>作者举了一个票务系统的例子。如果座位必须明确地组织和分配，座位首先必须拥有一个 ID和关联表，否则则不需要。所以我们对领域对象总能衍生出两种设计策略：需要使用可排序查找的数据结构存储独占数据的策略；和不需要的策略。第一种策略的关联表里充满了外键引用，后一种策略则没有这样的关联表。</p>
<p>接下来作者举了customer模型的演变的例子：可用于唯一查找的 phone 和 address 更适合移动到主模型上（正如很多订单系统的做法一样），而不是放在一个单独的 contact 模型上。</p>
<p>我们的对象即使是在分布式系统里分布，仍然要维持使用唯一标识符。如果我们使用可重复的id，必须限定他们所处的名字空间-如某类模型或者某个系统的模型，让重复的冲突域小一点。如我们在自动回收系统中使用秒级时间戳来表达id，如果我们能够限制并发数，则这个 id 是可以被采用的。</p>
<h4 id="模式-value-object">模式 Value Object</h4>
<p>领域对象模式其二。</p>
<p>我们需要区分每幅画，但我们不需要识别每一笔。</p>
<p>软件设计需要时刻与复杂性作斗争，我们建模的颗粒度如果很细，则我们到处都得到 entity。<strong>Entity 拥有一个 uniqueness 且需要追踪连续变化的潜在特性</strong>，Value Object 不需要。Value Object 是 <strong>immutable 的、描述属性的、可复用的领域对象</strong>。即使 Value Object 彼此之间存在复杂结构关系，它仍然是一组 Value Object。</p>
<p>很多时候，抽象出 Value Object 对大型系统至关重要，如果对象本身是易于传递的、易于跨分布式系统共享的、易于在同一段内存系统里共享的，它应该是一个 Value Object。所以 Value Object 本身易于被实现位 flyweight。</p>
<p>有一个巧妙的点子：引入 COW 是否可以让 immutable 的 Value Object 产生自生产的工厂。</p>
<h4 id="service">Service</h4>
<p>领域对象模式其三，特别复杂的一章。</p>
<p>有些复杂的操作横跨多个对象（如在两个账户之间转账），因此不适合放在单一的对象中，于是诞生了 domain service。</p>
<p>如果我们乱放管理流程的领域概念，我们可能扰乱模型之间的真正耦合：比如本来转账是不属于单个 account 的，但仍然被放在单一 account里，这就产生了不恰当的 account 之间的“转账耦合”。另一类错误是转向面向过程编程。</p>
<p>折中的方法是，找到一个接口来表达为领域对象（比如某个manager），让流程仍然是对象之间的互操作（接口的方法参数和返回值都应该是领域对象），这就解决了职责分配的问题。</p>
<p>好的 domain service 拥有以下特征：</p>
<ol>
<li>领域概念是操作而不是名词，而且天然不属于某个特定的 Entity 或者 Value Object。</li>
<li>接口是根据领域模型的其他元素定义的-也就是跨对象的操作。所以这要求 Service 是 Ubiquitous Language 的一部分。</li>
<li>操作是无状态的。即使它能修改全局状态，但这种修改不影响其自身的行为。</li>
</ol>
<h5 id="service-的分层">service 的分层</h5>
<p>有三种 service：</p>
<ol>
<li>application service。获取各种格式的输入，调用领域对象，因为领域对象是细颗粒度的，使用 application service 可以隔离用例，也可以把功能以大颗粒度暴露出去，又隔离了真正的业务知识和外部系统。</li>
<li>domain service。仍然是领域流程的一部分操作，但不能简单明确的属于某一个单一对象。比如 account、ledger。</li>
<li>infrastructure service。一种纯技术的 service，一定要保持与业务知识无关。比如 mail service。</li>
</ol>
<h4 id="module">module</h4>
<p>没有出现在“模型驱动开发标准模式导航图”里的构造块（上面提到的三种概念都是构造块），却出现在封面图里。</p>
<p>module 给了我们一种选择：把连贯的思想放在一个 module 里，实现高内聚；把不相关的思想放到不同 module 里，实现低耦合。这样可以<strong>减低认知超载-cognitive overload</strong>。</p>
<p>module 也是 Ubiquitous Language 的一部分，<strong>给我们提供了另一种高层视角来审视模型</strong>。4C 视图是另一种类似的例子。</p>
<p>如果不能把所有的领域概念放在一个对象里，至少保证他们被放在一个 module 里。反过来，领域层里不应该有非领域概念的东西-比如格式相关，通信相关的内容。</p>
<h4 id="我们不能保持范式的纯净">我们不能保持范式的纯净</h4>
<p>如上所述，逻辑范式也可以用来表达领域模型，如果<strong>领域模型可以由规则和事实表达的话</strong>。FP也有可能，<strong>如果业务可以表达为计算流程的话</strong>。</p>
<p>否则，应该尽量以 OO 范式为主，因为 OO 把问题的大小处理得更好，支持任意颗粒度的建模。最多辅以<strong>规则引擎</strong>、<strong>关系型数据库</strong>等其他技术，但我们仍然要保持对范式的坚定选择。</p>
<p>作者还有四条规则：</p>
<ol>
<li>不要和实现范式对抗。</li>
<li>把通用语言作为依靠的基础。模型只要不分裂，则必可避免范式分裂带来的问题。</li>
<li>不要一味依赖 UML。</li>
<li>保持怀疑态度。<strong>怎样才能让问题更简单点</strong>。</li>
</ol>
<h3 id="领域对象的生命周期">领域对象的生命周期</h3>
<p>领域对象有不同的生命周期状态，从创建到消亡。</p>
<p><img src="%E9%A2%86%E5%9F%9F%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpeg" alt="领域对象的生命周期"></p>
<h4 id="aggregate">Aggregate</h4>
<p>这项技术是由 David Siegel 于 90年代发明的，但从没公开发表过。</p>
<p>聚合这个话题，是从“如果我要删除 person 要怎样”这个问题引出，作者得出结论，<strong>只有使用固定规则，才能保证业务得到一致性的修改</strong>。事务的边界，之所以易于出错，是因为在模型中缺乏明确定义的边界。在模型中定义边界的方法就是引入 Aggregate。这个系统是 David Siegel 发明的。</p>
<p>每个 Aggregate 都有一个 root 和一个 boudary。</p>
<ol>
<li>外部只能引用 root，boudary 内的引用靠本地标识（只在本地有效的 uniqueness）相互区别，内部对象和 root 相互引用。</li>
<li>所有内部对象必须通过 root 通过<strong>遍历关联获取</strong>，临时传递给外部引用场景。</li>
<li>删除必须以全 Aggregate 为单位。可以利用垃圾收集机制，清除孤儿记录。</li>
<li>当提交对 Aggregate 的修改时，全 Aggregate 的固定规则必须被遵守。为了达成4，很多修改方法说不定要写在 Aggregate 上，或者用 Aggregate 作为 domain service 实现一定程度上都绑定。</li>
</ol>
<h4 id="factory">Factory</h4>
<p>汽车的装备和驾驶，属于汽车的不同生命周期。所以不同的职责需要通过不同的方法把工作流程分开。</p>
<p>构造是一个复杂的主要操作，构造函数通常是原子操作，让客户负责创建对象会让对象的设计混乱，产生不必要的耦合，而且破坏对 Aggregate 的封装。</p>
<p>于是应该设计单独的对象来承担这个职责。由 Factory 来提供一个抽象接口，提供 Aggregate 的创建，并满足固定规则。</p>
<ol>
<li>所有创建出来的对象必须是“<strong>一致</strong>”的，也就是立即可用。必须是<strong>原子</strong>的，一次把所有的信息都传递给工厂方法，不能少，不能延迟，这些参数就是必要的耦合。</li>
<li>Factory 生产的是抽象类型，而不是具体的类，Factory 也可以是接口。</li>
</ol>
<p>所以好的 Factory 其实是抽象工厂。</p>
<p>Factory <strong>可以分层</strong>，分别实现 root 和 boundary 内部对象。如果有必要，把 <strong>Factory 绑定在领域对象上</strong>。</p>
<p>只有很少的场景下可以使用构造器：比如在领域层内由 domain service 创建领域对象。<strong>不要在客户代码里使用构造器</strong>。</p>
<p>固定规则最好的安置处是领域对象本身，其次就是工厂-让修改收敛在对象的访问权限周围。</p>
<p>归根结底，Factory 用来管理领域对象的创建和重建，是对象生命周期开始需要用到的对象。</p>
<h4 id="repository">Repository</h4>
<p>找到对象有 3 种方法：</p>
<ol>
<li>创建</li>
<li>遍历关联</li>
<li>基于对象的属性进行查找；或者基于找到的组成部分，重建它。</li>
</ol>
<p>基于3，我们产生了 Repository 这一种领域设计。这一领域设计是为了避免领域对象的生命周期管理从<strong>关注领域模型转向“数据处理”这种风格</strong>，也不能让领域规则和查询代码融合在一起。特别地，如果用户可以很便利地查询到领域对象，那么 Aggregate 的封装便无意义，很多复杂度就变成客户层代码和数据库访问代码之间的问题，领域层很快就变得无关紧要了。</p>
<p><strong>所以边界要被 Aggregate、Factory 和 Repository 牢牢守护</strong>：</p>
<ol>
<li>业务计算规则，由领域对象承担。</li>
<li>领域对象开始的创建规则，由 Factory 承担。</li>
<li>领域对象中间的和存储交互的访问规则，由 Repository 承担。</li>
</ol>
<p>Repository 表现得像一个 Collection 一样，只不过它们能支持更复杂的查询、存储和删除操作。Repository 应该表现为一个接口，这样可以切换多个数据源，也可以实现 dummy implementation 可以在测试中使用。</p>
<p>最基础的 Repository 可以使用硬编码来表达复杂查询流程。但使用 Specification 模式可以表达复杂查询，Criteria、Specification 和 Example 在语义上是同一种东西，是【在穿越层次，不让内部的领域/数据库结构暴露出来的前提下】表达复杂的 Query Object 的一种具体形式。但 Criteria 是为了让内部的值被取出来使用而存在的，而 Specification 是为了【消费一个对象实例】而存在的。</p>
<p>客户代码可以忽略 Repository 的实现，开发人员不可以。：</p>
<ol>
<li>客户代码在切换 Repository 的实现的时候，可以保持不变，就好 Stream的客户端代码一样。</li>
<li>所以查询方法的实现要控制查询的业务复杂度和性能，如应该禁止无条件的 findAll、deleteAll 和 updateAll 方法。</li>
</ol>
<p>如果使用架构框架，不支持这样职责划分的领域模型的视线，则不要硬坳框架的实现。Sofa也不是完全符合ddd 的原书。</p>
<p>Repository 有一个地方和 Factory 很像，从 Repository 得到对象实际上就采用了重建多功能，但此时我们最好在领域模型层面忽视重建这一事实。最好让客户感受到这一对象一直驻留在内存里，是被查找出来的一样，<strong>处于生命周期的中间</strong>，这样可以让 Factory 专注于显式地创建，Repository 管理所有的查找。</p>
<p>Factory 也可以用来生产 Value Object。Repository 还可以用来存储一些特殊的 Value Object，比如某些配置信息、干系人（用户可以在元数据编辑数据库里通过增加行的方式增加 role1、role2、role3）。</p>
<h4 id="为关系数据库设计对象">为关系数据库设计对象</h4>
<p>本节作者讨论了很多原则，有两可的选择：</p>
<ol>
<li>数据库为了领域对象改良，而且保持映射透明简单易于理解。</li>
<li>数据库的设计模式保持原状，这样利于从数据处理角度来设计和维护我们的系统。</li>
</ol>
<p>作者倾向于我们采用方案1，但现实中我们通常采用方案2，因为数据库的使用已经足够复杂，不应该因为 ddd 修改我们的 schema 设计方案，让对应的问题交给 ORM 吧。</p>
<h3 id="使用语言：一个扩展的示例">使用语言：一个扩展的示例</h3>
<p>只有通过多次的迭代，才能经过发现过程，得到清晰的模型。</p>
<p><img src="%E8%A1%A8%E7%A4%BA%E8%B4%A7%E8%BF%90%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%B1%BB%E5%9B%BE.png" alt="表示货运领域模型的类图"></p>
<p>首先作者探讨了货运公司的最初的领域模型。</p>
<p>这个模型值得注意的地方有：</p>
<ol>
<li>控制 Cargo 和 Customer 之间的关联的方法是在 Cargo 里增加了一个 Role 的引用，这样虽然 Customer 会有多个货物，但 Customer 和 Cargo 之间的关联关系是1对多的。</li>
<li>DeliverySpecification 是为了表达 action 的目的存在的。把它从 Cargo 里分离出来表达，可以让 Cargo 的目的更清晰，而且可以适应更多的 action。</li>
<li>Action、Event、Transaction 都可以用来表达对 Entity 的操作，在这套模型里表达为 Handling Event。</li>
<li>Event 有 type，Movement 也有 type，这都是未来需要思考的扩展点。在本书中出现的 type，第一时间使用的类型都是 String。</li>
</ol>
<p>这套模型有三个主要功能，在本次主要描述为三种 application：</p>
<ol>
<li>Tracking Query</li>
<li>Booking Application</li>
<li>Incident Logging Application</li>
</ol>
<p>这里面出现的 Entity ，不能互换的模型有：</p>
<ol>
<li>Cargo。</li>
<li>Handling Event 可以通过 Cargo 的 ID 来表达，但仍然是 Entity。</li>
<li>Carrier Movement。</li>
<li>Loation。</li>
<li>Delivery History，可以通过 Cargo 的 ID 来表达，但仍然是 Entity。</li>
</ol>
<p>这里面出现的 Value Object，可以共享的模型有：</p>
<ol>
<li>Delivery Specification。</li>
<li>Role。</li>
</ol>
<p>在关联上如果引入约束，则可以得到第二类的模型：</p>
<p><img src="%E5%9C%A8%E4%B8%80%E4%BA%9B%E5%85%B3%E8%81%94%E4%B8%8A%E5%AF%B9%E9%81%8D%E5%8E%86%E6%96%B9%E5%90%91%E8%BF%9B%E8%A1%8C%E4%BA%86%E7%BA%A6%E6%9D%9F.png" alt="在一些关联上对遍历方向进行了约束"></p>
<ol>
<li>单一方向的箭头意味着存在主控端里存在一个引用另一类模型的机会。一个模型是另一个模型的成员。</li>
<li>Cargo-Delivery History-Handling Event 出现了一个环。</li>
</ol>
<p>接下来我们引入了 Aggregate，让实体有了有限的访问边界：</p>
<p><img src="%E6%A8%A1%E5%9E%8B%E4%B8%AD%E7%9A%84AGGREGATE%E8%BE%B9%E7%95%8C.png" alt="模型中的AGGREGATE边界（注意：边界之外的ENTITY是其自己的AGGREGATE的根）"></p>
<p>并不是所有的模型都拥有自己的 Repository，只有根才有自己的 Repository。</p>
<p><img src="REPOSITORY%E6%8F%90%E4%BE%9B%E4%BA%86%E5%AF%B9%E6%89%80%E9%80%89%E7%9A%84AGGREGATE%E6%A0%B9%E7%9A%84%E8%AE%BF%E9%97%AE.png" alt="REPOSITORY提供了对所选的AGGREGATE根的访问"></p>
<p>在 DDD sample 里还可以看到，每类模型的 Entity 和 Repository 都放在一起，这样可以避免访问权限的泄露。</p>
<p>如果使用了嵌套的模型，则 root 的构造器可能混搭其他 entity，这导致了维护 root 的生命周期的事务的颗粒度变大，也会产生查询耦合。这可能正是我们本来想要达到的，但作者认为，这个模型还有2点可以优化：</p>
<ol>
<li>Handling Event 本身才是存储数据的地方，可以用<strong>查询来代替关联</strong>（这是接下来我们要经常在本书中经常看到的优化技巧），不使用关联，则对 Aggregate 的操作事务颗粒度，还可以再缩小。</li>
<li>Delivery History 可能是一个不必实际存在的模型，但它仍然需要被用聚合的方式重建（reconsistitute）出来。<strong>这种为了聚合而临时创建的模型对象并不符合中国程序员的编程习惯</strong>，很容易被中国程序员在建模的时候忽略掉，要么彻底去掉 Delivery History 这一模型，要么坚持让它和一张临时表关联起来。</li>
</ol>
<p><img src="%E7%A9%BA%E5%BF%83%E5%8C%96%E7%9A%84%E6%A8%A1%E5%9E%8B.png" alt="空心化的模型"></p>
<p>然后作者谈到了两种module，第一种 module 没有传达领域知识，而第二种传达了：</p>
<p><img src="%E4%BC%A0%E8%BE%BE%E4%BA%86%E9%A2%86%E5%9F%9F%E7%9F%A5%E8%AF%86%E7%9A%84%E5%88%86%E5%8C%85%E6%A8%A1%E5%9E%8B.png" alt="传达了领域知识的分包模型"></p>
<h4 id="引入新特性：配额检查">引入新特性：配额检查</h4>
<p>配额检查的例子告诉我们，有时候我们需要接入一个不是使用同一套 model-driven-design 的方案设计出来的系统，我们就要考虑设计一个专门的 service 来封装这种差异，实现翻译机能。这 service 类是防腐层（ANTICORRUPTION LAYER），<strong>这可以被当作第四种 service，也可以被当作 domain service的一种</strong>。</p>
<p>好的防腐层分成双层，一层通信 Sales Management System Interface，一层翻译 Allocation Checker-中国工程师肯定会把它们合一的。然后这一层一定要起到一个“信息专家”的作用，尽量把数据和对数据的判定流程封装起来。在这个例子里，作者引用《分析模式》里提到的 ENTERPRISE SEGMENT。这个东西有多种类型，可以帮我们解决配额的参数配置的封装问题。它的出现告诉我们一个原则：知道划分规则的对象，应该承担查找这种划分相关的对象的职责。这样就实现了<strong>高层和低层的解耦，依赖于抽象通信</strong>。</p>
<p>这一层对上层的 application 而言，也是一个领域能力。</p>
<p><img src="allocation-checker1.png" alt="allocation-checker1"><br>
<img src="allocation-checker2.png" alt="allocation-checker2"></p>
<h2 id="通过重构加深理解">通过重构加深理解</h2>
<p>这一部分讲的是不断的重构，让我们在发现领域模型的弱点的时候，借助重构这个过程和工具，通过与领域专家不断学习领域知识，发现正确的模型和设计。<strong>因为模型既是也是分析也是设计，所以可以经得起这种改进</strong>。</p>
<p>作者把重构分成两种：</p>
<ol>
<li>高层次的设计模式重构</li>
<li>低层次的代码细节重构</li>
</ol>
<p>建模的本质是非结构化的，所以这个探索过程包含漫长的非正式的反馈，尽管模型本身要力图向某种设计标准看齐。</p>
<p>传统的分析方法是先确定名词和动词，仿佛只要找到领域对象和方法就够。这是初学者就会的方法。在作者的例子里，每个新手在加入货运项目的时候，都会建议加入“货轮”和“集装箱”这两个缺失的类。但这个缺失是易于被注意到的，即四色建模法里的 PlacePartyThing，而作者经过深层的讨论，得到的是航次（voyage）、航段（leg）这样的抽象模型，更近于 MomentInterval。</p>
<p>柔性设计要求我们易于对我们的软件进行修改，而且还能与系统的其他部分进行集成，这可能是一个“可扩展性”在架构级别上的表述。</p>
<p><strong>深层次的模型应该更具有表现力</strong>（这可能是我们不断追求深层的模型的原因），设计的灵活性要让开发人员进行实验，又能清晰地表达出领域含义。</p>
<h3 id="突破">突破</h3>
<p>突破不是一种技巧，而是一个事件。作者在这一章里举了贷款系统的例子，说明了最开始是怎么从<strong>华而不实的模型</strong>开始工作的。</p>
<p>作者在这几章里一再提醒：如果你和领域专家都在使用对方不在使用的词汇，或者领域专家提示你们“这个词汇太技术了”，这是一个当前通用语言有问题、模型有问题的迹象。</p>
<h3 id="将隐式概念转变为显式概念">将隐式概念转变为显式概念</h3>
<p>这是核心章节之一。</p>
<p>这一章的意思是寻求深层模型，所谓深层模型是核心抽象。只要抽象足够核心，它就足够简单，足够<strong>用简单灵活的方式表达出基本的用户活动、问题及解决方案</strong>。</p>
<p>好的深化模型的过程大概是这样：<strong>开发人员在讨论中发现一个隐含的概念或者收到启发，于是增加模型，或者调整关系，于是显式地表达了本概念</strong>。这也是本章的核心含义。</p>
<p>如果有人在反复告诉你他需要某类对象才能讨论业务流程，但你的模型不包含这类对象，你要小心了。这也是日常业务过程中经常出现的问题，这证明<strong>操作最复杂而难以解释的东西，没有一个明确的模型来表达</strong>，这是深层模型所在。</p>
<p>本章讨论的模型即《使用语言：一个扩展的示例》里使用的模型。</p>
<p>很多行业，已经有了成熟的模型，也有专门的书籍来表达领域概念，作者在贷款系统里遇到了诸多分析过程，后来发现直接找《分析模式》就可以得到一套模型-尽管并不是标准答案，但足以给人以深深的启发。</p>
<p><strong>最难解释的东西经常是业务规则，业务规则最好是一个 Value Object，通过它来包装计算流程</strong>。这引出了一种“自动分析领域对象的领域对象”，也就是 Specification。这样复杂的规则不会被暴露到应用层，又让 Entity 足够简单。<strong>凡是能够转为“某对象是否满足一个条件”的问题，都可以转为“如何构建一个 Specification”的问题</strong>，实现了对谓词的分离，提供了复杂规则逻辑的 OO 构建方法。这样领域对象只要保有自己的属性即可，在特定场景下的处理规则用 Specification 来承接，使用一个又一个 Value Object 来承载处理结果的职责。</p>
<p>本书还介绍了另一种很重要的模式：基于双分派的 visitor，实现了 repository 和 specification 对“条件”的分离。所谓的双分派，就是不只依赖于 message receiver 来决定多态行为的逻辑，也依赖于方法参数本身。</p>
<p>详细的例子见<a target="_blank" rel="noopener" href="https://michalkowal.github.io/FluentSpecification/docs/concept/specification-design-pattern">《Specification Design Pattern》</a>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DelinquentInvoiceSpecification</span> <span class="hljs-keyword">extends</span><br>    <span class="hljs-title class_">InvoiceSpecification</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> Date currentDate;<br>    <br>    <span class="hljs-comment">// An instance is used and discarded on a single date</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DelinquentInvoiceSpecification</span><span class="hljs-params">(Date currentDate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.currentDate = currentDate;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSatisfiedBy</span><span class="hljs-params">(Invoice candidate)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">gracePeriod</span> <span class="hljs-operator">=</span><br>        candidate.customer().getPaymentGracePeriod();<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">firmDeadline</span> <span class="hljs-operator">=</span><br>            DateUtility.addDaysToDate(candidate.dueDate(),<br>                gracePeriod);<br>        <span class="hljs-keyword">return</span> currentDate.after(firmDeadline);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">accountIsDelinquent</span><span class="hljs-params">(Customer customer)</span> &#123;<br>    <span class="hljs-type">Date</span> <span class="hljs-variable">today</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>    <span class="hljs-type">Specification</span> <span class="hljs-variable">delinquentSpec</span> <span class="hljs-operator">=</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelinquentInvoiceSpecification</span>(today);<br>        <br>    <span class="hljs-type">Iterator</span> <span class="hljs-variable">it</span> <span class="hljs-operator">=</span> customer.getInvoices().iterator();<br>    <span class="hljs-keyword">while</span> (it.hasNext()) &#123;<br>        <span class="hljs-type">Invoice</span> <span class="hljs-variable">candidate</span> <span class="hljs-operator">=</span> (Invoice) it.next();<br>        <span class="hljs-keyword">if</span> (delinquentSpec.isSatisfiedBy(candidate)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> Set <span class="hljs-title function_">selectSatisfying</span><span class="hljs-params">(InvoiceSpecification spec)</span> &#123;<br>    <span class="hljs-type">Set</span> <span class="hljs-variable">results</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>();<br>    <br>    <span class="hljs-type">Iterator</span> <span class="hljs-variable">it</span> <span class="hljs-operator">=</span> invoices.iterator();<br>    <span class="hljs-keyword">while</span> (it.hasNext()) &#123;<br>        <span class="hljs-type">Invoice</span> <span class="hljs-variable">candidate</span> <span class="hljs-operator">=</span> (Invoice) it.next();<br>        <span class="hljs-keyword">if</span> (spec.isSatisfiedBy(candidate)) results.add(candidate);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> results;<br>&#125;<br><br><br><span class="hljs-type">Set</span> <span class="hljs-variable">delinquentInvoices</span> <span class="hljs-operator">=</span> invoiceRepository.selectSatisfying(<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelinquentInvoiceSpecification</span>(currentDate));<br></code></pre></td></tr></table></figure>
<p>但作者警告，Specification 本身只是规格，不是产品本身，它只能用在“验证产品是否具有某种性质”的场景。</p>
<h3 id="柔性设计">柔性设计</h3>
<p>柔性设计指的是大家乐于使用、易于修改的设计，是“<strong>基于深层模型的灵活设计</strong>”。</p>
<p>大块的，条理不分明（圈复杂度高）的逻辑不是柔性设计。作者从没有见过任何一个大型项目一直是柔性的，但只要采取修改模型的方法，就可以突破僵化设计的限制-但一直是僵化的项目他倒是见过。有很多过度设计是借着灵活性的名义得到一个合理的外衣，过度的抽象容易做到，而简单的东西不容易做到。</p>
<p>本章一口气讲了柔性设计的构造块：</p>
<h4 id="intention-revealing-interfaces">INTENTION-REVEALING INTERFACES</h4>
<p>好的设计，接口要能暴露意图-用法，而不是更多地暴露实现。这样用户不需要了解实现就能使用接口。</p>
<p>在这一节里提到的例子：paint 是一个很差的名字，mixin 是一个稍微好一点的名字。</p>
<h4 id="side-effect-free-function">SIDE-EFFECT-FREE FUNCTION</h4>
<p>副作用的特点是，难以预料。复杂系统很忌讳一件事情，就是隔了两三层的调用层次，产生了难以预料的作用-如误发了短信，或者修改了本无需关心的全局状态。</p>
<p>为了防止这种情况，客户必须限制“组合爆炸”，或者深入了解接口实现，这是这个设计不够灵活的体现。</p>
<p>作者把只有返回值而无副作用的操作叫函数（其实就是纯函数）。如果能够尽力实现这种函数，则任意层次的调用嵌套深度。</p>
<p>构造 SIDE-EFFECT-FREE FUNCTION 的过程会引出很多很特别的技术：</p>
<ol>
<li>cqrs 的模型和操作分离</li>
<li>把职责完全转移到一个 Value Object 上。</li>
</ol>
<p>对于 2，作者还专门举了一个 Pigment Color 模型的例子。</p>
<h4 id="assertion">Assertion</h4>
<p>使用契约性编程的开发者可能用到这一技术。</p>
<p>这一技术的本质是把对接口的后置条件写在断言流程里，这样也能实现“<strong>不用读代码也能理解接口</strong>”。</p>
<p>如果语言写不了 Assertion，也可以写单元测试。<strong>其实这两者在日常中都很难贯彻，这是开发者一直要面对的难题</strong>。</p>
<h4 id="conceptual-contour">CONCEPTUAL CONTOUR</h4>
<p>概念化轮廓强调：我们要考虑模型与领域的部分吻合，得到让我们得到<strong>领域概念的一致性</strong>。</p>
<p>大结构是不好的，细颗粒度的对象也是不好的。<strong>“WHOLE VALUE”</strong>（指完整地把对象建模出来的得到的单一模型）是比较好的，只要有 CONCEPTUAL CONTOUR 就能做到。在<strong>演技式架构那里，架构量子越小，进行引导性增量变更的可能性越大</strong>，但本书认为，太小的领域模型颗粒度，会迫使模型使用者深入了解领域深度的东西，放弃了封装的便利，而且集成度不好。</p>
<p>下文会再讨论限界上下文的大小问题。</p>
<h4 id="standalone-class">STANDALONE CLASS</h4>
<p>依赖关系越多，一个模块和类就越难理解。不增加心智负担的依赖可能只出现在 Integer 这样的 primitive 类型上。</p>
<p>尽量把复杂的计算提取到 STANDALONE CLASS 里，这又回到了我们上面提到的 <strong>Value Object</strong> 问题。在实践中我们也经常使用无状态的 <strong>helper utility</strong>。这两者的辩证关系要看你是否要通过这类 STANDALONE CLASS 来维护某种过程状态，这种类<strong>不需要依赖其他类，就可以被独立测试</strong>。</p>
<h4 id="closure-of-operation">CLOSURE OF OPERATION</h4>
<p><strong>我们对集合中的任意两个元素组合时，结果仍在这个集合中，这就叫做闭合操作</strong>。</p>
<p>如果一个操作的参数类型与返回类型一样，这也是个闭合操作。闭合操作的妙处在于，这样的操作不引入任何多余的概念：Value Object 的 COW 操作都是 CLOSURE OF OPERATION。</p>
<p>我们很多时候实现不了 CLOSURE OF OPERATION，实现半 CLOSURE OF OPERATION 也可以提供减少心智负担的优点。</p>
<h4 id="声明式设计">声明式设计</h4>
<p>典型的声明式设计还是声明一个 specification，然后用一套技术生成相关的代码。</p>
<p>但这套代码有两个缺点：</p>
<ol>
<li>难以扩展。</li>
<li>生成代码和手写代码混合很难维护。</li>
</ol>
<h4 id="声明式设计风格">声明式设计风格</h4>
<p>这一节不知道为什么要叫这名，带有逻辑操作符的 Specification 在这一节出现了。</p>
<p>在这一章里还提供了一种能够实现“逻辑蕴含”的 Specification：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">subsumes</span><span class="hljs-params">(Specification other)</span> &#123;<br>    <span class="hljs-keyword">if</span> (other <span class="hljs-keyword">instanceof</span> CompositionSpecification) &#123;<br>        <span class="hljs-type">Collection</span> <span class="hljs-variable">otherLeaves</span> <span class="hljs-operator">=</span> (CompositionSpecification) other.leafSpecifications();<br>        <span class="hljs-type">Iterator</span> <span class="hljs-variable">it</span> <span class="hljs-operator">=</span> otherLeaves.iterator();<br>        <span class="hljs-keyword">while</span> (it.hasNext()) &#123;<br>            <span class="hljs-keyword">if</span> (!leafSpecifications().contains(it.hasNext())) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125; <br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>     <span class="hljs-keyword">if</span> (!leafSpecifications().contains(other)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>支持 subsumes 的规格，可能支持“逻辑蕴含”。逻辑蕴含在工程上有什么实际用处，目前还不知道。</p>
<h4 id="切入问题的角度">切入问题的角度</h4>
<p>如果模型的某个部分有专门的数学问题，那么可以把这部分分离出来。</p>
<p>如果程序实施了某些用来限制状态改变的复杂规则，那么规则可以被提取到单独的模型里，或者提取到一个允许声明规则的简单框架。</p>
<p>尽量利用已有形式：</p>
<ol>
<li>会计学模型</li>
<li>数学模型</li>
<li>《分析模式》里记载的模型</li>
</ol>
<p>有些隐式的概念不是故事里天然存在的名词，这是上文里提到的，MI 和 Role 是最需要好好推理的。</p>
<h3 id="应用分析模式">应用分析模式</h3>
<p>分析模式是很有价值的知识。</p>
<h3 id="将设计模式应用于模型">将设计模式应用于模型</h3>
<blockquote>
<p>一个人认为是模式的东西，在另一个人看来，可能是基本构造块。</p>
</blockquote>
<p>并不是所有的模式都是领域模式。从代码角度来看它们是技术设计模式，从模型的角度来看它们就是概念模式。</p>
<p>本章使用了某些模式解释了：如何使用经典的设计模式来解决领域问题。</p>
<h3 id="通过重构获得更深层的理解">通过重构获得更深层的理解</h3>
<p>有三件事情是必须始终关注的：</p>
<ol>
<li>以领域为本。</li>
<li>用一种不同的方式来看待事物。</li>
<li>始终坚持与领域专家对话。</li>
</ol>
<p>传统意义上的重构听起来是一个非常稳定的过程。但通过重构得到更深层理解往往不是这样的。<strong>顿悟才是重构最需要得到的</strong>。</p>
<h2 id="第四部分-战略设计">第四部分 战略设计</h2>
<p>战略设计的目的是为了提供<strong>操纵和理解大模型的技术</strong>。</p>
<p>整体业务模型很难作为一个整体理解，单一模型是不行的，要使用模块化互操作的思路分解复杂系统，又保证集成点不产生不一致的问题。</p>
<ol>
<li>不要试图统一模型，要允许模型<strong>在可统一的范围内形成限界上下文，然后管理上下文之间的关系</strong>。</li>
<li>战略精炼可以让模型变得清晰，我们熟知的 core domain 就从此而来。</li>
<li>大型结构是为了防止“只见树木，不见森林”。精炼得到了核心，大型结构解决这些要素的关系问题。值得关注的有：职责层和演化顺序。</li>
</ol>
<h3 id="保持模型的完整性">保持模型的完整性</h3>
<p>这是核心章节之一。</p>
<p>模型混乱会导致重复与矛盾，这是限界上下文要解决的问题-保持模型的完整性。</p>
<p>只要问题规模大到一定程度，模型统一是很难做到的，权力的划分和管理界的不同也要求把模型分开。</p>
<p><img src="%E6%A8%A1%E5%9E%8B%E5%AE%8C%E6%95%B4%E6%80%A7%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AF%BC%E8%88%AA%E5%9B%BE.png" alt="模型完整性模式的导航图"></p>
<h4 id="模式：bounded-context">模式：Bounded Context</h4>
<p>康威定律在这里起效了，通常 bounded-context 的切线、架构量子的边界、组件的边界、物理表现的边界、团队的边界是相一致的。</p>
<p>限界上下文不同于 module，一个限界上下文也可以拥有多个 module。限界上下文的出现是为了让模型分裂被隔离，如果在一个限界上下文里使用多个 module，也可能造成无意之中的模型分裂。</p>
<p>作者接下来又举了运输系统的例子：</p>
<p>项目的现状是，遗留系统由遗留团队维护，它们肯定和新系统属于两个不同的限界上下文，<strong>应该停止共享代码</strong>。在作者的例子里，边界上的转换工作是由遗留系统团队负责的。</p>
<p>在任何一个限界之内，每个团队获得了“一致”；在每一个限界上下文之外，每个团队获得了“自由”。</p>
<h5 id="识别-bounded-context-中的不一致">识别 Bounded Context 中的不一致</h5>
<p>常见的元素组合可能引发两类问题：重复的概念和假同源。</p>
<ul>
<li>重复的概念：指的是代表相同含义的不同形式，产生了不同的数据。</li>
<li>假同源：指的是很多人使用同一个词，以为他们在谈论同一个事情，事实上他们相互误解。</li>
</ul>
<h4 id="模式：continous-integration">模式：Continous Integration</h4>
<p>持续集成帮我们持续检查模型分裂的情形，使用统一语言能够防止人们头脑里演变出不一致的概念。</p>
<h4 id="模式：context-map">模式：Context Map</h4>
<p>模型之间的联系点和通信，必须被单独标识出来。</p>
<p>Context Map 不一定拘泥于特定的文档形式，但必须被共享，而且从全局的角度来精确地解决混乱点。</p>
<p>在作者的例子里，Routing Service 接收一个 Specification，返回一个 Itinerary。<br>
在两个上下文中，存在如下映射：</p>
<ul>
<li>Route Specification-地点代码的列表</li>
<li>Node 标识的列表(Arc) -&gt; Itinerary（Leg 对应 Node）</li>
</ul>
<p><img src="routing-service.jpg" alt="routing-service"><br>
<img src="%E5%8F%8C%E9%99%90%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87.jpg" alt="双限界上下文"><br>
<img src="%E6%9F%A5%E8%AF%A2%E8%BD%AC%E6%8D%A2.jpg" alt="查询转换"><br>
<img src="%E8%B7%AF%E7%BA%BF%E8%BD%AC%E6%8D%A2.jpg" alt="路线转换"><br>
<img src="Translator.jpg" alt="Translator"></p>
<p>translator 就是 Context Map 存在的证据，也是需要两个团队一起维护的东西。</p>
<p><img src="%E7%BF%BB%E8%AF%91%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8.jpg" alt="翻译器的作用"><br>
<img src="%E8%BD%AC%E6%8D%A2%E6%B5%81%E7%A8%8B.jpg" alt="转换流程"></p>
<p>维护多个上下文的和谐共存的秘诀是：拥有有效的接口测试集。</p>
<p>描述 context map 需要做好如下工作：</p>
<ol>
<li>Bounded Context 应该有名称。</li>
<li>每个人都应该知道边界在哪里。</li>
</ol>
<h4 id="模式：bounded-context-之间的关系">模式：Bounded Context 之间的关系</h4>
<p>我们对不同的 Bounded Context 的控制程度、团队间的合作水平、系统集成度决定了接下来的模式。事实上，很多公司虽然声称自己使用了 DDD，但却经常在一个团队内部制造多个 Bounded Context，属于画蛇添足。</p>
<h4 id="模式：共享内核-shared-kernel">模式：共享内核（Shared Kernel）</h4>
<p>模型/代码/数据库应该存在一个共用的子集，这个子集的修改应该经过所有交叉上下文的团队的同意，而且需要经过所有团队的测试。</p>
<p>我们常见的 common langs 实际上是 Shared Kernel 的一种，保险核心可能像是 Shared Kernel，因为保险核心上层的业务中台仍然是核心的一部分，所以不能算是接下来讲的 Abstract Core。所以作者说“<strong>Shared Kernel 通常是 CORE DOMAIN，或者一组 GENERIC SUBDOMAIN</strong>”，它的存在减少了重复。使用 Shared Kernel 的目的是为了减少重复，而不是消除重复-除非两套模型在同一个上下文里。</p>
<p>不同的技术实现不适合使用 Shared Kernel，比如不同语言不能共享一个 Lang 包。</p>
<h4 id="模式：customer-supplier-development-team">模式：CUSTOMER/SUPPLIER DEVELOPMENT TEAM</h4>
<p>在作者的语境里，上游是基础研发团队，下游是用户团队。通过协商来指定计划，准备预算（实际上是资源）。由上游团队接收下游团队的需求，设计和执行测试套件的测试。</p>
<h4 id="模式：墨守成规者-遵奉者-conformist">模式：墨守成规者/遵奉者（Conformist）</h4>
<p>当上下游团队不属于同一个管理者时，CUSTOMER/SUPPLIER 模式不会生效。会转换成墨守成规者模式。本模式要求一个 team 直接使用另一个 team 的模型，而不要使用复杂的转换成-这似乎就是我们很多时候常见的模式。</p>
<h4 id="模式：anticoruption-layer">模式：ANTICORUPTION LAYER</h4>
<p>防腐层主要是为了让本领域模型和其他遗留系统做集成用，作者说这个设计是为了<strong>让模型进行双向转换用的</strong>-哪些模式执行的是单向转换呢？这个本文没有讲清楚。</p>
<p><img src="ANTICORRUPTIONLAYER.png" alt="ANTICORRUPTIONLAYER"></p>
<p>在其他书籍里，这个处于中间的模块就是集成点。</p>
<p>防腐层有一个基本的结构，也有三种组件：</p>
<ol>
<li>service 和领域服务很像。</li>
<li>Adapter 如果有特殊的通信协议，需要使用适配器做通信链接的信息转换则存在这样的组件。</li>
<li>Facade 如果遗留子系统的复杂性很高，想要使用简单的方法来使用这些功能，则我们需要一个更友好的外观，来同时处理大接口（此处的大接口，应该是很多功能的接口的意思）的功能。</li>
</ol>
<p><strong>防腐层通常是一组服务，但也可以是 entity。</strong></p>
<h4 id="模式：各行其是-separate-way">模式：各行其是（SEPARATE WAY）</h4>
<p>各行其是。</p>
<p>不同团队使用完全不需要集成的上下文，这样就不用费心想集成的模式的问题了。</p>
<p>本文的作者举了一个保险的例子：把不同功能的子模块只用一个前端封装起来，除此之外两者无需集成。</p>
<h4 id="模式：open-host-service">模式：OPEN HOST SERVICE</h4>
<p>设计一种简单且内聚的协议，让服务能够被其他服务访问。这实际上就是一种 SAAS 的思想了。</p>
<p>要保持这个协议简单文档，如果有特殊的需求，要单独使用 Translator 定制。</p>
<h4 id="模式：published-language">模式：PUBLISHED LANGUAGE</h4>
<p>引入良好文档化、而且能够表达领域信息的语言，作为公共的通信媒介，必要时在其他信息与该语言之间进行转换。</p>
<p>这种模式的例子有：CML（化学标记语言）。</p>
<p>注意，<strong>PUBLISHED LANGUAGE 和 OPEN HOST SERVICE 不是同一个东西</strong>。</p>
<h4 id="选择模型">选择模型</h4>
<p>要解盲人摸象的问题，<strong>承认多个相互冲突的领域模型是面对现实的做法，也要彼此承认彼此的模型是不完整的</strong>。</p>
<h4 id="转化">转化</h4>
<p>加下来作者讲了好几种模式之间的转化。</p>
<p>SEPARATE WAY -&gt; Shared Kernel，意味着模型可以融合，或者一个替代另一个。</p>
<p>Shared Kernel -&gt; Continous Integration，意味着模型的精炼和合并是需要加以检验的。</p>
<p><img src="CONTEXT%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%BC%8F.png" alt="CONTEXT关系模式"></p>
<h3 id="精炼">精炼</h3>
<p>作者使用了 4 个麦克斯韦方程的例子，说明几个方程就可以表达 19 世纪经典电磁学的全部内涵。意在说明， 一些“<strong>基本构造</strong>”、“基本结构”是可以被精炼出来，帮助其他人把握核心概念。</p>
<p>领域驱动设计首先是一个分层架构（Layered Architecture），把 domain 概念从技术逻辑中分离出来（即拥有一个<strong>领域层</strong>）。但它的复杂性仍然要被管理好，让人能够专注于核心问题。</p>
<p>精炼是把一堆混在一起的组件分开的过程，以便通过某种形式从中提取最重要的内容。模型是知识的精炼，领域知识里藏有最关键的领域知识。</p>
<p>精炼有关键内容：CORE DOMAIN，也有副产品 GENERIC DOMAIN、COHERENT MECHANISM。CORE DOMAIN 必须是通用语的一部分。这种精炼被专门称作“战略精炼”，它附有一张模型图：</p>
<p><img src="%E6%88%98%E7%95%A5%E7%B2%BE%E7%82%BC%E7%9A%84%E5%AF%BC%E8%88%AA%E5%9B%BE.png" alt="战略精炼的导航图"></p>
<h4 id="模式：core-domain">模式：CORE DOMAIN</h4>
<p>业务里最有价值的资产是不能被轻易忽略的，也就是《软件方法》里同样关注的 CORE DOMAIN。</p>
<p>核心域的出现能够解决一个很容易被忽略的问题：如果我们不能把核心功能内聚，系统的功能的实现和集成会变得混乱。我们不能对所有的设计部分都做深层的整理的话，我们必须整齐地梳理出真正的核心。</p>
<p>高手不要沉迷于领域知识无关的基础设施，而把“业务丢给次要人员”，数据模式、业务建模完全可以决定一个项目的成败。他们应该被精心整理（设计、实现）为可复用、便于其他组件集成的组件。从洋葱架构出发，先有核心，再让它与其他组件集成，是一个高度可移植的方案，也让这个核心层高度凝练，只有业务价值有关，实现了与技术逻辑的分离，让我们专注于业务逻辑。作者举了一个最成功的贷款系统的例子，高手忙着写 ORM 和消息功能（因为这些东西是<strong>更加通用的技术，容易找到下一份工作</strong>），低手写贷款模块，几乎导致业务失败。</p>
<p>好的模型要轮廓分明（所以 <strong>CORE DOMAIN 只是对 model 的挑选</strong>），要实现系统蓝图的深层模型和柔性设计，我们要精心挑选最关键的逻辑（如果它会让你业务更有优势，或者需要保密，它就足够关键），甚至要让它指导重构。</p>
<h5 id="选择核心">选择核心</h5>
<p>核心域能够表达业务领域，<strong>也能解决业务问题</strong>。</p>
<p>货币是一种常用模型，我们可以把一部分专有部分留在 CORE DOMAIN 里，把通用的部分抽离出去。</p>
<p>我们对什么是 CORE DOMAIN 是要经过很多认知迭代的。随着我们认识的深入，我们会发现一个项目的核心域对其他项目可能是通用域，这并不妨碍我们在我们的项目里把它当作核心域加以设计。甚至有些我们原本是核心域的东西，最终可能变成通用域的一部分。</p>
<h5 id="工作分配">工作分配</h5>
<p>技术能力强的工程师不愿意学习领域知识，最终会导致他们远离核心域。这需要组成一支由领域专家和技术高手组成的长期团队，技术人员要长期稳定地学习他们感兴趣的领域知识。</p>
<p>不要试图通过购买来获得 CORE DOMAIN，尽管现在已经有了一些行业标准、行业框架，但拥有自己的 CORE DOMAIN 仍然很重要。拥有自己完全能控制的核心域配合一个高水平的通用框架可以节省开发通用组件的时间，但你要注意框架是不是自带一些约束，比如要严格保持核心域的整洁。从这一点来讲，Spring 是一个高水平的通用框架，Play 并不是，从结果来看 Spring 能够帮助我们得到更小的核心域，因为它向我们示范了像时间、数据库访问这样的通用组件怎么在核心域之外怎么实现与集成，我们不会不自觉地把它们集成进 core 里，但 play 做不到。</p>
<h4 id="精炼的逐步提升">精炼的逐步提升</h4>
<p>反复采用几个技术能够促进精炼，下述内容会提到哪些技术是“足够好的技术”。</p>
<p>CORE DOMAIN 很容易变得越来越薄，这样他越纯粹、精要。如果我们的 core 不能越来越薄，我们其实肯定还有在 core 里耦合了很多我们未加思索地引入的通用逻辑。</p>
<h4 id="generic-subdomain">GENERIC SUBDOMAIN</h4>
<p>核心域代表了这项业务专门的知识，换言之通用域不需要这项业务专门（domain specific）的知识。</p>
<p>项目组织图属于通用子域，时间属于通用子域。我们能够把项目意图无关的功能内聚子领域识别出来，专门放进这些模块里，保证它们纯净（无任何核心的东西）。</p>
<p>核心开发人员可以采用如下的方式获得 GENERIC SUBDOMAIN：</p>
<ol>
<li>购买软件包：如使用 joda、jdk 时间包。</li>
<li>采用通用框架。</li>
<li>直接使用《分析模式》里提到的东西。</li>
<li>外包-在通用域工作不会让核心团队成员获得领域知识，明智的策略反而可能是让核心成员远离这些工作。</li>
<li>和非领域专家合作实现。</li>
</ol>
<p>随着 CORE DOMAIN 变薄，GENERIC SUBDOMAIN 会越来越厚-复杂度没有消失，而是被怯魅，不断放在核心之外。人们也越来越不直接开发 GENERIC SUBDOMAIN，而<strong>选择集成它</strong>。作者举了两个例子来说明这一点。</p>
<p>优秀的架构师应该这样思考问题：我们如何让核心域能够与时间模块交互，但又不让时间的细节和系统耦合在一起。比如核心业务逻辑都假设时间共用时区，而把各种时间转换入同一时区。所以要 segregate core domain and generic subdomain。<strong>通用不等于重用，只有真正通用的概念，才可以放在 generic subdomain 中</strong>。</p>
<p>很多人都会选择从最容易的东西开始构建本系统，但作者认为，应该从最关键的领域开始构建，<strong>从真正的 CORE DOMAIn 开始构建系统</strong>，这样才能解决项目风险里最需要关注的问题。这无意之中暗合了风险驱动开发的理念。</p>
<h3 id="模式：domain-vision-statement">模式：DOMAIN VISION STATEMENT</h3>
<p>很像逆向工作法的 PR DRAFT，但要围绕“模型为什么，模型可以什么”来写，而不是“软件有什么”来写。</p>
<p>这类似支付宝的支付团队宣言。</p>
<h3 id="模式：highlighted-core">模式：HIGHLIGHTED CORE</h3>
<p>使用专门的文档来专门表达核心的概念，确保团队内所有成员都可以清楚地知道核心模型的现状和变更-这种文档化的工作方式就是我们架构活动里经常提到的架构基线。</p>
<p>200 页的文档太多了，只要 3-7 页的文档就够了，这不仅要求描述 entity，也要描述交互。</p>
<p>作者对 200 页文档的项目的解决方法是：先建立一个最小的核心，然后通过重构让它成为一个完整的系统。</p>
<h3 id="模式：cohesive-mechanism">模式：COHESIVE MECHANISM</h3>
<p>内聚机制指的是一个算法框架，通过 INTENTION-REVEALING-INTERFACE 来供外部使用。</p>
<p>COHESIVE MECHANISM 和 GENERIC SUBDOMAIN 都是为 CORE DOMAIN 减负用的。但 COHESIVE MECHANISM 不是任何领域概念的一部分，它主要解决描述性模型提出的复杂性问题。这就让我们引入了 DAG 框架、状态机框架、数学框架和任务框架。</p>
<p>但这种模式有个特殊情况，算法实际上是能够产生核心价值的组织资产，这时候把它们表达为一些领域模型是好的，这不是走回原点，<strong>这得到了一个更深层的模型</strong>。</p>
<h3 id="模式：segregated-core">模式：SEGREGATED CORE</h3>
<p>把 CORE 相关的模型代码单独隔离出来。注意，到此为止，CORE DOMAIN 和 GENERIC SUBDOMAIN 的区别，主要在于多个模块和包的标记方法：有的 module 属于 CORE DOMAIN，有的 module 属于<br>
GENERIC SUBDOMAIN。本模式和 HIGHLIGHTED CORE 的区别是：HIGHLIGHTED CORE 着重于识别领域模型，把这种识别表达出来；而 SEGREGATED CORE 是我们对我们的代码进行重构和隔离的动作。</p>
<p><img src="%E5%AE%8C%E6%88%90%E9%9A%94%E7%A6%BB%E6%A0%B8%E5%BF%83%E5%90%8E%E7%9A%84%E6%A8%A1%E5%9D%97.png" alt="完成隔离核心后的模块"></p>
<h3 id="模式：abstracted-core">模式：ABSTRACTED CORE</h3>
<p><img src="%E6%8A%BD%E8%B1%A1%E6%A0%B8%E5%BF%83.png" alt="抽象核心"></p>
<p>单独的 CORE DOMAIN MODULE 如果太大，就很难用来表达出整体视图。</p>
<p><strong>这个模式要求出现一个抽象子域和若干个具体子域，交互关系由抽象子域表达，而实现由具体子域表达</strong>。</p>
<h3 id="选择重构目标">选择重构目标</h3>
<ol>
<li>接受挑战，<strong>修复核心</strong>。如同保险核心对 order 模型的升级。</li>
<li>完善对 CORE DOMAIN 的分离，实现轻薄的核心。</li>
</ol>
<h2 id="大型结构">大型结构</h2>
<p>前一章是讲问题的规模变大以后，怎样继续使用分而治之的方法，来治理膨胀的复杂度。</p>
<p>上下文让我们防止模型的完整性被破坏；精炼让我们继续保持专注。</p>
<p>而大型结构介绍了组织的<strong>调节机制和原则，让我们可以通过角色来解释元素，既见树木也见森林</strong>。</p>
<p><img src="%E5%A4%A7%E5%9E%8B%E7%BB%93%E6%9E%84%E4%BB%8D%E7%84%B6%E6%98%AF%E6%A8%A1%E5%9E%8B%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86.png" alt="大型结构仍然是模型驱动设计的一部分"></p>
<h3 id="模式：evolving-order">模式：EVOLVING ORDER</h3>
<p>不要让大型结构带来的约束限制架构的演化，不然又不如无。</p>
<p>这里译作演化顺序，不如译作演化遵循-中文版翻译得太差了。</p>
<h3 id="模式：system-metaphore">模式：SYSTEM METAPHORE</h3>
<p>可以使用隐喻来表达架构，但要小心幼稚隐喻，要恰当地使用隐喻。</p>
<p>什么是恰当的隐喻？实际上我们找到了恰当的 UBIQUITOUS LANGUAGE，我们就找到了恰当的隐喻。</p>
<h3 id="模式：responsibility-layer">模式：RESPONSIBILITY LAYER</h3>
<p>这是本章中最重要的&quot;大型结构&quot;。</p>
<p><img src="%E5%B7%A5%E5%8E%82%E8%87%AA%E5%8A%A8%E5%8C%96%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%88%86%E5%B1%82.png" alt="工厂自动化系统中的分层"></p>
<p>这套分层能不能用，还是挺值得怀疑的。</p>
<h3 id="模式：knowledge-level">模式：KNOWLEDGE LEVEL</h3>
<p>这是分析模式中提到的一种模式，当前还看不懂，以后回来补。</p>
<h3 id="模式：plugable-component-framework">模式：PLUGABLE COMPONENT FRAMEWORK</h3>
<p>把 ABSTRACTED CORE 做成微内核架构的核心，把这种设计模式框架化。</p>
<h2 id="领域驱动设计的综合运用">领域驱动设计的综合运用</h2>
<p><img src="%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8%E4%B8%89%E7%A7%8D%E6%8A%80%E6%9C%AF.png" alt="结合使用三种技术"></p>
<p><img src="%E5%8D%95%E4%B8%80%E4%B8%8A%E4%B8%8B%E6%96%87%E5%86%85%E6%9E%84%E9%80%A0%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9E%8B.png" alt="单一上下文内构造一个模型"></p>
<p><img src="%E5%9C%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E9%99%90%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%89%B9%E5%AE%9A%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="在不同的限界上下文中使用特定的结构"></p>
<p><img src="%E5%85%81%E8%AE%B8%E4%B8%80%E4%BA%9B%E7%BB%84%E4%BB%B6%E8%B7%A8%E8%B6%8A%E5%A4%9A%E4%B8%AA%E5%B1%82.png" alt="允许一些组件跨越多个层"></p>
<p><img src="%E5%9C%A8%E4%B8%80%E4%B8%AA%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%98%A0%E5%B0%84%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%90%8C%E4%B8%80%E7%A7%8D%E7%BB%93%E6%9E%84.png" alt="在一个上下文和映射中使用同一种结构"></p>
<p><img src="%E9%80%9A%E8%BF%87%E5%88%86%E5%B1%82%E6%8A%8ACOREDOMAINMODULE%E8%A2%AB%E5%88%86%E5%BE%97%E6%9B%B4%E6%B8%85%E6%A5%9A.png" alt="通过分层把COREDOMAINMODULE被分得更清楚"></p>
<p>不要歧视其他人，特别是使用聪明来歧视别人。<br>
要注意 EVOLVING ORDER，不要乱加约束。<br>
<strong>大型结构中提到的模式绝不会同时出现在一个项目中，我们应当加以选择</strong>。</p>
<h1>领域驱动设计模式、原理与实践</h1>
<h2 id="前言">前言</h2>
<p>领域驱动设计是包含了<strong>若干思想的思想体系</strong>，看重开发人员和领域专家协同工作以便均等地理解领域概念、策略和逻辑。</p>
<h2 id="第一部分-领域驱动设计的原则与实践">第一部分 领域驱动设计的原则与实践</h2>
<h3 id="什么是领域驱动设计">什么是领域驱动设计</h3>
<p>软件的复杂性来源于两个地方：</p>
<p><img src="%E8%BD%AF%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%A4%8D%E6%9D%82%E6%80%A7.jpg" alt="软件中的复杂性">。</p>
<h4 id="领域驱动设计如何管理复杂性">领域驱动设计如何管理复杂性</h4>
<p>领域驱动设计是为复杂问题域创建软件的挑战而存在的。</p>
<p>复杂软件通常拥有如下问题：</p>
<ol>
<li>未使用通用语言创建代码。对公共语言和问题域知识缺乏重视会导致代码库可用但无法揭示业务目的。</li>
<li>缺乏组织结构。</li>
<li>架构退化成泥球模式泥球模式（本书经常出现的 BBoM）必将扼杀开发，导致功能扩展的步伐放缓。当然，大泥球也不一定是坏的，软件质量够用就行。</li>
</ol>
<p><img src="%E6%88%98%E7%95%A5%E6%A8%A1%E5%BC%8F%E6%9C%89%E6%97%B6%E5%80%99%E5%85%81%E8%AE%B8%E5%B0%8F%E6%B3%A5%E7%90%83.jpg" alt="战略模式有时候允许小泥球"></p>
<p>在这里引出了战略模式的一系列步骤：</p>
<ol>
<li>提炼问题域以揭示重要之处是什么。探索核心域意味着成就意味着什么。</li>
<li>创建一个模型以解决领域问题。</li>
<li>使用公共语言以开启建模协作。</li>
<li>将模型歧义和损坏隔离。</li>
<li>理解上下文之间的关系。</li>
</ol>
<p><img src="DDD%E9%97%AE%E9%A2%98%E7%A9%BA%E9%97%B4%E7%9A%84%E4%B8%80%E5%BC%A0%E8%93%9D%E5%9B%BE.jpg" alt="DDD问题空间的一张蓝图"></p>
<p><img src="%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E8%A7%A3%E7%A9%BA%E9%97%B4%E7%9A%84%E4%B8%80%E5%BC%A0%E8%93%9D%E5%9B%BE.jpg" alt="领域驱动设计解空间的一张蓝图"></p>
<p>上下文可以比支撑域大，支撑域也可以比上下文大。</p>
<p>在这里我们可以看到，子域首先用于问题空间，而后才用于解空间。</p>
<h4 id="领域驱动设计的实践与原则">领域驱动设计的实践与原则</h4>
<p>本书讲的实践与原则主要就在这里了：</p>
<ol>
<li>专注核心领域。</li>
<li>通过协作进行学习。</li>
<li>通过探索和实验来创建模型。重构意味着精进，突破是一种事件。要费足够多的时间琢磨模型。</li>
<li>通信。</li>
<li>理解模型的适用性。模型要在上下文中才有用。</li>
<li>让模型持续发展。</li>
</ol>
<h4 id="领域驱动设计的误区">领域驱动设计的误区</h4>
<ol>
<li>战术模式是关键。很多人误以为 DDD 是一种实现模式，Eric Evans 对此很遗憾。他应该先介绍战略模式的，战术模式也是 DDD 中不需要领域专家也能落地的工具。<strong>DDD 如果有本质的话，一定是开发与领域专家之间的协作，而不是一套值对象组成的程序</strong>。</li>
<li>DDD 是一套框架。DDD 从来不强制 OO，所以 DDD 实际上无框架，尽管 practice 是有的。</li>
<li>DDD 是银弹。DDD 对复杂业务，采用<strong>分析模式、迭代式开发方法论、企业应用架构模式、敏捷实践、持续交付和设计模式</strong>混合在一起的时候，比较像是一个银弹。</li>
</ol>
<h3 id="提炼问题域">提炼问题域</h3>
<p><img src="%E7%9F%A5%E8%AF%86%E6%8F%90%E7%82%BC.jpg" alt="知识提炼"></p>
<p>提炼知识要求我们在示例白板上开展头脑风暴（以事件为主要关注点的头脑风暴就是事件风暴）。</p>
<p>需求大致上等于一组输入和预期输出，解空间就是包含满足这些需求的一组模型的地方。</p>
<p><img src="DDD%E5%8D%8F%E5%90%8C%E6%97%B6%E7%9A%84%E8%A7%92%E8%89%B2.jpg" alt="DDD协同时的角色"></p>
<p>可能这里很多人会慢慢发现，很多隐含的概念，一定要显式定义。这又要求开发团队与领域专家深入互动，这要求我们落实敏捷开发中的开放团队的观念。</p>
<h4 id="有效提炼知识的模式">有效提炼知识的模式</h4>
<ol>
<li>专注在最有意思的对话上。</li>
<li>从用例开始。</li>
<li>提出最有力的问题：
<ol>
<li>这个系统需求来自何处。</li>
<li>我们成功的标准是什么。</li>
<li>这个系统如何为业务创造价值。</li>
<li>如果不构建这个系统会发生什么情况。</li>
</ol>
</li>
<li>CRC 卡。class responsibility collaborative card。</li>
<li>草图。</li>
<li>延迟对模型中概念的命名，<strong>直到你找到名称背后的真实意图为止</strong>。</li>
<li>BDD。Given When Then。</li>
<li>快速成型可以帮我们验证想法。但这要求我们做好“可牺牲架构”和“可抛弃模型”的基本准备。</li>
</ol>
<h4 id="查看现有模型">查看现有模型</h4>
<p>不存在正确的模型，只存在对当前上下文有用的模型。</p>
<ol>
<li>理解需求背后的意图：客户的真实需求是什么。提出问题的最佳人选是客户，<strong>回答领域问题的最佳人选是领域专家，而非开发人员</strong>。</li>
<li>事件风暴：由事件和命令推导 UL。</li>
<li>影响地图：5Why 分析法。</li>
<li>理解业务模型。</li>
<li>刻意发现。</li>
<li>Whirlpool 探讨旋涡。</li>
</ol>
<p><img src="%E4%B8%80%E4%BB%BD%E5%BD%B1%E5%93%8D%E5%9C%B0%E5%9B%BE.jpg" alt="一份影响地图"><br>
<img src="%E4%B8%80%E4%BB%BD%E4%B8%9A%E5%8A%A1%E6%A8%A1%E5%9E%8B%E5%9B%BE.jpg" alt="一份业务模型图"></p>
<p>有点像房子图。</p>
<h3 id="专注于核心领域">专注于核心领域</h3>
<h4 id="为什么要分解一个问题域">为什么要分解一个问题域</h4>
<p>为了追求资源的有效分配，我们实际上是要力求不平均的。</p>
<h4 id="如何捕获问题的实质">如何捕获问题的实质</h4>
<ol>
<li>超越需求：作为需求的推动者，要问到需求之后的东西。</li>
<li>为达成什么是核心内容的共识而捕获领域愿景。这里没有使用 Domain Vision Statement），而是采用了 Amazon 的 PR draft。</li>
</ol>
<h4 id="如何专注于核心问题">如何专注于核心问题</h4>
<p>不要将子域与公司的组织结构混淆。<strong>子域表示能力区域，定义业务过程</strong>。</p>
<p>在这里引出了全书对子域的定义：</p>
<ol>
<li>独特的、带来竞争优势、需要独立构建的领域叫核心子域。要把核心域当做一款产品而非一个项目。</li>
<li>我们必须构建大型程序的其他部分被称作支撑域-这是在 DDD 原书里没有的。支撑域可以被自行构建，也可以被采购集成。支撑域更内部。如 Product Catalog。</li>
<li>构成任何公司的任何业务的软件被称为通用域。通用域可以被采购集成。通用域更外部，如 CRM/ERP/电邮/OA。</li>
</ol>
<p><img src="%E4%B8%80%E5%AE%B6%E6%8B%8D%E5%8D%96%E7%BD%91%E7%AB%99%E7%9A%84%E9%A2%86%E5%9F%9F%E5%88%92%E5%88%86.jpg" alt="一家拍卖网站的领域划分"></p>
<p>注意看，争议解决为什么是通用的，因为它可以是一个工单系统。</p>
<p><img src="%E5%AD%90%E5%9F%9F%E5%A6%82%E4%BD%95%E5%86%B3%E5%AE%9A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E7%9A%84%E5%BD%A2%E6%88%90.jpg" alt="子域如何决定解决方案的形成"></p>
<p>注意看，定制应用程序包括核心域和支撑域，然后找了一个通用域来解决现实问题。</p>
<p>并不是系统的每个部分都经过良好设计，并不是所有模型都具有同等质量，<strong>只做好核心域的事情就行了</strong>。</p>
<p>如果没得选，边界清晰比模型完美更重要。边界清晰可以保证边界和集成点不出岔子，内部的模型还可以慢慢改。</p>
<p><img src="%E5%A4%84%E7%90%86%E9%81%97%E7%95%99%E5%86%85%E5%AE%B9.jpg" alt="处理遗留内容"></p>
<p>一开始核心域也不需要多完美，能够及时推向市场就行了。后续可以开发替代方案优化老模型-这和 Evans 的实践还是有差别的，重点取决于核心域的变动难度。</p>
<p>模型驱动设计是很重的，如果没有核心域，也不用硬上 UL。</p>
<h3 id="模型驱动设计">模型驱动设计</h3>
<h4 id="什么是领域模型">什么是领域模型</h4>
<p>领域模型位于 DDD 的中心，它不是一个真实的问题域视图，是为了满足业务用例（经过抽象、设计、转化，应用了若干模式）的结果。</p>
<p><img src="%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%BD%9C%E7%94%A8.jpg" alt="领域模型的作用"></p>
<p><strong>领域模型的要义不是多大程度上反映真实的业务情况，而是能多大程度上描述复杂领域逻辑以解决问题-治理复杂性。</strong></p>
<p><img src="%E9%A2%86%E5%9F%9F%E4%B8%8E%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B%E5%AF%B9%E6%AF%94.jpg" alt="领域与领域模型对比"></p>
<p><img src="%E4%BB%A3%E7%A0%81%E5%92%8C%E5%88%86%E6%9E%90%E6%A8%A1%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E7%BB%91%E5%AE%9A.jpg" alt="代码和分析模型之间的绑定"></p>
<p>传统经验里有分析模型-设计模型-代码模型。代码模型是分析模型的实现，本书无设计模型。</p>
<p><strong>模型驱动设计不能够反映领域专家真实的思考模式，或者不能真正被实现，都是错误的。</strong></p>
<p><img src="%E9%A2%84%E5%85%88%E8%AE%BE%E8%AE%A1%E7%9A%84%E9%97%AE%E9%A2%98.jpg" alt="预先设计的问题"></p>
<p>如果：1. 没有反馈回路；2. 只专注于技术问题。则最终代码模型和设计模型会分离。</p>
<p><img src="%E4%BB%A3%E7%A0%81%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%88%86%E6%9E%90%E6%A8%A1%E5%9E%8B%E8%A6%81%E4%BF%9D%E6%8C%81%E5%8D%8F%E5%90%8C.jpg" alt="代码模型和分析模型要保持协同"><br>
<img src="%E5%9B%A2%E9%98%9F%E5%BB%BA%E6%A8%A1.jpg" alt="团队建模"></p>
<p>只有采用完整的团队的协同方式，持续通过揭示-同步的工作流，才能保证分析模型和代码模型的协同。如果分析模型无用，则最后只剩下代码模型。</p>
<h4 id="使用通用语言把分析和代码模型绑定在一起">使用通用语言把分析和代码模型绑定在一起</h4>
<p>要创建这样的通用语言：</p>
<ol>
<li>生命周期大于软件。</li>
<li>对领域有深刻见解，洞察本质而不是盲人摸象。</li>
<li>所有人能够明白。</li>
<li>是领域概念而非技术概念。</li>
</ol>
<h4 id="基于通用语言进行协作">基于通用语言进行协作</h4>
<ol>
<li>使用业务术语交流在具体示例里交流。</li>
<li>不要跳到解决方案上，先把问题描述清楚。</li>
</ol>
<p>塑造语言的最佳实践有：</p>
<ol>
<li>确保语言有一致性。你用专家也用。</li>
<li>与领域专家创建一份领域术语表。</li>
<li>确保你为每个特定概念使用一个单词。</li>
<li>远离过载的术语。如策略、服务或者管理者。这世界上有很多的概念天然就是为抽象存在的，在具体的场景里需要加上具体的涵义再加以使用。</li>
<li>不要使用软件开发中具有特定含义的术语。</li>
<li>命名非常重要。</li>
<li>根据 UL 命名异常情况。</li>
<li>不要在你的领域模型中使用设计模式的名称。</li>
<li>UL 应该随处可见。</li>
<li>获得了更深的理解后，UL 将演化。</li>
</ol>
<p><strong>开发 UL 的过程是 DDD 最重要的过程。下一步的创建领域模型是它的产物。</strong></p>
<h4 id="如何创建有用的领域模型">如何创建有用的领域模型</h4>
<ol>
<li>不要指望领域模型匹配真实情况。它匹配有用的部分即可。识别用例中的名词和动词只是基本。所有的拓扑线路图都可能和真实比例尺不一致，但它们是有用的线路图。</li>
<li>评价领域模型的金标准应该是看它对解决问题是否有用，或者长期有用。</li>
<li>要仅对相关内容进行建模。领域的全部内容是非常庞大的，只对问题相关的内容进行建模是可行。</li>
<li><strong>要克制自己抽象的冲动，要明白很多模型具象就够了</strong>。</li>
<li>对行为而非实现进行抽象-完整的业务单元都是围绕业务流程来的。<strong>如果你有一个领域行为，它的抽象应该就是领域内的行为，如果你要使用快递公司来实现这个行为，那是 infrastructure 的问题，不要把这种抽象设计进领域层里</strong>。下面的例子会详细讲：高层次的行为是用例，即应用层的内容；低层次的行为即用例的细节，即领域层的内容。</li>
<li>当你需要更加努力建模的时候，更加努力建模；如果业务不复杂，则根本不需要UL建模。因为UL 是有代价的，应该优先保证核心域。</li>
</ol>
<h3 id="领域模型实现模式">领域模型实现模式</h3>
<p>综合前面的章节，我们可以知道。实现领域模型有几个前提：</p>
<ol>
<li>专注于核心领域。</li>
<li>把领域逻辑和技术问题隔离。</li>
</ol>
<h4 id="领域层">领域层</h4>
<p><img src="%E8%A1%A8%E7%A4%BA%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%BB%A3%E7%A0%81%E4%BB%85%E6%9E%84%E6%88%90%E6%95%B4%E4%BD%93%E4%BB%A3%E7%A0%81%E5%BA%93%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86.jpg" alt="表示领域模型的代码仅构成整体代码库的一部分"></p>
<p>注意看这幅图，<strong>对 infrastructure 调用主要来自于 application，而不是 domain</strong>，这是一个很重要的信息。</p>
<h4 id="领域模型实现模式">领域模型实现模式</h4>
<p>我们总是会有多个模型、多个上下文和多种实现模式。这些“多种”共存是必然的，需要我们客观地看待它们的存在：</p>
<p><img src="%E5%9C%A8%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%86%85%E9%83%A8%E4%BB%A5%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%A4%9A%E4%B8%AA%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B.png" alt="在应用程序内部以各种模式实现的多个领域模型"></p>
<p>注意，这里只是允许我们在领域层切换实现而已。正如我们在蚂蚁可以严格使用事务脚本加表模型来实现领域层一样，我们可以使用事务脚本、表模型、活动对象和领域模型模式等多种模式<strong>实现本有界上下文</strong>-如果一个应用程序内存在多个有界上下文的话。</p>
<h5 id="领域模型-模式">领域模型（模式）</h5>
<p>在这里的领域模型模式指的是数据持久化模型（贫血模型）+ 关联关系、规则和丰富领域逻辑（计算能力），大大丰富了数据 + 行为这一OO的内涵。</p>
<p>如果可以，在实践中应该尽量实现持久无关的模型，而不是直接上来实现关系型数据库模型。</p>
<p><img src="%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B%E6%A8%A1%E5%BC%8F.jpg" alt="领域模型模式"></p>
<p>domain-model-pattern意味着专注领域逻辑，意味着业务行为逻辑。</p>
<p>如果必须要选，<strong>专注于行为而不是状态</strong>上。</p>
<p><img src="%E4%B8%80%E5%AE%B6%E6%8B%8D%E5%8D%96%E7%BD%91%E7%AB%99%E7%9A%84%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B.jpg" alt="一家拍卖网站的领域模型"></p>
<p>在这里作者强调，只有核心域需要采取领域模型模式，其他模块可以使用贫血模型+事务脚本或者表模式。</p>
<h5 id="事务脚本">事务脚本</h5>
<p>事务脚本围绕静态管理器或服务类来分组的。</p>
<p><img src="%E4%BA%8B%E5%8A%A1%E8%84%9A%E6%9C%AC%E6%A8%A1%E5%BC%8F.jpg" alt="事务脚本模式"></p>
<p>这里面使用一个很经典的事务脚本实现：</p>
<ol>
<li>在构造器里增加参数。</li>
<li>在一个 execue 接口里实现其中的逻辑。</li>
</ol>
<p>这不是传统的无状态 service 的实现模式。</p>
<p><img src="%E4%BA%8B%E5%8A%A1%E8%84%9A%E6%9C%AC%E6%A8%A1%E5%BC%8FUML.jpg" alt="事务脚本模式UML"><br>
<img src="%E4%BD%BF%E7%94%A8%E4%BA%8B%E5%8A%A1%E8%84%9A%E6%9C%AC%E6%A8%A1%E5%BC%8F%E5%AF%B9%E7%94%A8%E4%BE%8B%E5%BB%BA%E6%A8%A1.jpg" alt="使用事务脚本模式对用例建模"></p>
<p>事务脚本适用于简单的逻辑，但不适合在大规模逻辑里实现组件复用。</p>
<p><strong>当业务扩展要求我们把逻辑复用作为主要问题的时候，我们就需要从事务脚本向更加 OO 的方向转换了，以此减少重复而实现复用</strong>。</p>
<h5 id="表模型">表模型</h5>
<p>单个对象对应数据库的一张表或者一个视图。</p>
<p>适合数据库驱动设计。</p>
<h5 id="活动记录">活动记录</h5>
<p>对象对应数据库中的一行。</p>
<p>适合数据库驱动设计。</p>
<h5 id="贫血领域模型">贫血领域模型</h5>
<p>不包含领域逻辑而只包含数据行为的数据结构。</p>
<p>在这里作者明确提出，要仅创建和使用不可变数据结构与集合。</p>
<h5 id="贫血领域模型和函数式编程">贫血领域模型和函数式编程</h5>
<p>最重要的领域概念是动词：<strong>转账比银行账户重要</strong>。</p>
<h3 id="使用有界上下文维护领域模型的完整性">使用有界上下文维护领域模型的完整性</h3>
<h4 id="单个模型的挑战">单个模型的挑战</h4>
<p>单个模型的挑战来源于：</p>
<ol>
<li>更多的用例让它复杂性增加。</li>
<li>多个团队会让明确性降低。</li>
<li>歧义不可避免：同一个名词在不同上下文中意味着不同的内容。</li>
</ol>
<p><img src="%E5%A4%8D%E6%9D%82%E6%80%A7%E5%B0%86%E5%A2%9E%E5%8A%A0%E7%9A%84%E6%A8%A1%E5%9E%8B.jpg" alt="复杂性将增加的模型"><br>
<img src="%E6%A8%A1%E5%9E%8B%E4%B8%AD%E7%9A%84%E5%A4%8D%E6%9D%82%E6%80%A7%E4%BC%9A%E9%9A%8F%E7%9D%80%E5%A4%9A%E4%B8%AA%E5%9B%A2%E9%98%9F%E7%9A%84%E4%BB%8B%E5%85%A5%E8%80%8C%E5%A2%9E%E5%8A%A0.png" alt="模型中的复杂性会随着多个团队的介入而增加"><br>
<img src="%E9%A2%86%E5%9F%9F%E6%9C%AF%E8%AF%AD%E5%9C%A8%E4%B8%8D%E5%90%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%AD%E6%84%8F%E5%91%B3%E7%9D%80%E4%B8%8D%E5%90%8C%E7%9A%84%E5%86%85%E5%AE%B9.jpg" alt="领域术语在不同上下文中意味着不同的内容"></p>
<p>对采购和销售团队而言，产品就是不同的概念，也可以是不同的概念。</p>
<p><img src="%E4%BA%A7%E5%93%81%E7%9A%84%E4%BE%8B%E5%AD%90.jpg" alt="产品的例子"></p>
<p>使用单一模型也会让应用程序变成 BBoM。</p>
<p><strong>违反 SRP 原则会产生上帝对象</strong>：</p>
<p><img src="%E4%B8%8A%E5%B8%9D%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BE%8B%E5%AD%90.jpg" alt="上帝对象的例子"></p>
<p>除此之外：</p>
<ol>
<li>小模型更加容易与遗留代码和第三方代码集成。</li>
<li>有时候要把企业模型和领域模型分离出来，虽然有时候没有企业模型用领域模型也能制造和生成报表。</li>
</ol>
<p><img src="%E4%BC%81%E4%B8%9A%E6%A8%A1%E5%9E%8B%E5%92%8C%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB.jpg" alt="企业模型和领域模型之间的区别"></p>
<h4 id="使用有界上下文和破除大模型">使用有界上下文和破除大模型</h4>
<p><strong>限界上下文界定了模型的用途和它能够保持一致性的职责边界</strong>。所以上下文的名字就是模型的用途-核心职责。</p>
<p><img src="%E5%B0%86%E6%9C%AF%E8%AF%AD%E6%94%BE%E5%85%A5%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%AD%E5%85%B5%E6%A0%87%E8%AF%86%E5%A4%9A%E4%B8%AA%E6%A8%A1%E5%9E%8B.jpg" alt="将术语放入上下文中兵标识多个模型"><br>
<img src="%E5%9C%A8%E6%AF%8F%E4%B8%AA%E6%A8%A1%E5%9E%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%AD%E5%AE%9A%E4%B9%89%E5%AE%83%E4%BB%AC.jpg" alt="在每个模型自己的上下文中定义它们"></p>
<p>影响有界上下文的因素有：</p>
<ol>
<li>领域专业术语发生是否发生歧义，发生歧义则它们应该被放在不同上下文里。</li>
<li>要与子域的业务能力保持一致。</li>
<li>团队组织和实际位置。</li>
<li>遗留代码库。</li>
<li>第三方集成。</li>
</ol>
<p>定义模型边界的方法有：</p>
<ol>
<li>围绕语言定义边界。</li>
<li>要与业务能力保持一致。这里讲的行为就是下面讲的用例。</li>
<li>围绕团队。单个团队应该至少拥有一个上下文，而不是反过来多个团队共享一个上下文。</li>
<li>物理部署边界。</li>
</ol>
<p><strong>子域和有界上下文的差异（极端重要）</strong>：</p>
<ol>
<li>子域代表了问题域的逻辑区域，反映了组织的业务能力。子域存在的意义是为了提炼问题空间分解复杂性。子域是没有模型的。</li>
<li>理想情况下，子域和模型会一对一映射。但子域可能包含多套模型，一个模型可能跨多套子域。</li>
<li>限界上下文是一套模型的边界，存在在解空间里。模型存在于有限上下文里。</li>
</ol>
<p><img src="%E6%AF%8F%E4%B8%AA%E6%9C%89%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E8%80%8C%E9%9D%9E%E6%AF%8F%E4%B8%AA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F.jpg" alt="每个有界上下文而非每个应用程序的分层架构模式"></p>
<p>可以看到 BC 是有自己的展现层、领域层和持久层的。</p>
<p><img src="%E4%B8%8D%E5%90%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%AD%E7%9A%84%E4%BA%A7%E5%93%81%E7%B1%BB.jpg" alt="不同上下文中的产品类"><br>
<img src="%E5%8F%AF%E4%BB%A5%E5%B0%86%E4%B8%8D%E5%90%8C%E7%9A%84%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8%E5%88%B0%E4%B8%8D%E5%90%8C%E7%9A%84%E6%9C%89%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87.jpg" alt="可以将不同的架构模式应用到不同的有界上下文"></p>
<p>这里面的复合 UI 可能替换为我们常见的 BFF。</p>
<p><img src="%E6%9C%89%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E8%A7%A3%E6%9E%90.jpg" alt="有界上下文解析"></p>
<h3 id="上下文映射">上下文映射</h3>
<p>当有多个上下文的时候、当多个上下文不共享一个老板、存在遗留代码和第三方代码时，必须考虑上下文映射问题。上下文映射让我们理解<strong>系统集成点</strong>和<strong>团队间关系</strong>。</p>
<h4 id="一个现实情况的映射">一个现实情况的映射</h4>
<p>上下文映射是一个重要构件，职责是确保上下文之间的边界被明确定义。</p>
<p><img src="%E4%B8%8A%E4%B8%8B%E6%96%87%E6%98%A0%E5%B0%84.jpg" alt="上下文映射"><br>
<img src="%E4%B8%8A%E4%B8%8B%E6%96%87%E6%98%A0%E5%B0%84%E7%9A%84%E6%8A%80%E6%9C%AF%E9%9B%86%E6%88%90.jpg" alt="上下文映射的技术集成"><br>
<img src="%E4%B8%8A%E4%B8%8B%E6%96%87%E6%98%A0%E5%B0%84%E7%9A%84%E7%BB%84%E7%BB%87%E5%85%B3%E7%B3%BB.jpg" alt="上下文映射的组织关系"></p>
<p>上下文映射要懂政治，知道上下文不能独善其身。</p>
<h4 id="认识有界上下文之间的关系">认识有界上下文之间的关系</h4>
<h5 id="防止损坏层">防止损坏层</h5>
<p>ACl 的存在原因是你无法管控某些库和 API，换言之如果你能改造遗留代码库或者第三方代码库，你可以逐步取消 ACL。</p>
<p><img src="ACL%E7%9A%84%E9%80%BB%E8%BE%91.jpg" alt="ACL的逻辑"></p>
<h5 id="共享内核">共享内核</h5>
<p><img src="%E5%85%B1%E4%BA%AB%E5%86%85%E6%A0%B8%E7%9A%84%E9%9B%86%E6%88%90.jpg" alt="共享内核的集成"></p>
<p>共享内核强要求持续集成。</p>
<h5 id="开放宿主服务">开放宿主服务</h5>
<p><img src="%E9%9B%86%E6%88%90%E5%BC%80%E6%94%BE%E5%AE%BF%E4%B8%BB%E6%9C%8D%E5%8A%A1.jpg" alt="集成开放宿主服务"></p>
<p>From C to S。</p>
<h5 id="顾客-供应商关系">顾客-供应商关系</h5>
<p><img src="%E9%A1%BE%E5%AE%A2-%E4%BE%9B%E5%BA%94%E5%95%86%E4%B8%8A%E4%B8%8B%E6%96%87%E5%85%B3%E7%B3%BB.jpg" alt="顾客-供应商上下文关系"></p>
<p>注意，被调用方是供应商也是上游。上游团队不会和下游团队协商，除非下游提需求。</p>
<h5 id="separated-ways">Separated Ways</h5>
<p>不要忘记还有分道扬镳这一选择。<strong>如果无法采用技术手法处理合作问题，就只能采取这一方法</strong>。</p>
<h4 id="传递上下文映射">传递上下文映射</h4>
<p>可以在模型上加上小方格，如开放宿主、ACL，来说明集成类型。</p>
<p><img src="%E6%98%BE%E7%A4%BA%E6%9C%89%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B9%8B%E9%97%B4%E9%9B%86%E6%88%90%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E6%98%A0%E5%B0%84.jpg" alt="显示有界上下文之间集成类型的上下文映射"></p>
<h4 id="上下文映射的战略重要性">上下文映射的战略重要性</h4>
<p>上下文之间的通信对于团队开始一个项目来说，对技术上和组织上都更重要。</p>
<ol>
<li>保持模型的完整性。每个团队需要更加关注公开的信息（API）、负责的概念模型，而允许其内部可以自由修改。</li>
<li>解决计划的基础。<strong>没有舍弃就没有管理</strong>。</li>
<li>理解所有权和职责。团队和上下文的归属是在划分映射的过程中浮现出来的。</li>
<li>揭示工作流中的混乱区域。不要小看这一点，忽略通信问题通常会导致项目失败。</li>
<li>识别非技术障碍。到底什么是部门墙，必须预先心里有数。</li>
<li>鼓励良好的沟通。沟通会引导政策制定。</li>
<li>帮助新加入的员工。丰富而简约的信息是一种了解大局的奇妙方式。</li>
</ol>
<h3 id="应用程序架构">应用程序架构</h3>
<p>DDD 治理复杂性的主要思路是：</p>
<ol>
<li>在战略模式层面把业务复杂度分而治之。</li>
<li>在战术模式层面-通过架构模式，特别是设计过的分层架构（不同于strict layered architecture、flexible layered architecture），把技术问题和业务问题分离出来。</li>
</ol>
<h4 id="应用程序架构">应用程序架构</h4>
<p>但当代的 DDD 架构模式的最佳实践有一个特别的地方，领域的原始复杂性是一个低端详情，Application 层算一个高层次的粗粒度用例集，真正展示了<strong>组织的业务能力</strong>。这个样子我们有了：</p>
<ol>
<li>一个很详细的，会深度演进和重构的领域层。</li>
<li>粗粒度用例集，稍微稳定一些。</li>
<li>五花八门的端口与适配器。</li>
</ol>
<p><img src="%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84.jpg" alt="分层架构"><br>
<img src="%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84%E4%B8%AD%E7%9A%84%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE.jpg" alt="分层架构中的依赖倒置"></p>
<ol>
<li>应用层意味着做什么。</li>
<li>领域层意味着怎么做，领域层是不能了解存储和客户端的细节的。应用层要尽量精简，不要和框架有耦合（这和我们以往的实践并不相同，我们很容易在设计中滥用类似 Spring 之类的依赖），控制任务进度。</li>
<li>基础设施层意味着在依赖于具体技术时怎么做。我们经常会忽略安全、事务管理和日志管理都应该聚集在这一层实现。</li>
</ol>
<p><img src="%E5%90%91%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%9A%90%E8%97%8F%E7%9A%84%E9%A2%86%E5%9F%9F%E5%AF%B9%E8%B1%A1.jpg" alt="向应用程序客户端隐藏的领域对象"></p>
<p>我们一定要注意，转换是发生在appliction之外，跟application通信应该使用 appliction指定的类型（通常是领域对象）。而对外输出通常是 dto。</p>
<p><img src="%E6%B5%8B%E8%AF%95%E9%9A%94%E7%A6%BB%E4%B8%AD%E7%9A%84%E5%B1%82.jpg" alt="测试隔离中的层"></p>
<p>这里要注意 mock 和 stub 的运用。</p>
<p><img src="%E9%80%9A%E8%BF%87%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9B%86%E6%88%90%E6%9C%89%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87.jpg" alt="通过共享数据结构集成有界上下文"></p>
<p>通过共享内存来通信也是一种集成的方法，但这是一种 anti-pattern。</p>
<p><img src="%E5%85%B7%E6%9C%89%E5%85%B6%E4%B8%93%E6%9C%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E6%9C%89%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87.jpg" alt="具有其专有数据结构的有界上下文"></p>
<p>同库不同表算是一种稍微好一点的模式，算一种多租户模式吧。</p>
<p><img src="%E9%80%9A%E8%BF%87%E5%8D%95%E7%8B%AC%E7%9A%84%E5%BA%94%E7%94%A8%E5%B1%82%E9%9B%86%E6%88%90%E6%9C%89%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87.jpg" alt="通过单独的应用层集成有界上下文"></p>
<p>单独的应用层可以集成多个 BC，这可以看出来 BC 本身可以共享外层，但自领域层以下必须隔离。</p>
<p><img src="%E7%94%B1%E6%9C%89%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E7%BB%84%E6%88%90%E7%9A%84%E5%B1%95%E7%8E%B0%E5%B1%82.jpg" alt="由有界上下文组成的展现层"></p>
<h4 id="应用程序服务">应用程序服务</h4>
<p><img src="%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E9%80%BB%E8%BE%91%E5%AF%B9%E6%AF%94%E9%A2%86%E5%9F%9F%E9%80%BB%E8%BE%91.jpg" alt="应用程序逻辑对比领域逻辑"></p>
<ol>
<li>查询可以直接引用 repo。</li>
<li>事务必须保持在 Application 层里。</li>
<li>转换必须发生在 interface 里，完成 dto 和领域对象之间的转换。</li>
</ol>
<p>应用层应该只为了用例变化而变化，接口层必须适应应用层的变化。</p>
<p>这里再度强调了应用层的“业务用例协作”性质，如果控制器被拿出来做一番比较的话，控制器要关注：</p>
<ol>
<li>映射输入输出。</li>
<li>管理任务状态、通信状态和浏览状态。</li>
</ol>
<p>但其实在一般的 DDD 架构里，控制器是在 interface 里。</p>
<p>如果可以，<strong>我们使用 BDD 捕获的行为来描述用例，而不只是 CRUD 来描述行为</strong>：理赔是个好的应用层用例的名称，创建赔付不是。</p>
<p>相比之下，领域层可能很简单，有些通用域简单到只是存储层的外观。这时候丰富领域模型模式是个错误的选择，事务脚本或者简单 CRUD 是个好选择。</p>
<p><img src="%E9%A2%86%E5%9F%9F%E6%8A%A5%E5%91%8A.jpg" alt="领域报告"></p>
<p>有时候应用层也会展现出一些在 BI、CQRS 类架构里会出现的聚合报表能力，这被称为领域报告-这可能是一个无用的概念。作者接下来还点出了一点，通过<code>数据源-&gt;丰富领域模型-&gt;应用层</code>来获取领域信息的视图是低效的，<code>数据源-&gt;应用层</code>是合理的。在架构中这可能被体现为 controller repo 模式。</p>
<p><img src="%E8%A7%86%E5%9B%BE%E6%A8%A1%E5%9E%8B%E9%97%AE%E9%A2%98.jpg" alt="视图模型问题"></p>
<p>一种理解事件的视图：</p>
<p><img src="%E4%B8%8E%E4%BA%8B%E5%8A%A1%E5%AD%98%E5%82%A8%E5%88%86%E7%A6%BB%E7%9A%84%E8%A7%86%E5%9B%BE%E5%AD%98%E5%82%A8.jpg" alt="与事务存储分离的视图存储"></p>
<p>插播两个原则：</p>
<ol>
<li>无论如何，<strong>越是内层，应该对外层一无所知</strong>，Application 层应该对谁使用系统用例一无所知。这是展现层、端口/适配器需要关注的东西。</li>
<li><strong>内层公开外围层必须遵从和实现的接口，这种依赖倒置可以保护领域层和应用层的完整性</strong>-这允许这两层的服务由最外层的 infra 层实现。</li>
</ol>
<p><img src="%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8%E4%B8%80%E4%B8%AA%E7%B3%BB%E7%BB%9F%E5%92%8C%E5%A4%9A%E4%B8%AA%E7%B3%BB%E7%BB%9F.jpg" alt="如何调用一个系统和多个系统"></p>
<p><img src="%E8%BF%87%E7%A8%8B%E7%AE%A1%E7%90%86%E5%99%A8.jpg" alt="过程管理器"></p>
<p>这里的过程管理器很像其他架构模式下的coordinator、cohort、Task Master 之类的节点。</p>
<h3 id="团队开始应用领域驱动设计通常会遇到的问题">团队开始应用领域驱动设计通常会遇到的问题</h3>
<p>DDD 虽然有模板语言，但不要仅把 DDD 的战术模式当作一种框架或者预定义服务模板（虽然我们乐于使用各种框架和服务模板，如 Spring/XFrame 来）来使用。<strong>重视模板语言而忽略沟通和协同是一种买椟还珠的行为</strong>。<strong>成为一名伟大的软件工程师的最根本点是理解他要解决的问题域</strong>-极其重要。</p>
<h4 id="过分强调战术模式的重要性">过分强调战术模式的重要性</h4>
<p>编码从来都不会是主要问题，它只是单人工作的内容。</p>
<p>很多时候 DDD 的战术模式被当做服务模板，将相同的架构使用于所有上下文。</p>
<p>大部分的服务都不需要使用 CQRS 和 EventSourcing，不要在本书中学到以后到处拿来用。</p>
<p>DDD 的构造块也不是什么圣经。在 DDD 一书面试以来，<strong>战术模式的构造块已经发生了很大的演化</strong>（特别是参考过很多书的本文），而战略模式一如最初。搞清楚为什么要选用这些解决方案比精准地实施这些方案还要重要。</p>
<p>有价值的东西是 UL：易于评价其价值的东西是你是否采取了某类特定的模式解决了具有一定复杂程度的问题，但难以评价其价值的东西是你是否真的构造出了 UL。<strong>很多人沉迷于战术模式其实是在回避战略模式的困难</strong>。</p>
<p>视图从代码构件里反向解读模型，是很难理模型的长期演化的。</p>
<h4 id="缺失了-ddd-的真实价值：协作-通信和上下文">缺失了 DDD 的真实价值：协作、通信和上下文</h4>
<p>代码只是有效协作的副产品，我们的目标是让开发人员和领域专家在定义好的上下文内使用 UL 毫不费力地沟通。</p>
<p>模糊边界即缺失上下文会导致 BBoM。</p>
<p><strong>UL 的本质是共享模型，强迫所有人理解和维护同一个东西</strong>。</p>
<h4 id="在不重要的部分花费太多时间">在不重要的部分花费太多时间</h4>
<p>重视框架是一个例子。</p>
<h4 id="简单的问题复杂化">简单的问题复杂化</h4>
<ol>
<li>将 DDD 原则应用到少量业务预期的琐碎领域。<strong>问题域要又重要又不简单</strong>。</li>
<li>将 CRUD 当作反模式。</li>
<li>将领域模型模式用于每一个有界上下文。</li>
<li>问一问自己：额外的复杂性是否值得。这里有一个例子，<strong>最初学设计模式的人总喜欢把设计模式应用到每段代码里</strong>。</li>
</ol>
<h4 id="低估使用-ddd-的成本">低估使用 DDD 的成本</h4>
<ol>
<li>尝试在没有积极专注的团队下取得成功。</li>
<li>在非迭代式开发方法中进行学习。</li>
<li>将 DDD 应用到每一个问题。</li>
<li>为不必要的纯粹性而<strong>牺牲实用主义</strong>。实用主义可能是我们需要采纳的。</li>
<li>寻求验证而浪费精力。</li>
<li>永远力求代码之美。有时候，可以被轻易替换的小泥球比优美的上下文实现要好，毕竟做过代码隔离了。</li>
</ol>
<p>本章的要点有：</p>
<ol>
<li>战术模式价值有限，强调细节逼真无意义。</li>
<li>DDD 的<strong>核心价值是与领域专家的协作</strong>。</li>
<li>从上面这一层下来，最重要的有：UL、模型驱动设计和上下文。</li>
</ol>
<h3 id="应用-ddd-的原则-实践与模式">应用 DDD 的原则、实践与模式</h3>
<p>“你能说明这么做能取得什么优势吗？”</p>
<p>顾客为何想要，何时想要？</p>
<p>我们能否精炼问题空间，专注于重要方面。</p>
<p>要懂得丢弃第一第二个模型。</p>
<p>如果非得选，边界必边界内重要。</p>
<p><img src="DDD%E7%9A%84%E8%BF%87%E7%A8%8B.jpg" alt="DDD的过程"></p>
<p>本章中，再次提到了对规则的诠释最好引入 Policy 或者 Rule 之类的模型，这可以让规则判定变得简单。</p>
<p><strong>伟大的开发者能够让问题变得更简单</strong>，而不是更复杂。</p>
<h2 id="战略模式：在有界上下文之间通信">战略模式：在有界上下文之间通信</h2>
<h3 id="有界上下文集成介绍">有界上下文集成介绍</h3>
<p>SOA 本质是面向业务的。</p>
<p>如果使用事件驱动架构来集成上下文，开发者要懂得另类的思考方式-必须要提防最终一致性问题。</p>
<p>上下文不独立自主，带来的问题是相互延误和代码损坏。</p>
<p><img src="%E5%9C%A8%E5%8D%95%E4%B8%AA%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B8%AD%E9%9B%86%E6%88%90%E5%A4%9A%E4%B8%AA%E6%9C%89%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87.jpg" alt="在单个解决方案中集成多个有界上下文"><br>
<img src="%E4%BD%BF%E7%94%A8%E5%85%B1%E4%BA%AB%E6%9E%B6%E6%9E%84%E7%9A%84%E5%A4%9A%E4%B8%AA%E6%9C%89%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87.jpg" alt="使用共享架构的多个有界上下文"><br>
<img src="%E4%BD%BF%E7%94%A8%E9%9B%B6%E5%85%B1%E4%BA%AB%E6%9E%B6%E6%9E%84%E7%9A%84%E6%9C%89%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87.jpg" alt="使用零共享架构的有界上下文"><br>
<img src="%E6%B0%94%E6%B3%A1%E4%B8%8A%E4%B8%8B%E6%96%87.jpg" alt="气泡上下文"></p>
<p>气泡上下文的神髓在于：<strong>上下文之间的交互要有一个新的起点</strong>。</p>
<p><img src="%E5%B0%86%E9%81%97%E7%95%99%E4%B8%8A%E4%B8%8B%E6%96%87%E4%BD%9C%E4%B8%BAJSON-WEB%E6%9C%8D%E5%8A%A1%E5%85%AC%E5%BC%80.jpg" alt="将遗留上下文作为JSON-WEB服务公开"></p>
<h4 id="集成分布式有界上下文">集成分布式有界上下文</h4>
<p>有时候共享文件和数据库也可以：</p>
<p><img src="%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9B%86%E6%88%90.jpg" alt="数据库集成"></p>
<p><img src="%E5%B9%B3%E9%9D%A2%E6%96%87%E4%BB%B6%E9%9B%86%E6%88%90.png" alt="平面文件集成"></p>
<p>flat files 不受数据库爱好者的热爱。因为它是一开始就有的，不够先进。</p>
<p>集成的主要模式有：RPC、Messaging、REST。</p>
<h5 id="使用-rpc">使用 RPC</h5>
<p>优点：</p>
<ol>
<li>使用桩可以让网络通信透明化。</li>
<li>即时上线。</li>
<li>平台解耦-所有透明化方案都有这样的特点。</li>
</ol>
<p>缺点：</p>
<ol>
<li>使用 RPC 难以带来弹性（resillience？elastic？）。这个问题似乎可以被仓壁模式妥善解决。</li>
<li>扩展 RPC 的代价更高（scalable）。作者的观点是全部的有界上下文都要做性能优化才行。</li>
<li>RPC 涉及紧密耦合。特别是你把它当作一个类来看的时候尤其如此。这涉及到逻辑耦合（logical coupling）或者 temporal coupling（这里中文译作临时耦合，我觉得时序耦合更好）。</li>
</ol>
<h4 id="分布式事务将损害可扩展性和可靠性">分布式事务将损害可扩展性和可靠性</h4>
<p>事务的成本总是很高的，不基于锁很难实现简单的分布式事务安全。但如果使用锁事务的吞吐量和成功率可能会降低。</p>
<p><strong>不要想着各个有界上下文保持一直存在的一致性视图（consistent view），这是得不偿失的</strong>。在某一个时刻达到 BASE 是好的。</p>
<h4 id="事件驱动响应式-ddd">事件驱动响应式 DDD</h4>
<p><img src="%E7%94%A8%E5%93%8D%E5%BA%94%E5%BC%8F%E6%9B%BF%E4%BB%A3RPC.jpg" alt="用响应式替代RPC"></p>
<p>作者说过，响应式编程只是异步消息传递和相关概念赋予的一个名称罢了。</p>
<p>响应式编程意味着，支付后其他上下文是通过订阅 PaymentAccepted 事件来实现的。</p>
<p>这带来了：</p>
<ol>
<li>弹性：依靠 MQ 的韧性</li>
<li>可扩展性：通过只使用 LB 和给 Web。 层做到，这要求同步流程极短，最好还得配上云基础设施。</li>
<li>异构技术集成：发布订阅者彼此之间完全无感。</li>
</ol>
<p>它的缺点是：</p>
<ol>
<li>间接性思维。</li>
<li>最终一致性思维。</li>
</ol>
<h4 id="soa-和响应式-ddd">SOA 和响应式 DDD</h4>
<p>响应式架构是促成低耦合的低层技术指南，SOA 是促成低耦合的高层次概念。</p>
<ol>
<li>将有界上下文分解成业务组件</li>
<li>将业务组件分解成组件</li>
</ol>
<p><img src="%E5%B0%86%E8%BF%90%E8%BE%93%E6%9C%89%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%86%E8%A7%A3%E6%88%90%E4%B8%9A%E5%8A%A1%E7%BB%84%E4%BB%B6.jpg" alt="将运输有界上下文分解成业务组件"><br>
<img src="%E8%BF%90%E8%BE%93%E6%9C%89%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%86%E8%A7%A3%E6%88%90%E4%B8%9A%E5%8A%A1%E7%BB%84%E4%BB%B6%E5%92%8C%E7%BB%84%E4%BB%B6.jpg" alt="运输有界上下文分解成业务组件和组件"></p>
<p>这里的组件和 4C 的组件又不一样了。但看起来就是一个独立功能的边界。</p>
<p><img src="%E7%BB%84%E4%BB%B6%E6%98%AF%E9%83%A8%E7%BD%B2%E7%9A%84%E5%8D%95%E4%BD%8D.jpg" alt="组件是部署的单位"></p>
<p>在这里我们可以看到在 .Net 技术里，使用多个组件也会得到多个部署单元。</p>
<p><img src="%E5%9C%A8%E7%9B%B8%E5%90%8C%E4%B8%9A%E5%8A%A1%E7%BB%84%E4%BB%B6%E5%86%85%E5%85%B1%E4%BA%AB%E4%BE%9D%E8%B5%96%E6%80%A7%E6%98%AF%E5%94%AF%E4%B8%80%E5%85%81%E8%AE%B8%E7%9A%84.jpg" alt="在相同业务组件内共享依赖性是唯一允许的"></p>
<p>在这里的共享依赖性其实就是共享数据库-进而共享数据结构。</p>
<p>MSA 也是一个好的架构选择，但用了就一定要下决心，都用下去。</p>
<h3 id="通过消息传递集成">通过消息传递集成</h3>
<p>在 RPC 的部分，我们已经知道了我们要构建的是可扩展的分布式系统（extensible distributed system），并且还要得到 DDD 的种种好处。所以我们会仔细探讨各种分布式系统之间的通信方式。我们要知道这些通信方式的优缺点。</p>
<p>其他的通信方案都要引入重试（特别难地，是在 HTTP 上），但消息队列通常自带重试，这就带来弹性了。</p>
<p>MQ 的缺点通常有：</p>
<ol>
<li>非标准格式</li>
<li>异步化思维</li>
<li>最终一致性处理</li>
</ol>
<h4 id="消息传递基础">消息传递基础</h4>
<p><img src="%E6%B6%88%E6%81%AF%E6%80%BB%E7%BA%BF%E6%9E%B6%E6%9E%84.jpg" alt="消息总线架构"></p>
<p>讨论消息的可靠性就会回到 at least once + 幂等的问题上。</p>
<p>作者给幂等下了一个简单定义，多次被发送，但实际只触发一次处理，而多次转发，要求的存储转发的功能，即本地副本 + ACK 确认删除机制。</p>
<p><img src="%E6%B7%BB%E5%8A%A0%E6%96%B0%E7%9A%84%E4%BA%8B%E4%BB%B6%E8%AE%A2%E9%98%85%E8%80%85%E4%B8%8D%E4%BC%9A%E5%BD%B1%E5%93%8D%E5%B7%B2%E6%9C%89%E4%BB%A3%E7%A0%81.jpg" alt="添加新的事件订阅者不会影响已有代码"></p>
<p>在一般的 MQ 里，订阅者有一个注册的流程，但在事件框架内部，有时候一个泛型参数就能决定消息的路由走向。注册-路由机制是 mq 机制里特别有意思的一部分。</p>
<p><strong>大的事务并不易扩展，最终一致性引入告诉我们-别忘了每个子事务都要带有确认功能</strong>。</p>
<h4 id="使用-nservicebus-构建一个电子商务应用程序">使用 NServiceBus 构建一个电子商务应用程序</h4>
<p><img src="%E6%98%BE%E7%A4%BA%E9%A2%86%E5%9F%9F%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%BB%84%E4%BB%B6%E5%9B%BE.jpg" alt="显示领域事件的组件图"></p>
<p>我们要学会分离：1. 功能性领域需求 2. 非功能性技术需求。</p>
<p>在非功能性技术需求上，要学会辨别主要技术选择（major tech choice）：OS、Language、Web Server、MiddleWare、Framework。</p>
<p><img src="%E7%94%A8%E4%BA%8E%E4%B8%80%E4%B8%AA%E5%85%B8%E5%9E%8B%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%AE%B9%E5%99%A8%E5%9B%BE.jpg" alt="用于一个典型电子商务应用程序的容器图"></p>
<p>处理最终一致性时要注意：</p>
<ol>
<li>明确确认的重要性。</li>
<li>在事务一致性不可能达成时要准备前滚，要有一个前滚状态集，而且用户要有所准备。</li>
</ol>
<p>这个案例里作者还举了一个例子：如果一个操作需要先扣费，然后再存储数据库，如何防止重复扣费？答案是消息传递网关：即扣费和存数据库之间采用命令解耦，<strong>把一个大事务对半分</strong>。</p>
<p><img src="%E6%94%AF%E4%BB%98%E8%A2%AB%E6%8B%92%E7%BB%9D.jpg" alt="支付被拒绝"></p>
<p>这个图体现了邮件的重要性。</p>
<p><img src="%E5%A4%9A%E4%B8%AA%E6%9C%89%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E9%83%BD%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E7%9B%B8%E5%90%8C%E7%9A%84%E6%95%B0%E6%8D%AE%E7%89%87%E6%AE%B5.jpg" alt="多个有界上下文都本地存储相同的数据片段"></p>
<p>对于“顾客地址的查询问题”，我们有两类选项：</p>
<ol>
<li>每次需要就去查，但这会引入 temporal coupling。如果顾客上下文不稳定，则流程无法继续。</li>
<li>本地冗余。这要求我们对事件的属性进行把控，不要产生不恰当的事件的耦合，不要污染事件。</li>
</ol>
<p>做数据冗余的时候要提防这样的问题：</p>
<ol>
<li>不同时期的价格会波动，使用时要仔细辨别。</li>
<li>使用有效日期界定事件的有效期：availableFrom、availableTo。</li>
</ol>
<p><img src="%E4%B8%9A%E5%8A%A1%E7%BB%84%E4%BB%B6%E6%9C%89%E5%85%B6%E8%87%AA%E5%B7%B1%E7%9A%84API.jpg" alt="业务组件有其自己的API"><br>
<img src="%E4%BB%8E%E5%A4%9A%E4%B8%AAAPI%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E7%9A%84%E9%A1%B5%E9%9D%A2.jpg" alt="从多个API获取数据的页面"></p>
<p>多个 API 的好处是，当一个数据显示不出来的时候，主要数据还可以被显示出来。</p>
<h4 id="维护消息传递应用程序">维护消息传递应用程序</h4>
<p>多版本 OrderCreated 消息可以通过继承来实现，继承产生了不同的类型可以让框架支持自动路由。</p>
<h4 id="将有界上下文与公共传输集成">将有界上下文与公共传输集成</h4>
<p><img src="%E4%BF%83%E9%94%80%E6%9C%89%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E9%9B%86%E6%88%90%E5%88%B0%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E7%B3%BB%E7%BB%9F%E4%B8%AD.jpg" alt="促销有界上下文集成到电子商务消息传递系统中"></p>
<p><img src="%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E6%A1%A5%E5%B0%B1%E5%83%8F%E4%B8%80%E4%B8%AA%E9%93%BE%E6%8E%A5.jpg" alt="消息传递桥就像一个链接"></p>
<p>这里引入了消息桥模式。</p>
<h3 id="通过使用-rpc-和-rest-的-http-集成">通过使用 RPC 和 REST 的 HTTP 集成</h3>
<p>HTTP 已经被证明是无处不在的了，它可以在不同的硬件和软件技术栈上运行，所以对于用来集成有界上下文来讲是个很不错的选择。它可以支持 RPC 和 REST。有界上下文集成要思考的几个基本问题分别是：</p>
<ol>
<li>通信</li>
<li>可扩展性</li>
<li>容错</li>
</ol>
<h4 id="为何选用-http">为何选用 HTTP</h4>
<p>http 的独特优势在于：</p>
<ol>
<li>没有平台耦合。</li>
<li>每个人都理解 HTTP。</li>
<li>大量成熟工具和库</li>
<li>内部测试你的 API。</li>
</ol>
<p>1234意味着内部 API 和外部 API 可以使用同一种 API。</p>
<h4 id="rpc">RPC</h4>
<p><strong>RPC 使用抽象隐藏网络，也让很多人失去了扩展整个通信的架构的机会</strong>，对于有极大扩展性的需求的公司，仍然可以选择 RPC over http 的方式来通信，这是可行的。</p>
<p>使用 HTTP 可以采用如下方案：</p>
<ol>
<li>SOAP</li>
<li>XML</li>
<li>json</li>
</ol>
<p><strong>实现 RPC 的诀窍是 payload 能够携带 data 和 method metadata</strong>。但不同的载体意味着不一样的格式，和不同程度的复杂。</p>
<p><img src="%E2%80%9C%E6%89%BE%E5%88%B0%E6%8E%A8%E8%8D%90%E7%94%A8%E6%88%B7%E2%80%9D%E7%94%A8%E4%BE%8B.jpg" alt="“找到推荐用户”用例"></p>
<p>RPC 仍然是 remote 的 IPC。当然在 .Net 技术栈里使用 WCF 来构建 RPC 框架。c 端通过一个 stub proxy 来发起调用，但生成 stub proxy 交给框架。</p>
<h4 id="rest">REST</h4>
<p>要理解 REST 要抓住<strong>资源、超媒体、无状态性</strong>。</p>
<p>RPC 使用命令式请求和响应来模拟方法调用，而 REST 通过 URI 来<strong>请求资源</strong>。领域概念-主要是对象，可以被表达为资源，于是资源也成为 UL 的一部分。</p>
<p>超媒体意味着，每个步骤的响应都是下一个步骤用到的超媒体的链接。<strong>RESTful apis must be hypertext driven</strong>。这实现了 C/S 的解耦，让两端独立演化。MQ 和 HTTP、REST 都具有这种特点，这是尤其值得注意的，我们在做主要技术选择的时候必须明确：</p>
<ol>
<li>我们是否都清楚某一类技术选择的优缺点？</li>
<li>我们将采用哪一个方案来解决另一个方案带来的问题。</li>
</ol>
<p>REST 完全支持 HTTP（为什么不是反过来？），因为 HTTP 太过流行，<strong>很多松耦合的约定都被大家接受了</strong>，特别是<strong>一系列动词集</strong>、状态码。</p>
<p><img src="%E8%A2%AB%E6%8E%A8%E8%8D%90%E8%B4%A6%E6%88%B7%E7%94%A8%E4%BE%8B%E7%9A%84%E7%BB%84%E4%BB%B6%E5%9B%BE.jpg" alt="被推荐账户用例的组件图"></p>
<p>设计 API 要兼顾端点（endpoint）的颗粒度，为了扩展性考虑，要和项目（这里专指.Net项目）的划分考虑到一起。</p>
<p><img src="%E2%80%9C%E5%8F%91%E7%8E%B0%E2%80%9D%E3%80%81%E2%80%9C%E8%B4%A6%E6%88%B7%E7%AE%A1%E7%90%86%E2%80%9D%E4%BB%A5%E5%8F%8A%E2%80%9C%E5%B8%82%E5%9C%BA%E2%80%9D%E6%9C%89%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E5%AE%B9%E5%99%A8%E5%9B%BE.jpg" alt="“发现”、“账户管理”以及“市场”有界上下文的容器图"></p>
<p><img src="%E7%94%A8%E4%BA%8E%E2%80%9C%E6%B7%BB%E5%8A%A0%E5%85%B3%E6%B3%A8%E8%80%85%E2%80%9D%E7%94%A8%E4%BE%8B%E7%9A%84HTTP%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B.jpg" alt="用于“添加关注者”用例的HTTP请求流程"></p>
<p>客户端仅耦合到入口点 API。</p>
<p><img src="%E8%BD%AE%E8%AF%A2%E5%92%8C%E4%BD%BF%E7%94%A8%E2%80%9C%E5%BC%80%E5%A7%8B%E5%85%B3%E6%B3%A8%E2%80%9D%E4%BA%8B%E4%BB%B6%E6%BA%90%E7%9A%84HTTP%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B.jpg" alt="轮询和使用“开始关注”事件源的HTTP请求流程"></p>
<p>这种API格式有一个特点：<strong>BoundedContext.Resource</strong>。</p>
<p>AccountManagement.Account.Api 名字空间下还会有专门的 HAL，如果有必要可以引入 HAL 浏览器来调试这一 Api。</p>
<p>REST 如何解决容错和最终一致性问题？</p>
<ol>
<li>依赖于 LB 的failover作为另一种形式的存储转发。</li>
<li>依赖轮询来达成最终一致性-就这点而言，还不如用回调。</li>
</ol>
<p>本章留给我们一个悬疑：如何正确构建事件驱动的 REST 应用程序？</p>
<h2 id="战术模式：创建有效的领域模型">战术模式：创建有效的领域模型</h2>
<h3 id="构造块领域建模介绍">构造块领域建模介绍</h3>
<p>领域模型这一概念很早就存在的（不知道谁发明的），哪怕是 Martin Fowler 把它编录进《PEAA》也是很早的事情。但 <strong>Eric Evans 是第一个引入一套构造块作为模式语言，把它介绍出来帮助开发者创建有效的软件的人</strong>。这些模式全都围绕面向对象原则来设计。</p>
<p>值得关注的新模式都是与事件相关的，特别是领域事件（进而引出事件驱动）和事件溯源。</p>
<h4 id="战术模式">战术模式</h4>
<p><img src="%E6%88%98%E6%9C%AF%E6%A8%A1%E5%BC%8F-%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B%E6%9E%84%E9%80%A0%E5%9D%97.jpg" alt="战术模式-领域模型构造块"></p>
<h4 id="对领域建模的模式">对领域建模的模式</h4>
<p><img src="%E5%AE%9E%E4%BD%93.jpg" alt="实体"><br>
<img src="%E5%80%BC%E5%AF%B9%E8%B1%A1.jpg" alt="值对象"></p>
<p>注意看求等的箭头指向哪里。</p>
<p><strong>领域服务的职责是使用实体和值对象编排业务逻辑，不应该具有内部状态</strong>。一个特别好的例子是，运输成本计算器：得到一组托运货物和重量组别，计算出价格。</p>
<p>c# 里面也有模块，这和其他书籍谈到 ddd 的时候，也会提到模块封装一样。</p>
<h4 id="显露模式-revealing-pattern">显露模式（Revealing Pattern）</h4>
<p>事件有两大类作用：</p>
<ol>
<li>记录模型的变更。</li>
<li>实现跨聚合的通信。</li>
</ol>
<p>事件溯源是为了<strong>补充传统的快照式存储</strong>而存在的。</p>
<h4 id="生命周期模式">生命周期模式</h4>
<p><img src="%E5%A4%A7%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%9B%BE%E8%A1%A8.jpg" alt="大的对象图表"><br>
<img src="%E5%A4%A7%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%9B%BE%E5%BD%A2%E8%A2%AB%E5%88%92%E5%88%86%E6%88%90%E8%81%9A%E5%90%88.jpg" alt="大的对象图形被划分成聚合"><br>
<img src="%E8%81%9A%E5%90%88%E6%A0%B9%E5%85%85%E5%BD%93%E8%81%9A%E5%90%88%E7%9A%84%E5%85%A5%E5%8F%A3%E7%82%B9.jpg" alt="聚合根充当聚合的入口点"></p>
<p>聚合模式要求我们拥有一个一致性的事务并发边界。聚合根的 mutator 方法会改变我们维护不变性条件的方法-所有的不变性条件都表达在聚合根的 mutator 上。</p>
<p><img src="%E8%81%9A%E5%90%88%E7%9A%84%E5%9F%BA%E7%A1%80%E5%BA%94%E8%AF%A5%E5%9B%B4%E7%BB%95%E4%B8%8D%E5%8F%98%E6%9D%A1%E4%BB%B6.jpg" alt="聚合的基础应该围绕不变条件"></p>
<p><img src="%E4%B8%80%E4%B8%AA%E5%B7%A5%E5%8E%82.jpg" alt="一个工厂"></p>
<p>工厂是为了让使用和创建分离。</p>
<p><img src="%E5%AD%98%E5%82%A8%E5%BA%93.jpg" alt="存储库"></p>
<p>理论上讲存储库应该用于<strong>检索而不应该用于报告</strong>-但谁在乎这点呢？。</p>
<p><img src="%E9%A2%86%E5%9F%9F%E4%BA%8B%E4%BB%B6.jpg" alt="领域事件"></p>
<h3 id="值对象">值对象</h3>
<p>值对象通过 value 而不是 Identity 求等。</p>
<ol>
<li>表示描述性的、欠缺身份的概念。比如 balance、description <strong>等描述性数量</strong>。</li>
<li>增强明确性。代替字符串和简单数字，这通常易于被忽略。</li>
<li>有自带工厂、转换方法、self-validate()方法。</li>
<li>不可变。</li>
<li>如果有必要，带有单位。</li>
<li>可测试。</li>
<li>因为3，有时候会有微类型。</li>
<li>某一些值对象在另一个领域中是实体。</li>
<li>可组合。</li>
</ol>
<p>在有些存储模式（schema）下，我们可以定制值对象的存储过程-正如我们对序列化和反序列化做的那样，但我们通常不会这么做。</p>
<h3 id="实体">实体</h3>
<p><strong>关注实体，最初就要关注生命周期。</strong></p>
<p>关注生命周期，就要关注 identity。这就引出经典问题：如果没有自然 identity，我们应该如何为一个实体生成一个？</p>
<p>第二个我们需要重点关注的问题是：什么行为应该归属于实体与值对象？依赖于内部状态的行为应该归属于实体与值对象，否则应该归属于领域服务。</p>
<p>恰当地分离行为，会帮我们简化测试。</p>
<p>注意迪米特法则-注意使用 private。</p>
<p>在设计实体的时候，<strong>应该关注行为，而不是数据</strong>。</p>
<p>尽量不要直接暴露需要被检查的数据，因为你不知道客户端会用什么方式来检查这一数据，最好内聚到状态边。</p>
<p>要避免两种行为：</p>
<ol>
<li>完整建模现实世界。如果因为UI需要，我们不得不建立一些后端模型，请保持这些模型为 ViewModel 或者 Dto。</li>
<li>完全去除技术细节-比如完全去掉 ORM 在entity中的痕迹，这很难做到。</li>
</ol>
<p>要避免建立一个完整的分布式实体，如一个需要采集多方数据才能读出的cusomer。一个替代方案是多个 Namespace 下共用一个 customerId 来在多个上下文中共享多片数据。</p>
<p>实体要支持 validation，这是它保持不变性的方法。</p>
<p>要避免使用状态模式-特别是基于继承派生多个 state 的模式，使用带有不同状态的 stateful entity 子类稍微好一点-虽然也没有好多少。</p>
<p>如果可以，备忘录模式更好，但要注意产生一个 immutable 的copy。</p>
<p>带有副作用的方法最好命名为一个命令的格式。</p>
<h3 id="领域服务">领域服务</h3>
<p>领域服务的特点：</p>
<ol>
<li>无身份</li>
<li>无状态</li>
<li>代表组织多个领域实体和值对象的概念-这使得这些行为不适合放在任何一个其他领域对象上。</li>
</ol>
<h4 id="理解领域服务">理解领域服务</h4>
<p>领域服务是 UL 的一部分，不必讳言，要经常拿出来大声讨论。</p>
<p>需要使用领域服务的场景有：</p>
<ol>
<li>封装领域策略和过程。</li>
<li>表示约定。</li>
</ol>
<p>有一个关于领域服务多寡的争论：</p>
<ol>
<li>过多的领域服务一定对应非常多的贫血对象，这让我们对问题域的理解简单化了。</li>
<li>过少的领域服务也意味着可能有逻辑错配到对象上。</li>
<li>保持平衡很难。</li>
</ol>
<p>有很多很多的问题是基础架构问题和领域问题的叠加，比较明智的做法是把属于领域概念的接口留在内圈层，把实现留在外圈层。</p>
<h4 id="利用领域服务">利用领域服务</h4>
<p>领域服务通常是一个步骤，它必然驻留在领域模型中，这产生了一个争论，它和实体之间的关系是怎样的？</p>
<ol>
<li>在服务层中，domainservice 只在service层接收 entity 作为参数。这是我们常用的方案。</li>
<li>在领域中，entity 的成员方法引用domainservice 的逻辑完成业务动作：
<ol>
<li>手动在工厂的构造器里注入 service 到 entity，或者<strong>在 Repo 里复写query 方法实现注入</strong>，后者很妙，不容易被想到。</li>
<li>使用依赖注入，这要求对象有被 configured 的配置-这是很危险的。</li>
<li>在服务中“相对静态地引用服务定位器模式”。这会引入静态耦合。这是很多人在 Spring 里常用的反模式。</li>
</ol>
</li>
<li><strong>使用双重分派</strong>：在实体的方法参数里引入领域服务，两者组合完成领域策略的全部步骤。</li>
<li><strong>实体发出一个领域事件</strong>。</li>
</ol>
<p>让实体依赖于服务是一种模式，不依赖于服务是另一种模式，社区里对上面这几种实践存在巨大的争论。</p>
<h3 id="领域事件">领域事件</h3>
<p>以往我们通过探究领域实体来理解领域，现在我们还需要理解事件。</p>
<p>了解领域事件的实践可以是事件风暴。</p>
<p>如果引入事件，可能会<strong>让概念化的模型以事件为中心</strong>，我们可能不习惯。</p>
<p>注意，前面讲到的消息总线和 REST 是上下文之间的集成方式，<strong>本章讲的领域事件设计模式其实是上下文内的单线程模式</strong>。</p>
<p>辨析：</p>
<ol>
<li>领域事件是问题域内的事件。</li>
<li>领域事件设计模式是设计模式。</li>
<li>领域事件不一定需要使用事件溯源（特别是用关系型数据库来存储这一事件），但<strong>异步消息传递/事件溯源和领域事件是不错的组合</strong>。</li>
</ol>
<h4 id="领域事件模式的实质">领域事件模式的实质</h4>
<p>事件表述了：问题域中的，有不可变的公共属性的 POCO，它本身是一种视图模型。</p>
<p>事件总是有同步和异步两种选项，但<strong>异步是事务性的敌人</strong>。</p>
<p><img src="%E7%A1%AE%E4%BF%9D%E6%AD%A3%E7%A1%AE%E7%9A%84%E4%BA%8B%E5%8A%A1%E8%A1%8C%E4%B8%BA.jpg" alt="确保正确的事务行为"></p>
<p>要严格区分内部事件和外部事件：内部事件可以耦合领域对象，但决不能对外披露，比较易于变更；外部事件会跨不同上下文传递，所以要小心版本化和兼容性问题。</p>
<p><img src="%E4%B8%80%E4%B8%AA%E5%85%B8%E5%9E%8B%E4%B8%9A%E5%8A%A1%E7%94%A8%E4%BE%8B%E4%B8%AD%E7%9A%84%E5%86%85%E9%83%A8%E5%92%8C%E5%A4%96%E9%83%A8%E4%BA%8B%E4%BB%B6%E6%B5%81.jpg" alt="一个典型业务用例中的内部和外部事件流"></p>
<h4 id="模式处理操作">模式处理操作</h4>
<p>事件可以调用两种逻辑：</p>
<ol>
<li>领域层逻辑</li>
<li>应用服务层逻辑：这一层逻辑应该倾向于基础架构类问题，如发邮件。这个原则是很难实践的。</li>
</ol>
<h4 id="领域事件的实现模式">领域事件的实现模式</h4>
<ol>
<li>使用 .Net 原生的事件体系 event-delegate。+= 操作符很方便，但这会导致强耦合。</li>
<li>使用内存中的总线，这里的 NServiceBus 大概等于 SpringEvent 事件系统。解耦就妙在只要实现泛型的 handler，框架就会自动完成处理器的注册工作。</li>
</ol>
<h5 id="guava-是怎么完成事件的注册和分发的呢？">Guava 是怎么完成事件的注册和分发的呢？</h5>
<h6 id="官方示例">官方示例</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Class is typically registered by the container.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EventBusChangeRecorder</span> &#123;<br>  <span class="hljs-meta">@Subscribe</span> <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recordCustomerChange</span><span class="hljs-params">(ChangeEvent e)</span> &#123;<br>    recordChange(e.getChange());<br>  &#125;<br>&#125;<br><span class="hljs-comment">// somewhere during initialization</span><br>eventBus.register(<span class="hljs-keyword">new</span> <span class="hljs-title class_">EventBusChangeRecorder</span>());<br><span class="hljs-comment">// much later</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">changeCustomer</span><span class="hljs-params">()</span><br>  <span class="hljs-type">ChangeEvent</span> <span class="hljs-variable">event</span> <span class="hljs-operator">=</span> getChangeEvent();<br>  eventBus.post(event);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个示例不完全使用注解实现自注册，还需要老观察者模式下的注册和解注册。但是注解让类型系统变得更松散，可以使用多种事件。</p>
<h6 id="subscriberregistry-订阅注册表">SubscriberRegistry 订阅注册表</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SubscriberRegistry</span> &#123;<br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConcurrentMap&lt;Class&lt;?&gt;, CopyOnWriteArraySet&lt;Subscriber&gt;&gt; subscribers =<br>      Maps.newConcurrentMap();<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">(Object listener)</span> &#123;<br>    <span class="hljs-comment">// 通过缓存获取本对象相应的全部的 Subscriber 列表，在内部已经把 listener 生成了若干个 Subscriber 了</span><br>    Multimap&lt;Class&lt;?&gt;, Subscriber&gt; listenerMethods = findAllSubscribers(listener);<br><br>    <span class="hljs-keyword">for</span> (Entry&lt;Class&lt;?&gt;, Collection&lt;Subscriber&gt;&gt; entry : listenerMethods.asMap().entrySet()) &#123;<br>      <span class="hljs-comment">// 注意这里的 eventType 是 raw type，我们看不到 genericParameters</span><br>      Class&lt;?&gt; eventType = entry.getKey();<br>      <span class="hljs-comment">// 获取一个 eventType 对应的 Subscriber 集合</span><br>      Collection&lt;Subscriber&gt; eventMethodsInListener = entry.getValue();<br>        <br>        <span class="hljs-comment">// 从全局缓存里取出这个 eventType 的订阅者列表</span><br>      CopyOnWriteArraySet&lt;Subscriber&gt; eventSubscribers = subscribers.get(eventType);<br>        <br>      <span class="hljs-keyword">if</span> (eventSubscribers == <span class="hljs-literal">null</span>) &#123;<br>        CopyOnWriteArraySet&lt;Subscriber&gt; newSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CopyOnWriteArraySet</span>&lt;&gt;();<br>        <span class="hljs-comment">// 在多线程中获取同一个订阅者列表 CopyOnWriteArraySet</span><br>        eventSubscribers =<br>            MoreObjects.firstNonNull(subscribers.putIfAbsent(eventType, newSet), newSet);<br>      &#125;<br>    <br>      <span class="hljs-comment">// 把本事件的监听器加入全局缓存，为了防止出现重复注册消息，必须依赖于 Set，这有要求 Subscriber 自己带有相应的 HashCode 行为</span><br>      eventSubscribers.addAll(eventMethodsInListener);<br>    &#125;<br>  &#125;<br>  <br>    <span class="hljs-comment">// 理论上重复调用这个方法应该会触发重复注册</span><br>  <span class="hljs-keyword">private</span> Multimap&lt;Class&lt;?&gt;, Subscriber&gt; findAllSubscribers(Object listener) &#123;<br>    <span class="hljs-comment">// 每一次 find 都使用一个全新的 Map，因为 Subscriber 是全新的</span><br>    Multimap&lt;Class&lt;?&gt;, Subscriber&gt; methodsInListener = HashMultimap.create();<br>    Class&lt;?&gt; clazz = listener.getClass();<br>    <span class="hljs-comment">// 获取全部的 @Subscribe 注解方法</span><br>    <span class="hljs-keyword">for</span> (Method method : getAnnotatedMethods(clazz)) &#123;<br>      Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();<br>      <span class="hljs-comment">// 这个方法必须是首参数作为事件，此处只获取裸类型</span><br>      Class&lt;?&gt; eventType = parameterTypes[<span class="hljs-number">0</span>];<br>      <span class="hljs-comment">// 所以理论上</span><br>      <span class="hljs-comment">// 每个对象-方法生成一个 Subscriber，放在 Map 里，自动得到 Collection</span><br>      methodsInListener.put(eventType, Subscriber.create(bus, listener, method));<br>    &#125;<br>    <span class="hljs-keyword">return</span> methodsInListener;<br>  &#125;<br>  <br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ImmutableList&lt;Method&gt; <span class="hljs-title function_">getAnnotatedMethods</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">return</span> subscriberMethodsCache.getUnchecked(clazz);<br>    &#125; <span class="hljs-keyword">catch</span> (UncheckedExecutionException e) &#123;<br>      throwIfUnchecked(e.getCause());<br>      <span class="hljs-keyword">throw</span> e;<br>    &#125;<br>  &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>
<h6 id="subscriber-订阅者">Subscriber 订阅者</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Subscriber</span> &#123;<br><br>  <span class="hljs-comment">/** Dispatches &#123;<span class="hljs-doctag">@code</span> event&#125; to this subscriber using the proper executor. */</span><br> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispatchEvent</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Object event)</span> &#123;<br>   <span class="hljs-comment">// 这里的 executor 本身可以是一个全同步的执行器</span><br>   executor.execute(<br>       <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>         <span class="hljs-meta">@Override</span><br>         <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>           <span class="hljs-keyword">try</span> &#123;<br>             invokeSubscriberMethod(event);<br>           &#125; <span class="hljs-keyword">catch</span> (InvocationTargetException e) &#123;<br>             bus.handleSubscriberException(e.getCause(), context(event));<br>           &#125;<br>         &#125;<br>       &#125;);<br> &#125;<br><br>   <span class="hljs-comment">// hashCode 由 method 和 target 决定</span><br>  <span class="hljs-meta">@Override</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>   <span class="hljs-comment">// 这里会获取最为原始的，未被复写的 hashCode 的值</span><br>   <span class="hljs-keyword">return</span> (<span class="hljs-number">31</span> + method.hashCode()) * <span class="hljs-number">31</span> + System.identityHashCode(target);<br> &#125;<br><br> <span class="hljs-meta">@Override</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(<span class="hljs-meta">@CheckForNull</span> Object obj)</span> &#123;<br>   <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> Subscriber) &#123;<br>     <span class="hljs-type">Subscriber</span> <span class="hljs-variable">that</span> <span class="hljs-operator">=</span> (Subscriber) obj;<br>     <span class="hljs-comment">// Use == so that different equal instances will still receive events.</span><br>     <span class="hljs-comment">// We only guard against the case that the same object is registered</span><br>     <span class="hljs-comment">// multiple times</span><br>     <span class="hljs-keyword">return</span> target == that.target &amp;&amp; method.equals(that.method);<br>   &#125;<br>   <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br> &#125;<br> <br> <span class="hljs-comment">/**</span><br><span class="hljs-comment">  * Invokes the subscriber method. This method can be overridden to make the invocation</span><br><span class="hljs-comment">  * synchronized.</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-meta">@VisibleForTesting</span><br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invokeSubscriberMethod</span><span class="hljs-params">(Object event)</span> <span class="hljs-keyword">throws</span> InvocationTargetException &#123;<br>   <span class="hljs-keyword">try</span> &#123;<br>     method.invoke(target, checkNotNull(event));<br>   &#125; <span class="hljs-keyword">catch</span> (IllegalArgumentException e) &#123;<br>     <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Method rejected target/argument: &quot;</span> + event, e);<br>   &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>     <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Method became inaccessible: &quot;</span> + event, e);<br>   &#125; <span class="hljs-keyword">catch</span> (InvocationTargetException e) &#123;<br>     <span class="hljs-keyword">if</span> (e.getCause() <span class="hljs-keyword">instanceof</span> Error) &#123;<br>       <span class="hljs-keyword">throw</span> (Error) e.getCause();<br>     &#125;<br>     <span class="hljs-keyword">throw</span> e;<br>   &#125;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="eventbus-事件总线">EventBus 事件总线</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EventBus</span> &#123;<br><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">post</span><span class="hljs-params">(Object event)</span> &#123;<br>    Iterator&lt;Subscriber&gt; eventSubscribers = subscribers.getSubscribers(event);<br>    <span class="hljs-keyword">if</span> (eventSubscribers.hasNext()) &#123;<br>      dispatcher.dispatch(event, eventSubscribers);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!(event <span class="hljs-keyword">instanceof</span> DeadEvent)) &#123;<br>      <span class="hljs-comment">// the event had no subscribers and was not itself a DeadEvent</span><br>      post(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DeadEvent</span>(<span class="hljs-built_in">this</span>, event));<br>    &#125;<br>  &#125;<br>  <br> &#125;<br> <br></code></pre></td></tr></table></figure>
<h6 id="dispatcher-分派器">Dispatcher 分派器</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dispatcher</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispatch</span><span class="hljs-params">(Object event, Iterator&lt;Subscriber&gt; subscribers)</span> &#123;<br>      checkNotNull(event);<br>      checkNotNull(subscribers);<br>      <span class="hljs-comment">// 这是在 threadlocal 里获取了一个 ArrayDeQue，Resizable-array implementation of the &#123;@link Deque&#125; interface</span><br>      Queue&lt;Event&gt; queueForThread = queue.get();<br>      <span class="hljs-comment">// 这一步 offer 总是会成功</span><br>      queueForThread.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Event</span>(event, subscribers));<br>    <br>      <span class="hljs-comment">//  Per-thread dispatch state, used to avoid reentrant event dispatching</span><br>      <span class="hljs-keyword">if</span> (!dispatching.get()) &#123;<br>        dispatching.set(<span class="hljs-literal">true</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>          Event nextEvent;<br>          <span class="hljs-comment">// 在这里是把 queueForThread 排干</span><br>          <span class="hljs-keyword">while</span> ((nextEvent = queueForThread.poll()) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 双重遍历处理 dispatchEvent</span><br>            <span class="hljs-keyword">while</span> (nextEvent.subscribers.hasNext()) &#123;<br>              nextEvent.subscribers.next().dispatchEvent(nextEvent.event);<br>            &#125;<br>          &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>          dispatching.remove();<br>          queue.remove();<br>        &#125;<br>      &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="spring-的事件机制是怎么工作的？">Spring 的事件机制是怎么工作的？</h5>
<h6 id="注册和执行-applicationlistener-的流程">注册和执行 ApplicationListener 的流程</h6>
<p><img src="EventPublish%E4%B8%8Edispatch%E6%B5%81%E7%A8%8B.png" alt="EventPublish与dispatch流程"></p>
<p>但这里面只看到了从 retriever 寻找 supportType 的流程，没有看到前面生成 retriever 内容的过程。</p>
<p>####### 在 refresh 里初始化多播器和监听器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractApplicationContext</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">DefaultResourceLoader</span><br>        <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ConfigurableApplicationContext</span> &#123;<br>        <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">refresh</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException, IllegalStateException &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.startupShutdownMonitor) &#123;<br>            <span class="hljs-type">StartupStep</span> <span class="hljs-variable">contextRefresh</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.applicationStartup.start(<span class="hljs-string">&quot;spring.context.refresh&quot;</span>);<br><br>                <span class="hljs-comment">// 在这里初始化和注册应有的 Multicaster</span><br>                initApplicationEventMulticaster();<br><br>                <span class="hljs-comment">// Initialize other special beans in specific context subclasses.</span><br>                onRefresh();<br><br>                <span class="hljs-comment">// Check for listener beans and register them.</span><br>                registerListeners();<br>    &#125;<br>    <br></code></pre></td></tr></table></figure>
<p>我们可以认为 EventMulticaster 是桥梁，context publich event -&gt; EventMulticaster -&gt; invoke listeners 是一个基本流程。</p>
<p>但中间使用的多播器本身是在一个巨大的类型系统里工作的。</p>
<p>####### initApplicationEventMulticaster</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initApplicationEventMulticaster</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">ConfigurableListableBeanFactory</span> <span class="hljs-variable">beanFactory</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getBeanFactory();<br>    <span class="hljs-comment">// 从bean工厂中找是否有ID为“applicationEventMulticaster”的组件</span><br>    <span class="hljs-keyword">if</span> (beanFactory.containsLocalBean(<span class="hljs-string">&quot;applicationEventMulticaster&quot;</span>)) &#123;<br>        <span class="hljs-comment">// 获取到该组件</span><br>        <span class="hljs-built_in">this</span>.applicationEventMulticaster = (ApplicationEventMulticaster)beanFactory.getBean(<span class="hljs-string">&quot;applicationEventMulticaster&quot;</span>, ApplicationEventMulticaster.class);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.logger.isTraceEnabled()) &#123;<br>            <span class="hljs-built_in">this</span>.logger.trace(<span class="hljs-string">&quot;Using ApplicationEventMulticaster [&quot;</span> + <span class="hljs-built_in">this</span>.applicationEventMulticaster + <span class="hljs-string">&quot;]&quot;</span>);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果没有则自己创建一个简单的ApplicationEventMulticaster</span><br>        <span class="hljs-built_in">this</span>.applicationEventMulticaster = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleApplicationEventMulticaster</span>(beanFactory);<br>        <span class="hljs-comment">// 将创建的注册到容器的单实例bean中</span><br>        beanFactory.registerSingleton(<span class="hljs-string">&quot;applicationEventMulticaster&quot;</span>, <span class="hljs-built_in">this</span>.applicationEventMulticaster);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.logger.isTraceEnabled()) &#123;<br>            <span class="hljs-built_in">this</span>.logger.trace(<span class="hljs-string">&quot;No &#x27;applicationEventMulticaster&#x27; bean, using [&quot;</span> + <span class="hljs-built_in">this</span>.applicationEventMulticaster.getClass().getSimpleName() + <span class="hljs-string">&quot;]&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这类初始化在 Spring 里出现多次，LifeCycleProcessor 和某些 ShutdownHook 一样，本身都可要有一个缺省的实现，和一个可以被注册的实现。</p>
<p>####### 使用两种循环把 ApplicationListener 和 ApplicationEventMulticaster 关联起来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerListeners</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// Register statically specified listeners first.</span><br>    <span class="hljs-comment">// 这部分的监听器是实现类型式的监听器</span><br>    <span class="hljs-keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123;<br>        getApplicationEventMulticaster().addApplicationListener(listener);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 在这里只是得到 ApplicationListener 类型的全部 bean</span><br>    <span class="hljs-comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span><br>    <span class="hljs-comment">// uninitialized to let post-processors apply to them!</span><br>    String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">for</span> (String listenerBeanName : listenerBeanNames) &#123;<br>        <span class="hljs-comment">// 对得到的多播器进行加名操作</span><br>        getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);<br>    &#125;<br><br>    <span class="hljs-comment">// Publish early application events now that we finally have a multicaster...</span><br>    Set&lt;ApplicationEvent&gt; earlyEventsToProcess = <span class="hljs-built_in">this</span>.earlyApplicationEvents;<br>    <span class="hljs-built_in">this</span>.earlyApplicationEvents = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (!CollectionUtils.isEmpty(earlyEventsToProcess)) &#123;<br>        <span class="hljs-keyword">for</span> (ApplicationEvent earlyEvent : earlyEventsToProcess) &#123;<br>            <span class="hljs-comment">// 这个 api 在这里就被第一次调用了</span><br>            getApplicationEventMulticaster().multicastEvent(earlyEvent);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>####### 发布事件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">publishEvent</span><span class="hljs-params">(ApplicationEvent event)</span> &#123;<br>        <span class="hljs-comment">// 本群</span><br>        publishEvent(event, <span class="hljs-literal">null</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">publishEvent</span><span class="hljs-params">(Object event, <span class="hljs-meta">@Nullable</span> ResolvableType eventType)</span> &#123;<br>        Assert.notNull(event, <span class="hljs-string">&quot;Event must not be null&quot;</span>);<br><br>        <span class="hljs-comment">// Decorate event as an ApplicationEvent if necessary</span><br>        ApplicationEvent applicationEvent;<br>        <span class="hljs-keyword">if</span> (event <span class="hljs-keyword">instanceof</span> ApplicationEvent) &#123;<br>            applicationEvent = (ApplicationEvent) event;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            applicationEvent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PayloadApplicationEvent</span>&lt;&gt;(<span class="hljs-built_in">this</span>, event);<br>            <span class="hljs-keyword">if</span> (eventType == <span class="hljs-literal">null</span>) &#123;<br>                eventType = ((PayloadApplicationEvent&lt;?&gt;) applicationEvent).getResolvableType();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// Multicast right now if possible - or lazily once the multicaster is initialized</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.earlyApplicationEvents != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-built_in">this</span>.earlyApplicationEvents.add(applicationEvent);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 在本上下文中通过多播器发布事件，通过单参数 API 进入此处的</span><br>            getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);<br>        &#125;<br>        <br>        <span class="hljs-comment">// 往父类发布事件</span><br>        <span class="hljs-comment">// Publish event via parent context as well...</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.parent != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.parent <span class="hljs-keyword">instanceof</span> AbstractApplicationContext) &#123;<br>                ((AbstractApplicationContext) <span class="hljs-built_in">this</span>.parent).publishEvent(event, eventType);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">this</span>.parent.publishEvent(event);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们也要区分一些事件是否是 earlyApplicationEvents 应该理解的。</p>
<p>####### AbstractApplicationEventMulticaster 事件多播器的基类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 真实的多播器基类，常见的子类为 SimpleApplicationEventMulticaster</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractApplicationEventMulticaster</span><br>        <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationEventMulticaster</span>, BeanClassLoaderAware, BeanFactoryAware &#123;<br>        <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addApplicationListenerBean</span><span class="hljs-params">(String listenerBeanName)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.defaultRetriever) &#123;<br>            <span class="hljs-comment">// 把 beanName 放进 beanName 列表里</span><br>            <span class="hljs-built_in">this</span>.defaultRetriever.applicationListenerBeans.add(listenerBeanName);<br>            <span class="hljs-comment">// 清理 retrieverCache，实际上所有的写操作都可能触发这一个 clear</span><br>            <span class="hljs-built_in">this</span>.retrieverCache.clear();<br>        &#125;<br>    &#125;<br>        <br>    <span class="hljs-comment">// 通过 ResolvableType eventType 取出所有监听 event 的监听器 </span><br>    <span class="hljs-keyword">protected</span> Collection&lt;ApplicationListener&lt;?&gt;&gt; getApplicationListeners(<br>            ApplicationEvent event, ResolvableType eventType) &#123;<br><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">source</span> <span class="hljs-operator">=</span> event.getSource();<br>        Class&lt;?&gt; sourceType = (source != <span class="hljs-literal">null</span> ? source.getClass() : <span class="hljs-literal">null</span>);<br>        <span class="hljs-type">ListenerCacheKey</span> <span class="hljs-variable">cacheKey</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListenerCacheKey</span>(eventType, sourceType);<br><br>        <span class="hljs-comment">// Potential new retriever to populate</span><br>        <span class="hljs-type">CachedListenerRetriever</span> <span class="hljs-variable">newRetriever</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <br>        <span class="hljs-comment">// retrieverCache 在读的时候第一次被使用了</span><br>        <span class="hljs-comment">// Quick check for existing entry on ConcurrentHashMap</span><br>        <span class="hljs-type">CachedListenerRetriever</span> <span class="hljs-variable">existingRetriever</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.retrieverCache.get(cacheKey);<br>        <span class="hljs-keyword">if</span> (existingRetriever == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 校验当前类加载器是否有加载的痕迹，确认能否 cache，但为什么要这么做呢？</span><br>            <span class="hljs-comment">// Caching a new ListenerRetriever if possible</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.beanClassLoader == <span class="hljs-literal">null</span> ||<br>                    (ClassUtils.isCacheSafe(event.getClass(), <span class="hljs-built_in">this</span>.beanClassLoader) &amp;&amp;<br>                            (sourceType == <span class="hljs-literal">null</span> || ClassUtils.isCacheSafe(sourceType, <span class="hljs-built_in">this</span>.beanClassLoader)))) &#123;<br>                newRetriever = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CachedListenerRetriever</span>();<br>                <span class="hljs-comment">// 通过 putIfAbsent 生成一套 CachedListenerRetriever</span><br>                existingRetriever = <span class="hljs-built_in">this</span>.retrieverCache.putIfAbsent(cacheKey, newRetriever);<br>                <span class="hljs-keyword">if</span> (existingRetriever != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">// 如果 existingRetriever 能从缓存里取出来，此处不需要再使用 newRetriever</span><br>                    newRetriever = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// no need to populate it in retrieveApplicationListeners</span><br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (existingRetriever != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 直接通过存量 existingRetriever 获取监听器</span><br>            Collection&lt;ApplicationListener&lt;?&gt;&gt; result = existingRetriever.getApplicationListeners();<br>            <span class="hljs-keyword">if</span> (result != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> result;<br>            &#125;<br>            <span class="hljs-comment">// If result is null, the existing retriever is not fully populated yet by another thread.</span><br>            <span class="hljs-comment">// Proceed like caching wasn&#x27;t possible for this current local attempt.</span><br>        &#125;<br>        <span class="hljs-comment">// 否则走入这个获取监听器的流程</span><br>        <span class="hljs-keyword">return</span> retrieveApplicationListeners(eventType, sourceType, newRetriever);<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> Collection&lt;ApplicationListener&lt;?&gt;&gt; retrieveApplicationListeners(<br>            ResolvableType eventType, <span class="hljs-meta">@Nullable</span> Class&lt;?&gt; sourceType, <span class="hljs-meta">@Nullable</span> CachedListenerRetriever retriever) &#123;<br><br>        List&lt;ApplicationListener&lt;?&gt;&gt; allListeners = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 为 retriever 准备字符串和 BeanName 类型的 Set</span><br>        Set&lt;ApplicationListener&lt;?&gt;&gt; filteredListeners = (retriever != <span class="hljs-literal">null</span> ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;() : <span class="hljs-literal">null</span>);<br>        Set&lt;String&gt; filteredListenerBeans = (retriever != <span class="hljs-literal">null</span> ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;() : <span class="hljs-literal">null</span>);<br><br>        Set&lt;ApplicationListener&lt;?&gt;&gt; listeners;<br>        Set&lt;String&gt; listenerBeans;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.defaultRetriever) &#123;<br>            <span class="hljs-comment">// 把之前注册好的监听器集合数据拷贝到当前的两个局部变量里，注意，这里的监听器是监听全部事件的监听器</span><br>            listeners = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;(<span class="hljs-built_in">this</span>.defaultRetriever.applicationListeners);<br>            listenerBeans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;(<span class="hljs-built_in">this</span>.defaultRetriever.applicationListenerBeans);<br>        &#125;<br><br>        <span class="hljs-comment">// Add programmatically registered listeners, including ones coming</span><br>        <span class="hljs-comment">// from ApplicationListenerDetector (singleton beans and inner beans).</span><br>        <span class="hljs-keyword">for</span> (ApplicationListener&lt;?&gt; listener : listeners) &#123;<br>            <span class="hljs-comment">// 重要：在这里确认 listener 是否支持特定的事件，泛型解析在这一步</span><br>            <span class="hljs-keyword">if</span> (supportsEvent(listener, eventType, sourceType)) &#123;<br>                <span class="hljs-keyword">if</span> (retriever != <span class="hljs-literal">null</span>) &#123;<br>                    filteredListeners.add(listener);<br>                &#125;<br>                allListeners.add(listener);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 一般走完上面的步骤以后，我们自定义的 Listener 就会出现在 filteredListeners 里</span><br><br>        <span class="hljs-comment">// Add listeners by bean name, potentially overlapping with programmatically</span><br>        <span class="hljs-comment">// registered listeners above - but here potentially with additional metadata.</span><br>        <span class="hljs-keyword">if</span> (!listenerBeans.isEmpty()) &#123;<br>            <span class="hljs-type">ConfigurableBeanFactory</span> <span class="hljs-variable">beanFactory</span> <span class="hljs-operator">=</span> getBeanFactory();<br>            <span class="hljs-keyword">for</span> (String listenerBeanName : listenerBeans) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">if</span> (supportsEvent(beanFactory, listenerBeanName, eventType)) &#123;<br>                        ApplicationListener&lt;?&gt; listener =<br>                                beanFactory.getBean(listenerBeanName, ApplicationListener.class);<br>                        <span class="hljs-comment">// 在这里，即使同一个 beanName 通过 supportsEvent 再次被检出，仍然</span><br>                        <span class="hljs-keyword">if</span> (!allListeners.contains(listener) &amp;&amp; supportsEvent(listener, eventType, sourceType)) &#123;<br>                            <span class="hljs-keyword">if</span> (retriever != <span class="hljs-literal">null</span>) &#123;<br>                                <span class="hljs-keyword">if</span> (beanFactory.isSingleton(listenerBeanName)) &#123;<br>                                    filteredListeners.add(listener);<br>                                &#125;<br>                                <span class="hljs-keyword">else</span> &#123;<br>                                    filteredListenerBeans.add(listenerBeanName);<br>                                &#125;<br>                            &#125;<br>                            allListeners.add(listener);<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-comment">// Remove non-matching listeners that originally came from</span><br>                        <span class="hljs-comment">// ApplicationListenerDetector, possibly ruled out by additional</span><br>                        <span class="hljs-comment">// BeanDefinition metadata (e.g. factory method generics) above.</span><br>                        <span class="hljs-type">Object</span> <span class="hljs-variable">listener</span> <span class="hljs-operator">=</span> beanFactory.getSingleton(listenerBeanName);<br>                        <span class="hljs-keyword">if</span> (retriever != <span class="hljs-literal">null</span>) &#123;<br>                            filteredListeners.remove(listener);<br>                        &#125;<br>                        allListeners.remove(listener);<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;<br>                    <span class="hljs-comment">// Singleton listener instance (without backing bean definition) disappeared -</span><br>                    <span class="hljs-comment">// probably in the middle of the destruction phase</span><br>                &#125;<br>            &#125;<br>        &#125;<br><br>        AnnotationAwareOrderComparator.sort(allListeners);<br>        <span class="hljs-keyword">if</span> (retriever != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (filteredListenerBeans.isEmpty()) &#123;<br>                retriever.applicationListeners = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;(allListeners);<br>                retriever.applicationListenerBeans = filteredListenerBeans;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                retriever.applicationListeners = filteredListeners;<br>                retriever.applicationListenerBeans = filteredListenerBeans;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> allListeners;<br>    &#125;<br>    <br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">supportsEvent</span><span class="hljs-params">(</span><br><span class="hljs-params">            ApplicationListener&lt;?&gt; listener, ResolvableType eventType, <span class="hljs-meta">@Nullable</span> Class&lt;?&gt; sourceType)</span> &#123;<br>        <span class="hljs-comment">// 在这一步把原状的 listener 都转成 GenericApplicationListener 相关类型，一般会转成 GenericApplicationListenerAdapter</span><br>        <span class="hljs-type">GenericApplicationListener</span> <span class="hljs-variable">smartListener</span> <span class="hljs-operator">=</span> (listener <span class="hljs-keyword">instanceof</span> GenericApplicationListener ?<br>                (GenericApplicationListener) listener : <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericApplicationListenerAdapter</span>(listener));<br>        <span class="hljs-keyword">return</span> (smartListener.supportsEventType(eventType) &amp;&amp; smartListener.supportsSourceType(sourceType)); <span class="hljs-comment">// 对 smartListener 而言，supportsSourceType 默认返回 true</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">supportsEventType</span><span class="hljs-params">(ResolvableType eventType)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.delegate <span class="hljs-keyword">instanceof</span> GenericApplicationListener) &#123;<br>            <span class="hljs-keyword">return</span> ((GenericApplicationListener) <span class="hljs-built_in">this</span>.delegate).supportsEventType(eventType);<br>        &#125;<br>        <span class="hljs-comment">// SmartApplicationListener 本身带有一个 supportsEventType 接口，可以和 class 类型的参数进行匹配，它本身还支持 order，也就是支持排序</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.delegate <span class="hljs-keyword">instanceof</span> SmartApplicationListener) &#123;<br>            Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ApplicationEvent</span>&gt; eventClass = (Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ApplicationEvent</span>&gt;) eventType.resolve();<br>            <span class="hljs-keyword">return</span> (eventClass != <span class="hljs-literal">null</span> &amp;&amp; ((SmartApplicationListener) <span class="hljs-built_in">this</span>.delegate).supportsEventType(eventClass));<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 通常 supportsEvent 会走到这里，如果一个 listener 的 declaredEventType isAssignableFrom 和目标的 eventType 一致，这个 listener 就脱颖而出</span><br>            <span class="hljs-keyword">return</span> (<span class="hljs-built_in">this</span>.declaredEventType == <span class="hljs-literal">null</span> || <span class="hljs-built_in">this</span>.declaredEventType.isAssignableFrom(eventType));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个类型大量使用 ResolvableType 来把 ApplicationEvent&lt;?&gt; 里的类型实参取出来，进行解析。</p>
<p>####### SimpleApplicationEventMulticaster 事件多播器的基本实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleApplicationEventMulticaster</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractApplicationEventMulticaster</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">multicastEvent</span><span class="hljs-params">(<span class="hljs-keyword">final</span> ApplicationEvent event, <span class="hljs-meta">@Nullable</span> ResolvableType eventType)</span> &#123;<br>        <span class="hljs-type">ResolvableType</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> (eventType != <span class="hljs-literal">null</span> ? eventType : resolveDefaultEventType(event)); <span class="hljs-comment">// 注意看，通过原生的 event 找到一个类型主要看这里</span><br>        <span class="hljs-comment">// 对 Spring 来讲 ResolvableType 就是一个含有多个成员的数据结构，此时它还是只有 ApplicationEvent 的实际 Class 作为成员而已 </span><br>        <span class="hljs-type">Executor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> getTaskExecutor(); <span class="hljs-comment">// 同步调用这里取不到执行器</span><br>        <span class="hljs-keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) <span class="hljs-comment">// 这个 getListener 的操作就是把带有泛型的 listener 取出来的流程，非常重要</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (executor != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 如果配置了线程池，则异步调用</span><br>                executor.execute(() -&gt; invokeListener(listener, event));<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                invokeListener(listener, event);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 对于每一个找到的 listener，直接调用</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invokeListener</span><span class="hljs-params">(ApplicationListener&lt;?&gt; listener, ApplicationEvent event)</span> &#123;<br>        <span class="hljs-type">ErrorHandler</span> <span class="hljs-variable">errorHandler</span> <span class="hljs-operator">=</span> getErrorHandler();<br>        <span class="hljs-keyword">if</span> (errorHandler != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                doInvokeListener(listener, event);<br>            &#125;<br>            <span class="hljs-keyword">catch</span> (Throwable err) &#123;<br>                errorHandler.handleError(err);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            doInvokeListener(listener, event);<br>        &#125;<br>    &#125;<br>    <br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doInvokeListener</span><span class="hljs-params">(ApplicationListener listener, ApplicationEvent event)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            listener.onApplicationEvent(event);<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (ClassCastException ex) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> ex.getMessage();<br>            <span class="hljs-keyword">if</span> (msg == <span class="hljs-literal">null</span> || matchesClassCastMessage(msg, event.getClass()) ||<br>                    (event <span class="hljs-keyword">instanceof</span> PayloadApplicationEvent &amp;&amp;<br>                            matchesClassCastMessage(msg, ((PayloadApplicationEvent) event).getPayload().getClass()))) &#123;<br>                <span class="hljs-comment">// Possibly a lambda-defined listener which we could not resolve the generic event type for</span><br>                <span class="hljs-comment">// -&gt; let&#x27;s suppress the exception.</span><br>                <span class="hljs-type">Log</span> <span class="hljs-variable">loggerToUse</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lazyLogger;<br>                <span class="hljs-keyword">if</span> (loggerToUse == <span class="hljs-literal">null</span>) &#123;<br>                    loggerToUse = LogFactory.getLog(getClass());<br>                    <span class="hljs-built_in">this</span>.lazyLogger = loggerToUse;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (loggerToUse.isTraceEnabled()) &#123;<br>                    loggerToUse.trace(<span class="hljs-string">&quot;Non-matching event type for listener: &quot;</span> + listener, ex);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">throw</span> ex;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>####### DefaultListenerRetriever</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Helper class that encapsulates a general set of target listeners.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultListenerRetriever</span> &#123;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Set&lt;ApplicationListener&lt;?&gt;&gt; applicationListeners = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Set&lt;String&gt; applicationListenerBeans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">public</span> Collection&lt;ApplicationListener&lt;?&gt;&gt; getApplicationListeners() &#123;<br>            List&lt;ApplicationListener&lt;?&gt;&gt; allListeners = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(<br>                    <span class="hljs-built_in">this</span>.applicationListeners.size() + <span class="hljs-built_in">this</span>.applicationListenerBeans.size());<br>            allListeners.addAll(<span class="hljs-built_in">this</span>.applicationListeners);<br>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.applicationListenerBeans.isEmpty()) &#123;<br>                <span class="hljs-type">BeanFactory</span> <span class="hljs-variable">beanFactory</span> <span class="hljs-operator">=</span> getBeanFactory();<br>                <span class="hljs-keyword">for</span> (String listenerBeanName : <span class="hljs-built_in">this</span>.applicationListenerBeans) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        ApplicationListener&lt;?&gt; listener =<br>                                beanFactory.getBean(listenerBeanName, ApplicationListener.class);<br>                        <span class="hljs-keyword">if</span> (!allListeners.contains(listener)) &#123;<br>                            allListeners.add(listener);<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;<br>                        <span class="hljs-comment">// Singleton listener instance (without backing bean definition) disappeared -</span><br>                        <span class="hljs-comment">// probably in the middle of the destruction phase</span><br>                    &#125;<br>                &#125;<br>            &#125;<br>            AnnotationAwareOrderComparator.sort(allListeners);<br>            <span class="hljs-keyword">return</span> allListeners;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个类把基于类型的监听器和基于名称的监听器做了一个合并，提供一个合并获取方法。</p>
<p>####### GenericApplicationListenerAdapter</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericApplicationListenerAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">GenericApplicationListener</span> &#123;<br>    <br>    <span class="hljs-comment">// 这个类的构造器就做好了类型解析</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">GenericApplicationListenerAdapter</span><span class="hljs-params">(ApplicationListener&lt;?&gt; delegate)</span> &#123;<br>        Assert.notNull(delegate, <span class="hljs-string">&quot;Delegate listener must not be null&quot;</span>);<br>        <span class="hljs-comment">// 在这里做了一个强转，因为编译器存在，所以我们可以保证这个 casting 是不会错的，这里做了一个奇怪的协变。其实这个协变是应该会出错的，但不知道为什么这里会允许这样做</span><br>        <span class="hljs-built_in">this</span>.delegate = (ApplicationListener&lt;ApplicationEvent&gt;) delegate;<br>        <span class="hljs-built_in">this</span>.declaredEventType = resolveDeclaredEventType(<span class="hljs-built_in">this</span>.delegate);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Nullable</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ResolvableType <span class="hljs-title function_">resolveDeclaredEventType</span><span class="hljs-params">(ApplicationListener&lt;ApplicationEvent&gt; listener)</span> &#123;<br>        <span class="hljs-comment">// 在这里，每个 listener 的 class 会置换出一个 declaredEventType，就是它泛型声明里的那个</span><br>        <span class="hljs-type">ResolvableType</span> <span class="hljs-variable">declaredEventType</span> <span class="hljs-operator">=</span> resolveDeclaredEventType(listener.getClass());<br>        <br>        <span class="hljs-comment">// 确认这个参数类型是否能够直接映射为 ApplicationEvent（为了兼容 Object 场景）。在实验中我们会观察到一个奇怪的情况，ApplicationEnvironmentPreparedEvent extends SpringApplicationEvent extends ApplicationEvent，但 ApplicationEnvironmentPreparedEvent 的解析类型 isAssignableFrom ApplicationEvent.class 却返回 false。这个 isAssignableFrom 会返回 true是这种情况，父类.isAssignableFrom(子类)</span><br>        <span class="hljs-keyword">if</span> (declaredEventType == <span class="hljs-literal">null</span> || declaredEventType.isAssignableFrom(ApplicationEvent.class)) &#123;<br>        <br>            <span class="hljs-comment">// 在这里要处理一下，看看</span><br>            Class&lt;?&gt; targetClass = AopUtils.getTargetClass(listener);<br>            <span class="hljs-keyword">if</span> (targetClass != listener.getClass()) &#123;<br>                declaredEventType = resolveDeclaredEventType(targetClass);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> declaredEventType;<br>    &#125;<br>    <br>    <span class="hljs-keyword">static</span> ResolvableType <span class="hljs-title function_">resolveDeclaredEventType</span><span class="hljs-params">(Class&lt;?&gt; listenerType)</span> &#123;<br>            <span class="hljs-comment">// 如果能够从 cache 里取出数据 ResolvableType 出来，则使用取出来的数据</span><br>        <span class="hljs-type">ResolvableType</span> <span class="hljs-variable">eventType</span> <span class="hljs-operator">=</span> eventTypeCache.get(listenerType);<br>        <span class="hljs-keyword">if</span> (eventType == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 否则</span><br>            <span class="hljs-comment">// 第一步，初始化一个基本的 ResolvableType</span><br>            <span class="hljs-comment">// 第二步，比较 ApplicationListener 与它的子类（也就是 ResolvableType 包装的类型）</span><br>            <span class="hljs-comment">// 第三部，等 as 成功以后，调用 generic，得到泛型的 ResolvableType。理论上任何的类型通过这三行就可以得到它被包装过的 genericType</span><br>            eventType = ResolvableType.forClass(listenerType).as(ApplicationListener.class).getGeneric();<br>            <span class="hljs-comment">// eventType 解析成功则放入缓存中，这里我们已经知道一个 listener 监听的是什么类型的事件了</span><br>            eventTypeCache.put(listenerType, eventType);<br>        &#125;<br>        <span class="hljs-keyword">return</span> (eventType != ResolvableType.NONE ? eventType : <span class="hljs-literal">null</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>提供对任意类型的事件监听器的类型解析能力。</p>
<p>####### ResolvableType</p>
<p>可解析的类型包装器类型，有点类似 Jackson 的 TypeReference，但实际上又不是：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 这个类型本质上就是 Type 类型的容器，很多 actualTypeArguments 不能表现为简单的 class，而必须表现为 Type</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResolvableType</span> <span class="hljs-title">implements</span> <span class="hljs-title">Serializable</span> &#123;<br>    <br>    <span class="hljs-comment">// 这个方法就是在超类型和接口里面寻找可以转型的 ResolvableType 的机会，转型出一个类型然后往上走</span><br>    <span class="hljs-keyword">public</span> ResolvableType <span class="hljs-keyword">as</span>(Class&lt;?&gt; type) &#123;<br>        <span class="hljs-comment">// 如果转型不出来（也就是搜索走到了尽头），则在这里返回给递归一个 NONE</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == NONE) &#123;<br>            <span class="hljs-keyword">return</span> NONE;<br>        &#125;<br>        <span class="hljs-comment">// 这一步的 resolved 一开始都是被包装的原生 Class，注意，是不带泛型的</span><br>        Class&lt;?&gt; resolved = resolve();<br>        <br>        <span class="hljs-comment">// 如果比较类型和解析类型一样，在这里就可以直接返回了</span><br>        <span class="hljs-keyword">if</span> (resolved == <span class="hljs-literal">null</span> || resolved == type) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br>        <span class="hljs-comment">// 这里返回的都是 ResolvableType 包装的接口，这些接口的 generics 变量里有实际的泛型类型</span><br>        <span class="hljs-keyword">for</span> (ResolvableType interfaceType : getInterfaces()) &#123;<br>            ResolvableType interfaceAsType = interfaceType.<span class="hljs-keyword">as</span>(type);<br>            <span class="hljs-keyword">if</span> (interfaceAsType != NONE) &#123;<br>                <span class="hljs-keyword">return</span> interfaceAsType;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> getSuperType().<span class="hljs-keyword">as</span>(type);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> ResolvableType[] getInterfaces() &#123;<br>        Class&lt;?&gt; resolved = resolve();<br>        <span class="hljs-keyword">if</span> (resolved == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> EMPTY_TYPES_ARRAY;<br>        &#125;<br>        <span class="hljs-comment">// 本类型的 interfaces 如果已经解析过了，此处则不为空，这里的 ResolvableType 是带有泛型类型的！</span><br>        ResolvableType[] interfaces = <span class="hljs-keyword">this</span>.interfaces;<br>        <span class="hljs-keyword">if</span> (interfaces == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 否则，使用 Java 原生的 Type 类型的 getGenericInterfaces 方法生成若干个 ResolvableType</span><br>            Type[] genericIfcs = resolved.getGenericInterfaces();<br>            interfaces = new ResolvableType[genericIfcs.length];<br>            <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; genericIfcs.length; i++) &#123;<br>                interfaces[i] = forType(genericIfcs[i], <span class="hljs-keyword">this</span>);<br>            &#125;<br>            <span class="hljs-keyword">this</span>.interfaces = interfaces;<br>        &#125;<br>        <span class="hljs-keyword">return</span> interfaces;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 这个方法可以获取任意一个泛型参数</span><br>    <span class="hljs-keyword">public</span> ResolvableType getGeneric(<span class="hljs-meta">@Nullable</span> int... indexes) &#123;<br>        ResolvableType[] generics = getGenerics();<br>        <span class="hljs-keyword">if</span> (indexes == <span class="hljs-literal">null</span> || indexes.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> (generics.length == <span class="hljs-number">0</span> ? NONE : generics[<span class="hljs-number">0</span>]);<br>        &#125;<br>        ResolvableType generic = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">for</span> (int index : indexes) &#123;<br>            generics = generic.getGenerics();<br>            <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= generics.length) &#123;<br>                <span class="hljs-keyword">return</span> NONE;<br>            &#125;<br>            generic = generics[index];<br>        &#125;<br>        <span class="hljs-keyword">return</span> generic;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> ResolvableType[] getGenerics() &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == NONE) &#123;<br>            <span class="hljs-keyword">return</span> EMPTY_TYPES_ARRAY;<br>        &#125;<br>        ResolvableType[] generics = <span class="hljs-keyword">this</span>.generics;<br>        <span class="hljs-keyword">if</span> (generics == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.type instanceof Class) &#123;<br>                Type[] typeParams = ((Class&lt;?&gt;) <span class="hljs-keyword">this</span>.type).getTypeParameters();<br>                generics = new ResolvableType[typeParams.length];<br>                <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; generics.length; i++) &#123;<br>                    generics[i] = ResolvableType.forType(typeParams[i], <span class="hljs-keyword">this</span>);<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 在这里可以解析 generics</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.type instanceof ParameterizedType) &#123;<br>                Type[] actualTypeArguments = ((ParameterizedType) <span class="hljs-keyword">this</span>.type).getActualTypeArguments();<br>                generics = new ResolvableType[actualTypeArguments.length];<br>                <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; actualTypeArguments.length; i++) &#123;<br>                    generics[i] = forType(actualTypeArguments[i], <span class="hljs-keyword">this</span>.variableResolver);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                generics = resolveType().getGenerics();<br>            &#125;<br>            <span class="hljs-keyword">this</span>.generics = generics;<br>        &#125;<br>        <span class="hljs-keyword">return</span> generics;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="eventlistener-注解驱动的事件注册流程">EventListener 注解驱动的事件注册流程</h6>
<p>####### @EventListener</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @author Stephane Nicoll</span><br><span class="hljs-comment"> * @author Sam Brannen</span><br><span class="hljs-comment"> * @since 4.2</span><br><span class="hljs-comment"> * @see EventListenerMethodProcessor</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Target(&#123;ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EventListener &#123;<br><br>    <span class="hljs-meta">@AliasFor(&quot;classes&quot;)</span><br>    Class&lt;?&gt;[] value() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>    <span class="hljs-meta">@AliasFor(&quot;value&quot;)</span><br>    Class&lt;?&gt;[] classes() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>    String <span class="hljs-title function_">condition</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们一般用 classes 来指定事件类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-comment">// 当容器中发布事件后，该方法会触发</span><br>    <span class="hljs-meta">@EventListener(classes = &#123;ApplicationEvent.class&#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listener1</span><span class="hljs-params">(ApplicationEvent event)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;监听到的事件1：&quot;</span> + event);<br>    &#125;<br>    <span class="hljs-meta">@EventListener(classes = &#123;ApplicationEvent.class&#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listener2</span><span class="hljs-params">(ApplicationEvent event)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;监听到的事件2：&quot;</span> + event);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1>DDD Sample 的分层</h1>
<pre><code class="hljs mermaid">%% ------------- 1. C4 Context / Container 层级 -------------
graph TD
    subgraph ddd-sample
        subgraph Presentation
            WEB[&quot;Cargo Booking Web\n(REST &amp; HTML)&quot;]
        end
        
        subgraph Application
            APP[&quot;Booking Service\n(@Application Service)&quot;]
        end
        
        subgraph Domain
            subgraph Aggregate
                CARGO[&quot;Cargo (AggregateRoot)&quot;]
                ITINERARY[&quot;Itinerary (Entity)&quot;]
                LEG[&quot;Leg (ValueObject)&quot;]
            end
            subgraph Repository
                CR[&quot;CargoRepository\n(interface)&quot;]
            end
            subgraph DomainService
                DS[&quot;RoutingService&quot;]
            end
        end
        
        subgraph Infrastructure
            JPA[&quot;CargoRepositoryJpa\n(impl)&quot;]
            WS[&quot;External Routing WS\n(graphhopper)&quot;]
            DB[(H2 / Postgres)]
        end
    end
    
    WEB --&gt;|HTTP/JSON| APP
    APP --&gt;|call| CARGO
    APP --&gt;|use| DS
    CARGO --&gt;|hold| ITINERARY
    ITINERARY --&gt;|contains| LEG
    CARGO -.-&gt;|persist| CR
    CR -.-&gt;|implemented by| JPA
    JPA --&gt;|JPA/Hibernate| DB
    DS --&gt;|HTTP| WS
    
    style CARGO fill:#f9f,stroke:#333
    style ITINERARY fill:#ffe,stroke:#333
    style LEG fill:#efe,stroke:#333</code></pre>
<p><a target="_blank" rel="noopener" href="https://github.com/citerus/dddsample-core">codebase</a></p>
<p>主轴线是先分层，非领域层根据用例/工具类型划分，领域层根据领域/聚合做垂直切分（而不是按照 class 类型垂直切分）。工具类、公共类就近在轴线附近部署，如有必要放在 common 包、common 模块中。</p>
<p>在调用顺序上，保持一种 interface -&gt; application，infrastructure -&gt; application，application -&gt; domain，但 application 和 domain 的service 如果涉及到外部介质，又由 infrastructure 实现（所以 application -&gt; infrasctructure 是实际存在的）的趋势。或者这样说：</p>
<p><img src="ddd-sample-breakdown.drawio.png" alt="ddd-sample-breakdown.drawio"><br>
<a href="ddd-sample-breakdown.drawio">ddd-sample-breakdown</a></p>
<blockquote>
<p>infra -&gt; application<br>
-&gt; interface 虽然它有 web controller<br>
-&gt; domain 在查询场景下</p>
<p>interface -&gt; domain 抽象引用<br>
-&gt; application 抽象引用<br>
application -&gt; interface抽象引用 理论上应用层应该仅依赖于领域层，这里有一个例外<br>
-&gt; domain</p>
<p>domain 完全独立</p>
</blockquote>
<p>因为这样的分层，所以：</p>
<ol>
<li>可以被设计为最外围的 module 的是 infra。</li>
<li>interface 和 application 是同层的。</li>
<li>domain 一定是最底层的。</li>
<li>真正让应用程序跑起来一定有一个 main 组件，让组件能够实现依赖反转：<strong>源代码（继承关系）级的依赖和控制流的依赖反过来</strong>。</li>
</ol>
<ul>
<li>interfaces 层：定义用例动词的接口，包括 facade 定义、web 接口定义、webservice 定义、facade 实现。<strong>controller 和 facade 定义和实现都在同层</strong>。</li>
<li>dto 在这一层定义，dto 是贫血对象，在语义上是 a particular section of the domain model，而且 immutable（这一步时常为我们所忽略，因为它只是一个数据信封/容器），主要目的是为了 loosen the coupling of the application and the user interface。dto 有自己的生命周期，而实际上 domain entity 的生命周期是和 database access window (the Hibernate session in this case)绑定的。dto 的存在可以跨前端 io 设备： Using DTOs also makes the service layer reusable across different kinds of frontends: web, rich clients, other backend systems etc。</li>
<li>Conroller 调用 facade。dto 在 facade 层生成。</li>
<li>Assembler 的实现在 facade 层附近声明，实现 Enity -&gt; Dto 的转换。</li>
<li>application 层：定义业务用例和<strong>事务边界</strong>（<code>@Transactional</code>在这层被定义），动作的延伸，引用领域能力和 repo。它可以引用同层的 service（application 有自己的 service，这类service 如果有外部实现，主要是消息机制，可以被 interface 和 infra 引用），但同层 service 如果是介质的实现（如消息，在本事例中，领域事件是由 application 层发出的）的实现，需要放在 infrastructure 层实现（infracstructure 也有自己的 service）。</li>
<li>domain：定义基础的领域模型子类型：Entity、Event、ValueObject。所有对象按照聚合边界划分和组织。service 是跨 aggregate 边界的（domain 有自己的 service）。</li>
<li>infrastructure：这一层的目的是：<strong>外部介质（io 设备）和某类 service 的实现，换言之，这一层是不会声明接口的</strong>，所有的接口的语义可以留在各层，但实现统一收拢到 infrastructure 层。实现domain 层的 repo、domain/application（以 events 为名目的应用层服务）层的 service。所以 application 调用 domain，domain 在需要与外界交互（存储层、external 的限界上下文）的时候，定义一个 interface，然后交给 infrastructure 实现。<strong>这样的实现依赖要求模块之间是平层的关系</strong>，不要产生源代码级别的错误依赖，而且通过 ioc 来实现 dip，这又要求有个容器工厂。这种架构实际上是 flexible layered architecture，而不是 strict layered architecture。这种设计和 sofa 的把“外部接口的声明统一在一起”的设计思路，正好反过来。
<ul>
<li>一般消息消费者在这层实现</li>
</ul>
</li>
<li>config：bean 工厂。</li>
</ul>
<p><img src="dddsample-core.png" alt="dddsample-core"><br>
<a href="dddsample-core.xmind">dddsample-core.xmind</a><br>
<img src="%E4%B8%A4%E7%A7%8D%E7%BB%84%E7%BB%87%E5%88%86%E5%B1%82%E7%9A%84%E6%96%B9%E5%BC%8F.png" alt="两种组织分层的方式"></p>
<h1>领域驱动设计峰会</h1>
<h2 id="领域驱动设计揭秘">领域驱动设计揭秘</h2>
<h3 id="两个-ddd">两个 DDD</h3>
<h4 id="data-driven-design-vs-domain-driven-design">Data Driven Design Vs Domain Driven Design</h4>
<p>Data Driven Design 在设计时直接产出表，需要得到 ER diagram；而 Domain Driven Design 产出的首先是分析模型，主要看重概念，而不是类有哪些属性。</p>
<p>当我们直接进入表的时候，我们就要用数据库范式来思考了。</p>
<p>数据驱动设计，让我们先产生数据结构，然后产生没有任何领域行为的贫血模型 + 事务脚本 + persistence object 模式，这适用于简单的业务。这是过程式的编程，降低可重用性，可维护性差。我们设计模块的时候，也会采用分而治之的思想，以提高模型的内聚和重用。但因为没有明确的边界，模型的扭结联系很容易产生大泥球应用-一个需求的变化可能要调整多个类和模块。这是架构设计的不足之处。</p>
<p>但领域驱动设计引入限界上下文，让我们在知识语境之下封装了不同的领域知识。有了限界上下文，可以<strong>支持业务能力的纵向划分</strong>。BC 之间的能力重用是能力级，而不是模块/模型级。</p>
<p><img src="%E9%99%90%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E9%80%9A%E8%BF%87%E5%A4%8D%E7%94%A8%E8%83%BD%E5%8A%9B%E6%9D%A5%E8%B7%A8%E7%9F%A5%E8%AF%86%E8%AF%AD%E5%A2%83%E5%AE%8C%E6%88%90%E9%87%8D%E7%94%A81.png" alt="限界上下文通过复用能力来跨知识语境完成重用1"><br>
<img src="%E9%99%90%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E9%80%9A%E8%BF%87%E5%A4%8D%E7%94%A8%E8%83%BD%E5%8A%9B%E6%9D%A5%E8%B7%A8%E7%9F%A5%E8%AF%86%E8%AF%AD%E5%A2%83%E5%AE%8C%E6%88%90%E9%87%8D%E7%94%A82.png" alt="限界上下文通过复用能力来跨知识语境完成重用2"></p>
<p>BC 通过求助别的知识，获取自己不具备的领域知识，本地的领域知识只能算一个stub，远端的领域知识则是它的 skeleton。这样的话，重用总是需要引入 context map，这样可以避免对模型模型进行耦合，不同的模型之间通过外观进行耦合。</p>
<p>我们最好从业务的纬度（领域的维度）来切分我们的组件，而不是技术的维度来切分对我们的组件，这样我们得到的内聚组件变更就不会混乱，演变成大泥球：</p>
<p><img src="%E6%8A%80%E6%9C%AF%E7%BB%B4%E5%BA%A6%E4%B8%8E%E9%A2%86%E5%9F%9F%E7%BB%B4%E5%BA%A6%E7%9A%84%E5%8F%98%E5%8C%96%E6%96%B9%E5%90%91%E4%B8%8D%E4%B8%80%E8%87%B4.jpg" alt="技术维度与领域维度的变化方向不一致"></p>
<p>这种情况在多种 service 的场景下特别容易出现。</p>
<p><img src="%E9%A1%BA%E5%BA%94%E4%B8%9A%E5%8A%A1%E7%9A%84%E5%8F%98%E5%8C%96%E6%96%B9%E5%90%91%E7%9A%84%E5%88%87%E5%88%86%E6%96%B9%E6%B3%95.jpg" alt="顺应业务的变化方向的切分方法"></p>
<p>如果只允许聚合根之间允许有依赖关系，则对象图存在有高层的简化版本，减少了类和类之间的依赖关系，把聚合根当做聚合的代言人。所谓的意大利面条就是交织在一起的代码，聚合的存在让我们的对象模型分成了边界内的关联和边界外的关联。</p>
<p><img src="%E8%81%9A%E5%90%88%E7%9A%84%E8%BE%B9%E7%95%8C%E7%AE%80%E5%8C%96%E4%BA%86%E5%AF%B9%E8%B1%A1%E5%9B%BE.png" alt="聚合的边界简化了对象图"></p>
<h3 id="黑铁时代与黄金时代">黑铁时代与黄金时代</h3>
<p>最近5年是 DDD 的黄金时代。</p>
<p>大部分的开发者是没有听过这些全部模式的：</p>
<p><img src="%E9%99%90%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E%E8%81%9A%E5%90%88%E6%98%AFDDD%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%BC%8F.png" alt="限界上下文与聚合是DDD的核心模式"></p>
<p>但大部分的开发者都或多或少地见过一些基础的组件 REPO/Factory/Entity/VO，很少有人见过</p>
<p>对外暴露的是一种能力，对内调用的也是一种领域。这产生了一种菱形对称架构：</p>
<p><img src="%E9%99%90%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%98%AF%E6%9E%B6%E6%9E%84%E5%B1%82%E6%AC%A1%E7%9A%84%E8%87%AA%E6%B2%BB%E5%8D%95%E5%85%83.png" alt="限界上下文是架构层次的自治单元"></p>
<p>BC 要通过外观相互调用。</p>
<p>在微服务出来以前，大家都不认可对称菱形架构之间的相互调用，因为抽象层次太多，BC 之间通信太复杂：</p>
<p><img src="%E9%99%90%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B9%8B%E9%97%B4%E6%98%AF%E4%B8%9A%E5%8A%A1%E8%83%BD%E5%8A%9B%E7%9A%84%E9%87%8D%E7%94%A8%E8%80%8C%E9%9D%9E%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%87%8D%E7%94%A8.png" alt="限界上下文之间是业务能力的重用而非模型的重用"></p>
<p>有了微服务以后，BC 之间最好使用 RESTful、消息队列（或者更进一步，事件驱动）、内部的 RPC 之间进行通信。物理限界上下文的边界要小于等于微服务的架构边界。</p>
<p>我们一直都没有很好地看到 BC 的价值。</p>
<h3 id="单体架构是邪恶的吗">单体架构是邪恶的吗</h3>
<p>单体比较差的一点是容易演化成大泥球-如果其实它可以被拆分成多个 BC 而我们没有这么做的话。如果单体本身能够守好自己的内部逻辑边界，变更不纠缠多种职责，则单体架构也可以接受。</p>
<p>菱形对称架构还存在若干种带有消息契约的分层架构风格：</p>
<p><img src="%E8%8F%B1%E5%BD%A2%E5%AF%B9%E7%A7%B0%E6%9E%B6%E6%9E%84%E5%9C%A8%E5%8D%95%E4%BD%93%E4%B8%AD%E7%9A%84%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84.jpg" alt="菱形对称架构在单体中的分层架构"></p>
<p>这种风格应该可以被应用在单体、微服务、事件驱动架构中：</p>
<p><img src="%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E7%9A%84%E5%8D%97%E5%8C%97%E5%90%91%E8%B0%83%E7%94%A8.jpg" alt="单体架构的南北向调用"></p>
<p>这里的南北和六边形架构里的 driving adapter、driven adapter 非常相似。</p>
<p><img src="%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E5%8D%97%E5%8C%97%E7%9B%B8%E4%BA%92%E8%B0%83%E7%94%A8.jpg" alt="微服务场景下的南北相互调用"><br>
<img src="%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E4%B8%8B%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.jpg" alt="事件驱动下的微服务架构"><br>
<img src="BC%E6%9C%AC%E8%B4%A8%E4%B8%8A%E5%8F%AA%E6%98%AF%E9%80%BB%E8%BE%91%E8%BE%B9%E7%95%8C%EF%BC%8C%E9%99%A4%E9%9D%9E%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6%E5%8F%98%E5%8C%96%EF%BC%8C%E4%BA%A7%E7%94%9F%E4%BA%86%E7%89%A9%E7%90%86%E8%BE%B9%E7%95%8C.jpg" alt="BC本质上只是逻辑边界，除非通信机制变化，产生了物理边界"></p>
<p>单体架构优先。</p>
<p><img src="martinfowler%E8%AF%B4%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E4%BC%98%E5%85%88.png" alt="martinfowler说单体架构优先"></p>
<h3 id="ddd-不足与-ddd-up">DDD 不足与 DDD-UP</h3>
<p><img src="%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%8D%E8%B6%B3.png" alt="领域驱动设计的不足"></p>
<p>需求管理和工作流不足是现实中 DDD 闭门造车的根本原因。</p>
<p>UP 是 RUP 的统一过程。</p>
<p><img src="DDD-UP1.jpg" alt="DDD-UP1"></p>
<p>要做好多层的映射，这在现实中的组织似乎做不到。</p>
<p><img src="%E9%A2%86%E5%9F%9F%E8%AE%BE%E8%AE%A1%E7%BB%9F%E4%B8%80%E8%BF%87%E7%A8%8B%E7%9A%84%E6%89%A7%E8%A1%8C.png" alt="领域设计统一过程的执行"></p>
<h2 id="当中台遇上-ddd-如何设计微服务">当中台遇上 DDD，如何设计微服务</h2>
<h3 id="建立中台与-ddd-的统一语言">建立中台与 DDD 的统一语言</h3>
<p>中台一开始的流行只是理论的流行，不是案例的流行。</p>
<p><img src="%E4%BB%8E%E4%B8%9A%E5%8A%A1%E8%A7%86%E8%A7%92%E7%9C%8B%E4%B8%AD%E5%8F%B0.png" alt="从业务视角看中台"><br>
<img src="divide-and-conquer.jpeg" alt="divide-and-conquer"><br>
<img src="%E5%88%86%E8%A7%A3%E5%AD%90%E5%9F%9F%E8%A6%81%E4%BB%8E%E9%97%AE%E9%A2%98%E7%A9%BA%E9%97%B4%E5%BC%80%E5%A7%8B.png" alt="分解子域要从问题空间开始"><br>
<img src="%E4%BF%9D%E9%99%A9%E7%9A%84%E5%AD%90%E5%9F%9F%E5%88%92%E5%88%86.png" alt="保险的子域划分"></p>
<p>通用子域是会被很多企业软件复用，支撑子域不会。所以客户是通用子域而产品是支撑子域。</p>
<p>划分完子域后，在子域内采用事件风暴进行分析建模，首先找出限界上下文，然后根据 BC 构建微服务，在微服务内构建 aggregate。</p>
<p><img src="%E4%BB%8E%E4%B8%9A%E5%8A%A1%E8%A7%86%E8%A7%92%E5%BB%BA%E7%AB%8BDDD%E4%B8%8E%E4%B8%AD%E5%8F%B0%E7%9A%84%E7%BB%9F%E4%B8%80%E8%AF%AD%E8%A8%80.jpg" alt="从业务视角建立DDD与中台的统一语言"><br>
<img src="DDD%E4%B8%8E%E4%B8%AD%E5%8F%B0%E5%92%8C%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="DDD与中台和微服务的关系"></p>
<h3 id="如何使用-ddd-完成中台和微服务设计">如何使用 DDD 完成中台和微服务设计</h3>
<p><img src="DDD%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB.png" alt="DDD核心知识体系"><br>
<img src="DDD%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B.jpg" alt="DDD的基本设计过程"><br>
<img src="DDD%E9%A2%86%E5%9F%9F%E5%BB%BA%E6%A8%A1%E8%BF%87%E7%A8%8B.png" alt="DDD领域建模过程"></p>
<p>领域模型的质量会决定微服务的质量。</p>
<p><img src="%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84%E5%8F%8A%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%BB%B7%E5%80%BC.png" alt="分层架构及领域模型的价值"></p>
<p>infrastructure 和其他层之间的依赖关系一定要妥善使用依赖倒置原则。<br>
核心层的代码应该由最资深的开发者维护。</p>
<p><img src="%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B1.jpg" alt="微服务的设计过程1"><br>
<img src="%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B2.jpg" alt="微服务的设计过程2"></p>
<h3 id="领域模型与微服务的架构演进">领域模型与微服务的架构演进</h3>
<p><img src="%E5%9F%BA%E4%BA%8E%E8%81%9A%E5%90%88%E6%9D%A5%E8%AE%BE%E8%AE%A1%E7%9B%AE%E5%BD%95.png" alt="基于聚合来设计目录"><br>
<img src="%E5%9C%A8%E8%81%9A%E5%90%88%E7%9A%84%E8%BE%B9%E7%95%8C%E9%87%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E4%BB%BB%E6%84%8F%E7%9A%84%E6%8B%86%E5%88%86%E5%92%8C%E9%87%8D%E7%BB%84.jpg" alt="在聚合的边界里我们可以实现任意的拆分和重组"></p>
<h3 id="总结">总结</h3>
<p>DDD 不是万能的，在我们需要分治处理业务复杂度的时候才需要关注。</p>
<h2 id="领域驱动设计在大型遗留系统改造中的实践">领域驱动设计在大型遗留系统改造中的实践</h2>
<h3 id="遗留系统的现状以及改造步骤">遗留系统的现状以及改造步骤</h3>
<p><img src="%E6%80%9D%E8%80%83%E6%AD%A5%E9%AA%A4.jpg" alt="思考步骤"><br>
<img src="%E4%BA%8B%E4%BB%B6%E9%A3%8E%E6%9A%B4%E5%B7%A5%E4%BD%9C%E5%9D%8A.jpg" alt="事件风暴工作坊"></p>
<p>事件风暴要找一个有经验的人主持。如果没有准备好，可能出现大家都听着，但讨论不起来的问题。</p>
<p>思考模型的时候，可以修正不当的设计，而不要【先入为主】。</p>
<p><img src="%E8%A6%81%E6%9C%89%E5%BE%88%E5%BC%BA%E7%9A%84ownership%E6%8A%8A%E9%94%99%E7%9A%84%E6%94%B9%E6%88%90%E5%AF%B9%E7%9A%84.jpg" alt="要有很强的ownership把错的改成对的"></p>
<h3 id="微服务系统实现">微服务系统实现</h3>
<p>使用绞杀者模式：strangler pattern。也算是蓝绿发布的一种特例。</p>
<p><img src="%E7%BB%9E%E6%9D%80%E8%80%85%E6%A8%A1%E5%BC%8F.jpg" alt="绞杀者模式"><br>
<img src="%E5%9F%BA%E4%BA%8E%E5%8F%AF%E4%BB%A5%E5%8D%95%E7%8B%AC%E4%B8%8A%E7%BA%BF%E7%9A%84MVP%E8%BF%9B%E8%A1%8C%E7%9A%84%E5%88%86%E6%AD%A5%E6%8B%86%E5%88%86.jpg" alt="基于可以单独上线的MVP进行的分步拆分"></p>
<p>在 pipeline 里加入了大量的测试：安全测试、性能测试、合规测试和无障碍测试。</p>
<p><img src="%E9%98%B2%E8%85%90%E5%B1%82.jpg" alt="防腐层"></p>
<p>微服务的规模扩大后，防腐层会变变厚。防腐层的厚度和通信量有关。但如果新服务取代了旧服务，防腐层又会变薄。防腐层的最小厚度取决于不能替换的服务-掌控之外的服务，如异构服务。</p>
<p><img src="%E4%BA%91%E5%92%8C%E9%9D%9E%E4%BA%91%E7%9A%84%E9%9B%86%E6%88%90%E8%BF%98%E6%98%AF%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8LB%E4%B8%BA%E5%A5%BD.jpg" alt="云和非云的集成还是优先使用LB为好"></p>
<p>当然，如果都在云上，就可以考虑使用服务网格了。</p>
<p><img src="%E5%AF%B9%E9%81%97%E7%95%99%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%94%B9%E9%80%A0%E8%A6%81%E4%BE%9D%E8%B5%96%E4%BA%8E%E5%9B%A2%E9%98%9F%E7%9A%84%E8%BD%AC%E5%9E%8B.jpg" alt="对遗留系统的改造要依赖于团队的转型"></p>
<h2 id="ddd-从战略设计到代码落地的三阶段方法">DDD 从战略设计到代码落地的三阶段方法</h2>
<p>主讲人是“大魔头”杨云。</p>
<h3 id="为什么大家觉得-ddd-落地难">为什么大家觉得 DDD 落地难</h3>
<p>什么是模型？</p>
<p><img src="%E4%BB%80%E4%B9%88%E6%98%AF%E6%A8%A1%E5%9E%8B.jpg" alt="什么是模型"></p>
<p>模型不精练或不能用于沟通就是废话。</p>
<p><img src="DDD%E8%BF%9B%E5%85%A5%E5%88%B0%E6%9B%B4%E6%B7%B1%E5%B1%82%E7%9A%84%E5%BA%94%E7%94%A8.jpg" alt="DDD进入到更深层的应用"></p>
<p>业务专家要真的能够解释清楚业务的 operation model 是怎么样的；技术专家级别要架构师级别。更大规模的落地里，普通的基层执行人员也会参与到其中。百人大团队要面对的挑战：如何让代码按照模型落地。DDD 落地难主要因为前期设计成本高。</p>
<p><img src="%E5%AF%B9%E6%94%B9%E5%96%84%E8%90%BD%E5%9C%B0%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83.jpg" alt="对改善落地问题的思考"></p>
<ol>
<li>落地的时候要讲 practice 和 pattern，而不只是 principle。要有微观模型，才能适用于大团队。</li>
<li>要有更好的工具。</li>
</ol>
<h3 id="ddd-落地的三阶段方法">DDD 落地的三阶段方法</h3>
<p><img src="%E4%B8%89%E9%98%B6%E6%AE%B5%E6%96%B9%E6%B3%95.jpg" alt="三阶段方法"></p>
<ol>
<li>名词动词是为了识别实体和聚合，建立实体间关系。</li>
<li>类型流是为了建立柔性设计，特别是暴露意图接口、无副作用函数和 cohesive mechanism。</li>
</ol>
<h3 id="用事件风暴来做战略建模">用事件风暴来做战略建模</h3>
<p><img src="%E4%BA%8B%E4%BB%B6%E9%A3%8E%E6%9A%B4.jpg" alt="事件风暴"></p>
<p>最好找个可以支持事件风暴的软件来通过工作坊的方式完成事件风暴。事件风暴有四要素，从上到下排列。</p>
<h3 id="用名词动词法做子域内的结构化战术建模">用名词动词法做子域内的结构化战术建模</h3>
<p><img src="%E5%90%8D%E8%AF%8D%E5%8A%A8%E8%AF%8D%E6%B3%95.jpg" alt="名词动词法"></p>
<p>这个法则很像四色建模法，但其实是 OO 的基本设计法则的运用，但应该是受 Eric Evans 的基于 role 的遍历法构建出来的方法。也强调了 rule 的显示存在-<strong>把隐式概念转化为显式概念</strong>。演讲者说四色建模法过于复杂了，不适合直接拿出来使用-终于有人承认这一点了，过于复杂的理论是不是适合学习和推广？</p>
<ol>
<li>业务逻辑不要有副作用；无副作用的函数与技术设施服务耦合。</li>
<li>所有的名词都是聚合根。<strong>把所有的规则和行为都聚集到聚合根身上</strong>，维护规则变得特别容易-真的是这样吗。</li>
<li>所有设计都不是唯一的设计，也不是客观的设计，而是设计者的主观想法的映射。允许不同于客观的设计。不同的设计有不同的优劣和取舍。不存在公式化的方法导出标准的模型。</li>
<li>用 user story 来驱动这个模型的设计就足够了，这个模型表达完了 user story 的信息量就行，就足够指导我们的系统的开发了。一般的模型设计到此就够。</li>
<li>这个方法对小团队而言已经足够了。</li>
</ol>
<h3 id="用类型流做行为内部的微观详细设计">用类型流做行为内部的微观详细设计</h3>
<p><img src="%E7%B1%BB%E5%9E%8B%E6%B5%81%E6%98%AF%E4%BB%80%E4%B9%88.jpg" alt="类型流是什么"></p>
<ol>
<li>类型流本身是为了大团队用的。</li>
<li>业务流程给的需求一般都是过程式，OO 是我们的设计师拗过来的。</li>
<li>类型流更贴近过程式的思维方式。实际上，过程式的思维可以拿来描述任意复杂的需求，就可以拿来写出任意复杂的程序，只不过需求好改而程序不好改罢了。</li>
<li>对外部世界产生影响的函数是副作用函数，最好把这些东西和业务割离开，被割开的东西在有些 ddd 里叫作 infrastructure，在本演讲中叫过程。但这里留下一个有意思的问题：有些业务是依赖于全局状态的-其他微服务的状态、数据库里的状态的，是否总是能把业务拆解成若干个“相同的输入总是得到相同的输出”的“纯函数”呢？</li>
<li></li>
</ol>
<p><img src="%E7%B1%BB%E5%9E%8B%E6%B5%81%E7%9A%84%E6%9E%84%E9%80%A0%E5%9D%97.jpg" alt="类型流的构造块"><br>
<img src="%E7%B1%BB%E5%9E%8B%E6%B5%81%E5%AE%9E%E4%BE%8B-%E5%88%9B%E5%BB%BA%E5%BE%85%E5%8A%9E%E4%BA%8B%E9%A1%B91.jpg" alt="类型流实例-创建待办事项1"><br>
<img src="%E5%88%9B%E5%BB%BA%E5%BE%85%E5%8A%9E%E4%BA%8B%E9%A1%B92.jpg" alt="创建待办事项2"></p>
<ol>
<li>三个函数的拆分可以让三个开发者去开发。</li>
<li>有副作用函数的编排是总设计师的问题，总设计师保证各个函数协同共用一套契约，编译必定通过。</li>
<li>查询只做查询，更新只做更新，为什么不用管，这样做易于让“为什么”的这段逻辑进行 mock 和 unit test。这也是端口适配器模式所倡导的。</li>
</ol>
<p><img src="%E7%B1%BB%E5%9E%8B%E6%B5%81-%E6%95%B4%E5%90%88%E6%A6%82%E8%A7%88.jpg" alt="类型流-整合概览"></p>
<ol>
<li>下一层的建模可能会发现上一层的建模的错误。</li>
<li>DDD 的建模-设计要考虑团队工作的细节层次。</li>
</ol>
<h2 id="bounded-context-events-microservice">Bounded Context + Events =&gt; Microservice</h2>
<p>这个演讲是一位印度裔的 Unisys 全球架构师。</p>
<p>她从亚马逊的一个例子讲到在不同场景下 （Sales、Inventory、Shipping）Product 这个模型应该怎么演变。</p>
<p><img src="%E5%91%BD%E4%BB%A4%E5%92%8C%E9%A2%86%E5%9F%9F%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%B7%AE%E5%88%AB.jpg" alt="命令和领域事件的差别"></p>
<p>在这里我们可以看出，<strong>命令产生领域事件</strong>，这是针对事件风暴的基本建模。</p>
<p>EDA 下所有组件通过消息通信，<strong>消息可以被分为命令和领域事件</strong>，这就是主讲人要强调的。<br>
事件是 immutable 的，所以总是要引入发布订阅的架构风格，是已经发生的事情；而命令是可能失败的，它展现了意图。</p>
<p><img src="%E5%9C%A8%E8%88%AA%E7%A9%BA%E9%A2%86%E5%9F%9F%E7%9A%84%E4%B8%A4%E4%B8%AA%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E4%BE%8B%E5%AD%90.jpg" alt="在航空领域的两个上下文的例子"></p>
<p><img src="saga%E6%A8%A1%E5%BC%8F%E8%A6%81%E6%9C%89%E4%B8%80%E4%B8%AA%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E5%99%A8.jpg" alt="sage模式要有一个流程管理器"></p>
<p><img src="%E6%8E%A5%E8%BF%9E%E4%B8%8D%E6%96%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E9%A3%8E%E6%9A%B4.jpg" alt="接连不断的事件风暴"></p>
<p>事件风暴本来只是一个多人协同的方法，但在这里被主讲人描述为事件和命令之间接连不断的建模流程。黄色事件，蓝色命令。</p>
<p><img src="%E4%BD%BF%E7%94%A8ServiceBus%E6%9D%A5%E5%AE%9E%E7%8E%B0%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%9E%B6%E6%9E%84.jpg" alt="使用ServiceBus来实现事件驱动架构"><br>
<img src="PublishEvent.jpg" alt="PublishEvent"></p>
<p>事件驱动架构的解耦要求框架自己对事件有 route 能力。在这个航班公司的例子里，之所以适合使用事件驱动架构的原因在于它是分布式事务天然需要处理的场景，booking order 和 flight 之间的事务必然要处理提交和回滚的问题。但这又要求事件架构本身具有 SAGA 的事务编排能力了。</p>
<p><img src="%E9%A2%86%E5%9F%9F%E6%A6%82%E5%BF%B5%E8%AE%A4%E7%9F%A5%E8%BF%AD%E4%BB%A3%E5%B8%A6%E6%9D%A5%E9%87%8D%E6%9E%84.jpg" alt="领域概念认知迭代带来重构"></p>
<p>演讲者还提到了一点，重构和领域概念的认知迭代是密不可分的，两者互相驱动。</p>
<p><img src="%E5%AE%81%E5%8F%AF%E8%A6%81%E4%B8%80%E4%B8%AA%E9%95%BF%E7%9A%84%E5%90%8D%E5%AD%97.jpg" alt="宁可要一个长的名字"></p>
<p>演讲者讲的第一个名字没有明确表达到底要消费什么事件，她宁可取一个长的名字。</p>
<p><img src="%E4%B8%80%E4%B8%AAself-explanatory%E9%95%BF%E5%91%BD%E5%90%8D%E7%9A%84%E4%BE%8B%E5%AD%90.jpg" alt="一个self-explanatory长命名的例子"></p>
<p>如果有两个上下文，下游上下文在上游上下文遇到问题的时候，会不会因为耦合而不能正常工作呢？本文给出了另一个例子：</p>
<p><img src="%E4%B8%8A%E4%B8%8B%E6%96%87%E8%87%AA%E6%B2%BB.jpg" alt="上下文自治"></p>
<p>演讲者把这种问题叫作 temporal coupling，解耦这种耦合的方法是：下游上下文一开始就把所有变更事件存起来，出现特定事件的时候，本系统自己查询自己的数据库，实现上下文自治。<strong>上下文自治是通过冗余远端数据来实现的</strong>。</p>
<p>我们一再强调自治，<strong>因为有用的限界上下文是能够独立部署的限界上下文</strong>。</p>
<p><img src="%E4%BD%BF%E7%94%A8ERROR%E9%98%9F%E5%88%97%E6%9D%A5%E7%AE%A1%E7%90%86%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98.jpg" alt="使用ERROR队列来管理兼容问题"></p>
<p>这里有一个 ERROR queue，而不是抛弃消息，这要求我们既选用了能有这种功能的队列，也要求我们的设计运用这种功能。这要求我们有监控能力。</p>
<p><img src="%E6%9C%AC%E6%BC%94%E8%AE%B2%E7%9A%84%E4%B8%89%E4%B8%AA%E5%8E%9F%E5%88%99.jpg" alt="本演讲的三个原则"></p>
<h2 id="演进式架构">演进式架构</h2>
<p>老生常谈。不过 Neal Ford 加了一句，演进式架构是从 DDD 的实践中演化来的。</p>
<p>演进式架构是支持跨越多维度的引导性增量变更的适应度函数的架构。</p>
<h1>附属架构</h1>
<p><img src="%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%90%E5%9F%9F%E4%B8%8E%E9%99%90%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87.jpeg" alt="电子商务系统的子域与限界上下文"><br>
<img src="%E9%99%90%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E4%BE%8B%E5%AD%90.jpeg" alt="限界上下文例子"><br>
<img src="ERP%E7%9A%84%E4%BE%8B%E5%AD%90.jpeg" alt="ERP的例子"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://magicliang.github.io">magicliang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://magicliang.github.io/2022/03/29/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E6%B1%87%E6%80%BB/">https://magicliang.github.io/2022/03/29/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E6%B1%87%E6%80%BB/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/DDD/">DDD</a></div><div class="post-share"><div class="social-share" data-image="/2022/03/29/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%B9%82%E5%B9%82.gif" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/09/25/%E9%A3%9E%E9%A9%AC%E6%A8%A1%E5%9E%8B/" title="飞马模型"><img class="cover" src="/2024/09/25/%E9%A3%9E%E9%A9%AC%E6%A8%A1%E5%9E%8B/%E9%A3%9E%E9%A9%AC%E6%A8%A1%E5%9E%8B9%E5%A4%A7%E4%B8%BB%E9%A2%98.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-25</div><div class="info-item-2">飞马模型</div></div><div class="info-2"><div class="info-item-1">飞马模型来自 IBM 的 FSDM 模型 飞马模型可以覆盖银行、证券和保险业务场景，更加容易实现“全局最优”的金融信息互通、集成标准的建立。 飞马模型包括9类主题：产品、合约、条件、参与者、账户、事件、渠道、资源项、位置 。与FSDM的9大概念（ 参与者、合约、条件、产品、地点/位置、分类、业务方向、事件、资源项）相比，飞马模型少了分类和业务方向，增加了账户和渠道两个主题，更加贴合金融业务特点。  账户的概念来源于会计核算中的会计账户。银行账户是客户在银行开立的存款账户、贷款账户、往来账户的总称。银行业务就是在账户体系基础上为个人和对公客户提供各种金融服务。账户体系定义所有的操作均以交易的形式发生，也就是信息模型中的事件。 渠道是银行为客户提供金融产品和服务的场所。渠道的作用在于触达客户、传递产品和服务、达成交易。对于传统金融机构，同时拥有线下渠道和线上渠道。而对于互联网金融来说，完全是线上渠道。这也决定了互联网金融的业务模式与传统金融机构相比存在较大的差异，渠道对于互联网金融来说意义更大。互联网渠道不仅能够完成触达客户、传递产品和服务、达成交易的基本作用，而且其所带来的全新优质...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">DDD 官网</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">链接汇总</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">设计拆解</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">核心概念解释</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">DDD 原书</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E8%BF%90%E7%94%A8%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.1.</span> <span class="toc-text">第一部分 运用领域模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E5%8C%96%E7%9F%A5%E8%AF%86"><span class="toc-number">6.1.1.</span> <span class="toc-text">消化知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%B5%81%E4%B8%8E%E8%AF%AD%E8%A8%80%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">6.1.2.</span> <span class="toc-text">交流与语言的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.1.3.</span> <span class="toc-text">绑定模型和实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E6%A8%A1%E5%9E%8B%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E7%9A%84%E6%9E%84%E9%80%A0%E5%9D%97"><span class="toc-number">6.2.</span> <span class="toc-text">第二部分 模型驱动设计的构造块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%A6%BB%E9%A2%86%E5%9F%9F"><span class="toc-number">6.2.1.</span> <span class="toc-text">分离领域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E4%B8%AD%E6%89%80%E8%A1%A8%E7%A4%BA%E7%9A%84%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.2.2.</span> <span class="toc-text">软件中所表示的模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E8%81%94"><span class="toc-number">6.2.2.1.</span> <span class="toc-text">关联</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F-entity-%E5%8F%88%E7%A7%B0-reference-object"><span class="toc-number">6.2.2.2.</span> <span class="toc-text">模式 Entity（又称 Reference Object）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F-value-object"><span class="toc-number">6.2.2.3.</span> <span class="toc-text">模式 Value Object</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#service"><span class="toc-number">6.2.2.4.</span> <span class="toc-text">Service</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#service-%E7%9A%84%E5%88%86%E5%B1%82"><span class="toc-number">6.2.2.4.1.</span> <span class="toc-text">service 的分层</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#module"><span class="toc-number">6.2.2.5.</span> <span class="toc-text">module</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%91%E4%BB%AC%E4%B8%8D%E8%83%BD%E4%BF%9D%E6%8C%81%E8%8C%83%E5%BC%8F%E7%9A%84%E7%BA%AF%E5%87%80"><span class="toc-number">6.2.2.6.</span> <span class="toc-text">我们不能保持范式的纯净</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%86%E5%9F%9F%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">6.2.3.</span> <span class="toc-text">领域对象的生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#aggregate"><span class="toc-number">6.2.3.1.</span> <span class="toc-text">Aggregate</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#factory"><span class="toc-number">6.2.3.2.</span> <span class="toc-text">Factory</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#repository"><span class="toc-number">6.2.3.3.</span> <span class="toc-text">Repository</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.2.3.4.</span> <span class="toc-text">为关系数据库设计对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%AF%AD%E8%A8%80%EF%BC%9A%E4%B8%80%E4%B8%AA%E6%89%A9%E5%B1%95%E7%9A%84%E7%A4%BA%E4%BE%8B"><span class="toc-number">6.2.4.</span> <span class="toc-text">使用语言：一个扩展的示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E5%85%A5%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9A%E9%85%8D%E9%A2%9D%E6%A3%80%E6%9F%A5"><span class="toc-number">6.2.4.1.</span> <span class="toc-text">引入新特性：配额检查</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E9%87%8D%E6%9E%84%E5%8A%A0%E6%B7%B1%E7%90%86%E8%A7%A3"><span class="toc-number">6.3.</span> <span class="toc-text">通过重构加深理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AA%81%E7%A0%B4"><span class="toc-number">6.3.1.</span> <span class="toc-text">突破</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E9%9A%90%E5%BC%8F%E6%A6%82%E5%BF%B5%E8%BD%AC%E5%8F%98%E4%B8%BA%E6%98%BE%E5%BC%8F%E6%A6%82%E5%BF%B5"><span class="toc-number">6.3.2.</span> <span class="toc-text">将隐式概念转变为显式概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%94%E6%80%A7%E8%AE%BE%E8%AE%A1"><span class="toc-number">6.3.3.</span> <span class="toc-text">柔性设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#intention-revealing-interfaces"><span class="toc-number">6.3.3.1.</span> <span class="toc-text">INTENTION-REVEALING INTERFACES</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#side-effect-free-function"><span class="toc-number">6.3.3.2.</span> <span class="toc-text">SIDE-EFFECT-FREE FUNCTION</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#assertion"><span class="toc-number">6.3.3.3.</span> <span class="toc-text">Assertion</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#conceptual-contour"><span class="toc-number">6.3.3.4.</span> <span class="toc-text">CONCEPTUAL CONTOUR</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#standalone-class"><span class="toc-number">6.3.3.5.</span> <span class="toc-text">STANDALONE CLASS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#closure-of-operation"><span class="toc-number">6.3.3.6.</span> <span class="toc-text">CLOSURE OF OPERATION</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%BC%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">6.3.3.7.</span> <span class="toc-text">声明式设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%BC%8F%E8%AE%BE%E8%AE%A1%E9%A3%8E%E6%A0%BC"><span class="toc-number">6.3.3.8.</span> <span class="toc-text">声明式设计风格</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%87%E5%85%A5%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%92%E5%BA%A6"><span class="toc-number">6.3.3.9.</span> <span class="toc-text">切入问题的角度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%88%86%E6%9E%90%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.3.4.</span> <span class="toc-text">应用分析模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8%E4%BA%8E%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.3.5.</span> <span class="toc-text">将设计模式应用于模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E9%87%8D%E6%9E%84%E8%8E%B7%E5%BE%97%E6%9B%B4%E6%B7%B1%E5%B1%82%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">6.3.6.</span> <span class="toc-text">通过重构获得更深层的理解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E6%88%98%E7%95%A5%E8%AE%BE%E8%AE%A1"><span class="toc-number">6.4.</span> <span class="toc-text">第四部分 战略设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E6%8C%81%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="toc-number">6.4.1.</span> <span class="toc-text">保持模型的完整性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%EF%BC%9Abounded-context"><span class="toc-number">6.4.1.1.</span> <span class="toc-text">模式：Bounded Context</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%86%E5%88%AB-bounded-context-%E4%B8%AD%E7%9A%84%E4%B8%8D%E4%B8%80%E8%87%B4"><span class="toc-number">6.4.1.1.1.</span> <span class="toc-text">识别 Bounded Context 中的不一致</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%EF%BC%9Acontinous-integration"><span class="toc-number">6.4.1.2.</span> <span class="toc-text">模式：Continous Integration</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%EF%BC%9Acontext-map"><span class="toc-number">6.4.1.3.</span> <span class="toc-text">模式：Context Map</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%EF%BC%9Abounded-context-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">6.4.1.4.</span> <span class="toc-text">模式：Bounded Context 之间的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%85%B1%E4%BA%AB%E5%86%85%E6%A0%B8-shared-kernel"><span class="toc-number">6.4.1.5.</span> <span class="toc-text">模式：共享内核（Shared Kernel）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%EF%BC%9Acustomer-supplier-development-team"><span class="toc-number">6.4.1.6.</span> <span class="toc-text">模式：CUSTOMER&#x2F;SUPPLIER DEVELOPMENT TEAM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%A2%A8%E5%AE%88%E6%88%90%E8%A7%84%E8%80%85-%E9%81%B5%E5%A5%89%E8%80%85-conformist"><span class="toc-number">6.4.1.7.</span> <span class="toc-text">模式：墨守成规者&#x2F;遵奉者（Conformist）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%EF%BC%9Aanticoruption-layer"><span class="toc-number">6.4.1.8.</span> <span class="toc-text">模式：ANTICORUPTION LAYER</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%90%84%E8%A1%8C%E5%85%B6%E6%98%AF-separate-way"><span class="toc-number">6.4.1.9.</span> <span class="toc-text">模式：各行其是（SEPARATE WAY）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%EF%BC%9Aopen-host-service"><span class="toc-number">6.4.1.10.</span> <span class="toc-text">模式：OPEN HOST SERVICE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%EF%BC%9Apublished-language"><span class="toc-number">6.4.1.11.</span> <span class="toc-text">模式：PUBLISHED LANGUAGE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.4.1.12.</span> <span class="toc-text">选择模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E5%8C%96"><span class="toc-number">6.4.1.13.</span> <span class="toc-text">转化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B2%BE%E7%82%BC"><span class="toc-number">6.4.2.</span> <span class="toc-text">精炼</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%EF%BC%9Acore-domain"><span class="toc-number">6.4.2.1.</span> <span class="toc-text">模式：CORE DOMAIN</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%A0%B8%E5%BF%83"><span class="toc-number">6.4.2.1.1.</span> <span class="toc-text">选择核心</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%88%86%E9%85%8D"><span class="toc-number">6.4.2.1.2.</span> <span class="toc-text">工作分配</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B2%BE%E7%82%BC%E7%9A%84%E9%80%90%E6%AD%A5%E6%8F%90%E5%8D%87"><span class="toc-number">6.4.2.2.</span> <span class="toc-text">精炼的逐步提升</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#generic-subdomain"><span class="toc-number">6.4.2.3.</span> <span class="toc-text">GENERIC SUBDOMAIN</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%EF%BC%9Adomain-vision-statement"><span class="toc-number">6.4.3.</span> <span class="toc-text">模式：DOMAIN VISION STATEMENT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%EF%BC%9Ahighlighted-core"><span class="toc-number">6.4.4.</span> <span class="toc-text">模式：HIGHLIGHTED CORE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%EF%BC%9Acohesive-mechanism"><span class="toc-number">6.4.5.</span> <span class="toc-text">模式：COHESIVE MECHANISM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%EF%BC%9Asegregated-core"><span class="toc-number">6.4.6.</span> <span class="toc-text">模式：SEGREGATED CORE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%EF%BC%9Aabstracted-core"><span class="toc-number">6.4.7.</span> <span class="toc-text">模式：ABSTRACTED CORE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E9%87%8D%E6%9E%84%E7%9B%AE%E6%A0%87"><span class="toc-number">6.4.8.</span> <span class="toc-text">选择重构目标</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7%E5%9E%8B%E7%BB%93%E6%9E%84"><span class="toc-number">6.5.</span> <span class="toc-text">大型结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%EF%BC%9Aevolving-order"><span class="toc-number">6.5.1.</span> <span class="toc-text">模式：EVOLVING ORDER</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%EF%BC%9Asystem-metaphore"><span class="toc-number">6.5.2.</span> <span class="toc-text">模式：SYSTEM METAPHORE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%EF%BC%9Aresponsibility-layer"><span class="toc-number">6.5.3.</span> <span class="toc-text">模式：RESPONSIBILITY LAYER</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%EF%BC%9Aknowledge-level"><span class="toc-number">6.5.4.</span> <span class="toc-text">模式：KNOWLEDGE LEVEL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%EF%BC%9Aplugable-component-framework"><span class="toc-number">6.5.5.</span> <span class="toc-text">模式：PLUGABLE COMPONENT FRAMEWORK</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E7%9A%84%E7%BB%BC%E5%90%88%E8%BF%90%E7%94%A8"><span class="toc-number">6.6.</span> <span class="toc-text">领域驱动设计的综合运用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">领域驱动设计模式、原理与实践</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">7.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%8E%9F%E5%88%99%E4%B8%8E%E5%AE%9E%E8%B7%B5"><span class="toc-number">7.2.</span> <span class="toc-text">第一部分 领域驱动设计的原则与实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1"><span class="toc-number">7.2.1.</span> <span class="toc-text">什么是领域驱动设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E5%A4%8D%E6%9D%82%E6%80%A7"><span class="toc-number">7.2.1.1.</span> <span class="toc-text">领域驱动设计如何管理复杂性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%AE%9E%E8%B7%B5%E4%B8%8E%E5%8E%9F%E5%88%99"><span class="toc-number">7.2.1.2.</span> <span class="toc-text">领域驱动设计的实践与原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E7%9A%84%E8%AF%AF%E5%8C%BA"><span class="toc-number">7.2.1.3.</span> <span class="toc-text">领域驱动设计的误区</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E7%82%BC%E9%97%AE%E9%A2%98%E5%9F%9F"><span class="toc-number">7.2.2.</span> <span class="toc-text">提炼问题域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E6%95%88%E6%8F%90%E7%82%BC%E7%9F%A5%E8%AF%86%E7%9A%84%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.2.2.1.</span> <span class="toc-text">有效提炼知识的模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E7%8E%B0%E6%9C%89%E6%A8%A1%E5%9E%8B"><span class="toc-number">7.2.2.2.</span> <span class="toc-text">查看现有模型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%93%E6%B3%A8%E4%BA%8E%E6%A0%B8%E5%BF%83%E9%A2%86%E5%9F%9F"><span class="toc-number">7.2.3.</span> <span class="toc-text">专注于核心领域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%86%E8%A7%A3%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98%E5%9F%9F"><span class="toc-number">7.2.3.1.</span> <span class="toc-text">为什么要分解一个问题域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%8D%95%E8%8E%B7%E9%97%AE%E9%A2%98%E7%9A%84%E5%AE%9E%E8%B4%A8"><span class="toc-number">7.2.3.2.</span> <span class="toc-text">如何捕获问题的实质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%B8%93%E6%B3%A8%E4%BA%8E%E6%A0%B8%E5%BF%83%E9%97%AE%E9%A2%98"><span class="toc-number">7.2.3.3.</span> <span class="toc-text">如何专注于核心问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1"><span class="toc-number">7.2.4.</span> <span class="toc-text">模型驱动设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B"><span class="toc-number">7.2.4.1.</span> <span class="toc-text">什么是领域模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%80%9A%E7%94%A8%E8%AF%AD%E8%A8%80%E6%8A%8A%E5%88%86%E6%9E%90%E5%92%8C%E4%BB%A3%E7%A0%81%E6%A8%A1%E5%9E%8B%E7%BB%91%E5%AE%9A%E5%9C%A8%E4%B8%80%E8%B5%B7"><span class="toc-number">7.2.4.2.</span> <span class="toc-text">使用通用语言把分析和代码模型绑定在一起</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E9%80%9A%E7%94%A8%E8%AF%AD%E8%A8%80%E8%BF%9B%E8%A1%8C%E5%8D%8F%E4%BD%9C"><span class="toc-number">7.2.4.3.</span> <span class="toc-text">基于通用语言进行协作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E6%9C%89%E7%94%A8%E7%9A%84%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B"><span class="toc-number">7.2.4.4.</span> <span class="toc-text">如何创建有用的领域模型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.2.5.</span> <span class="toc-text">领域模型实现模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%86%E5%9F%9F%E5%B1%82"><span class="toc-number">7.2.5.1.</span> <span class="toc-text">领域层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.2.5.2.</span> <span class="toc-text">领域模型实现模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B-%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.2.5.2.1.</span> <span class="toc-text">领域模型（模式）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E8%84%9A%E6%9C%AC"><span class="toc-number">7.2.5.2.2.</span> <span class="toc-text">事务脚本</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A1%A8%E6%A8%A1%E5%9E%8B"><span class="toc-number">7.2.5.2.3.</span> <span class="toc-text">表模型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B4%BB%E5%8A%A8%E8%AE%B0%E5%BD%95"><span class="toc-number">7.2.5.2.4.</span> <span class="toc-text">活动记录</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B4%AB%E8%A1%80%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B"><span class="toc-number">7.2.5.2.5.</span> <span class="toc-text">贫血领域模型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B4%AB%E8%A1%80%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-number">7.2.5.2.6.</span> <span class="toc-text">贫血领域模型和函数式编程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%9C%89%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E7%BB%B4%E6%8A%A4%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="toc-number">7.2.6.</span> <span class="toc-text">使用有界上下文维护领域模型的完整性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%B8%AA%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%8C%91%E6%88%98"><span class="toc-number">7.2.6.1.</span> <span class="toc-text">单个模型的挑战</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%9C%89%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E7%A0%B4%E9%99%A4%E5%A4%A7%E6%A8%A1%E5%9E%8B"><span class="toc-number">7.2.6.2.</span> <span class="toc-text">使用有界上下文和破除大模型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E6%98%A0%E5%B0%84"><span class="toc-number">7.2.7.</span> <span class="toc-text">上下文映射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E7%8E%B0%E5%AE%9E%E6%83%85%E5%86%B5%E7%9A%84%E6%98%A0%E5%B0%84"><span class="toc-number">7.2.7.1.</span> <span class="toc-text">一个现实情况的映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86%E6%9C%89%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">7.2.7.2.</span> <span class="toc-text">认识有界上下文之间的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%98%B2%E6%AD%A2%E6%8D%9F%E5%9D%8F%E5%B1%82"><span class="toc-number">7.2.7.2.1.</span> <span class="toc-text">防止损坏层</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E6%A0%B8"><span class="toc-number">7.2.7.2.2.</span> <span class="toc-text">共享内核</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%80%E6%94%BE%E5%AE%BF%E4%B8%BB%E6%9C%8D%E5%8A%A1"><span class="toc-number">7.2.7.2.3.</span> <span class="toc-text">开放宿主服务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%BE%E5%AE%A2-%E4%BE%9B%E5%BA%94%E5%95%86%E5%85%B3%E7%B3%BB"><span class="toc-number">7.2.7.2.4.</span> <span class="toc-text">顾客-供应商关系</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#separated-ways"><span class="toc-number">7.2.7.2.5.</span> <span class="toc-text">Separated Ways</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E9%80%92%E4%B8%8A%E4%B8%8B%E6%96%87%E6%98%A0%E5%B0%84"><span class="toc-number">7.2.7.3.</span> <span class="toc-text">传递上下文映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E6%98%A0%E5%B0%84%E7%9A%84%E6%88%98%E7%95%A5%E9%87%8D%E8%A6%81%E6%80%A7"><span class="toc-number">7.2.7.4.</span> <span class="toc-text">上下文映射的战略重要性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%9E%B6%E6%9E%84"><span class="toc-number">7.2.8.</span> <span class="toc-text">应用程序架构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%9E%B6%E6%9E%84"><span class="toc-number">7.2.8.1.</span> <span class="toc-text">应用程序架构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%9C%8D%E5%8A%A1"><span class="toc-number">7.2.8.2.</span> <span class="toc-text">应用程序服务</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%A2%E9%98%9F%E5%BC%80%E5%A7%8B%E5%BA%94%E7%94%A8%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E9%80%9A%E5%B8%B8%E4%BC%9A%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">7.2.9.</span> <span class="toc-text">团队开始应用领域驱动设计通常会遇到的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%87%E5%88%86%E5%BC%BA%E8%B0%83%E6%88%98%E6%9C%AF%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7"><span class="toc-number">7.2.9.1.</span> <span class="toc-text">过分强调战术模式的重要性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E5%A4%B1%E4%BA%86-ddd-%E7%9A%84%E7%9C%9F%E5%AE%9E%E4%BB%B7%E5%80%BC%EF%BC%9A%E5%8D%8F%E4%BD%9C-%E9%80%9A%E4%BF%A1%E5%92%8C%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">7.2.9.2.</span> <span class="toc-text">缺失了 DDD 的真实价值：协作、通信和上下文</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E4%B8%8D%E9%87%8D%E8%A6%81%E7%9A%84%E9%83%A8%E5%88%86%E8%8A%B1%E8%B4%B9%E5%A4%AA%E5%A4%9A%E6%97%B6%E9%97%B4"><span class="toc-number">7.2.9.3.</span> <span class="toc-text">在不重要的部分花费太多时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84%E9%97%AE%E9%A2%98%E5%A4%8D%E6%9D%82%E5%8C%96"><span class="toc-number">7.2.9.4.</span> <span class="toc-text">简单的问题复杂化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8E%E4%BC%B0%E4%BD%BF%E7%94%A8-ddd-%E7%9A%84%E6%88%90%E6%9C%AC"><span class="toc-number">7.2.9.5.</span> <span class="toc-text">低估使用 DDD 的成本</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8-ddd-%E7%9A%84%E5%8E%9F%E5%88%99-%E5%AE%9E%E8%B7%B5%E4%B8%8E%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.2.10.</span> <span class="toc-text">应用 DDD 的原则、实践与模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%98%E7%95%A5%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%9C%A8%E6%9C%89%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B9%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-number">7.3.</span> <span class="toc-text">战略模式：在有界上下文之间通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E9%9B%86%E6%88%90%E4%BB%8B%E7%BB%8D"><span class="toc-number">7.3.1.</span> <span class="toc-text">有界上下文集成介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E6%88%90%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%89%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">7.3.1.1.</span> <span class="toc-text">集成分布式有界上下文</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-rpc"><span class="toc-number">7.3.1.1.1.</span> <span class="toc-text">使用 RPC</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%B0%86%E6%8D%9F%E5%AE%B3%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7%E5%92%8C%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="toc-number">7.3.1.2.</span> <span class="toc-text">分布式事务将损害可扩展性和可靠性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E5%93%8D%E5%BA%94%E5%BC%8F-ddd"><span class="toc-number">7.3.1.3.</span> <span class="toc-text">事件驱动响应式 DDD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#soa-%E5%92%8C%E5%93%8D%E5%BA%94%E5%BC%8F-ddd"><span class="toc-number">7.3.1.4.</span> <span class="toc-text">SOA 和响应式 DDD</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E9%9B%86%E6%88%90"><span class="toc-number">7.3.2.</span> <span class="toc-text">通过消息传递集成</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E5%9F%BA%E7%A1%80"><span class="toc-number">7.3.2.1.</span> <span class="toc-text">消息传递基础</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-nservicebus-%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">7.3.2.2.</span> <span class="toc-text">使用 NServiceBus 构建一个电子商务应用程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%B4%E6%8A%A4%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">7.3.2.3.</span> <span class="toc-text">维护消息传递应用程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86%E6%9C%89%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E%E5%85%AC%E5%85%B1%E4%BC%A0%E8%BE%93%E9%9B%86%E6%88%90"><span class="toc-number">7.3.2.4.</span> <span class="toc-text">将有界上下文与公共传输集成</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E4%BD%BF%E7%94%A8-rpc-%E5%92%8C-rest-%E7%9A%84-http-%E9%9B%86%E6%88%90"><span class="toc-number">7.3.3.</span> <span class="toc-text">通过使用 RPC 和 REST 的 HTTP 集成</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BD%95%E9%80%89%E7%94%A8-http"><span class="toc-number">7.3.3.1.</span> <span class="toc-text">为何选用 HTTP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rpc"><span class="toc-number">7.3.3.2.</span> <span class="toc-text">RPC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rest"><span class="toc-number">7.3.3.3.</span> <span class="toc-text">REST</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%98%E6%9C%AF%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%88%9B%E5%BB%BA%E6%9C%89%E6%95%88%E7%9A%84%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B"><span class="toc-number">7.4.</span> <span class="toc-text">战术模式：创建有效的领域模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%9D%97%E9%A2%86%E5%9F%9F%E5%BB%BA%E6%A8%A1%E4%BB%8B%E7%BB%8D"><span class="toc-number">7.4.1.</span> <span class="toc-text">构造块领域建模介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%98%E6%9C%AF%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.4.1.1.</span> <span class="toc-text">战术模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E9%A2%86%E5%9F%9F%E5%BB%BA%E6%A8%A1%E7%9A%84%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.4.1.2.</span> <span class="toc-text">对领域建模的模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%BE%E9%9C%B2%E6%A8%A1%E5%BC%8F-revealing-pattern"><span class="toc-number">7.4.1.3.</span> <span class="toc-text">显露模式（Revealing Pattern）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.4.1.4.</span> <span class="toc-text">生命周期模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%BC%E5%AF%B9%E8%B1%A1"><span class="toc-number">7.4.2.</span> <span class="toc-text">值对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BD%93"><span class="toc-number">7.4.3.</span> <span class="toc-text">实体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%86%E5%9F%9F%E6%9C%8D%E5%8A%A1"><span class="toc-number">7.4.4.</span> <span class="toc-text">领域服务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E9%A2%86%E5%9F%9F%E6%9C%8D%E5%8A%A1"><span class="toc-number">7.4.4.1.</span> <span class="toc-text">理解领域服务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E9%A2%86%E5%9F%9F%E6%9C%8D%E5%8A%A1"><span class="toc-number">7.4.4.2.</span> <span class="toc-text">利用领域服务</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%86%E5%9F%9F%E4%BA%8B%E4%BB%B6"><span class="toc-number">7.4.5.</span> <span class="toc-text">领域事件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%86%E5%9F%9F%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E8%B4%A8"><span class="toc-number">7.4.5.1.</span> <span class="toc-text">领域事件模式的实质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C"><span class="toc-number">7.4.5.2.</span> <span class="toc-text">模式处理操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%86%E5%9F%9F%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.4.5.3.</span> <span class="toc-text">领域事件的实现模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#guava-%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%8C%E6%88%90%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%B3%A8%E5%86%8C%E5%92%8C%E5%88%86%E5%8F%91%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-number">7.4.5.3.1.</span> <span class="toc-text">Guava 是怎么完成事件的注册和分发的呢？</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%98%E6%96%B9%E7%A4%BA%E4%BE%8B"><span class="toc-number">7.4.5.3.1.1.</span> <span class="toc-text">官方示例</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#subscriberregistry-%E8%AE%A2%E9%98%85%E6%B3%A8%E5%86%8C%E8%A1%A8"><span class="toc-number">7.4.5.3.1.2.</span> <span class="toc-text">SubscriberRegistry 订阅注册表</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#subscriber-%E8%AE%A2%E9%98%85%E8%80%85"><span class="toc-number">7.4.5.3.1.3.</span> <span class="toc-text">Subscriber 订阅者</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#eventbus-%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF"><span class="toc-number">7.4.5.3.1.4.</span> <span class="toc-text">EventBus 事件总线</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#dispatcher-%E5%88%86%E6%B4%BE%E5%99%A8"><span class="toc-number">7.4.5.3.1.5.</span> <span class="toc-text">Dispatcher 分派器</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#spring-%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F"><span class="toc-number">7.4.5.3.2.</span> <span class="toc-text">Spring 的事件机制是怎么工作的？</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E5%92%8C%E6%89%A7%E8%A1%8C-applicationlistener-%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">7.4.5.3.2.1.</span> <span class="toc-text">注册和执行 ApplicationListener 的流程</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#eventlistener-%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%B3%A8%E5%86%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">7.4.5.3.2.2.</span> <span class="toc-text">EventListener 注解驱动的事件注册流程</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">DDD Sample 的分层</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">9.</span> <span class="toc-text">领域驱动设计峰会</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E6%8F%AD%E7%A7%98"><span class="toc-number">9.1.</span> <span class="toc-text">领域驱动设计揭秘</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA-ddd"><span class="toc-number">9.1.1.</span> <span class="toc-text">两个 DDD</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#data-driven-design-vs-domain-driven-design"><span class="toc-number">9.1.1.1.</span> <span class="toc-text">Data Driven Design Vs Domain Driven Design</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%91%E9%93%81%E6%97%B6%E4%BB%A3%E4%B8%8E%E9%BB%84%E9%87%91%E6%97%B6%E4%BB%A3"><span class="toc-number">9.1.2.</span> <span class="toc-text">黑铁时代与黄金时代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%98%AF%E9%82%AA%E6%81%B6%E7%9A%84%E5%90%97"><span class="toc-number">9.1.3.</span> <span class="toc-text">单体架构是邪恶的吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ddd-%E4%B8%8D%E8%B6%B3%E4%B8%8E-ddd-up"><span class="toc-number">9.1.4.</span> <span class="toc-text">DDD 不足与 DDD-UP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%93%E4%B8%AD%E5%8F%B0%E9%81%87%E4%B8%8A-ddd-%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%BE%AE%E6%9C%8D%E5%8A%A1"><span class="toc-number">9.2.</span> <span class="toc-text">当中台遇上 DDD，如何设计微服务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E4%B8%AD%E5%8F%B0%E4%B8%8E-ddd-%E7%9A%84%E7%BB%9F%E4%B8%80%E8%AF%AD%E8%A8%80"><span class="toc-number">9.2.1.</span> <span class="toc-text">建立中台与 DDD 的统一语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-ddd-%E5%AE%8C%E6%88%90%E4%B8%AD%E5%8F%B0%E5%92%8C%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1"><span class="toc-number">9.2.2.</span> <span class="toc-text">如何使用 DDD 完成中台和微服务设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B"><span class="toc-number">9.2.3.</span> <span class="toc-text">领域模型与微服务的架构演进</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">9.2.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E5%9C%A8%E5%A4%A7%E5%9E%8B%E9%81%97%E7%95%99%E7%B3%BB%E7%BB%9F%E6%94%B9%E9%80%A0%E4%B8%AD%E7%9A%84%E5%AE%9E%E8%B7%B5"><span class="toc-number">9.3.</span> <span class="toc-text">领域驱动设计在大型遗留系统改造中的实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%97%E7%95%99%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%8E%B0%E7%8A%B6%E4%BB%A5%E5%8F%8A%E6%94%B9%E9%80%A0%E6%AD%A5%E9%AA%A4"><span class="toc-number">9.3.1.</span> <span class="toc-text">遗留系统的现状以及改造步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.3.2.</span> <span class="toc-text">微服务系统实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ddd-%E4%BB%8E%E6%88%98%E7%95%A5%E8%AE%BE%E8%AE%A1%E5%88%B0%E4%BB%A3%E7%A0%81%E8%90%BD%E5%9C%B0%E7%9A%84%E4%B8%89%E9%98%B6%E6%AE%B5%E6%96%B9%E6%B3%95"><span class="toc-number">9.4.</span> <span class="toc-text">DDD 从战略设计到代码落地的三阶段方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%A4%A7%E5%AE%B6%E8%A7%89%E5%BE%97-ddd-%E8%90%BD%E5%9C%B0%E9%9A%BE"><span class="toc-number">9.4.1.</span> <span class="toc-text">为什么大家觉得 DDD 落地难</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ddd-%E8%90%BD%E5%9C%B0%E7%9A%84%E4%B8%89%E9%98%B6%E6%AE%B5%E6%96%B9%E6%B3%95"><span class="toc-number">9.4.2.</span> <span class="toc-text">DDD 落地的三阶段方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E4%BA%8B%E4%BB%B6%E9%A3%8E%E6%9A%B4%E6%9D%A5%E5%81%9A%E6%88%98%E7%95%A5%E5%BB%BA%E6%A8%A1"><span class="toc-number">9.4.3.</span> <span class="toc-text">用事件风暴来做战略建模</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E5%90%8D%E8%AF%8D%E5%8A%A8%E8%AF%8D%E6%B3%95%E5%81%9A%E5%AD%90%E5%9F%9F%E5%86%85%E7%9A%84%E7%BB%93%E6%9E%84%E5%8C%96%E6%88%98%E6%9C%AF%E5%BB%BA%E6%A8%A1"><span class="toc-number">9.4.4.</span> <span class="toc-text">用名词动词法做子域内的结构化战术建模</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%B5%81%E5%81%9A%E8%A1%8C%E4%B8%BA%E5%86%85%E9%83%A8%E7%9A%84%E5%BE%AE%E8%A7%82%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1"><span class="toc-number">9.4.5.</span> <span class="toc-text">用类型流做行为内部的微观详细设计</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bounded-context-events-microservice"><span class="toc-number">9.5.</span> <span class="toc-text">Bounded Context + Events &#x3D;&gt; Microservice</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%94%E8%BF%9B%E5%BC%8F%E6%9E%B6%E6%9E%84"><span class="toc-number">9.6.</span> <span class="toc-text">演进式架构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">10.</span> <span class="toc-text">附属架构</span></a></li></ol></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2017 - 2025 By magicliang</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional and Simplified Chinese">簡</button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>