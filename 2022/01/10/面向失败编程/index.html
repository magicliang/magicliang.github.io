<!DOCTYPE html>

<html lang="zh-Hans">
    <head>
    <meta charset="utf-8">
    <!--
        hexo-theme-suka © SukkaW
        GitHub: https://github.com/SukkaW/hexo-theme-suka
    -->

    <!-- ### Resource Hint ### -->

    <!-- ## DNS Prefetch ## -->
    <meta http-equiv="x-dns-prefetch-control" content="on">

<!-- busuanzi -->

    <link rel="dns-prefetch" href="//busuanzi.ibruce.info">


<!-- comment -->







<!-- analytics -->







    <!-- ## Preload ## -->
    
    <!-- Busuanzi -->
    
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/busuanzi@2.3.0/bsz.pure.mini.js" as="script">







    <!-- ### Meta & Title & Info ### -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, maximum-scale=5, viewport-fit=cover">
    <meta name="renderer" content="webkit">

    <!-- Title -->
    <title>面向失败编程 | 守株阁</title>

    <!-- Favicons -->
    <link rel="icon" type="image&#x2F;ico" href="/img/suka-favicon.ico">

    <!-- ### Import File ### -->
    <link rel="stylesheet" href="/lib/spectre/spectre.min.css"><style>
    body {
        background-color: #f8f9fa;
    }

    a, a:visited {
        color: #0070ff;
    }

    a:active, a:focus, a:hover {
        color: #0070ff;
        opacity: .75;
    }

    #post-content a,
    #post-content a:hover,
    #post-content a:focus,
    #post-content a:visited {
        color: #005eb9;
        opacity: 1;
    }

    

    .post-entry .card-body a {
        color: #0070ff;
    }

    .avatar {
        background: #444;
    }

    .navbar-link,
    .navbar-link:visited,
    .timeline .timeline-item .timeline-icon.icon-lg {
        color: #0070ff;
    }

    .navbar-link:hover {
        color: #0070ff;
        opacity: .8;
    }

    #search-input .btn,
    #disqus_click_btn,
    #disqus-switch-to-direct,
    #disqus-loadmore-button {
        background: #727e96;
        border-color: #727e96;
        color: #fff;
    }

    #post-toc a.post-toc-link,
    #post-toc a.post-toc-link:visited,
    .share-menu.menu .menu-item>a {
        color: #727e96;
    }

    .share-menu.menu .menu-item>a:hover,
    .share-menu.menu .menu-item>a:focus,
    .share-menu.menu .menu-item>a:visited {
        color: #50596c;
        background: #f8f9fa;
        opacity: .85;
    }
</style><link rel="stylesheet" href="/css/style.min.css">








    <!-- Prettify Theme -->
    
    <link rel="preload" href="/css/highlight/github.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="/css/highlight/github.min.css"></noscript>





<script>
/*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
!function(t){"use strict";t.loadCSS||(t.loadCSS=function(){});var e=loadCSS.relpreload={};if(e.support=function(){var e;try{e=t.document.createElement("link").relList.supports("preload")}catch(t){e=!1}return function(){return e}}(),e.bindMediaToggle=function(t){var e=t.media||"all";function a(){t.addEventListener?t.removeEventListener("load",a):t.attachEvent&&t.detachEvent("onload",a),t.setAttribute("onload",null),t.media=e}t.addEventListener?t.addEventListener("load",a):t.attachEvent&&t.attachEvent("onload",a),setTimeout(function(){t.rel="stylesheet",t.media="only x"}),setTimeout(a,3e3)},e.poly=function(){if(!e.support())for(var a=t.document.getElementsByTagName("link"),n=0;n<a.length;n++){var o=a[n];"preload"!==o.rel||"style"!==o.getAttribute("as")||o.getAttribute("data-loadcss")||(o.setAttribute("data-loadcss",!0),e.bindMediaToggle(o))}},!e.support()){e.poly();var a=t.setInterval(e.poly,500);t.addEventListener?t.addEventListener("load",function(){e.poly(),t.clearInterval(a)}):t.attachEvent&&t.attachEvent("onload",function(){e.poly(),t.clearInterval(a)})}"undefined"!=typeof exports?exports.loadCSS=loadCSS:t.loadCSS=loadCSS}("undefined"!=typeof global?global:this);
</script>

    <!-- ### Site Verification ### -->
    


    <link rel="alternate" type="application/atom+xml" href="/atom.xml"><meta name="mobile-web-app-capable" content="yes"><meta name="application-name" content="守株阁"><meta name="msapplication-starturl" content="http://magicliang.github.io"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="守株阁"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <!-- ### The Open Graph & Twitter Card Protocol ### -->
    <meta property="og:title" content="面向失败编程 | 守株阁"><meta property="og:site_name" content="守株阁"><meta property="og:type" content="article"><meta property="og:url" content="http://magicliang.github.io/2022/01/10/%E9%9D%A2%E5%90%91%E5%A4%B1%E8%B4%A5%E7%BC%96%E7%A8%8B/"><meta property="og:locale" content="zh-Hans"><meta name="description" content="本文是《面向不确定性编程》的续篇，探讨与失败有关的编程问题。 前言我们的系统是一个乱动的螃蟹不可避免的乱动我们的分布式金融系统随时随地可能发生失败（此处的失败专指系统进入了异常状态，因为内外 bug 导致的 failure。我们不专门辨析 error、fault 等其他词汇）：  中间件崩溃 宿主机异常 黑客入侵 单据定价计算错误 营销活动配置错误导致黑产大规模薅羊毛 网络抖动  失败的原因有很多 - magicliang - 守株阁"><meta name="keywords" content="系统架构"><meta property="og:image" content="http://magicliang.github.io/2022/01/10/%E9%9D%A2%E5%90%91%E5%A4%B1%E8%B4%A5%E7%BC%96%E7%A8%8B/%E8%9E%83%E8%9F%B9%E5%9B%BE.svg"><meta property="og:image" content="http://magicliang.github.io/2022/01/10/%E9%9D%A2%E5%90%91%E5%A4%B1%E8%B4%A5%E7%BC%96%E7%A8%8B/%E7%94%A8%E4%BE%8B%E5%9B%BE%E7%9A%84%E4%BE%8B%E5%AD%90.png"><meta property="og:image" content="http://magicliang.github.io/2022/01/10/%E9%9D%A2%E5%90%91%E5%A4%B1%E8%B4%A5%E7%BC%96%E7%A8%8B/%E7%B1%BB%E5%9B%BE%E7%9A%84%E4%BE%8B%E5%AD%90.png"><meta property="og:image" content="http://magicliang.github.io/2022/01/10/%E9%9D%A2%E5%90%91%E5%A4%B1%E8%B4%A5%E7%BC%96%E7%A8%8B/%E7%8A%B6%E6%80%81%E5%9B%BE%E7%9A%84%E4%BE%8B%E5%AD%90.png"><meta property="og:image" content="http://magicliang.github.io/2022/01/10/%E9%9D%A2%E5%90%91%E5%A4%B1%E8%B4%A5%E7%BC%96%E7%A8%8B/%E7%B3%BB%E7%BB%9F%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%9A%84%E4%BE%8B%E5%AD%90.png"><meta property="og:image" content="http://magicliang.github.io/2022/01/10/%E9%9D%A2%E5%90%91%E5%A4%B1%E8%B4%A5%E7%BC%96%E7%A8%8B/%E6%97%B6%E5%BA%8F%E5%9B%BE%E7%9A%84%E4%BE%8B%E5%AD%90.png"><meta property="og:image" content="http://magicliang.github.io/2022/01/10/%E9%9D%A2%E5%90%91%E5%A4%B1%E8%B4%A5%E7%BC%96%E7%A8%8B/%E4%BA%A4%E6%98%93%E7%B3%BB%E7%BB%9F%E9%A3%8E%E9%99%A9%E5%A4%A7%E5%9B%BE.png"><meta property="og:image" content="http://magicliang.github.io/2022/01/10/%E9%9D%A2%E5%90%91%E5%A4%B1%E8%B4%A5%E7%BC%96%E7%A8%8B/%E6%9C%A8%E6%A1%B6%E5%AE%9A%E5%BE%8B.jpeg"><meta property="og:image" content="http://magicliang.github.io/2022/01/10/%E9%9D%A2%E5%90%91%E5%A4%B1%E8%B4%A5%E7%BC%96%E7%A8%8B/%E5%BC%82%E5%B8%B8%E5%88%86%E7%B1%BB.png"><meta property="og:image" content="http://magicliang.github.io/2022/01/10/%E9%9D%A2%E5%90%91%E5%A4%B1%E8%B4%A5%E7%BC%96%E7%A8%8B/%E8%B4%A6%E8%AF%81%E5%AE%9E%E6%A8%A1%E5%9E%8B.svg"><meta property="og:image" content="http://magicliang.github.io/2022/01/10/%E9%9D%A2%E5%90%91%E5%A4%B1%E8%B4%A5%E7%BC%96%E7%A8%8B/%E4%B8%80%E4%B8%AA%E6%95%B4%E6%B4%81%E7%9A%84%E4%BF%9D%E9%99%A9%E6%A0%B8%E5%BF%83.svg"><meta property="og:image" content="http://magicliang.github.io/2022/01/10/%E9%9D%A2%E5%90%91%E5%A4%B1%E8%B4%A5%E7%BC%96%E7%A8%8B/double-check%E7%9A%84%E4%BE%8B%E5%AD%90.jpg"><meta property="og:image" content="http://magicliang.github.io/2022/01/10/%E9%9D%A2%E5%90%91%E5%A4%B1%E8%B4%A5%E7%BC%96%E7%A8%8B/%E4%B8%80%E9%94%81%E4%BA%8C%E5%88%A4%E4%B8%89%E6%9B%B4%E6%96%B0.svg"><meta property="og:image" content="http://magicliang.github.io/2022/01/10/%E9%9D%A2%E5%90%91%E5%A4%B1%E8%B4%A5%E7%BC%96%E7%A8%8B/%E9%94%81%E5%AE%9A%E8%81%9A%E5%90%88%E6%A0%B9.svg"><meta property="og:image" content="http://magicliang.github.io/2022/01/10/%E9%9D%A2%E5%90%91%E5%A4%B1%E8%B4%A5%E7%BC%96%E7%A8%8B/ER%E5%88%86%E7%89%87.jpg"><meta property="og:image" content="http://magicliang.github.io/2022/01/10/%E9%9D%A2%E5%90%91%E5%A4%B1%E8%B4%A5%E7%BC%96%E7%A8%8B/%E5%AF%B9%E4%BF%9D%E5%8D%95%E7%9A%84%E9%94%81%E5%AE%9A.jpg"><meta property="og:image" content="http://magicliang.github.io/2022/01/10/%E9%9D%A2%E5%90%91%E5%A4%B1%E8%B4%A5%E7%BC%96%E7%A8%8B/%E6%B7%B7%E5%90%88%E4%BA%8B%E5%8A%A1.svg"><meta property="og:image" content="http://magicliang.github.io/2022/01/10/%E9%9D%A2%E5%90%91%E5%A4%B1%E8%B4%A5%E7%BC%96%E7%A8%8B/%E8%A7%81%E8%B4%B9%E5%87%BA%E5%8D%95%E6%A8%A1%E5%9E%8B.svg"><meta property="og:image" content="http://magicliang.github.io/2022/01/10/%E9%9D%A2%E5%90%91%E5%A4%B1%E8%B4%A5%E7%BC%96%E7%A8%8B/%E8%B7%A8%E4%BA%8B%E5%8A%A1%E7%8A%B6%E6%80%81%E8%A1%A5%E5%81%BF.svg"><meta property="og:image" content="http://magicliang.github.io/2022/01/10/%E9%9D%A2%E5%90%91%E5%A4%B1%E8%B4%A5%E7%BC%96%E7%A8%8B/%E8%BF%91%E7%AB%AF%E4%B8%BB%E5%8A%A8%E8%A1%A5%E5%81%BF.svg"><meta property="og:image" content="http://magicliang.github.io/2022/01/10/%E9%9D%A2%E5%90%91%E5%A4%B1%E8%B4%A5%E7%BC%96%E7%A8%8B/%E8%BF%9C%E7%AB%AF%E4%B8%BB%E5%8A%A8%E8%A1%A5%E5%81%BF%E6%B3%95.svg"><meta property="article:published_time" content="2022-01-10T12:00:48.000Z"><meta property="article:modified_time" content="2022-01-30T05:42:25.415Z"><meta property="og:updated_time" content="2022-01-30T05:42:25.415Z"><meta property="article:author" content="magicliang"><meta property="article:tag" content="系统架构"><meta name="twitter:card" content="summary">

    

    <!-- ### Canonical link ### -->
    <link rel="canonical" href="http://magicliang.github.io/2022/01/10/%E9%9D%A2%E5%90%91%E5%A4%B1%E8%B4%A5%E7%BC%96%E7%A8%8B/">

    <meta name="generator" content="Hexo 6.0.0">

    <!-- ### Analytics ### -->
    







    <!-- ### Structured Data ### -->
    



<script type="application/ld+json">
{
    "@context": "http://schema.org",
    "url": "http://magicliang.github.io/2022/01/10/%E9%9D%A2%E5%90%91%E5%A4%B1%E8%B4%A5%E7%BC%96%E7%A8%8B/",
    "@type": "BlogPosting",
    "logo": "http://magicliang.github.io/img/suka-favicon.ico",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "http://magicliang.github.io/2022/01/10/%E9%9D%A2%E5%90%91%E5%A4%B1%E8%B4%A5%E7%BC%96%E7%A8%8B/"
    },
    "headline": "面向失败编程 | 守株阁",
    
    "image": {
        "@type": "ImageObject",
        "url": "http://magicliang.github.io/img/suka-favicon.ico"
    },
    
    "datePublished": "2022-01-10T12:00:48.000Z",
    "dateModified": "2022-01-30T05:42:25.415Z",
    "author": {
        "@type": "Person",
        "name": "magicliang",
        "image": {
            "@type": "ImageObject",
            "url": "http://magicliang.github.io/img/default_avatar.png"
        },
        "description": "Hi, nice to meet you."
    },
    "publisher": {
        "@type": "Organization",
        "name": "守株阁",
        "logo": {
            "@type": "ImageObject",
            "url": "http://magicliang.github.io/img/suka-favicon.ico"
        }
    },
    
    "potentialAction": {
        "@type": "SearchAction",
        "target": "http://magicliang.github.io/search?s={search_term_string}",
        "query-input": "required name=search_term_string"
    },
    
    "keywords": "系统架构",
    "description": "本文是《面向不确定性编程》的续篇，探讨与失败有关的编程问题。 前言我们的系统是一个乱动的螃蟹不可避免的乱动我们的分布式金融系统随时随地可能发生失败（此处的失败专指系统进入了异常状态，因为内外 bug 导致的 failure。我们不专门辨析 error、fault 等其他词汇）：  中间件崩溃 宿主机异常 黑客入侵 单据定价计算错误 营销活动配置错误导致黑产大规模薅羊毛 网络抖动  失败的原因有很多 - magicliang - 守株阁"
}
</script>



    <!-- ### Custom Head ### -->
    
</head>

    <body>
            

            <!-- ### Main content ### -->
            <!-- ## Header ##-->
<header>
    <h1 class="header-title text-center"><a href="/">守株阁</a></h1>

    <p class="text-center header-slogan">
        
            
                Hi, nice to meet you.
            
        
    </p>

    <nav class="navbar-section text-center">
    
        <a href="/" class="navbar-link">Home</a>
    
    
        <a href="/archives/" class="navbar-link">Archives</a>
    
    
        <a href="/search" class="navbar-link">Search</a>
    
    
    
        <div class="dropdown dropdown-right">
    <a class="navbar-link dropdown-toggle" tabindex="0">Share</a>
    <ul class="menu share-menu">

        <!-- Share Weibo -->
        
        <li class="menu-item">
            <a href="http://service.weibo.com/share/share.php?appkey=&title=守株阁&url=http://magicliang.github.io&pic=http://magicliang.github.io/img/suka-favicon.ico&searchPic=false&style=simple" target="_blank" rel="external noopener noreferrer nofollow">Share to Weibo</a>
        </li>
        

        <!-- Share Twitter -->
        
        <li class="menu-item">
            <a href="https://twitter.com/intent/tweet?text=守株阁&url=http://magicliang.github.io&via=magicliang" target="_blank" rel="external noopener noreferrer nofollow">Share to Twitter</a>
        </li>
        

        <!-- Share Facebook -->
        
        <li class="menu-item">
            <a href="https://www.facebook.com/sharer/sharer.php?u=http://magicliang.github.io" target="_blank" rel="external noopener noreferrer nofollow">Share to Facebook</a>
        </li>
        

        <!-- Share Google+ -->
        
        <li class="menu-item">
            <a href="https://plus.google.com/share?url=http://magicliang.github.io" target="_blank" rel="external noopener noreferrer nofollow">Share to Google+</a>
        </li>
        

        <!-- Share LinkedIn -->
        
        <li class="menu-item">
            <a href="https://www.linkedin.com/shareArticle?mini=true&url=http://magicliang.github.io&title=面向失败编程" target="_blank" rel="external noopener noreferrer nofollow">Share to LinkedIn</a>
        </li>
        

        <!-- Share QQ -->
        
        <li class="menu-item">
            <a href="http://connect.qq.com/widget/shareqq/index.html?site=守株阁&title=面向失败编程&summary=关于技术以及人生&pics=http://magicliang.github.io/img/suka-favicon.ico&url=http://magicliang.github.io" target="_blank" rel="external noopener noreferrer nofollow"> Share to QQ</a>
        </li>
        

        <!-- Share Telegram -->
        
        <li class="menu-item">
            <a href="https://t.me/share/url?url=http://magicliang.github.io&text=面向失败编程" target="_blank" rel="external noopener noreferrer nofollow">Share to Telegram</a>
        </li>
        

        <!-- QRCode -->
        
        <li class="menu-item">
            <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALQAAAC0CAAAAAAYplnuAAACs0lEQVR42u3bQW4CMRBEUe5/6WQbEbvqtweQ0Hw2RJAMD5SO7erO4+cLbw/RokWLviH6EW6r5/9d6Onxvz/3fP/82Or5nUO06Al6+Uu/eLHdxVeoFbBdNzlEi56iV4hd0ay+vxXbqpBbQYoW/Q40fWFS0OTDES363ei2gOweaxuyXeGKFv0qdNqorDY4ZINFDg60kEWLnqBbsXzq/qWncdG3RaPgL1yohTbkIPGW1FT0bdFkcxM3MeDNpA0WPeCKFj1Bt8Clwdp10gGiHZxjo0i06LC4kOA8FU1ajNqBg4TuokVP0dtvLM3Qo4ZPKMAYgooWDdENm1CTxj+5jwuWaNEQnTYxJBifho2paGODVLToIbo1OVuRtUB+svFHAaRo0SD3qMUQFpH2hlJRtkVItGiKnmyE0mJCh2zRAZaeXESLHoQ1bXGYNEkngXoMOUWLBuhUINODbjvkpjeMile0aICmmxYSILZgkQwAHA+piBZd/qCnocDU3E+NTjIsEA8UokUP0K0AyZBKO+C2xaMGOKJFD9AkoJk0eOgGnx52RYueohukDVAlKGkYodcWLXo4l3dSfGRRORnwEi36FE0akC28oc/Tgj0+uYgWDRuVaROTmkuTDRQKOEWLBujpPyCQplJrONFwZ9QoEi26oEiAQxrzJHQfN/RFiy5oMoTVNjyk4dSGq+qAuWjREN0KkAwJThtFk4ODaNGn6KuNnvQBXAk1RYs+QU+GTOjXFJsGr0SLnqLbjTY9WzhOBmTHjSLRokEhpotPwhUa+qQhcdGiT9EkICdBDl2sJgHm9hAgWnRBtwJsg1akiOngLE6YRIu+gCZhJWmgkkMEDtVFiz5ATwZOaLEmbFxsRIseoGlBtWFA2hyij4kWfYKeBIGt+OhAOGkyXTqNi74t+ptuokWLFn0j9C8g4esJwPBhHwAAAABJRU5ErkJggg==" alr="QRCode">
        </li>
        

    </ul>
</div>
    
    
</nav>
</header>

            
    <!-- ## Post ## -->
    <div class="post-container">
    <div id="post-card" class="card">
        
        <div class="card-item-container">
            <div class="card-inner-cell">
                <!-- # Post Header Info # -->
                <div class="card-header">
                    
    <h1 class="card-title h3 mb-2">面向失败编程</h1>




<div class="post-header-info">
    <p class="post-header-info-left text-gray">
        <img class="author-thumb lazyload" data-src="/img/default_avatar.png" src="/img/suka-lazyload.gif" alt="magicliang's Avatar">
        <span>2022-01-10</span>
        
        
            <!-- Busuanzi Post Views -->
<span id="busuanzi_container_page_pv" hidden>
    <span class="suka-devide-dot"></span>
    <span></span>
    <span id="busuanzi_value_page_pv"></span>
    <span>Views</span>
</span>
        
        
    </p>
    <div class="post-header-info-right">
        
            <div class="dropdown dropdown-right">
<a class="dropdown-toggle" tabindex="0">Share the post</a>
<ul class="menu share-menu">
    <!-- Share Weibo -->
    
    <li class="menu-item">
        <a href="http://service.weibo.com/share/share.php?appkey=&title=面向失败编程&url=http://magicliang.github.io/2022/01/10/%E9%9D%A2%E5%90%91%E5%A4%B1%E8%B4%A5%E7%BC%96%E7%A8%8B/&pic=http://magicliang.github.io/img/suka-favicon.ico&searchPic=false&style=simple" target="_blank" rel="external noopener noreferrer nofollow">Share to Weibo</a>
    </li>
    

    <!-- Share Twitter -->
    
    <li class="menu-item">
        <a href="https://twitter.com/intent/tweet?text=面向失败编程&url=http://magicliang.github.io/2022/01/10/%E9%9D%A2%E5%90%91%E5%A4%B1%E8%B4%A5%E7%BC%96%E7%A8%8B/&via=magicliang" target="_blank" rel="external noopener noreferrer nofollow">Share to Twitter</a>
    </li>
    

    <!-- Share Facebook -->
    
    <li class="menu-item">
        <a href="https://www.facebook.com/sharer/sharer.php?u=http://magicliang.github.io/2022/01/10/%E9%9D%A2%E5%90%91%E5%A4%B1%E8%B4%A5%E7%BC%96%E7%A8%8B/" target="_blank" rel="external noopener noreferrer nofollow">Share to Facebook</a>
    </li>
    

    <!-- Share Google+ -->
    
    <li class="menu-item">
        <a href="https://plus.google.com/share?url=http://magicliang.github.io/2022/01/10/%E9%9D%A2%E5%90%91%E5%A4%B1%E8%B4%A5%E7%BC%96%E7%A8%8B/" target="_blank" rel="external noopener noreferrer nofollow">Share to Google+</a>
    </li>
    

    <!-- Share LinkedIn -->
    
    <li class="menu-item">
        <a href="https://www.linkedin.com/shareArticle?mini=true&url=http://magicliang.github.io/2022/01/10/%E9%9D%A2%E5%90%91%E5%A4%B1%E8%B4%A5%E7%BC%96%E7%A8%8B/&title=守株阁" target="_blank" rel="external noopener noreferrer nofollow">Share to LinkedIn</a>
    </li>
    

    <!-- Share QQ -->
    
    <li class="menu-item">
        <a href="http://connect.qq.com/widget/shareqq/index.html?site=守株阁&title=守株阁&summary=关于技术以及人生&pics=http://magicliang.github.io/img/suka-favicon.ico&url=http://magicliang.github.io/2022/01/10/%E9%9D%A2%E5%90%91%E5%A4%B1%E8%B4%A5%E7%BC%96%E7%A8%8B/" target="_blank" rel="external noopener noreferrer nofollow"> Share to QQ</a>
    </li>
    

    <!-- Share Telegram -->
    
    <li class="menu-item">
        <a href="https://t.me/share/url?url=http://magicliang.github.io/2022/01/10/%E9%9D%A2%E5%90%91%E5%A4%B1%E8%B4%A5%E7%BC%96%E7%A8%8B/&text=守株阁" target="_blank" rel="external noopener noreferrer nofollow">Share to Telegram</a>
    </li>
    

    <!-- QRCode -->
    
    <li class="menu-item">
        <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALQAAAC0CAAAAAAYplnuAAACs0lEQVR42u3bQW4CMRBEUe5/6WQbEbvqtweQ0Hw2RJAMD5SO7erO4+cLbw/RokWLviH6EW6r5/9d6Onxvz/3fP/82Or5nUO06Al6+Uu/eLHdxVeoFbBdNzlEi56iV4hd0ay+vxXbqpBbQYoW/Q40fWFS0OTDES363ei2gOweaxuyXeGKFv0qdNqorDY4ZINFDg60kEWLnqBbsXzq/qWncdG3RaPgL1yohTbkIPGW1FT0bdFkcxM3MeDNpA0WPeCKFj1Bt8Clwdp10gGiHZxjo0i06LC4kOA8FU1ajNqBg4TuokVP0dtvLM3Qo4ZPKMAYgooWDdENm1CTxj+5jwuWaNEQnTYxJBifho2paGODVLToIbo1OVuRtUB+svFHAaRo0SD3qMUQFpH2hlJRtkVItGiKnmyE0mJCh2zRAZaeXESLHoQ1bXGYNEkngXoMOUWLBuhUINODbjvkpjeMile0aICmmxYSILZgkQwAHA+piBZd/qCnocDU3E+NTjIsEA8UokUP0K0AyZBKO+C2xaMGOKJFD9AkoJk0eOgGnx52RYueohukDVAlKGkYodcWLXo4l3dSfGRRORnwEi36FE0akC28oc/Tgj0+uYgWDRuVaROTmkuTDRQKOEWLBujpPyCQplJrONFwZ9QoEi26oEiAQxrzJHQfN/RFiy5oMoTVNjyk4dSGq+qAuWjREN0KkAwJThtFk4ODaNGn6KuNnvQBXAk1RYs+QU+GTOjXFJsGr0SLnqLbjTY9WzhOBmTHjSLRokEhpotPwhUa+qQhcdGiT9EkICdBDl2sJgHm9hAgWnRBtwJsg1akiOngLE6YRIu+gCZhJWmgkkMEDtVFiz5ATwZOaLEmbFxsRIseoGlBtWFA2hyij4kWfYKeBIGt+OhAOGkyXTqNi74t+ptuokWLFn0j9C8g4esJwPBhHwAAAABJRU5ErkJggg==" alt="QRCode">
    </li>
    

</ul>
</div>
        
    </div>
</div>
                </div>
                <div class="card-body">
                    
                        
                        
                            <div id="post-toc"><ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E5%89%8D%E8%A8%80"><span class="post-toc-number">1.</span> <span class="post-toc-text">前言</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E6%88%91%E4%BB%AC%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%98%AF%E4%B8%80%E4%B8%AA%E4%B9%B1%E5%8A%A8%E7%9A%84%E8%9E%83%E8%9F%B9"><span class="post-toc-number">2.</span> <span class="post-toc-text">我们的系统是一个乱动的螃蟹</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%B8%8D%E5%8F%AF%E9%81%BF%E5%85%8D%E7%9A%84%E4%B9%B1%E5%8A%A8"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">不可避免的乱动</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%BD%95%E8%B0%93%E8%B4%A8%E9%87%8F%E5%B1%9E%E6%80%A7"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">何谓质量属性</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%B8%BA%E4%BD%95%E6%88%91%E4%BB%AC%E8%A6%81%E8%80%83%E8%99%91%E4%BD%93%E7%B3%BB%E5%8C%96%E7%9A%84%E6%96%B9%E6%A1%88"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">为何我们要考虑体系化的方案</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E6%8E%A8%E5%AF%BC%E7%BB%B3%E5%AD%90"><span class="post-toc-number">3.</span> <span class="post-toc-text">推导绳子</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E2%80%9C%E5%85%A8%E5%91%A8%E6%9C%9F%E3%80%81%E5%A4%9A%E7%BB%B4%E5%BA%A6%E2%80%9D%E7%9A%84%E9%A3%8E%E9%99%A9%E9%98%B2%E6%8E%A7%E4%BD%93%E7%B3%BB"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">我们需要“全周期、多维度”的风险防控体系</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E4%B8%8B%E7%9A%84%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%BA%BF%E4%B8%8E%E9%A3%8E%E9%99%A9%E5%A4%A7%E5%9B%BE"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">领域驱动设计下的架构基线与风险大图</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E5%A6%82%E4%BD%95%E5%81%9A%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84%E9%A3%8E%E9%99%A9%E9%98%B2%E6%8E%A7%E4%BD%93%E7%B3%BB"><span class="post-toc-number">4.</span> <span class="post-toc-text">如何做高可用的风险防控体系</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98%E5%88%B0%E5%BA%95%E4%BB%8E%E4%BD%95%E8%80%8C%E6%9D%A5%EF%BC%9F"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">高可用的问题到底从何而来？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%8B%BE%E5%8B%92%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84%E6%8B%93%E6%89%91"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">勾勒核心架构拓扑</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E7%90%86%E8%A7%A3%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%96%B9%E6%B3%95"><span class="post-toc-number">4.3.</span> <span class="post-toc-text">理解系统的方法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%BC%82%E5%B8%B8%E6%8C%87%E6%A0%87%E6%94%B6%E9%9B%86%E4%B8%8E%E5%91%8A%E8%AD%A6"><span class="post-toc-number">4.3.1.</span> <span class="post-toc-text">异常指标收集与告警</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E7%9A%84%E6%94%B6%E9%9B%86%E4%B8%8E%E5%91%8A%E8%AD%A6"><span class="post-toc-number">4.3.2.</span> <span class="post-toc-text">性能指标的收集与告警</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%9F%BA%E7%A1%80%E4%B8%9A%E5%8A%A1%E6%8C%87%E6%A0%87%E7%9A%84%E6%94%B6%E9%9B%86%E4%B8%8E%E5%91%8A%E8%AD%A6"><span class="post-toc-number">4.3.3.</span> <span class="post-toc-text">基础业务指标的收集与告警</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%87%A0%E7%A7%8D%E9%A3%8E%E9%99%A9%E5%88%86%E5%AD%90%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF"><span class="post-toc-number">4.4.</span> <span class="post-toc-text">几种风险分子的设计思路</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%91%8A%E8%AD%A6"><span class="post-toc-number">4.4.1.</span> <span class="post-toc-text">如何设计告警</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E8%B0%83%E4%BC%98%E6%89%8B%E6%AE%B5"><span class="post-toc-number">4.4.2.</span> <span class="post-toc-text">调优手段</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82%E8%B0%83%E4%BC%98"><span class="post-toc-number">4.4.2.1.</span> <span class="post-toc-text">应用层调优</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%B1%82%E8%B0%83%E4%BC%98"><span class="post-toc-number">4.4.2.2.</span> <span class="post-toc-text">系统层调优</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%B8%AD%E9%97%B4%E4%BB%B6%E8%B0%83%E4%BC%98"><span class="post-toc-number">4.4.2.3.</span> <span class="post-toc-text">中间件调优</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%AD%98%E5%82%A8%E5%B1%82%E8%B0%83%E4%BC%98"><span class="post-toc-number">4.4.2.4.</span> <span class="post-toc-text">存储层调优</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%9E%B6%E6%9E%84%E8%B0%83%E4%BC%98"><span class="post-toc-number">4.4.2.5.</span> <span class="post-toc-text">架构调优</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%86%97%E4%BD%99%E6%89%8B%E6%AE%B5"><span class="post-toc-number">4.4.3.</span> <span class="post-toc-text">冗余手段</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%BA%94%E6%80%A5%E6%89%8B%E6%AE%B5"><span class="post-toc-number">4.4.4.</span> <span class="post-toc-text">应急手段</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%9C%89%E6%8D%9F%E7%B1%BB"><span class="post-toc-number">4.4.4.1.</span> <span class="post-toc-text">有损类</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E9%99%8D%E7%BA%A7-%E7%86%94%E6%96%AD"><span class="post-toc-number">4.4.4.1.1.</span> <span class="post-toc-text">降级&#x2F;熔断</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%81%A2%E5%A4%8D%E7%B1%BB"><span class="post-toc-number">4.4.4.2.</span> <span class="post-toc-text">恢复类</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E9%87%8D%E8%AF%95"><span class="post-toc-number">4.4.4.2.1.</span> <span class="post-toc-text">重试</span></a></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%A6%82%E4%BD%95%E6%A3%80%E9%AA%8C%E9%AB%98%E5%8F%AF%E7%94%A8%E5%BB%BA%E8%AE%BE%E6%88%90%E6%9E%9C"><span class="post-toc-number">4.5.</span> <span class="post-toc-text">如何检验高可用建设成果</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E5%A6%82%E4%BD%95%E5%81%9A%E8%B5%84%E9%87%91%E5%AE%89%E5%85%A8%E7%9A%84%E9%A3%8E%E9%99%A9%E9%98%B2%E6%8E%A7%E4%BD%93%E7%B3%BB"><span class="post-toc-number">5.</span> <span class="post-toc-text">如何做资金安全的风险防控体系</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%9F%BA%E4%BA%8E%E2%80%9C%E8%B4%A6%E3%80%81%E8%AF%81%E3%80%81%E5%AE%9E%E2%80%9D%E7%9A%84%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B%E8%AE%BE%E8%AE%A1"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">基于“账、证、实”的领域模型设计</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%AF%BB%E6%B1%82%E5%88%86%E8%A7%A3%E5%BE%97%E5%BD%93%E5%92%8C%E5%8F%AF%E8%BF%BD%E6%BA%AF%E7%9A%84%E6%A8%A1%E5%9E%8B"><span class="post-toc-number">5.2.</span> <span class="post-toc-text">寻求分解得当和可追溯的模型</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%AF%BB%E6%B1%82%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%B9%B3%E8%A1%A1%E6%80%A7"><span class="post-toc-number">5.3.</span> <span class="post-toc-text">寻求模型的平衡性</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E8%A6%81%E5%81%9A%E5%A5%BD%E5%9F%BA%E7%A1%80%E7%9A%84%E9%98%B2%E5%BE%A1%E6%80%A7%E7%BC%96%E7%A8%8B%E6%A0%A1%E9%AA%8C"><span class="post-toc-number">5.3.1.</span> <span class="post-toc-text">要做好基础的防御性编程校验</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%9C%A8%E4%BA%A4%E6%98%93%E4%B8%AD%E4%B8%A5%E6%A0%BC%E4%BF%9D%E8%AF%81%E6%A8%A1%E5%9E%8B%E6%98%AF%E5%B9%B3%E8%A1%A1%E7%9A%84"><span class="post-toc-number">5.3.2.</span> <span class="post-toc-text">在交易中严格保证模型是平衡的</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%BF%9D%E8%AF%81%E4%BA%A4%E6%98%93%E5%9B%A0%E5%AD%90%E6%98%AF%E6%AD%A3%E7%A1%AE%E7%9A%84"><span class="post-toc-number">5.3.2.1.</span> <span class="post-toc-text">保证交易因子是正确的</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E4%B8%80%E9%94%81%E4%BA%8C%E5%88%A4%E4%B8%89%E6%9B%B4%E6%96%B0"><span class="post-toc-number">5.3.2.1.1.</span> <span class="post-toc-text">一锁二判三更新</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E4%B8%8D%E8%A6%81%E7%95%8F%E6%83%A7%E4%BD%BF%E7%94%A8%E6%82%B2%E8%A7%82%E9%94%81"><span class="post-toc-number">5.3.2.1.2.</span> <span class="post-toc-text">不要畏惧使用悲观锁</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%9C%80%E5%A5%BD%E7%9A%84%E7%9F%AD%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-select-for-update-%E6%82%B2%E8%A7%82%E9%94%81"><span class="post-toc-number">5.3.2.1.3.</span> <span class="post-toc-text">最好的短分布式锁-select for update 悲观锁</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E9%A2%86%E5%9F%9F%E8%83%BD%E5%8A%9B%E9%94%81%E5%AE%9A%E8%81%9A%E5%90%88%E6%A0%B9"><span class="post-toc-number">5.3.2.1.4.</span> <span class="post-toc-text">领域能力锁定聚合根</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E9%94%81%E7%9A%84%E5%8F%98%E7%A7%8D1-%E4%BD%BF%E7%94%A8%E5%8D%95%E6%8D%AE%E4%BD%9C%E4%B8%BA%E9%94%81%E5%AE%9E%E7%8E%B0%E7%B2%BE%E7%BB%86%E5%8C%96%E4%BA%92%E6%96%A5"><span class="post-toc-number">5.3.2.1.5.</span> <span class="post-toc-text">锁的变种1-使用单据作为锁实现精细化互斥</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E9%94%81%E7%9A%84%E5%8F%98%E7%A7%8D2-%E4%BF%9D%E5%8D%95%E6%8C%82%E8%B5%B7"><span class="post-toc-number">5.3.2.1.6.</span> <span class="post-toc-text">锁的变种2- 保单挂起</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%85%B6%E4%BB%96%E6%8E%AA%E6%96%BD-%E8%A7%81%E8%B4%B9%E5%87%BA%E5%8D%95%E7%9A%84%E6%B5%81%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="post-toc-number">5.3.2.1.7.</span> <span class="post-toc-text">其他措施-见费出单的流程模型</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%85%B6%E4%BB%96%E6%8E%AA%E6%96%BD-%E6%89%80%E6%9C%89%E5%AE%9A%E4%BB%B7%E8%AE%BE%E8%AE%A1%E5%8F%AF%E8%BF%BD%E6%BA%AF%E7%9A%84%E6%8A%A5%E4%BB%B7%E5%8D%95"><span class="post-toc-number">5.3.2.1.8.</span> <span class="post-toc-text">其他措施-所有定价设计可追溯的报价单</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%85%B6%E4%BB%96%E6%8E%AA%E6%96%BD-%E6%AD%A3%E9%80%86%E5%90%91%E6%A3%80%E6%9F%A5"><span class="post-toc-number">5.3.2.1.9.</span> <span class="post-toc-text">其他措施-正逆向检查</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%BF%9D%E8%AF%81%E7%B3%BB%E7%BB%9F%E4%BF%9D%E6%8C%81%E5%8A%A8%E5%8A%9B"><span class="post-toc-number">5.3.2.2.</span> <span class="post-toc-text">保证系统保持动力</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%81%9A%E5%B9%82%E7%AD%89%E6%80%A7%E6%A3%80%E6%9F%A5"><span class="post-toc-number">5.3.2.3.</span> <span class="post-toc-text">做幂等性检查</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%9C%A8%E4%BA%A4%E6%98%93%E4%B8%AD%E4%B8%A5%E6%A0%BC%E9%AA%8C%E8%AF%81%E6%A8%A1%E5%9E%8B%E6%98%AF%E5%B9%B3%E8%A1%A1%E7%9A%84"><span class="post-toc-number">5.3.3.</span> <span class="post-toc-text">在交易中严格验证模型是平衡的</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%97%A7%E5%AF%B9%E8%B4%A6%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%97%AE%E9%A2%98"><span class="post-toc-number">5.3.3.1.</span> <span class="post-toc-text">旧对账模式的问题</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%EF%BC%88%E5%87%86%EF%BC%89%E5%AE%9E%E6%97%B6%E6%A0%B8%E5%AF%B9"><span class="post-toc-number">5.3.3.2.</span> <span class="post-toc-text">（准）实时核对</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%AE%8C%E6%95%B4%E7%9A%84%E2%80%9C%E4%BA%8B%E5%89%8D%E3%80%81%E4%BA%8B%E4%B8%AD%E3%80%81%E4%BA%8B%E5%90%8E%E2%80%9D"><span class="post-toc-number">5.4.</span> <span class="post-toc-text">完整的“事前、事中、事后”</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E6%80%BB%E7%BB%93"><span class="post-toc-number">6.</span> <span class="post-toc-text">总结</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E9%99%84%E5%BD%95"><span class="post-toc-number">7.</span> <span class="post-toc-text">附录</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%BD%95%E8%B0%93%E5%A4%B1%E8%B4%A5%EF%BC%9F"><span class="post-toc-number">7.1.</span> <span class="post-toc-text">何谓失败？</span></a></li></ol></li></ol></div>
                        
                    
                    <article id="post-content">
                        <p>本文是<a href="https://magicliang.github.io/2022/01/10/%E9%9D%A2%E5%90%91%E4%B8%8D%E7%A1%AE%E5%AE%9A%E6%80%A7%E7%BC%96%E7%A8%8B/">《面向不确定性编程》</a>的续篇，探讨与失败有关的编程问题。</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h1 id="我们的系统是一个乱动的螃蟹"><a href="#我们的系统是一个乱动的螃蟹" class="headerlink" title="我们的系统是一个乱动的螃蟹"></a>我们的系统是一个乱动的螃蟹</h1><h2 id="不可避免的乱动"><a href="#不可避免的乱动" class="headerlink" title="不可避免的乱动"></a>不可避免的乱动</h2><p>我们的分布式金融系统随时随地可能发生失败（此处的失败专指系统进入了异常状态，因为内外 bug 导致的 failure。我们不专门辨析 error、fault 等其他词汇）：</p>
<ul>
<li>中间件崩溃</li>
<li>宿主机异常</li>
<li>黑客入侵</li>
<li>单据定价计算错误</li>
<li>营销活动配置错误导致黑产大规模薅羊毛</li>
<li>网络抖动</li>
</ul>
<p>失败的原因有很多种：</p>
<ul>
<li>网络并不是可靠的，存在不可预知的闪断、重试和并发引起的竞态条件</li>
<li>同节点之间的通信是存在延迟的</li>
<li>带宽是有上限的</li>
<li>数据由一份冗余成多份后如何保持一致</li>
<li>整个系统的不同部分可能是异构的</li>
<li>我们无法阻止程序员在快速迭代中出错，积累隐藏的错误</li>
<li>黑客总能入侵进入我们的系统中，制造某种程度的破坏</li>
</ul>
<p>从客观上讲，自从分布式系统诞生以来，网络的基本约束条件自始至终没有发生过本质的变化。逻辑解决方案无法根本改变物理层的局限；从主观上讲，我们也没有一种可以在分析-设计-编码阶段完全消除 bug 的方法。所以我们无法从根本上阻止我们的系统“乱动”，就好像我们无法阻止从菜市场上买回来的螃蟹乱动一样。<strong>乱动是螃蟹的天性，也是分布式系统的天性</strong>。在分布式系统中，怀疑者、悲观者和偏执狂才能生存。</p>
<p>更多的例子，可以参考<a target="_blank" rel="noopener" href="https://www.infoq.cn/article/hDI_l4Oec0FBWus1SDWD">别忽视分布式系统这六大“暗流”</a>和<a target="_blank" rel="noopener" href="https://coolshell.cn/articles/10910.html">分布式系统的事务处理</a>。</p>
<h2 id="何谓质量属性"><a href="#何谓质量属性" class="headerlink" title="何谓质量属性"></a>何谓质量属性</h2><p>我们的系统是由业务需求驱动而设计出来的。在堆砌业务功能的时候，我们会在系统里面下非常大的功夫，思考如何让功能性需求实现得准确。但我们很少思考：</p>
<ol>
<li>我们的系统的非功能性需求（即我们的系统中隐含的质量属性（Quality Attribute））有哪些？</li>
<li>如果我们理解了问题 1，我们应当如何交付质量属性很高的软件？</li>
</ol>
<p>对于分布式金融系统而言，质量属性至少应该包括：</p>
<ul>
<li>如何让我们的系统实现高可用？这个问题基本上等价于 CAP 问题中的 A 问题。</li>
<li>如何让我们的系统实现资金安全？这个问题近似于于 CAP 问题中的 C 问题，实现资金安全离不开对 C 问题的理解，但不等于只需要理解 C。</li>
</ul>
<p>众所周知，CAP 中的 P 是不可选择、必然存在的，我们可以选择性地调整我们对 P 的分布，在某些场景下寻求 A，在某些场景下寻找 C-我们常见的无状态服务搭配存储的设计，就是在一套 CP 的服务上搭建 AP 的服务。</p>
<h2 id="为何我们要考虑体系化的方案"><a href="#为何我们要考虑体系化的方案" class="headerlink" title="为何我们要考虑体系化的方案"></a>为何我们要考虑体系化的方案</h2><p>设计复杂的业务系统是一项复杂的工程，因此我们需要运用大量的分析和设计技术（比如 DDD）。这些技术只能帮助我们管理功能性需求的复杂度，我们其实并不十分清楚，如何按部就班地剖析非功能性需求，进而提升我们的质量属性。</p>
<p>因为没有通行的理论指导，进行这种设计的知识，通常来源于资深工程师对某一个领域常年的坎坷摸索。每个工程师都有各自的踩坑经历，这导致这类知识的积累、传递和运用非常地碎片化。在现实的工程世界里，真正有意识和能力进行非功能性需求设计的，往往是高级工程师甚至架构师。除非他们有意识地对领域新手进行指导，否则新手独自产出的系统设计必然充满问题。然而，即使我们有意识地这样做，如果我们不使用按部就班的方法，而使用头脑风暴的方法，结果也往往事倍功半。所以做这种事情是吃力不讨好的事情，在现实中工作中的 ROI 不高，所以在设计技术方案的时候，我们总是有意无意地忽略这些东西。久而久之，程序员经常很乐观，不愿意给自己设置“假设自己会犯错”的约束。</p>
<p>事实上，阻止系统乱动也是个复杂的工程。<strong>问题是自一个体系中产生的，也应该被一个体系（有时候是另一个体系）解决</strong>。考虑到非功能性需求解决的问题更抽象、更复杂，解决系统失败的解决方案，应该是一个“包容系统的系统”或者“设计之上的设计”。它只会比原来的解决方案更大。当我们构建起一整套解决方案了以后，就好像给一只永远无法控制自己乱动的“大螃蟹”套上了绳子，在架构层面对系统质量施加影响。我们姑且把这套东西称作“风险防控体系”，它与业务系统一起工作的时候就好像“三斤螃蟹两斤绳”-我们在市场上买到的螃蟹总是带有绳子的，奸商卖的螃蟹上绑的绳子还非常重。如果我们最终交付的系统里面，螃蟹（功能性设计）每重一斤，都会配上两斤重的绳子（非功能性设计），我们通常可以保证我们的系统的稳定性。-从反方向上看，我们经常给我们的系统加的绳子不够多，就是我们的系统线上问题频出的根本原因。</p>
<p>本文的主要内容是探讨如何找到每个领域的螃蟹，以及如何绑上属于它的绳子。</p>
<p><img src="%E8%9E%83%E8%9F%B9%E5%9B%BE.svg" alt="系统如螃蟹，乱动的时候需要绳子绑住"></p>
<p>按部就班是一种 divide and conquer，利于协同，不易出错。</p>
<h1 id="推导绳子"><a href="#推导绳子" class="headerlink" title="推导绳子"></a>推导绳子</h1><h2 id="我们需要“全周期、多维度”的风险防控体系"><a href="#我们需要“全周期、多维度”的风险防控体系" class="headerlink" title="我们需要“全周期、多维度”的风险防控体系"></a>我们需要“全周期、多维度”的风险防控体系</h2><p>全周期：大家在现实之中听资深工程师开堂布道，讲系统稳定性，都听过“事前事中事后”这句话。这句话的意思很复杂，事前事中和事后有很多事情可以做。很多人把事前事中事后当作“事前仔细评估”、“事中认真应对”、“事后注意复盘”，这套 sop 下来，最后做出来的效果大差不差。无论怎么理解这句话，当我们谈到“事前事中事后”的时候，我们其实已经意识到了，风险防控是一个“全生命周期，反复迭代”的体系。<strong>我们经常发现我们风险防控做得不够好，就是因为我们对生命周期的认知不够全面</strong>。</p>
<p>多维度：现实中，系统的风险来自多个维度。我们有无数的 case study 告诉我们，我们自己构建的系统其实比我们想象的复杂，我们并不真正了解我们的系统的运行时状态。系统的真正运行状态对我们这些建造者而言，是混沌的，我们只能理解我们心中的那个静态系统。即使只是推导我们心中的静态系统，我们对系统的理解的维度也不够全面，<strong>我们经常遇到的系统故障，来自于我们想象不到的一个环节、维度，让我们难以置信</strong>。</p>
<p>所以我们要构造一个能够绑住我们的螃蟹的系统，我们就要尽力把我们的设计按照“全周期”、“多维度”的方向推导。</p>
<ul>
<li>理解全周期的好处是：每个周期的输入和输出是有界的，它涉及的模型和行为也是有限的，我们只需要理解这个收敛问题的异常情况。</li>
<li>理解多维度的好处是：我们很难做到一次衡量多个混合维度，但经过多个维度的拆解，我们可以多次衡量单个单一维度。</li>
</ul>
<h2 id="领域驱动设计下的架构基线与风险大图"><a href="#领域驱动设计下的架构基线与风险大图" class="headerlink" title="领域驱动设计下的架构基线与风险大图"></a>领域驱动设计下的架构基线与风险大图</h2><p>领域驱动设计告诉我们，要做战略设计。</p>
<p>做战略设计的结果，通常是以下几样东西：</p>
<ol>
<li>被划分好的领域。</li>
<li>领域里有相互依赖关系的领域模型。</li>
<li>领域模型自己的状态机。</li>
<li>由领域模型支撑的领域能力。</li>
<li>由领域能力编排成的系统用例。</li>
</ol>
<p>绝大部分的失败，都隐藏在这些战略设计里。如果我们通过认真的设计消除了我们的风险，这些设计就是成功的设计。这样成功的设计，至少具有以下两个特点：</p>
<ol>
<li><strong>分解得当</strong>：我们能不能恰如其分地说明每一笔交易的所有细节，不漏不重。</li>
<li><strong>可追溯</strong>：所有的细节都是可联系的-只靠单据可以还原出全流程（这通常意味着，我们不能删除数据）。</li>
</ol>
<p>（下文会反反复复地出现这两个特点）</p>
<p>我们应当如何理解我们的服务架构？</p>
<p>在古典架构师的思考工具里面，经常提到 “4+1 视图”（这在他们的架构师群体里面叫作 Architectural Blueprints）：</p>
<p>![传统的 4+1 视图能够帮我们在团队里沟通架构](4+1 view of software architecture.png)</p>
<p>我们的系统是复杂的、混沌的，由多种要素组成，而且在静态视角、动态视角、功能视角和运行视角来看，侧重点并不一样。单一视图很难表达清楚所有的要素，<strong>我们要有所侧重地理解架构，也就要“横看成岭侧成峰”，建立对系统的完整认知</strong>。</p>
<p>我们有了基础的战略设计，我们就可以建立我们的架构基线文档。架构基线一定程度上是 4+1 架构的选择性落地实现，它应该包含：</p>
<ul>
<li>系统用例图（即 4+1 视图中的 scenarios，所以逻辑视图需要配合对用例的下钻）</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.plantuml.com/plantuml/uml/VP6_JiD03CPtFuN7TEW0OyHG11BgK5GHTKP7wgQdvlxexbAfGDyTkvS62ALJOdy_VxRFivXKI9rf8UwqzIeeWrxLEzLGbGujOQ0wGL49DS6xp-aKosMh3XHURqeu_uaGTBDDt-fj2L0yAKCISsMlzqvGBDoU35anPS-1x9K-Eq3mx19XSXxT1ZDHOkw4XgE8scAZzsHnhMLaxIptVt3cJVrjySA0iWrlzm68nNrAl76cSeLa7sb3TlqhUmJe8jKg4XVLDSM82x9TdA3g_n3oPzGGYfLlWbfJp7udQ3p6iWlrbhqpSYuGPPLqgzz70ieunTpopic5mnNZLIIS9p8P6IfEImRd_zFcTkF6wMC-nEcMSWfXIgosBYJacUgWlJozI9fT0SvRQTjScR3omrF_B129IUAxNX2F5zpxc01WnfQTQRy0">用例图的例子</a></p>
<p><img src="%E7%94%A8%E4%BE%8B%E5%9B%BE%E7%9A%84%E4%BE%8B%E5%AD%90.png" alt="用例图的例子"></p>
<ul>
<li>系统领域类图（logical view 是一部分）：</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.plantuml.com/plantuml/uml/XLJDRjmW4BxxAL1wsLNZVO1KYj9R3uroSDjBLLKiZBraCR0mNcMLfizUm0oscaZ9OVrztymmp0-v2yWzJgDk6iV5aG_09bIQFJUDq3m4rZaGaR7uzv6TkPwWO6KaF6NSjldJAutWDwU96mpRB3cEKJARcGNhiS01S7QSwO67DTtjyWVj4KpHsGtB81lEu8EoTEm8UB2o4BmuA539cdVoegXqDfTo4no8wrLQj1rwPORe-LAglqhbx-wvkwez6BcxOSylJQ7fe7AV7o3G-cqn29jaif5QSyJVCUMXHANEAyO3EvqeMnPdkBVoKX3tC2DumdH4dj7kDiOrYT8WHoiXJr8P1Dzp0Qox6C7t6ihvBVkj0vgVluWfIQZSc-Z11gIIKzysL53ngpocL56Rctlc-Zebg4RLzviz3q02TqvVDdcj0ccHASaH7hoCvrHFeIicZoXGimyWZj-TLkPOlOIs0IeRH8NQ3XJvbocZCBAPIEZvf1SEtfDdos1Kk9GLlDWM0rKVeOTCI1UmaBvVUsLMfty_JugQRLsyOhFk6LqzZRR3L7f8loHFvfM1WWCghR_QOJd2FjfA-cYi9F0plDcO3on0mg_h_Q-E3f0sDp_n8rpg_AHCz3era3GFepq3UT5zFg-k9ApM851PiqxpnOObZzq_He-GtkId8aKd_1Q8OUZWH4HeAuuFVHy0IN80leJNhCQ0m4rQ-kqR6pRNyCu38CxFNEdqvkRWKAAN9gsvXq45ZD6ngcMuQvMcGFDvPmNVthfvtzh9jNzkw_-4fWDCMfIolSbjRZNqkFPAyNTWv3JgVm00">类图的例子</a><br><img src="%E7%B1%BB%E5%9B%BE%E7%9A%84%E4%BE%8B%E5%AD%90.png" alt="类图的例子"></p>
<ul>
<li>领域模型的状态图（logical view 是一部分）：</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.plantuml.com/plantuml/uml/VPNhRjCm5CU_voaiyMKWPNCQUg4gqxQkcoPWG-c6X01LJksjLYwkR8S24--ESvbFJ2GVLMhYypiN_tt9cT94wgh8Wq1blDmJIGfanZH3pm4oTYLAlHIvaCZQOSSrQvpdMakULfe11SvwRCt_C0GMJTqmGABnq5EImdWkfU0KhKcfq2THYWQx8DliIOggfBQrL-FHz68vQTr2KYQThjFSXBGbf1G7y3Mn8sEJIV0t2Bwz-O52oPzsEZn5drUtbpUtrq7t3uxr_NbolxeCkdyKKd4ewu3axZfPhTV1omE4N9tVV7n8LjPZOvBLbxiF9iSSBLBpndwAZD75INhwlKn_eqensOl9sMDJ_s6vhCjqIL5enapdGPVBldUSVRSpQOhLoyoLvbj4NcIlw_OWGkc6rdi1ZN0KXpWAyGJXyHn7RYPDLDRjce9fOa98ayaAvAq7aASUG9vw0EqvHQqj-AbuH0SXCoON9xmFxOJgDja00iszhGC5lNSsL0nOpnI0ghrIsvo3ZAC-otAoLunkD2yQ6kDvD9v7CuVHnFex1iVpoCbJCCh9HjbZEugdetVnDCRZSH_RLsdErSw2qMmsVHjFPXXZ1sDooqgDNco60xidlRe2vCew41L0ZwO0IQQgNADd679L7ceCe2jnBV1i7cC0N7thVWpJ_A29eSQEmi0u0WyPHrrRBngKWXrUMvUKoR3VDXoLTYLZFErvpPsOhEwJhzxriWYirc2fBEDPg0Q1PUgEB_krPNlDHMbE9Z1QaYrBoJPh6ANDKplMKFPgzBODaAzne9YKlS_6qVkspzV_4nlADE6vGaV7nyVWzKuT8D_aWV9Fttu9lDC7o7Fn0kIxwCzOIQiY_mS0">状态图的例子</a><br><img src="%E7%8A%B6%E6%80%81%E5%9B%BE%E7%9A%84%E4%BE%8B%E5%AD%90.png" alt="状态图的例子"></p>
<ul>
<li>系统流程图（process view 的一部分）：</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.plantuml.com/plantuml/uml/ZLBDQi9043vddo97VONemLUnDABKQZ6HqbkqfhZM7wNYGKALYXMaLQ6WMHjzcMOctdo5RbmiQqwzXDcPR-Rx8Id3J9VCycsUd0gYuUOR6kD3ROZEnz5hmcBeCmhsEg0CzfK41pHfOC-ENXrQdSDYyMDLi3s5peGNmQu7zcFO6J3ezi9YNSVAykXHWdGFzPLumvB1jXyCQ-8eZdiuPeT6DQYo127tsLnULsDcgQp7YPBBg37OlG1j2K0I1ojuUnMFk6fczO8QUz0D3bKqd5WucifmJeAE1Pjt-EoU6HGzR-ZHk-XGw7pv-ndODV16_xeiByZ7kVf2yRHsLTBJDs6pS9tB4FvLJ-u8qM3r99o834JilhiDrNRRd8i7zaSaA1BdQCHYP8hEN8WKeLs0ahB6g3MkH1vZdt4PKGefFU55qNptsNSjtvrV1Y2PDCpY7Kdn1l-_VW40">流程图的例子</a><br><img src="%E7%B3%BB%E7%BB%9F%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%9A%84%E4%BE%8B%E5%AD%90.png" alt="系统流程图的例子"></p>
<ul>
<li>系统每个用例的时序图（process view 的另一部分）：</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.plantuml.com/plantuml/uml/bP9F2zim3CNl_XI2mVuSIdRUOPHI0ZllMYYkewIYZcGSkMk__Tm4p4QoBFKjbjxJJo_U3sgZfjuR9VK8DZKav_ZG1_nWnMYTaZ0SoNRHzYS-HB6DiuCQ4xAG70NB2Y6A--jYG6umdY-b_SzYH8TqpsLY9tsmsUmrvsuLHoVuKDU7VF9rKk7KNp0QCrPsk-zp-JTmmYrrAI9yX74ZCsk2PUNO3Pu6HIRke9KuXL2Gvgh2LvXc-ouW5SDPS_6R5URE1Vbrdu4ds1D_7cuKe9AsnVXbVTJNV8pn8c5Xu79ArHJ9vbJT5TqDfY-wa2Tzca-mbkZHnjjFwtlXrU1Vx7Nztj-jdB0I9uJWxLEIPfG6_pt5v51Cxdald2pO0BxwYXLZJvmDp1iBIYXhhIsrQBdulAfWqu1cusEaZYKYJ9hjsDUaZVpY_o3lyxZK-zy0">时序图的例子</a><br><img src="%E6%97%B6%E5%BA%8F%E5%9B%BE%E7%9A%84%E4%BE%8B%E5%AD%90.png" alt="时序图的例子"></p>
<p>基于这些领域基线，我们事实上已经穷举了我们领域里零散的“原子化元素”，这些元素不可再分，而且排列组合里隐藏了失败。我们可以建立对我们的领域有百科全书式的理解，进而回答这些问题：</p>
<ol>
<li>到底有多少种模型？</li>
<li>在每个用例中，到底模型之间存在怎样的平衡关系？</li>
<li>在每个用例中，运行中的原子能力有什么样的彼此依赖，会产生什么样的故障？</li>
</ol>
<p>只要我们“分解得当”，我们一定有办法得到我们的系统的一种风险静态视图-<strong>《风险大图》</strong>（这个东西 4+1 视图没有，但总体上来讲是从用例拆解到领域能力，再拆解到领域能力能够遇到的问题的一种描述方式）：</p>
<p><a href="%E9%A3%8E%E9%99%A9%E5%A4%A7%E5%9B%BE.xmind">风险大图.xmind</a><br><img src="%E4%BA%A4%E6%98%93%E7%B3%BB%E7%BB%9F%E9%A3%8E%E9%99%A9%E5%A4%A7%E5%9B%BE.png" alt="交易系统风险大图.png"></p>
<p>上图标红的子主题被称作风险分母，如果右边有相应的感知和应对手段，则可以称作我们找到了相应的风险分子，如果没有，则风险分子小于风险分母，存在风险敞口。从这个图我们可以看出，对于一个功能设计，应对风险的非功能性设计非常多，这就“三斤螃蟹两斤绳”的现实写照。风险分母和风险分子之间应该可以相互界定，风险分子和风险分子之间也应该可以相互界定。</p>
<p>关于风险大图还有几点需要注意：</p>
<ol>
<li>即使我们拆解到单一的功能模块（比如一个接口），一个功能模块里也可能隐含有多个风险分母。衡量一个好的风险分母的标准通常是：你能否用一个中学数学难度的等式或者不等式来表达这一种异常。为什么要这么做？因为我们的事中监控手段的表达能力往往是有限的，只适合表达一些简单的数学关系，我们必须适配这种有局限性的工具来表达我们的系统。</li>
<li>一个模块往往蕴含有多种异常而不是一种异常，所以它必然拥有多个风险分母，我们应该警惕对单一模块只提取出一个风险分母的思路。</li>
<li>当我们得到了一个风险分母，要建立相应的风险分子的时候，风险分子必须针对这个简单不等式做出响应，但这种响应可以是多种多样的，它可以是多种多样的：</li>
</ol>
<ul>
<li>系统模块内的果断熔断措施。</li>
<li>系统模块内的果断异常措施 + 相应的监控模块的精确告警策略。</li>
<li>基于离在线服务的信息流核对体系。</li>
<li>针对告警必须采取的 SOP。</li>
</ul>
<ol start="4">
<li>sop 应当具有这样的特征：</li>
</ol>
<ul>
<li>通常是问题的最优解。</li>
<li>通常采取的步骤简洁明了，一看就会。</li>
<li>通常能够覆盖所有隐藏的陷阱。</li>
</ul>
<p>风险大图是按照领域流程逐步分解，一直分解到领域能力不可再分为止。得到了风险分母后，我们需要仔细思考金融系统在这个能力遇到失败时，会产生什么样的错、漏、重的风险。</p>
<p>风险大图体现了架构师对系统运行时场景的理解，提供了一种从静态视角看待动态风险的工具。我们如何说明一个系统是安全的呢？<strong>一个简单的思路是使用数学归纳法，只要我们的系统的每个环节都是安全的，那么整体就是安全的</strong>。严谨的分解会产生有简单的说服力的系统，一个分解到这个地步的系统“过于简单，以至于明显没有 bug”，任何入门者都可以维护得很好，这就体现了架构师的功力。</p>
<p>每个季度架构滚动规划的时候，我们总能看到我们对领域做了什么事：</p>
<ul>
<li>我们新增了多少种领域模型？</li>
<li>我们新增了多少种领域能力？</li>
<li>我们新增了多少种系统用例？</li>
</ul>
<p>既然我们的系统变复杂了那么多，那么我们新增了多少种风险呢？我们如何说明我们理解了风险，我们化解了风险呢？我们在做架构滚动规划的时候，应该冷静地数清楚：</p>
<ul>
<li>我们的风险分母涨了多少？</li>
<li>我们的风险分子涨了多少？</li>
<li>我们的风险敞口现在有多大？</li>
</ul>
<p>只有把我们的架构分解到这个地步，我们才算对我们的系统的风险有了如指掌的认识，证明我们的螃蟹在长大的同时，我们没有忘记给它们绑上绳子。这也是架构师述职和晋升时必备的东西-<strong>能够向完全不理解我们领域的其他技术专家讲清楚我们领域内的风险，证明了我们建立了我们的风险大局观，是货真价实的领域专家</strong>。</p>
<p>（这是这张图在这个系列里第二次出现。这张图出现在此处的意思是：我们在往桶里装水的时候，要时刻评估我们的短板的高度，我们的风险防控体系，既要适应我们的系统，也要具有 scale-out 的延展性，我们的系统永远要适应业务和组织的生长）。</p>
<p><img src="%E6%9C%A8%E6%A1%B6%E5%AE%9A%E5%BE%8B.jpeg" alt="木桶定律"></p>
<p>（这是这张图在这个系列里第二次出现。这张图出现在此处的意思是：我们在往桶里装水的时候，要时刻评估我们的短板的高度，我们的风险防控体系，既要适应我们的系统，也要具有 scale-out 的延展性，我们的系统永远要适应业务和组织的生长）。</p>
<p>事实上，到这里我们已经开始建立了一个多维度风险防控体系的雏形。这个风险大图能够指导我们理解，我们的风险来自于如此多的维度。只要我们记得按时滚动更新它（特别是在出现事故以后），我们就在不断地认知迭代，进行更高层次的“事前事中事后”设计。</p>
<p>基于架构的风险防控体系，是源于架构基线又不仅仅关于架构基线的，算是超越架构基线的设计；同理，对于风险的管控，源于我们对生命周期的认识，又超越了我们对生命周期的认识。</p>
<p>当我们有了风险大图，我们可以按图索骥，开始构筑我们的风险防控体系。</p>
<h1 id="如何做高可用的风险防控体系"><a href="#如何做高可用的风险防控体系" class="headerlink" title="如何做高可用的风险防控体系"></a>如何做高可用的风险防控体系</h1><h2 id="高可用的问题到底从何而来？"><a href="#高可用的问题到底从何而来？" class="headerlink" title="高可用的问题到底从何而来？"></a>高可用的问题到底从何而来？</h2><p>我们的服务在孤立运作的时候，保持稳定总是很容易的，为什么进入分布式/云原生环境以后就变得如此脆弱？</p>
<p>我们的系统服务在这些环境下变得脆弱的原因通常有：</p>
<ol>
<li>不能处理的负载使得系统进入不正常的状态。</li>
<li>环境不稳定导致服务节点失效。</li>
</ol>
<p>这些问题一旦发生，在复杂的环境里就很有可能引发连锁反应，没有做过高可用设计的服务，往往不会直接变成“低可用”，甚至有可能会变成“零可用”。</p>
<p>为了保持稳定，我们寻找保持孤立的方法，化整为零，并小心翼翼地建立联系；为了提高效率，我们寻找规模化的方法，化零为整，并小心翼翼地维护每个节点。我们要在这两种策略里保持平衡。</p>
<h2 id="勾勒核心架构拓扑"><a href="#勾勒核心架构拓扑" class="headerlink" title="勾勒核心架构拓扑"></a>勾勒核心架构拓扑</h2><p>我们的系统通常很复杂，但我们在一个用例里通常不会用到一个系统的全部部分。每个用例的全流程在全局中的依赖是不一样的。有些系统中的依赖会一直被各种用例使用，有些系统中的依赖只会被部分用例使用到。可以想象我们的服务就好像一系列被有意摆放在一起的灯泡，每个业务流程只会点亮其中若干盏灯泡，有的灯泡无法点亮是可以接受的，它可能只会影响若干流程，或者流程里不重要的部分，有些灯泡无法点亮是不可接受的，它会导致我们的业务无法正常工作，进而对公司造成损失。</p>
<p>因为系统的不同部分对整体的影响是不一样的，我们一定有办法把核心区域勾勒出来，而把其他区域区别出来，这在很多团队叫作梳理核心链路。</p>
<p>核心区域通常具有以下特点：</p>
<ol>
<li>系统的某一项核心价值产生某一个核心流程。</li>
<li>核心流程包含若干个生命周期，每个生命周期由系统基线的若干个部分维护。</li>
<li>根据业务的特点（work load 是写还是读，需不需要引入事务模型？），系统的每个部分要满足某些 sla，保证业务事务的完整性（integrity）。我们经常说的“强依赖”，指的就是完成这样一个事务的必要组成部分；我们常说的“弱依赖”，指的就是完成这样一个事务的可选组成部分。</li>
</ol>
<p>所以核心区域是架构基线的一个子集。这个子集比整个架构里的其他部分更加重要，不容有失。</p>
<p>相应的保障措施需要考虑如下问题：</p>
<ol>
<li>如果我们无法理解我们的全部系统，我们一定要能够理解架构的核心区域。</li>
<li>如果我们要建立风险分母和风险分子，我们应当找到所有核心用例、核心模型和核心生命周期，进而找到所有的风险分母，然后建立风险分子。</li>
<li>核心链路里的风险分子，要恰如其分地应对风险，对齐最高标准。</li>
</ol>
<h2 id="理解系统的方法"><a href="#理解系统的方法" class="headerlink" title="理解系统的方法"></a>理解系统的方法</h2><p>理解系统即理解指标，理解指标才能理解系统。</p>
<p>那么应该理解多少种指标呢？</p>
<ol>
<li>异常指标。</li>
<li>基础性能指标。</li>
<li>基础业务指标。</li>
</ol>
<h3 id="异常指标收集与告警"><a href="#异常指标收集与告警" class="headerlink" title="异常指标收集与告警"></a>异常指标收集与告警</h3><p>首先应该关注异常指标。异常指标总是优先级最高的问题。</p>
<p>异常指标的收集要注意系统内组件的层次关系，也要注意系统自己的中间件的异常指标。</p>
<p>针对风险分母的不等式的理解一定能够产生多个异常指标。</p>
<h3 id="性能指标的收集与告警"><a href="#性能指标的收集与告警" class="headerlink" title="性能指标的收集与告警"></a>性能指标的收集与告警</h3><p>性能指标至少要对照 SLA 来设计，不同系统的要求是不一样的。有些人也会考虑使用 SLO 和 SLI。</p>
<p>一个被优化得很好的服务，需要长期关注这些指标：</p>
<ol>
<li>QPS。</li>
<li>RT（注意，通常很多人会看 AVG 和 MAX，但其实性能优化需要关注的是长尾部分，即 tp50、tp99、tp999、tp9999等指标）。要懂得使用 sampling（metric）、profiling（本地或者线上的全方法 profiling）、tracing（基于 transaction 的 tracing 和链路 trace 的 tracing）和 thread dump。</li>
<li>JVM 相关的指标：gc count、gc max time 和 gc mean time。</li>
<li>host 相关的指标：cpu busy、load（和 busy 不一样）、disk io utilization、network io utilization。</li>
<li>异常错误数。</li>
<li>中间件吞吐量。</li>
<li>节点数。</li>
</ol>
<p>如果我们的服务还有有状态的存储部分，我们还需要关注：</p>
<ol>
<li>存储分片数。</li>
<li>存储副本数。</li>
<li>存储水位。</li>
<li>负载均衡指标。</li>
<li>io 数。</li>
<li>qps 数、tps 数。</li>
<li>响应 rt。</li>
<li>主从延迟。</li>
</ol>
<p>如果我们的服务涉及中间件，也需要思考：</p>
<ol>
<li>中间件堆积。</li>
<li>中间件存储水位。</li>
<li>中间件 cpu、mem 水位。</li>
<li>中间件 sla：rt、吞吐。</li>
<li>中间件 io 水位。</li>
</ol>
<p>对于性能指标的收集和监控一定要引入运营的思路，懂得区分正常指标，和异常指标。</p>
<h3 id="基础业务指标的收集与告警"><a href="#基础业务指标的收集与告警" class="headerlink" title="基础业务指标的收集与告警"></a>基础业务指标的收集与告警</h3><p>要想办法把点状指标打磨得很敏锐，也要想办法把网状指标组装成线、面、网，然后监控才能形成体系。要善用聚合指标和智能告警等新技术方案。</p>
<p>懂得设计业务指标的基础，是了解业务，更具体地说，是要了解业务的预期。</p>
<p>懂得设计业务指标要知道业务的哪些运营指标是必须观测的，指标的波峰波谷分别是什么，波动的箱体是什么情况的，我们应该防止业务出现什么波动。</p>
<p>举个例子：</p>
<ol>
<li>保单：</li>
</ol>
<ul>
<li>请求数</li>
<li>最终投保成功数</li>
<li>退保数</li>
<li>净保单量</li>
<li>净保费</li>
</ul>
<ol start="2">
<li>理赔：</li>
</ol>
<ul>
<li>理赔保险金</li>
<li>赔付比</li>
<li>理赔各个阶段的案件比</li>
<li>理赔各阶段时效</li>
</ul>
<h2 id="几种风险分子的设计思路"><a href="#几种风险分子的设计思路" class="headerlink" title="几种风险分子的设计思路"></a>几种风险分子的设计思路</h2><h3 id="如何设计告警"><a href="#如何设计告警" class="headerlink" title="如何设计告警"></a>如何设计告警</h3><p>设计告警关系到事中发现，如果我们能够把风险分母理解为一个简单的数学表达式：“每 100 个请求里只允许出现 a 个 xxx 错误。”</p>
<p>我们就可以针对这个非常具体的错误设计告警策略。</p>
<p>设计告警策略最容易出现的失误是没有找到风险分母，一个接口所有错误共用一个异常，甚至一个模块一类流程共用一个异常，这实际上把多个维度的错误混到了一个监控项上，让监控项的阈值配置变得不可能。</p>
<p>好的监控要求我们能够直接从数据中解读系统正在出问题，也可以从线上问题症状直接前往监控项，进一步确认问题实际上出在系统中的哪个环节。</p>
<p><a href="%E5%91%8A%E8%AD%A6%E4%BD%93%E7%B3%BB.xmind">告警体系.xmind</a><br><img src="%E5%BC%82%E5%B8%B8%E5%88%86%E7%B1%BB.png" alt="异常分类"></p>
<h3 id="调优手段"><a href="#调优手段" class="headerlink" title="调优手段"></a>调优手段</h3><p>在调优的问题上，无效的误区往往多于有用的经验。</p>
<p>很多人迷信自己解决既往问题得到的若干经验，也有人迷信在网上某些博客里得到的独得之秘。大家应当相信几个事实：</p>
<ol>
<li>问题大致上比一个人的经验要复杂。</li>
<li>一个人的若干经验如果只能生硬地使用，那就是一把锤子，锤子往往只能锤一类钉子。</li>
<li>实事求是地分析当前问题比套用经验重要得多。</li>
<li>不要过早优化，要慎用深度优化手段。深度优化手段的影响面往往比大多数人能想象到的大。只有测试明确需要优化，论证可以优化，测试验证确实得到优化以后，我们才可以确认我们的优化是划算的。</li>
<li>避免深度优化的方法是：写好业务逻辑。</li>
</ol>
<h4 id="应用层调优"><a href="#应用层调优" class="headerlink" title="应用层调优"></a>应用层调优</h4><ol>
<li>面向 gc 编程。</li>
<li>异步化。</li>
<li>并行化。</li>
<li>调整流程。</li>
</ol>
<h4 id="系统层调优"><a href="#系统层调优" class="headerlink" title="系统层调优"></a>系统层调优</h4><ol>
<li>内核参数调优：调大某些参数，关闭危险参数。</li>
</ol>
<h4 id="中间件调优"><a href="#中间件调优" class="headerlink" title="中间件调优"></a>中间件调优</h4><h4 id="存储层调优"><a href="#存储层调优" class="headerlink" title="存储层调优"></a>存储层调优</h4><ol>
<li>工作参数调优。</li>
<li>关闭危险参数。</li>
<li>改变存储模式。</li>
<li>监控指标（待补充）</li>
</ol>
<h4 id="架构调优"><a href="#架构调优" class="headerlink" title="架构调优"></a>架构调优</h4><ol>
<li>架构隔离。</li>
<li>在架构层面，调整流程。</li>
<li>调整存储层次。</li>
<li>调整负载均衡策略。</li>
</ol>
<h3 id="冗余手段"><a href="#冗余手段" class="headerlink" title="冗余手段"></a>冗余手段</h3><ol>
<li>无状态的服务：考虑多活问题（物理机房分布、拓扑结构、单元化）、弹性伸缩问题。</li>
<li>有状态的服务：考虑带有共识机制的服务，不带有共识机制的服务，也需要考虑多活问题。还需要考虑紧急场景下存储切换的 sop。</li>
</ol>
<p>有状态的服务，无状态的服务。</p>
<p>考虑</p>
<p>冗余资源池在哪里，是否可以通过弹性来优化成本，是否有按照业务周期来批量扩容的 sop。</p>
<p>比较容易被忽略的地方：使用隔离来制造冗余（比如制造 liteSet）。</p>
<h3 id="应急手段"><a href="#应急手段" class="headerlink" title="应急手段"></a>应急手段</h3><p>为什么要有损，用流量整形来降低高负载对系统的影响。</p>
<h4 id="有损类"><a href="#有损类" class="headerlink" title="有损类"></a>有损类</h4><p>限流，集群级限流、单机限流。限流精确吗？</p>
<h5 id="降级-熔断"><a href="#降级-熔断" class="headerlink" title="降级/熔断"></a>降级/熔断</h5><p>阈值怎么设计？</p>
<p>精细化熔断设计？</p>
<h4 id="恢复类"><a href="#恢复类" class="headerlink" title="恢复类"></a>恢复类</h4><h5 id="重试"><a href="#重试" class="headerlink" title="重试"></a>重试</h5><ul>
<li>内存级重试</li>
<li>最大努力事务型重试</li>
</ul>
<p>想要了解，基本的设计理念和思想，推荐读读这本书：</p>
<h2 id="如何检验高可用建设成果"><a href="#如何检验高可用建设成果" class="headerlink" title="如何检验高可用建设成果"></a>如何检验高可用建设成果</h2><p><strong>检验我们的高可用体系设计和实现得好不好，最好的方法是常态化压测+攻防演练。</strong></p>
<h1 id="如何做资金安全的风险防控体系"><a href="#如何做资金安全的风险防控体系" class="headerlink" title="如何做资金安全的风险防控体系"></a>如何做资金安全的风险防控体系</h1><h2 id="基于“账、证、实”的领域模型设计"><a href="#基于“账、证、实”的领域模型设计" class="headerlink" title="基于“账、证、实”的领域模型设计"></a>基于“账、证、实”的领域模型设计</h2><p>账、证、实是起源于银行和第三方支付的词汇（当然它真实的起源和财务制度有关，非常复杂），大意上讲：</p>
<ol>
<li>我们做任何一次交易都会产生原始凭证，这种领域模型在金融系统里可以被归为“证”。证模型还可以再细分为“业务凭证”和“资金凭证”。</li>
<li>我们多次的凭证会产生全局汇总变化的台账，这种领域模型在金融系统里可以被归为“账”。</li>
<li>某些汇总变化的全局台账是具有法律效力的，这种领域模型在金融系统里可以被归为“实”。</li>
</ol>
<p>在我们的现实生活中，账、证、实模型可以说无处不在：</p>
<p><img src="%E8%B4%A6%E8%AF%81%E5%AE%9E%E6%A8%A1%E5%9E%8B.svg" alt="账证实模型"></p>
<p>以买水为例，一个用户在便利店靠第三方支付刷卡买了一瓶水，永远都会得到一张购物小票，来表达一次交易，所以我们构建系统的时候必须认真针对交易设计“<strong>业务凭证</strong>”，刷卡的过程中还会产生一张资金的小票，所以涉及资金流的系统还需要设计“<strong>资金凭证</strong>”。有交易必然涉及库存和余额等全局汇总信息，所以我们又必须在系统里设计“<strong>账模型</strong>”。如果要和远端的有法律效力的银行系统交互，还必须设计“<strong>实模型</strong>”。</p>
<p>资金安全的设计的根本理念是：<strong>通过分解得当的领域抽象，找到所有的“账、证、实”模型（不重不漏），保证所有交易被充分地表达清楚（可追溯），且保证模型之间是平衡的</strong>。</p>
<h2 id="寻求分解得当和可追溯的模型"><a href="#寻求分解得当和可追溯的模型" class="headerlink" title="寻求分解得当和可追溯的模型"></a>寻求分解得当和可追溯的模型</h2><p>设计账、证、实并没有看起来那么容易，因为工程师在建模的时候，很容易忘记我们在用户故事里某一段流程，实际上是一段交易。这种时候，如果我们对领域的知识不熟，我们往往会乱发明名词，凭空设计一些“XXXRequest”、“XXXLog”来描述我们的交易。</p>
<p>好的模型应该仅从名字就能表达交易的性质和内容，如果我们出现了“XXXRequest”、“XXXLog”之类的模型设计，就好像我们在店里办业务，没有办法得到正规的购物小票，店家给了我们一段录像带作为业务凭证一样。录像带当然也能够完整地表达清楚交易所有的过程和交易因子，但它不是强领域建模的，也不可能被清晰地自动化处理。</p>
<p>大家可以仔细想一想，在我们的计算机系统出现以前，各种金融系统里面的单据是否齐备，是否仅靠纸张就可以记录以下交易因子？</p>
<ul>
<li>时间</li>
<li>地点</li>
<li>性质</li>
<li>涉及人员</li>
<li>金额</li>
<li>状态</li>
</ul>
<p>如果他们可以，我们的系统也可以。领域驱动设计讲究以领域为师，就是这个道理。</p>
<p>有了好的领域模型，必须的交易因子总是可以从单据中被找到，从而还原出所有的交易细节，推导出其他模型的账实变化。没有好的领域模型，工程师排查问题就必须借助于各种日志系统。一旦出现了这种情况，工程师应该认真反思自己的领域抽象能力是不是真的“分解得当”和“可追溯”。</p>
<h2 id="寻求模型的平衡性"><a href="#寻求模型的平衡性" class="headerlink" title="寻求模型的平衡性"></a>寻求模型的平衡性</h2><p>用户花 1 块钱买水，一定会得到一张 1 块钱的业务凭证和 1 块钱的资金凭证，他的余额系统里面一定会少掉 1 块钱。如果资金划拨涉及多个系统，则每个系统之间的交互都会产生相应的业务凭证和资金凭证，而且所有的余额的账模型都会因此变更。如果我们做复式记账法，我们会发现所有的凭证存在平衡关系：</p>
<ol>
<li>不管跨越多少系统，所有的模型必定能够通过交易相关联上。</li>
<li>能够被关联上的模型上的交易因子必定相等，或者能够在正负算式上保持加减平衡。</li>
</ol>
<p>这种平衡性是业务本身的设计约束，一个逻辑上成功的事务，是具有原子性的，不受任何模型、系统边界的干扰，所有凭证之间的平衡性满足自反性、可传递性和可逆性（这里需要复习一点小学生数学）。</p>
<p>保障交易的平衡性，就保障了所有的资金安全，可以采取如下方法：</p>
<ol>
<li>在交易中严格保证模型是平衡的。</li>
<li>在交易中和交易后正确地检查出模型是不平衡的。</li>
<li>如果模型是不平衡的，系统应该具有自愈能力，通过补偿让系统达到平衡；或者直接熔断，阻断系统继续在有问题的状态下运行。</li>
</ol>
<p>我们能够定义好账、证、实，实际上是我们正确理解交易的开始。</p>
<h3 id="要做好基础的防御性编程校验"><a href="#要做好基础的防御性编程校验" class="headerlink" title="要做好基础的防御性编程校验"></a>要做好基础的防御性编程校验</h3><p>任何时候，我们都应该假定：</p>
<ol>
<li>上游的输入可能会出错。</li>
<li>下游的返回可能会出错。</li>
<li>本身的运行环境的资源管理可能出现故障（如操作系统文件句柄耗尽、内存枯竭）。</li>
</ol>
<h3 id="在交易中严格保证模型是平衡的"><a href="#在交易中严格保证模型是平衡的" class="headerlink" title="在交易中严格保证模型是平衡的"></a>在交易中严格保证模型是平衡的</h3><p>模型是不平衡的，意味着我们的交易中出现了错、漏、重其中一种错误：</p>
<ul>
<li>错：交易因子判定错误，有人/流程无意地篡改了本流程依赖的交易因子。</li>
<li>漏：系统失去了重试的动力，系统重试状态判定错误（有人/流程无意地篡改了本流程依赖的交易因子）。</li>
<li>重：系统发生了有意无意的重试，而系统缺乏唯一性检查，或者幂等失败。</li>
</ul>
<p>接下来我们会以一个模拟的保险核心为例，来介绍如何解决这些问题。</p>
<p><img src="%E4%B8%80%E4%B8%AA%E6%95%B4%E6%B4%81%E7%9A%84%E4%BF%9D%E9%99%A9%E6%A0%B8%E5%BF%83.svg" alt="模拟的整洁保险核心"></p>
<ol>
<li>任意一张保单是是由多属性组成的单据，它的每个属性是其他交易的交易因子。</li>
<li>不同的售后交易流程需要参考保单的属性，将其作为自己的交易上下文的交易因子（保单是交易流程的一部分），有时候也要参考其他单据的属性（一个子域可能有另一个子域的交易因子）。</li>
<li>售后交易流程可能随时随地发起、执行，比如一个保单可能在批改的同时被发起续期，续期的同时又被退保，退保的同时又发生理赔。因为保险业务有线下收单，线上执行的特性，所以多个交易流程可能存在混合异步、并发的场景。各个流程的执行正确性非常重要。比如：</li>
</ol>
<ul>
<li>如果发生了理赔，需要确认当前是否达到了保额的上限 ，这时候如果发生批改，则保额的上限可能发生变动，理赔有没有可能出错？批改影响理赔。</li>
<li>如果一个用户批改了保费保额的上下限，系统又同时发生续期，那么续期的时候，应该扣用户多少钱？批改影响续期。</li>
<li>如果用户理赔了，可能保单的续期责任就豁免了，接下来续期又不收钱了，那么并发执行的续期怎么办？理赔会影响续期。</li>
</ul>
<ol start="4">
<li>我们如何保证这些流程的资金安全？</li>
</ol>
<h4 id="保证交易因子是正确的"><a href="#保证交易因子是正确的" class="headerlink" title="保证交易因子是正确的"></a>保证交易因子是正确的</h4><h5 id="一锁二判三更新"><a href="#一锁二判三更新" class="headerlink" title="一锁二判三更新"></a>一锁二判三更新</h5><p>很多工程师都知道很多状态判定的方法，但所有的技巧都必须依赖于“一锁二判三更新”这个基础框架设计。没有合理的锁策略，任何防资损策略都可能失效。</p>
<p>这是为什么呢？</p>
<p>分布式系统中的并发，总是比工程师想象得到的多。因为分布式系统的全局状态的单一性和分布式节点的分布，决定了并发天然就在发生（一个具体的例子可以看看<a target="_blank" rel="noopener" href="https://blog.csdn.net/michael_kong_nju/article/details/45418313?utm_source=blogxgwz0">许式伟的分享</a>，看看为什么互斥、锁是不可避免的）。事实上，根据<a target="_blank" rel="noopener" href="https://book.douban.com/subject/10484692//">《Java并发编程实战》</a>，“当我们无法证明我们的api 是并发安全的时候，我们应该假定它不是并发安全的”。换言之，我们的所有的领域能力 API，都存在潜在的并发问题-各种领域流程的交互过程必然相互干扰，我们随随便便写的任何 if-else，可能都存在 bug，只是我们不知道而已。</p>
<p>我们日常开发过程中，很少感受到这种这种相互干扰。以投退保核心链路为例，我们的正向流程是单向的，只有投保；逆向流程也是单向的，只有退保，我们很难感受到其他金融交易里面混合异步/并发的复杂。但随着我们业务的发展，没有做好并发处理的代码早晚会出问题，所以我们最好有忧患意识-<strong>我们应该保证我们所有的原子能力都是并发安全的</strong>。今天没有并发问题的领域能力，明天放到一个新的异步流程或者编排方式里，就可能产生并发问题-为了系统安全，还不如今天就把原子能力建成并发安全的。</p>
<p>那么什么是一锁二判三更新呢？</p>
<p><img src="double-check%E7%9A%84%E4%BE%8B%E5%AD%90.jpg" alt="double-check的例子"></p>
<p>我们学习并发编程的时候都学过 double-check 的代码，它的第一行 if 是无悲观锁保护的，所以是不准的，可以被去掉。但全世界应该没有任何程序员能够直接去掉第二和第三行的判定，而让这个程序简明而不出错。所以“一锁二判三更新”的意思是：<strong>任何写操作，必须在一个悲观锁保护的临界区内，进行乐观锁的判定，保证互斥性+可见性，然后才能保证交易因子是正确的</strong>。但我们现实中的代码，去掉这个悲观锁的而不自知的例子，实在太多了。</p>
<p>实际上，我们常用的数据库的乐观锁比对写法，如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">update t_goods </span><br><span class="line"> <span class="keyword">set</span> status<span class="operator">=</span>#&#123;status&#125;,name<span class="operator">=</span>#&#123;name&#125;,version<span class="operator">=</span>version<span class="operator">+</span><span class="number">1</span> </span><br><span class="line"> <span class="keyword">where</span> id<span class="operator">=</span>#&#123;id&#125; <span class="keyword">and</span> version<span class="operator">=</span>#&#123;version&#125; </span><br></pre></td></tr></table></figure>

<p>就是在同一行的原子操作里面同时使用了悲观锁（record-lock）和乐观锁（比对 version）。</p>
<h5 id="不要畏惧使用悲观锁"><a href="#不要畏惧使用悲观锁" class="headerlink" title="不要畏惧使用悲观锁"></a>不要畏惧使用悲观锁</h5><p>但现实中大家都非常畏惧使用悲观锁，理由大概是：</p>
<ol>
<li>悲观锁很容易造成死锁，引起性能问题。</li>
<li>我们总是能够很巧妙地使用各种唯一性索引 + 数据库的乐观锁来巧妙地实现并发安全的问题，所以我们不需要在应用层面来使用悲观。</li>
</ol>
<p>这种观点，对悲观锁的态度过于悲观，对乐观锁的态度又过于乐观了。</p>
<p>因为，我们的业务逻辑的判定的实际逻辑往往非常复杂：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (保单当前已理赔) &#123;</span><br><span class="line">    操作 <span class="number">1</span>()</span><br><span class="line"><span class="keyword">if</span> (理赔金额为 xxx) &#123;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    操作 <span class="number">2</span>()</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (保单已续期) &#123;</span><br><span class="line">    操作 <span class="number">3</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复杂的逻辑可能涉及多张单据的多个属性，也可能涉及不同的判定组合，如果只使用“update where version = ”之类的判定逻辑，既难以表达在单行的乐观锁判定里面，也可能难以表达 else 逻辑（update where 的原子能力在失败后很容易抛出异常，导致需要使用异常来指示程序的控制流）。我们要把很复杂的业务判断写在 where 里面，有时候甚至是不可能的，where 语句也经常因为忘记维护而失去可维护性。但我们使用悲观锁就可以大大提高可维护性：</p>
<p><img src="%E4%B8%80%E9%94%81%E4%BA%8C%E5%88%A4%E4%B8%89%E6%9B%B4%E6%96%B0.svg" alt="一锁二判三更新"></p>
<p>当我们的业务变得复杂的时候，如果使用左边的方式，我们的判定可能会非常复杂，需要在应用代码和 SQL 语句两层代码里面<strong>上蹿下跳地维护代码</strong>。但如果我们我们把行级锁的锁定范围扩大到应用层，则我们可以得到一个被展开的临界区，维护的难度大大降低，即使是新手，也可以直接写出判定正确的代码。</p>
<p>在现实世界里，我们的项目里有大量的业务层代码是在无锁保护下做判定，只依赖于 update where，这就好像写多线程程序的时候不使用 synchronized 等悲观锁，而使用 atomic 尝试实现 lock-free 的并发安全一样，非常危险。既然有经验的程序员都知道多线程编程的时候，不要自己滥用 atomic，而应该使用 synchronized，那么为什么在定义更广义的并发操作的时候，会畏惧悲观锁呢？</p>
<p>当然，分布式系统使用悲观锁的时候确实应该处理好一些问题：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/44125bb12ebf">必须防止死锁</a>。</li>
<li>必须使用合适的分布式锁，而不能使用简单的线程锁。</li>
<li>锁不能解决可见性问题，可见性问题还需要专门解决-比如必须强制读主库，或者用其他方法来确保分布式场景下的强一致性。</li>
</ol>
<h5 id="最好的短分布式锁-select-for-update-悲观锁"><a href="#最好的短分布式锁-select-for-update-悲观锁" class="headerlink" title="最好的短分布式锁-select for update 悲观锁"></a>最好的短分布式锁-<code>select for update</code> 悲观锁</h5><p>常见的分布式锁组件有各种各样的实现，也有各种各样的问题（可以参考<a target="_blank" rel="noopener" href="https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html">《martin kleppman 关于分布式锁策略的博客​》</a>）。RPC 类分布式锁都有固有的缺点，即使是强一致性最好的 Zk 类分布式锁，锁也不是事务性的：</p>
<ol>
<li>如果在事务操作前后使用分布式锁，一旦事务发生异常中断，分布式锁不一定能够得到正确的归还，会降低重试的并发性。</li>
<li>如果持有锁的节点发生长时间 gc，可能导致锁无法续租，其他线程误闯入临界区。</li>
</ol>
<p>我们能够找到最好的悲观锁是数据库的互斥锁，<code>select for update</code>，它是唯一能够如影随形跟着事务的生命周期运行的锁。</p>
<p>在这里要多说一点，在现实中应该慎用<code>select in share mode</code>，因为它会：</p>
<ol>
<li>不能阻止写事务互斥地进入临界区。</li>
<li>在升级为互斥锁的时候可能导致死锁。</li>
</ol>
<p>综上，在现实中使用分布式锁的时候，直接对数据库使用<code>select for update</code> 是一个简明的选择。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  一锁</span></span><br><span class="line">String tradeNo = orderItemService.selectForLock(withholdRecordPO.getOrderDetailId(), (item) -&gt; &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> forbidden = TransOrderItemStatusEnum.forbidPayInstalment(item.getItemStatus());</span><br><span class="line">            <span class="comment">// 二判</span></span><br><span class="line">            <span class="keyword">if</span> (forbidden) &#123;</span><br><span class="line">                LOGGER.info(<span class="string">&quot;扣缴禁止续期的交易详单，不允许继续代扣，直接返回，&#123;&#125;&quot;</span>, JsonUtils.toJson(TransOrderItem));</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            List&lt;TransPayRecord&gt; pendingTransPayRecords = payManager.getPayRecordByItemIds(Lists.newArrayList(item.getId()),</span><br><span class="line">                    Lists.newArrayList(PayStatusEnum.WAITING_FOR_PAYMENT, PayStatusEnum.PAID));</span><br><span class="line">            <span class="comment">// 二判</span></span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isNotEmpty(pendingTransPayRecords)) &#123;</span><br><span class="line">                LOGGER.info(<span class="string">&quot;有已支付或者待支付的支付记录，不允许继续代扣，直接返回，&#123;&#125;&quot;</span>, JsonUtils.toJson(TransOrderItem));</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 三更新</span></span><br><span class="line">            Date now = <span class="keyword">new</span> Date();</span><br><span class="line">            WithholdTradeFlowPO withholdTradeFlow = <span class="keyword">new</span> WithholdTradeFlowPO();</span><br><span class="line">            <span class="comment">// 生成新的交易流水</span></span><br><span class="line">            withholdTradeFlow.setOrderItemId(TransOrderItem.getId());</span><br><span class="line">            <span class="comment">// 通过序列号获取交易流水号</span></span><br><span class="line">            withholdTradeFlow.setTradeNo(String.valueOf(sequenceNo));</span><br><span class="line">            withholdTradeFlow.setOrderId(TransOrderItem.getOrderId());</span><br><span class="line">            withholdTradeFlow.setTradeStatus(WithholdRetryTradeStatusEnum.PAY_WAITING.getCode());</span><br><span class="line">            withholdTradeFlow.setCreateTime(now);</span><br><span class="line">            withholdTradeFlow.setModifyTime(now);</span><br><span class="line">            withholdTradeFlowPOMapper.insert(withholdTradeFlow);</span><br><span class="line">            <span class="keyword">return</span> withholdTradeFlow.getTradeNo();</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<h5 id="领域能力锁定聚合根"><a href="#领域能力锁定聚合根" class="headerlink" title="领域能力锁定聚合根"></a>领域能力锁定聚合根</h5><p>如果使用领域驱动设计，最好锁定聚合根。</p>
<p>在某些并发理论里面，最好锁定是锁相关性对象，即所有的业务事务都会涉及的对象。只有锁定了这种对象，才能在新增加操作的时候，保证不漏锁定。领域驱动设计下，每个事务实际上是操作一揽子模型，所有的领域能力如果在事务里面操作，公有的聚合根是所有的领域能力的交点。如果有多个架构域、多层领域，那么很多时候只有锁定顶层聚合根。比如，在保单系统里面，最简单的锁定对象应该是保单。</p>
<p><img src="%E9%94%81%E5%AE%9A%E8%81%9A%E5%90%88%E6%A0%B9.svg" alt="锁定聚合根"></p>
<p>如果锁定了聚合根，我们的锁的颗粒度应该是多大呢？应该尽量只把事务的范围限定在小的领域能力上，而锁也尽量只在这样一个事务里加锁。这样事务的颗粒度也都是可以被接受的。</p>
<p>但这种基于事务的精细化锁定严重依赖于本地事务，我们又必须在数据库物理设计的时候，尽量把相关联的领域对象设计在一个库里。所以就例子而言，所有的业务中台是使用一个保险核心的，保险核心的模型使用 <a target="_blank" rel="noopener" href="https://blog.csdn.net/tototuzuoquan/article/details/80362892">ER-Sharding</a> 技术，保证我们可以把多个系统的事务涉及到的数据库模型分在一个分片上，让所有的分布式事务降级为本地事务。</p>
<p><img src="ER%E5%88%86%E7%89%87.jpg" alt="ER分片"></p>
<p>因为这种 ER-Sharding 的技术的运用，所以保险核心的设计要求所有的领域能力的锁定和防御性编程在同一个领域层-这也是整洁架构在保险核心里的应用之一。这样，我们建设新的领域能力，就有了统一的加锁方针，保证互斥的实现不漏、不重。</p>
<p>使用这种锁定聚合根的方法，还有一个好处，就是我们有意识地通过一把数据库行锁把对某一批事务的隔离级别从可重复读在关键操作里面提升到序列化。</p>
<p>这样，我们就得到了真正分布式并发安全的原子能力，这些能力依然可以被自由编排、异步化。这样我们可以继续使用<a href="https://magicliang.github.io/2022/01/10/%E9%9D%A2%E5%90%91%E4%B8%8D%E7%A1%AE%E5%AE%9A%E6%80%A7%E7%BC%96%E7%A8%8B/">面向不确定性编程</a>里提到的组合流程。</p>
<p><img src="%E5%AF%B9%E4%BF%9D%E5%8D%95%E7%9A%84%E9%94%81%E5%AE%9A.jpg" alt="对保单的锁定"></p>
<h5 id="锁的变种1-使用单据作为锁实现精细化互斥"><a href="#锁的变种1-使用单据作为锁实现精细化互斥" class="headerlink" title="锁的变种1-使用单据作为锁实现精细化互斥"></a>锁的变种1-使用单据作为锁实现精细化互斥</h5><p>普通的分布式锁是不可能长时间锁定的。尤其是使用<code>select for update</code> 的时候，不可以持有太久的事务。</p>
<p>但我们又有很多流程，需要很长时间的“静态性”，如：</p>
<ol>
<li>理赔可能持续十天半个月，这期间如果发生续期/保全，则理赔的交易因子可能发生变动，怎么办？</li>
</ol>
<p>我们需要基于对保单的锁定，实现领域流程之间的精细化互斥。具体思路是，在每个领域流程的二级聚合根生单之前，精细化地检查有没有与当前流程互斥的其他二级聚合根的存在，或者有没有跟当前流程互斥的一级聚合根的状态。</p>
<p><img src="%E6%B7%B7%E5%90%88%E4%BA%8B%E5%8A%A1.svg" alt="混合事务"></p>
<p>实现了这种设计，我们在长生命周期里就混合地使用了一级+二级聚合根来表达锁的语义，二级聚合根（赔案或者续期单）就像是 jvm 锁对象头里面的 markword，在它们自身生命周期里，就起到了类似锁的作用。</p>
<p>这种二级锁设计还有一个很特殊的用法，就是可以简单地实现“a 操作与 b 操作互斥，但 b 操作不与 a 操作互斥”等混合并发场景下的精细化互斥，我们可以任意设定互斥的判定条件，决定不同流程的并发程度。</p>
<p>在这里我们也可以看出贯彻领域驱动设计的重要性。只有分解得当，把一二级的聚合根都找到，并用二级聚合根把交易表达出来，我们才有可能实现这种精细化互斥。</p>
<p>实际上，某些互助保险业务里的某些双向互斥和单向互斥，就是通过这种方式实现的。</p>
<h5 id="锁的变种2-保单挂起"><a href="#锁的变种2-保单挂起" class="headerlink" title="锁的变种2- 保单挂起"></a>锁的变种2- 保单挂起</h5><p>这个略微有点复杂，改天再写。</p>
<h5 id="其他措施-见费出单的流程模型"><a href="#其他措施-见费出单的流程模型" class="headerlink" title="其他措施-见费出单的流程模型"></a>其他措施-见费出单的流程模型</h5><p>当我们设计完模型的状态机，我们就决定了系统的领域流程。</p>
<p>一般的交易系统设计业务凭证和资金凭证的时候，应该把<strong>资金凭证设计为业务凭证的衍生品</strong>。因为所有的交易都需要业务凭证，但不是所有的交易都产生资金流。大家可以回忆一下，自己平时去银行办业务，是不是不管什么样的业务，都会产生业务凭证作为回执，但只有有资金流的操作才会产生资金相关的回执。</p>
<p>如果我们确定了业务凭证和资金凭证的主次关系，那么我们可以建立一个“见费出单”模型，即：只有资金流交割清楚，我们的业务凭证才能走入终态。</p>
<p><img src="%E8%A7%81%E8%B4%B9%E5%87%BA%E5%8D%95%E6%A8%A1%E5%9E%8B.svg" alt="见费出单模型"></p>
<p>见费出单模型的设计思想是：假设有“资金交割”和“业务交割”两个事务，排在前面的事务可以得到优先补偿，我们认为哪一个事务的失败我们更不能容忍？从资金安全的角度来看，我们应该先补偿资金事务。</p>
<p>这样做的设计的好处是：</p>
<ol>
<li>在正向流程里，只有用户付清账款以后，保单才出单，这样可以避免保司无资损-<strong>实际上保司的保险核心受监管要求，是强制这样设计的</strong>。</li>
<li>在逆向流程里，只有用户得到退款后，保单才退保，避免用户侧资损。</li>
</ol>
<p>阿里/蚂蚁和大部分电商向用户推出的服务，都是符合“见费出单”的设计思想的。这种防资损设计在很多领域、系统实践了很多年，是被验证过的模式。</p>
<p>常见的非见费出单的模式也存在：</p>
<ol>
<li>搭售保险、后结算的住宿：这种架构模式需要很强的清结算能力，可以说资金安全完全取决于附带的清结算流程是否正确。</li>
<li>一般互联网公司保险商城售卖的商业保险的退保是先退保再付款的：如果退保成功而支付卡单，则用户可能会产生“我已解约而没有收到钱”的愤怒。通常，金融系统的用户也认为资金事务的失败更不能容忍。</li>
</ol>
<h5 id="其他措施-所有定价设计可追溯的报价单"><a href="#其他措施-所有定价设计可追溯的报价单" class="headerlink" title="其他措施-所有定价设计可追溯的报价单"></a>其他措施-所有定价设计可追溯的报价单</h5><p>这个略微有点复杂，改天再写。</p>
<h5 id="其他措施-正逆向检查"><a href="#其他措施-正逆向检查" class="headerlink" title="其他措施-正逆向检查"></a>其他措施-正逆向检查</h5><p>如果我们有了交易锁定的能力，所有的逆向流程要做好如下检查：</p>
<ol>
<li>逆向流程执行前要自己确认正向流程产生的交易因子，如：</li>
</ol>
<ul>
<li>退保保费不能超过投保保费。</li>
<li>理赔保险金不能超过保单保额。</li>
</ul>
<ol start="2">
<li>逆向流程执行前要确认自己在多次同类交易中的交易因子，如：</li>
</ol>
<ul>
<li>多次退保的累积保费不能超过投保保费。</li>
<li>多次理赔的累积保险金不能超过保单保额。</li>
</ul>
<ol start="3">
<li>逆向流程执行前要确认自己与其他交易的交易因子，如：</li>
</ol>
<ul>
<li>多次退保的累计保费不能超过保单批改过的保费。</li>
<li>多次理赔后的累积保险金不能超过批改后的保额。</li>
</ul>
<h4 id="保证系统保持动力"><a href="#保证系统保持动力" class="headerlink" title="保证系统保持动力"></a>保证系统保持动力</h4><p>我们最常见的编程模式是同步阻塞编程-我们绝大部分的 delegate/api 等服务都是用这个模式设计的，因为这符合我们的思维习惯。但分布式系统发生抖动或者逻辑错误的时候，我们很可能丢失我们的写请求的结果，这会造成难以察觉的错误。</p>
<p>我们的分布式系统通常会跨系统写数据库，所以这类跨系统写问题，都是分布式事务问题（<strong>分布式事务问题的存在比我们意识到地要广泛得多</strong>）。“本来应该成功而未成功”的写问题，实际上是分布式事务的 <a target="_blank" rel="noopener" href="https://blog.csdn.net/zjcjava/article/details/78893368">liveness 问题</a>-<strong>全局事务的成功，应该保证每一个局部事务都是成功的</strong>。</p>
<p>如果我们分解得当，跨系统的写实际上是两个模型的跨事务的状态同步问题：</p>
<p><img src="%E8%B7%A8%E4%BA%8B%E5%8A%A1%E7%8A%B6%E6%80%81%E8%A1%A5%E5%81%BF.svg" alt="跨事务状态补偿"></p>
<p>前置状态是为了让我们不漏这个操作，后置状态是告诉我们我们已经做完了这个操作。</p>
<p>通常失败会发生在 1、3、4这三个步骤。</p>
<p>为了解决这种问题，我们通常要给同步流程加上异步补偿流程，实现同异步混合，推拉结合：</p>
<p><img src="%E8%BF%91%E7%AB%AF%E4%B8%BB%E5%8A%A8%E8%A1%A5%E5%81%BF.svg" alt="近端主动补偿"><br><img src="%E8%BF%9C%E7%AB%AF%E4%B8%BB%E5%8A%A8%E8%A1%A5%E5%81%BF%E6%B3%95.svg" alt="远端主动补偿法"></p>
<p>实际上我们日常喜欢使用的是第一种方案（各类事务型消息都是此类方案），蚂蚁喜欢使用第二种（这种方法在资金安全的设计里面还有个专门的称呼，叫“单据追平”）。这两种方法是工程的复杂度上各有千秋，但都要求我们的“状态-rpc-状态”的顺序设计得非常准确（这又是一个分解得当的例子，我们有一些订单模型的状态机，是没有做过这么精细的设计的），而且要求我们针对所有的类似场景都考虑补偿。</p>
<p>这类补偿措施在某些文献里被称作<a target="_blank" rel="noopener" href="https://www.bookstack.cn/read/ddia/spilt.4.ch5.md#%E8%AF%BB%E4%BF%AE%E5%A4%8D%E5%92%8C%E5%8F%8D%E7%86%B5">反熵过程</a>。</p>
<h4 id="做幂等性检查"><a href="#做幂等性检查" class="headerlink" title="做幂等性检查"></a>做幂等性检查</h4><p>如上所言，我们的每一个系统之间的写操作都是分布式事务的一个环节，所以我们最好意识到-每一个操作既存在一个隐含的全局事务，又在各个系统里散落着本地事务（所以我们设计流程，就是在设计事务）。这些事务应该共用一个幂等号。</p>
<p>所以我们做设计的时候，要：</p>
<ol>
<li><p>定义好每一个本地事务的幂等号应该如何生成-可以直接使用全局幂等号，也可以本地自己生成一个（但必须保证本地幂等号和全局幂等号存在唯一映射关系）。</p>
</li>
<li><p>定义好每一个 api 针对幂等号的唯一行为，而且确保上下游都理解了幂等的语义：</p>
</li>
</ol>
<ul>
<li>如果有中断流程，是否从中间执行</li>
<li>是否返回一个空成功</li>
<li>其他行为</li>
</ul>
<ol start="3">
<li>确认全局全流程的初始幂等号的生成规则。</li>
</ol>
<p>事实上我们很多服务的幂等设计都不够完善，经常犯的错误有：</p>
<ol>
<li>没有真正意识到每次交易都应该服从“局部-全局”的幂等映射关系，本地幂等键的生成算法不完备，甚至生成了随机的幂等号。</li>
<li>幂等检查过度依赖于唯一性索引返回的异常。这种做法有两个缺点：</li>
</ol>
<ul>
<li>不是所有的幂等都能使用唯一索引来保证不重复的幂等性，如：一张业务凭证下可以有多张失败的支付凭证，但只能有唯一一张成功的支付凭证，简单的状态唯一索引就没有“锁定后查询”来实现幂等容易。所有的唯一索引都可以在应用层等价实现为“锁定后查询”。适用唯一索引号法则的场景是：只靠单一的单据号就可以确认幂等性，而不需要参考“其他可变状态”。只要有“其他可变状态”，就必须依靠锁来对抗交易因子的变动。</li>
<li>使用异常来确认幂等，需要在异常捕获里写控制流，程序的可维护性下降。</li>
</ul>
<ol start="3">
<li>只针对外部接口做幂等，没有对领域里的原子化 API 做幂等，这导致任务型的调用有可能产生并发时的重复写或者其他写丢失。</li>
</ol>
<h3 id="在交易中严格验证模型是平衡的"><a href="#在交易中严格验证模型是平衡的" class="headerlink" title="在交易中严格验证模型是平衡的"></a>在交易中严格验证模型是平衡的</h3><h4 id="旧对账模式的问题"><a href="#旧对账模式的问题" class="headerlink" title="旧对账模式的问题"></a>旧对账模式的问题</h4><p>我们都知道，如果交易流程有 bug，我们最终能够通过对账和查账发现问题。</p>
<p>我们通常使用的方案是：</p>
<ol>
<li>让系统把业务凭证和交易凭证单独出账单-依照账单格式生成多行账单。</li>
<li>财务同学定期核对（通常是以天为单位）。</li>
<li>如果发现核对异常，告知业务 rd，业务 rd 进行排查。</li>
</ol>
<p>这个方案有几个缺点：</p>
<ol>
<li>实时性不强：我们只能在 T+1 天的尺度上理解我们的资损，如果系统流量变大，我们可能一天之内就面临巨大的损失。</li>
<li>可解释性不强：我们只做了系统边界之间的模型转化出账单的核对，如果出现了核对不一致，我们需要逐层检查各级模型才能解释问题。</li>
<li>覆盖面不全：我们只做了资金相关的核对，我们并没有核对所有交易因子的一致性。有些交易因子日后会成为其他交易出现故障的原因。</li>
</ol>
<h4 id="（准）实时核对"><a href="#（准）实时核对" class="headerlink" title="（准）实时核对"></a>（准）实时核对</h4><p>我们是否可以发挥一点想象力，通过工程化的手段，把发现问题的实时性，推进到小时级，把排查问题的速度也推进到分钟级？</p>
<p>事实上，我们的系统中的大多数事务的执行时间都很短，如果其中出现了什么资损的问题，立刻会导致全局的“账、证、实”不平衡。譬如一张多米诺骨牌倒了，我们未必需要等到最后一块骨牌倒下才知道系统出了问题。如果我们的系统能够在每一笔交易完成时，立刻针对交易进行“证证核对”、“证账核对”、“账实核对”，我们当场可以知道系统出现了不平衡。</p>
<p>证证核对要注意核对项，主要核对跨事务的交易因子是否匹配。</p>
<p>这种核对和旧对账模式的区别是：</p>
<ol>
<li>不止核对账单，而是核对所有的“账、证、实”模型，建立简单的两两核对关系，保证交易因子全覆盖</li>
<li>基于大数据和 binlog 方案把可核对数据的产出时间推进到小时/分钟/秒级。</li>
</ol>
<p>相对于老的方案，这个新方案的特点是工程化程度更深，借助人工的流程变少，人的处理能力不再是系统的瓶颈，可以为后续系统自愈和自动化流程干预打下基础。</p>
<p>设计这套核对系统，是基于测试视角，区别于系统的功能性设计的独立校验系统，不受系统的迭代 bug 影响，独立性更强。设计这套系统，还有如下优点：</p>
<ol>
<li>能够反推我们设计出低延迟的系统，否则核对可能不准。</li>
<li>纠正不正确的模型设计-我们建立了很多支付模型，会产生大量重复建设的核对脚本。</li>
<li>让我们准确地表达我们对领域模型的理解，帮助我们思考我们的模型的迭代演进关系。</li>
</ol>
<h2 id="完整的“事前、事中、事后”"><a href="#完整的“事前、事中、事后”" class="headerlink" title="完整的“事前、事中、事后”"></a>完整的“事前、事中、事后”</h2><ol>
<li>事前。我们应该充分评估我们的领域（详细地梳理和设计）：</li>
</ol>
<ul>
<li>分解模型，建立对流程的平衡性认识，在设计时做好保证平衡性的设计。</li>
<li>分解事务，理解全生命周期里有多少个事务，<strong>事务和事务之间的边界在哪里</strong>，<strong>事务和事务之间怎样通过凭证关联</strong>。</li>
<li>在项目上线以前做好“监控” + “核对”。</li>
<li>在架构基线上充分评估变更的影响范围，考虑兼容方案+上线预案，<strong>把变更的变量罗列出来，并逐一评估影响范围，做到不重不漏。看重因果</strong>。</li>
<li>做好 review 和测试：新增测试手工测试加旧测试用例回归测试。</li>
<li>变更前要把所有准备措施的变更前置。</li>
</ul>
<ol start="2">
<li>事中，只能靠系统的准确问题响应、自愈和人工 sop：</li>
</ol>
<ul>
<li>使用通用方案进行灰度、回滚、降级和熔断。</li>
<li>使用专用方案进行灰度、回滚、降级和熔断。熔断、限流、扩容重启的顺序很重要。</li>
<li>仔细观察监控和核对中的平衡性，出现问题及时干预。</li>
<li>怎样快速定位到一台机器上。</li>
<li>使用云原生的基础设施对服务进行巡检。</li>
</ul>
<ol start="3">
<li>事后：</li>
</ol>
<ul>
<li><strong>我们要做好对结果的运营：有指标跟踪体系的升级迭代（多一个告警策略、多一个核对策略），也有运维体系的升级迭代（多一个 sop）</strong>。</li>
<li><strong>基于运营要实现：对特别好的结果和特别差的结果要复盘</strong>。</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>金融系统最终比拼的是风险控制力，金融系统应该更加看重风险控制，大型业务应该看重体系化风险防控。</p>
<p>我们在现实之中经常也会看到事前事中事后的反例，如我们建立了一套新的业务在生产上跑了很久，事后才急急忙忙去建立它的资金核算体系，我们并不知道我们的资金是不是安全的-如果我们不能向别人说明这套体系是安全的，我们应该默认它是不安全的。真正理解架构的人，能够清晰地讲出自己的系统什么地方遇到什么风险，有几种防范手段、问题发现手段、干预手段。</p>
<p>金融级系统对一致性的要求，和一般事务的一致性还不太一样，讲究的是全流程的平衡一致性。所以我们解决风险问题，不能仅从单一问题出发，要考虑全局的平衡性和一致性。我们看待失败的时候，不要只简单地看待接口的失败，要更广泛地看待事务的失败和模型之间的不平衡。</p>
<p>基于努力，我们可以在不可靠的环境中构建可靠的系统。现阶段，我们公司的资金安全文化还在草创阶段，我们还没有建立对于高可用和资金安全的深刻认识，我们也缺乏可以依托的基础设施-比如我们并没有通用的全周期核对系统。但如果我们继续努力，我们一定能够在未来把我们的系统的稳定性提升到非常高的水平。</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="何谓失败？"><a href="#何谓失败？" class="headerlink" title="何谓失败？"></a>何谓失败？</h2><p>如果我们的解决方案出现了逻辑错误，我们会在代码里面留下一各个需要被修复的问题，这一个个问题被称为 bug。</p>
<p>当我们的 bug 在程序运行时真的产生了一个个错误状态，我们的系统中就产生了无数个 error/fault。</p>
<p>一旦 error/fault 产生的意外情况无法被忽略、自动修复，我们就得到了一个个 failure。</p>
<p>我们常说的故障，就是指 failure。</p>
<p>但我们要探讨的失败，又不只是狭义的故障，而是广义的错误。因为正是一个个逻辑的 bug，导致了最终运行时的 error/fault/failure。</p>
<p>一段永远不运行的代码，永远不会失败。但只要程序运行起来，哪怕其中只有一个 bug，也可能最终产生无数个失败。只要有一个失败引起了严重的问题，都可能带来无可估量的损失。</p>
<p>所以程序员可能会忽略 warning、error，甚至一些明知故犯的 bug，但却必须正视失败。失败是实战中的错误，它刺激我们解决我们的系统中的所有错误。</p>
<p>因为实战中我们必须正视失败，所以我们应该面向失败编程。我们平常处理问题，既要处理 failure，最终又要“修 bug”，所以我们最好用一以贯之的思维来理解失败，才能正确地处理失败。本文讨论的面向失败编程，就是“如何体系化地处理失败风险”。</p>

                    </article>
                    


    <blockquote id="date-expire-notification" class="post-expired-notify">This article was last updated on <span id="date-expire-num"></span> days ago, and the information described in the article may have changed.</blockquote>
    <script>
    (function() {
        var dateUpdate = Date.parse("2022-01-30");
        var nowDate = new Date();
        var a = nowDate.getTime();
        var b = a - dateUpdate;
        var daysUpdateExpire = Math.floor(b/(24*3600*1000));
        if (daysUpdateExpire >= 120) {
            document.getElementById('date-expire-num').innerHTML = daysUpdateExpire;
        } else {
            document.getElementById('date-expire-notification').style.display = 'none';
        }
    })();
    </script>


<p class="post-footer-info mb-0 pt-0">Published at&nbsp;<time datetime="2022-01-10T12:00:48.000Z" itemprop="datePublished">2022-01-10</time>

    , Updated at&nbsp;<time datetime="2022-01-30T05:42:25.415Z" itemprop="dateModified">2022-01-30</time>

</p>
<p class="post-footer-info mb-0 pt-2">



<span class="post-tags-list mt-2">

<a class="post-tags-list-item" href="/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/" rel="tag">#&nbsp;系统架构</a>

</span>


</p>

                </div>
                <div class="post-nav px-2 bg-gray">
<ul class="pagination">
    <!-- Prev Nav -->
    
        <li class="page-item page-prev">
            <a href="/2022/01/12/%E3%80%8A%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E5%9B%A2%E9%98%9F-%E8%B0%B7%E6%AD%8C%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E3%80%8B/" rel="prev">
                <div class="page-item-title"><i class="icon icon-back" aria-hidden="true"></i></div>
                <div class="page-item-subtitle">《重新定义团队-谷歌如何工作》</div>
            </a>
        </li>
    

    <!-- Next Nav -->
    
        <li class="page-item page-next">
            <a href="/2022/01/10/%E9%9D%A2%E5%90%91%E4%B8%8D%E7%A1%AE%E5%AE%9A%E6%80%A7%E7%BC%96%E7%A8%8B/" rel="next">
                <div class="page-item-title"><i class="icon icon-forward" aria-hidden="true"></i></div>
                <div class="page-item-subtitle">面向不确定性编程</div>
            </a>
        </li>
    
</ul>
</div>

                
                    <!-- # Comment # -->
                    
                
            </div>
        </div>
    </div>
</div>

            <!-- ### Footer ### -->
            <footer class="text-center">
    <!-- footer copyright -->
    
        <p class="footer-copyright mb-0">Copyright&nbsp;©&nbsp;<span id="copyright-year"></span>
            <a class="footer-copyright-a" href="http://magicliang.github.io">守株阁</a>
        </p>

    <!-- footer custom text -->
    <p class="footer-text mb-0">
    
    </p>
    <!-- footer develop info -->
    <p class="footer-develop mb-0">
        
    <!-- Busuanzi User Views -->
    <span id="busuanzi_container_site_uv" hidden>
        <span></span>
        <span id="busuanzi_value_site_uv"></span>
        <span>Viewers</span>
        
            <span>|</span>
        
    </span>




        
        Powered by&nbsp;<!--
         --><a href="https://hexo.io" target="_blank" class="footer-develop-a" rel="external nofollow noopener noreferrer">Hexo</a><span class="footer-develop-divider"></span>Theme&nbsp;-&nbsp;<!--
         --><a href="https://github.com/SukkaW/hexo-theme-suka" target="_blank" class="footer-develop-a" rel="external noopener">Suka</a>
    </p>
</footer>


        <!-- ### Import File ### -->
        <!-- ### Footer JS Import ### -->

<script>

    
window.lazyLoadOptions = {
    elements_selector: ".lazyload",
    threshold: 50
};
document.getElementById('copyright-year').textContent = new Date().getFullYear();
console.log('\n %c Suka Theme (hexo-theme-suka) | © SukkaW | Verision 1.3.3 %c https://github.com/SukkaW/hexo-theme-suka \n', 'color: #fff; background: #444; padding:5px 0;', 'background: #bbb; padding:5px 0;');

</script>

<script src="/lib/vanilla-lazyload/lazyload.min.js" async></script>
    <script src="https://cdn.jsdelivr.net/npm/busuanzi@2.3.0/bsz.pure.mini.js" async></script>


<!-- Offset -->




<!-- Comment -->


<!-- ### Custom Footer ### -->

    </body>

</html>